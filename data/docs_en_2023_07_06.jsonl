{"title": "SUMMARY.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# The Cairo Programming Language [The Cairo Programming Language](title-page.md) [Foreword](ch00-01-foreword.md) [Introduction](ch00-00-introduction.md) ## Getting Started - [Getting Started](ch01-00-getting-started.md) - [Installation](ch01-01-installation.md) - [Hello, World!](ch01-02-hello-world.md) - [Hello, Scarb!](ch01-03-hello-scarb.md) ## Common Programming Concepts - [Common Programming Concepts](ch02-00-common-programming-concepts.md) - [Variables and Mutability](ch02-01-variables-and-mutability.md) - [Data Types](ch02-02-data-types.md) - [Functions](ch02-03-functions.md) - [Comments](ch02-04-comments.md) - [Control Flow](ch02-05-control-flow.md) - [Common Collections](ch02-06-common-collections.md) ## Understanding Ownership - [Understanding Ownership](ch03-00-understanding-ownership.md) - [What is Ownership?](ch03-01-what-is-ownership.md) - [References and Snapshots](ch03-02-references-and-snapshots.md) ## Using Structs to Structure Related Data - [Using Structs to Structure Related Data](ch04-00-using-structs-to-structure-related-data.md) - [Defining and Instantiating Structs](ch04-01-defining-and-instantiating-structs.md) - [An Example Program Using Structs](ch04-02-an-example-program-using-structs.md) - [Method Syntax](ch04-03-method-syntax.md) ## Enums and Pattern Matching - [Enums and Pattern Matching](ch05-00-enums-and-pattern-matching.md) - [Enums](ch05-01-enums.md) - [The Match Control Flow Construct](ch05-02-the-match-control-flow-construct.md) ## Managing Cairo Projects with Packages, Crates and Modules - [Managing Cairo Projects with Packages, Crates and Modules](ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md) - [Packages and Crates](ch06-01-packages-and-crates.md) - [Defining Modules to Control Scope](ch06-02-defining-modules-to-control-scope.md) - [Paths for Referring to an Item in the Module Tree](ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md) - [Bringing Paths into Scope with the 'use' Keyword](ch06-04-bringing-paths-into-scope-with-the-use-keyword.md) - [Separating Modules into Different Files](ch06-05-separating-modules-into-different-files.md) ## Generic Data Types - [Generic Types](ch07-00-generic-types-and-traits.md) - [Generic Functions](ch07-01-generic-data-types.md) - [Traits in Cairo](ch07-02-traits-in-cairo.md) ## Testing Cairo Programs - [Testing Cairo Programs](ch08-00-testing-cairo-programs.md) - [How To Write Tests](ch08-01-how-to-write-tests.md) - [Testing Organization](ch08-02-test-organization.md) ## Error Handling - [Error Handling](ch09-00-error-handling.md) - [Unrecoverable Errors with panic](ch09-01-unrecoverable-errors-with-panic.md) - [Recoverable Errors with Result](ch09-02-error-handling.md) ## Advanced Features - [Advanced Features](ch10-00-advanced-features.md) - [Operator Overloading](ch10-01-operator-overloading.md) ## Dictionaries - [Dictionaries](ch15-00-dictionaries.md) ## Starknet smart contracts - [Starknet Smart Contracts](./ch99-00-starknet-smart-contracts.md) - [Introduction to smart-contracts](./ch99-01-01-introduction-to-smart-contracts.md) - [Writing Starknet Contracts](./ch99-01-02-writing-starknet-contracts.md) - [ABIs and Cross-contract Interactions](./ch99-02-00-abis-and-cross-contract-interactions.md) - [ABIs and Interfaces](./ch99-02-01-abis-and-interfaces.md) - [Contract Dispatchers, Library Dispachers and system calls](./ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md) - [Security Considerations](./ch99-03-security-considerations.md) - [Appendix](appendix-00.md) - [A - Keywords](appendix-01-keywords.md) - [B - Operators and Symbols](appendix-02-operators-and-symbols.md) - [C - Derivable Traits](appendix-03-derivable-traits.md) - [D - Useful Development Tools](appendix-04-useful-development-tools.md) - [E - Cairo Most Common Types and Traits](appendix-05-most-common-types-and-traits.md)"}
{"title": "appendix-00.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Appendix The following sections contain reference material you may find useful in your Cairo journey."}
{"title": "appendix-01-keywords.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## Appendix A: Keywords The following list contains keywords that are reserved for current or future use by the Cairo language. There are two keyword categories: - strict - reserved There is a third category, which are functions from the core library. While their names are not reserved, they are not recommended to be used as names of any items to follow good practices. --- ### Strict keywords These keywords can only be used in their correct contexts. They cannot be used as names of any items. - `as` - Rename import - `break` - Exit a loop immediately - `const` - Define constant items - `continue` - Continue to the next loop iteration - `else` - Fallback for `if` and `if let` control flow constructs - `enum` - Define an enumeration - `extern` - Function defined at the compiler level using hint available at cairo1 level with this declaration - `false` - Boolean false literal - `fn` - Define a function - `if` - Branch based on the result of a conditional expression - `impl` - Implement inherent or trait functionality - `implicits` - Special kind of function parameters that are required to perform certain actions - `let` - Bind a variable - `loop` - Loop unconditionally - `match` - Match a value to patterns - `mod` - Define a module - `mut` - Denote variable mutability - `nopanic` - Functions marked with this notation mean that the function will never panic. - `of` - Implement a trait - `ref` - Bind by reference - `return` - Return from function - `struct` - Define a structure - `trait` - Define a trait - `true` - Boolean true literal - `type` - Define a type alias - `use` - Bring symbols into scope --- ### Reserved keywords These keywords aren't used yet, but they are reserved for future use. They have the same restrictions as strict keywords. The reasoning behind this is to make current programs forward compatible with future versions of Cairo by forbidding them to use these keywords. - `do` - `dyn` - `macro` - `move` - `Self` - `self` - `static_assert` - `static` - `super` - `try` - `typeof` - `unsafe` - `where` - `while` - `with` - `yield` --- ### Built-in functions The Cairo programming language provides several specific functions that serve a special purpose. We will not cover all of them in this book, but using the names of these functions as names of other items is not recommended. -`assert` - This function checks a boolean expression, and if it evaluates to false, it triggers the panic function. -`panic` - This function terminates the program."}
{"title": "appendix-02-operators-and-symbols.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Appendix B: Operators and Symbols This appendix includes a glossary of Cairo's syntax. ## Operators Table B-1 contains the operators in Cairo, an example of how the operator would appear in context, a short explanation, and whether that operator is overloadable. If an operator is overloadable, the relevant trait to use to overload that operator is listed. Table B-1: Operators | Operator | Example | Explanation | Overloadable? | |----------|---------|-------------|---------------| | `!` | `!expr` | Bitwise or logical complement | `Not` | | `!=` | `expr != expr` | Non-equality comparison | `PartialEq` | | `%` | `expr % expr` | Arithmetic remainder | `Rem` | | `%=` | `var %= expr` | Arithmetic remainder and assignment | `RemEq` | | `&` | `expr & expr` | Bitwise AND | `BitAnd` | | `*` | `expr * expr` | Arithmetic multiplication | `Mul` | | `*=` | `var *= expr` | Arithmetic multiplication and assignment | `MulEq` | | `@` | `@var` | Snapshot | | | `*` | `*var` | Desnap | | | `+` | `expr + expr` | Arithmetic addition | `Add` | | `+=` | `var += expr` | Arithmetic addition and assignment | `AddEq` | | `,` | `expr, expr` | Argument and element separator | | | `-` | `-expr` | Arithmetic negation | `Neg` | | `-` | `expr - expr` | Arithmetic subtraction | `Sub` | | `-=` | `var -= expr` | Arithmetic subtraction and assignment | `SubEq` | | `->` | `fn(...) -> type`, &vert;...&vert; -> type | Function and closure return type | | | `.` | `expr.ident` | Member access | | | `/` | `expr / expr` | Arithmetic division | `Div` | | `/=` | `var /= expr` | Arithmetic division and assignment | `DivEq` | | `:` | `pat: type`, `ident: type` | Constraints | | | `:` | `ident: expr` | Struct field initializer | | | `;` | `expr;` | Statement and item terminator | | | `` | `pat => expr` | Part of match arm syntax | | | `>` | `expr > expr` | Greater than comparison | `PartialOrd` | | `>=` | `expr >= expr` | Greater than or equal to comparison | `PartialOrd` | | `^` | `expr ^ expr` | Bitwise exclusive OR | `BitXor` | | &vert; | expr &vert; expr | Bitwise OR | `BitOr` | ## Non Operator Symbols The following list contains all symbols that are not used as operators; that is, they do not have the same behavior as a function or method call. Table B-2 shows symbols that appear on their own and are valid in a variety of locations. Table B-2: Stand-Alone Syntax | Symbol | Explanation | |--------|-------------| | `..._u8`, `..._usize`, etc. | Numeric literal of specific type | | `'...'` | Short string | | `_` | \u201cIgnored\u201d pattern binding; also used to make integer literals readable | Table B-3 shows symbols that are used within the context of a module hierarchy path to access an item. Table B-3: Path-Related Syntax | Symbol | Explanation | |--------|-------------| | `ident::ident` | Namespace path | | `super::path` | Path relative to the parent of the current module | | `trait::method(...)` | Disambiguating a method call by naming the trait that defines it | Table B-4 shows symbols that appear in the context of using generic type parameters. Table B-4: Generics | Symbol | Explanation | |--------|-------------| | `path` | Specifies parameters to generic type in a type (e.g., `Vec`) | | `path::`, `method::` | Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish | | `fn ident ...` | Define generic function | | `struct ident ...` | Define generic structure | | `enum ident ...` | Define generic enumeration | | `impl ...` | Define generic implementation | Table B-5 shows symbols that appear in the context of calling or defining macros and specifying attributes on an item. Table B-5: Macros and Attributes | Symbol | Explanation | |--------|-------------| | `#[meta]` | Outer attribute | Table B-6 shows symbols that create comments. Table B-6: Comments | Symbol | Explanation | |--------|-------------| | `//` | Line comment | Table B-7 shows symbols that appear in the context of using tuples. Table B-7: Tuples | Symbol | Explanation | |--------|-------------| | `()` | Empty tuple (aka unit), both literal and type | | `(expr)` | Parenthesized expression | | `(expr,)` | Single-element tuple expression | | `(type,)` | Single-element tuple type | | `(expr, ...)` | Tuple expression | | `(type, ...)` | Tuple type | | `expr(expr, ...)` | Function call expression; also used to initialize tuple `struct`s and tuple `enum` variants | Table B-8 shows the contexts in which curly braces are used. Table B-8: Curly Brackets | Context | Explanation | |---------|-------------| | `{...}` | Block expression | | `Type {...}` | `struct` literal |"}
{"title": "appendix-03-derivable-traits.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Appendix C: Derivable Traits In various places in the book, we\u2019ve discussed the `derive` attribute, which you can apply to a struct or enum definition. The `derive` attribute generates code to implement a default trait on the type you\u2019ve annotated with the `derive` syntax. In this appendix, we provide a comprehensive reference detailing all the traits in the standard library compatible with the `derive` attribute. These traits listed here are the only ones defined by the core library that can be implemented on your types using `derive`. Other traits defined in the standard library don\u2019t have sensible default behavior, so it\u2019s up to you to implement them in the way that makes sense for what you\u2019re trying to accomplish. The list of derivable traits provided in this appendix does not encompass all possibilities: external libraries can implement `derive` for their own traits, expanding the list of traits compatible with `derive`. ## PartialEq for equality comparison The `PartialEq` trait allows for comparison between instances of a type for equality, thereby enabling the == and != operators. When `PartialEq` is derived on structs, two instances are equal only if all fields are equal, and the instances are not equal if any fields are not equal. When derived on enums, each variant is equal to itself and not equal to the other variants. Example: ```Rust #[derive(PartialEq, Drop)] struct A { item: felt252 } fn main() { let first_struct = A { item: 2 }; let second_struct = A { item: 2 }; assert(first_struct == second_struct, 'Structs are different'); } ``` ## Clone and Copy for Duplicating Values The `Clone` trait provides the functionality to explicitly create a deep copy of a value. Deriving `Clone` implements the `clone` method, which, in turn, calls clone on each of the type's components. This means all the fields or values in the type must also implement `Clone` to derive `Clone`. Example: ```Rust use clone::Clone; #[derive(Clone, Drop)] struct A { item: felt252 } fn main() { let first_struct = A { item: 2 }; let second_struct = first_struct.clone(); assert(second_struct.item == 2, 'Not equal'); } ``` The `Copy` trait allows for the duplication of values. You can derive `Copy` on any type whose parts all implement `Copy`. Example: ```Rust #[derive(Copy, Drop)] struct A { item: felt252 } fn main() { let first_struct = A { item: 2 }; let second_struct = first_struct; assert(second_struct.item == 2, 'Not equal'); assert(first_struct.item == 2, 'Not Equal'); // Copy Trait prevents firs_struct from moving into second_struct } ``` ## Serializing with Serde `Serde` provides trait implementations for `serialize` and `deserialize` functions for data structures defined in your crate. It allows you to transform your structure into an array (or the opposite). Example: ```Rust use serde::Serde; use array::ArrayTrait; #[derive(Serde, Drop)] struct A { item_one: felt252, item_two: felt252, } fn main() { let first_struct = A { item_one: 2, item_two: 99, }; let mut output_array = ArrayTrait::new(); let serialized = first_struct.serialize(ref output_array); panic(output_array); } ``` Output: ```Bash Run panicked with [2 (''), 99 ('c'), ]. ``` We can see here that our struct A has been serialized into the output array. Also, we can use `deserialize` function to convert the serialized array back into our A struct. Example: ```Rust use serde::Serde; use array::ArrayTrait; use option::OptionTrait; #[derive(Serde, Drop)] struct A { item_one: felt252, item_two: felt252, } fn main() { let first_struct = A { item_one: 2, item_two: 99, }; let mut output_array = ArrayTrait::new(); let mut serialized = first_struct.serialize(ref output_array); let mut span_array = output_array.span(); let deserialized_struct: A = Serde::::deserialize(ref span_array).unwrap(); } ``` Here we are converting a serialized array span back to the struct A. `deserialize` returns an `Option` so we need to unwrap it. When using deserialize we also need to specify the type we want to deserialize into. ## Drop and Destruct When moving out of scope, variables need to be moved first. This is where the `Drop` trait intervenes. You can find more details about its usage [here](ch03-01-what-is-ownership.md#the-drop-trait). Moreover Dictionary need to be squashed before going out of scope. Calling manually the `squash` method on each of them can be quickly redundant. `Destruct` trait allows Dictionaries to be automatically squashed when they get out of scope. You can also find more information about `Destruct` [here](ch03-01-what-is-ownership.md#the-destruct-trait). ## StorageAccess Storing a user-defined struct in a storage variable within a Starknet contract requires the `StorageAccess` trait to be implemented for this type. You can automatically derive the `StorageAccess` trait for all structs that do not contain complex types like Dictionaries or Arrays. Example: ```rust #[starknet::contract] mod contract { #[derive(Drop, storage_access::StorageAccess)] struct A { item_one: felt252, item_two: felt252, } #[storage] struct Storage { my_storage: A, } } ``` Here we demonstrate the implementation of a `struct A` that derives the StorageAccess trait. This `struct A` is subsequently used as a storage variable in the contract. ## PartialOrd and Ord for Ordering Comparisons TODO (Not derivable yet ?)"}
{"title": "appendix-04-useful-development-tools.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## Appendix D - Useful Development Tools In this appendix, we talk about some useful development tools that the Cairo project provides. We\u2019ll look at automatic formatting, quick ways to apply warning fixes, a linter, and integrating with IDEs. ### Automatic Formatting with `cairo-format` The `cairo-format` tool reformats your code according to the community code style. Many collaborative projects use `cairo-format` to prevent arguments about which style to use when writing Cairo: everyone formats their code using the tool. To format any Cairo project, enter the following: ```console cairo-format -r ``` Running this command reformats all the Cairo code in the current directory, recursively. This should only change the code style, not the code semantics. ### IDE Integration Using `cairo-language-server` To help IDE integration, the Cairo community recommends using the [`cairo-language-server`][cairo-language-server]. This tool is a set of compiler-centric utilities that speaks the [Language Server Protocol][lsp], which is a specification for IDEs and programming languages to communicate with each other. Different clients can use `cairo-language-server`, such as [the Cairo extension for Visual Studio Code][vscode-cairo]. [lsp]: [vscode-cairo]: Visit the `vscode-cairo` [page][vscode-cairo] for installation instructions, You will gain abilities such as autocompletion, jump to definition, and inline errors. [cairo-language-server]:"}
{"title": "appendix-05-most-common-types-and-traits.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## Appendix E - Most Common Types and Traits Required To Write Contracts This appendix provides a reference for common types and traits used in contract development, along with their corresponding imports, paths, and usage examples. | Import | Path | Usage | | ------------------------- | ----------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `OptionTrait` | `std::OptionTrait` | `OptionTrait` defines a set of methods required to manipulate optional value. | | `ResultTrait` | `std::ResultTrait` | `ResultTrait` Type for Starknet contract address, a value in the range [0, 2 \\*\\* 251). | | `ContractAddress` | `starknet::ContractAddress` | `ContractAddress` is a type to represent the smart contract address | | `ContractAddressZeroable` | `starknet::ContractAddressZeroable` | `ContractAddressZeroable` is the implementation of the trait `Zeroable` for the `ContractAddress` type. It is required to check whether a value of `t:ContractAddress` is zero or not. | | `contract_address_const` | `starknet::contract_address_const` | The `contract_address_const!` it's a function that allows instantiating constant contract address values. | | `Into` | `traits::Into;` | `Into` is a trait used for conversion between types. If there is an implementation of Into for the types T and S, you can convert T into S. | | `TryInto` | `traits::TryInto;` | `TryInto` is a trait used for conversion between types.If there is an implementation of TryInto for the types T and S, you can convert T into S. | | `get_caller_address` | `starknet::get_caller_address` | `get_caller_address()` is a function that returns the address of the caller of the contract. It can be used to identify the caller of a contract function. | | `get_contract_address` | `starknet::get_contract_address` | `get_contract_address()` is a function that returns the address of the current contract. It can be used to obtain the address of the contract being executed. | This is not an exhaustive list, but it covers some of the commonly used types and traits in contract development. For more details, refer to the official documentation and explore the available libraries and frameworks."}
{"title": "ch00-00-introduction.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Introduction ## What is Cairo? Cairo is a programming language designed for a virtual CPU of the same name. The unique aspect of this processor is that it was not created for the physical constraints of our world but for cryptographic ones, making it capable of efficiently proving the execution of any program running on it. This means that you can perform time consuming operations on a machine you don't trust, and check the result very quickly on a cheaper machine. While Cairo 0 used to be directly compiled to CASM, the Cairo CPU assembly, Cairo 1 is a more high level language. It first compiles to Sierra, an intermediate representation of Cairo which will compile later down to a safe subset of CASM. The point of Sierra is to ensure your CASM will always be provable, even when the computation fails. ## What can you do with it? Cairo allows you to compute trustworthy values on untrusted machines. One major usecase is Starknet, a solution to Ethereum scaling. Ethereum is a decentralized blockchain platform that enables the creation of decentralized applications where every single interaction between a user and a d-app is verified by all the participants. Starknet is a Layer 2 built on top of Ethereum. Instead of having all the participants of the network to verify all user interactions, only one node, called the prover, executes the programs and generates proofs that the computations were done correctly. These proofs are then verified by an Ethereum smart contract, requiring significantly less computational power compared to executing the interactions themselves. This approach allows for increased throughput and reduced transaction costs while preserving Ethereum security. ## What are the differences with other programming languages? Cairo is quite different from traditional programming languages, especially when it comes to overhead costs and its primary advantages. Your program can be executed in two different ways: - When executed by the prover, it is similar to any other language. Because Cairo is virtualized, and because the operations were not specifically designed for maximum efficiency, this can lead to some performance overhead but it is not the most relevant part to optimize. - When the generated proof is verified by a verifier, it is a bit different. This has to be as cheap as possible since it could potentially be verified on many very small machines. Fortunately verifying is faster than computing and Cairo has some unique advantages to improve it even more. A notable one is non-determinism. This is a topic you will cover in more detail later in this book, but the idea is that you can theoretically use a different algorithm for verifying than for computing. Currently, writing custom non-deterministic code is not supported for the developers, but the standard library leverages non-determinism for improved performance. For example sorting an array in Cairo costs the same price as copying it. Because the verifier doesn't sort the array, it just checks that it is sorted, which is cheaper. Another aspect that sets the language apart is its memory model. In Cairo, memory access is immutable, meaning that once a value is written to memory, it cannot be changed. Cairo 1 provides abstractions that help developers work with these constraints, but it does not fully simulate mutability. Therefore, developers must think carefully about how they manage memory and data structures in their programs to optimize performance. ## References - Cairo CPU Architecture: - Cairo, Sierra and Casm: - State of non determinism:"}
{"title": "ch00-01-foreword.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Foreword In 2020, StarkWare released Cairo 0, a Turing-complete programming language supporting verifiable computation. Cairo started as an assembly language and gradually became more expressive. The learning curve was initially steep, as Cairo 0.x was a low-level language that did not entirely abstract the underlying cryptographic primitives required to build a proof for the execution of a program. With the release of Cairo 1, the developer experience has considerably improved, abstracting away the underlying immutable memory model of the Cairo architecture where possible. Strongly inspired by Rust, Cairo 1 has been built to help you create provable programs without specific knowledge of its underlying architecture so that you can focus on the program itself, increasing the overall security of Cairo programs. Powered by a Rust VM, the execution of Cairo programs is now _blazingly_ fast, allowing you to build an extensive test suite without compromising on performance. Blockchain developers that want to deploy contracts on Starknet will use the Cairo programming language to code their smart contracts. This allows the Starknet OS to generate execution traces for transactions to be proved by a prover, which is then verified on Ethereum L1 prior to updating the state root of Starknet. However, Cairo is not only for blockchain developers. As a general purpose programming language, it can be used for any computation that would benefit from being proved on one computer and verified on other machines with lower hardware requirements. This book is designed for developers with a basic understanding of programming concepts. It is a friendly and approachable text intended to help you level up your knowledge of Cairo, but also help you develop your programming skills in general. So, dive in and get ready to learn all there is to know about Cairo! \u2014 The Cairo community"}
{"title": "ch01-00-getting-started.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Getting Started"}
{"title": "ch01-01-installation.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Installation The first step is to install Cairo. We will download Cairo manually, using cairo repository or with an installation script. You\u2019ll need an internet connection for the download. ### Prerequisites First you will need to have Rust and Git installed. ```bash # Install stable Rust rustup override set stable && rustup update ``` Install [Git]( ## Installing Cairo with a Script ([Installer]( by [Fran]( ### Install If you wish to install a specific release of Cairo rather than the latest head, set the `CAIRO_GIT_TAG` environment variable (e.g. `export CAIRO_GIT_TAG=v2.0.0`). ```bash curl -L | bash ``` After installing, follow [these instructions](#set-up-your-shell-environment-for-cairo) to set up your shell environment. ### Update ``` rm -fr ~/.cairo curl -L | bash ``` ### Uninstall Cairo is installed within `$CAIRO_ROOT` (default: ~/.cairo). To uninstall, just remove it: ```bash rm -fr ~/.cairo ``` then remove these three lines from .bashrc: ```bash export PATH=\"$HOME/.cairo/target/release:$PATH\" ``` and finally, restart your shell: ```bash exec $SHELL ``` ### Set up your shell environment for Cairo - Define environment variable `CAIRO_ROOT` to point to the path where Cairo will store its data. `$HOME/.cairo` is the default. If you installed Cairo via Git checkout, we recommend to set it to the same location as where you cloned it. - Add the `cairo-*` executables to your `PATH` if it's not already there The below setup should work for the vast majority of users for common use cases. - For **bash**: Stock Bash startup files vary widely between distributions in which of them source which, under what circumstances, in what order and what additional configuration they perform. As such, the most reliable way to get Cairo in all environments is to append Cairo configuration commands to both `.bashrc` (for interactive shells) and the profile file that Bash would use (for login shells). First, add the commands to `~/.bashrc` by running the following in your terminal: ```bash echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bashrc echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.bashrc ``` Then, if you have `~/.profile`, `~/.bash_profile` or `~/.bash_login`, add the commands there as well. If you have none of these, add them to `~/.profile`. - to add to `~/.profile`: ```bash echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.profile echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.profile ``` - to add to `~/.bash_profile`: ```bash echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.bash_profile echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.bash_profile ``` - For **Zsh**: ```zsh echo 'export CAIRO_ROOT=\"$HOME/.cairo\"' >> ~/.zshrc echo 'command -v cairo-compile >/dev/null || export PATH=\"$CAIRO_ROOT/target/release:$PATH\"' >> ~/.zshrc ``` If you wish to get Cairo in non-interactive login shells as well, also add the commands to `~/.zprofile` or `~/.zlogin`. - For **Fish shell**: If you have Fish 3.2.0 or newer, execute this interactively: ```fish set -Ux CAIRO_ROOT $HOME/.cairo fish_add_path $CAIRO_ROOT/target/release ``` Otherwise, execute the snippet below: ```fish set -Ux CAIRO_ROOT $HOME/.cairo set -U fish_user_paths $CAIRO_ROOT/target/release $fish_user_paths ``` In MacOS, you might also want to install [Fig]( which provides alternative shell completions for many command line tools with an IDE-like popup interface in the terminal window. (Note that their completions are independent from Cairo's codebase so they might be slightly out of sync for bleeding-edge interface changes.) ### Restart your shell for the `PATH` changes to take effect. ```sh exec \"$SHELL\" ``` ## Installing Cairo Manually ([Guide]( by [Abdel]( ### Step 1: Install Cairo 1.0 If you are using an x86 Linux system and can use the release binary, download Cairo here: . For everyone else, we recommend compiling Cairo from source as follows: ```bash # Start by defining environment variable CAIRO_ROOT export CAIRO_ROOT=\"${HOME}/.cairo\" # Create .cairo folder if it doesn't exist yet mkdir $CAIRO_ROOT # Clone the Cairo compiler in $CAIRO_ROOT (default root) cd $CAIRO_ROOT && git clone git@github.com:starkware-libs/cairo.git . # OPTIONAL/RECOMMENDED: If you want to install a specific version of the compiler # Fetch all tags (versions) git fetch --all --tags # View tags (you can also do this in the cairo compiler repository) git describe --tags `git rev-list --tags` # Checkout the version you want git checkout tags/v2.0.0 # Generate release binaries cargo build --all --release ``` . **NOTE: Keeping Cairo up to date** Now that your Cairo compiler is in a cloned repository, all you will need to do is pull the latest changes and rebuild as follows: ```bash cd $CAIRO_ROOT && git fetch && git pull && cargo build --all --release ``` ### Step 2: Add Cairo 1.0 executables to your path ```bash export PATH=\"$CAIRO_ROOT/target/release:$PATH\" ``` **NOTE: If installing from a Linux binary, adapt the destination path accordingly.** ### Step 3: Setup Language Server #### VS Code Extension - If you have the previous Cairo 0 extension installed, you can disable/uninstall it. - Install the Cairo 1 extension for proper syntax highlighting and code navigation. You can find the link to the extension [here]( or just search for \"Cairo 1.0\" in the VS Code marketplace. - The extension will work out of the box once you will have [Scarb](./ch01-03-hello-scarb.md) installed. #### Cairo Language Server without Scarb If you don't want to depend on Scarb, you can still use the Cairo Language Server with the compiler binary. From [Step 1](#installing-cairo-with-a-script-installer-by-fran), the `cairo-language-server` binary should be built and executing this command will copy its path into your clipboard. ```bash which cairo-language-server | pbcopy ``` Update the `cairo1.languageServerPath` of the Cairo 1.0 extension by pasting the path."}
{"title": "ch01-02-hello-world.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## Hello, World Now that you\u2019ve installed Cairo, it\u2019s time to write your first Cairo program. It\u2019s traditional when learning a new language to write a little program that prints the text `Hello, world!` to the screen, so we\u2019ll do the same here! > Note: This book assumes basic familiarity with the command line. Cairo makes > no specific demands about your editing or tooling or where your code lives, so > if you prefer to use an integrated development environment (IDE) instead of > the command line, feel free to use your favorite IDE. The Cairo team has developed > a VSCode extension for the Cairo language that you can use to get the features from > the language server and code highlighting. See [Appendix D][devtools] > for more details. ### Creating a Project Directory You\u2019ll start by making a directory to store your Cairo code. It doesn\u2019t matter to Cairo where your code lives, but for the exercises and projects in this book, we suggest making a _cairo_projects_ directory in your home directory and keeping all your projects there. Open a terminal and enter the following commands to make a _cairo_projects_ directory and a directory for the \u201cHello, world!\u201d project within the _cairo_projects_ directory. For Linux, macOS, and PowerShell on Windows, enter this: ```console mkdir ~/cairo_projects cd ~/cairo_projects mkdir hello_world cd hello_world ``` For Windows CMD, enter this: ```cmd > mkdir \"%USERPROFILE%\\projects\" > cd /d \"%USERPROFILE%\\projects\" > mkdir hello_world > cd hello_world ``` ### Writing and Running a Cairo Program Next, make a new source file and call it _main.cairo_. Cairo files always end with the _.cairo_ extension. If you\u2019re using more than one word in your filename, the convention is to use an underscore to separate them. For example, use _hello_world.cairo_ rather than _helloworld.cairo_. Now open the _main.cairo_ file you just created and enter the code in Listing 1-1. Filename: main.cairo ```rust,file=hello_world.cairo use debug::PrintTrait; fn main() { 'Hello, world!'.print(); } ``` Listing 1-1: A program that prints `Hello, world!` Save the file and go back to your terminal window in the _~/cairo_projects/hello_world_ directory. Enter the following commands to compile and run the file: ```console $ cairo-run main.cairo Hello, world! ``` Regardless of your operating system, the string `Hello, world!` should print to the terminal. If `Hello, world!` did print, congratulations! You\u2019ve officially written a Cairo program. That makes you a Cairo programmer\u2014welcome! ### Anatomy of a Cairo Program Let\u2019s review this \u201cHello, world!\u201d program in detail. Here\u2019s the first piece of the puzzle: ```rust,ignore_format fn main() { } ``` These lines define a function named `main`. The `main` function is special: it is always the first code that runs in every executable Cairo program. Here, the first line declares a function named `main` that has no parameters and returns nothing. If there were parameters, they would go inside the parentheses `()`. The function body is wrapped in `{}`. Cairo requires curly brackets around all function bodies. It\u2019s good style to place the opening curly bracket on the same line as the function declaration, adding one space in between. > Note: If you want to stick to a standard style across Cairo projects, you can > use the automatic formatter tool called `cairo-format` to format your code in a > particular style (more on `cairo-format` in > [Appendix D][devtools]). The Cairo team has included this tool > with the standard Cairo distribution, as `cairo-run` is, so it should already be > installed on your computer! Prior to the main function declaration, The line `use debug::PrintTrait;` is responsible for importing an item defined in another module. In this case, we are importing the `PrintTrait` item from the Cairo core library. By doing so, we gain the ability to use the `print()` method on data types that are compatible with printing. The body of the `main` function holds the following code: ```rust 'Hello, world!'.print(); ``` This line does all the work in this little program: it prints text to the screen. There are four important details to notice here. First, Cairo style is to indent with four spaces, not a tab. Second, the `print()` function called is a method from the trait `PrintTrait`. This trait is imported from the Cairo core library, and it defines how to print values to the screen for different data types. In our case, our text is defined as a \"short string\", which is an ASCII string that can fit in Cairo's basic data type, which is the `felt252` type. By calling `Hello, world!'.print()`, we're calling the `print()` method of the `felt252` implementation of the `PrintTrait` trait. Third, you see the `'Hello, world!'` short string. We pass this short string as an argument to `print()`, and the short string is printed to the screen. Fourth, we end the line with a semicolon (`;`), which indicates that this expression is over and the next one is ready to begin. Most lines of Cairo code end with a semicolon. Just running with `cairo-run` is fine for simple programs, but as your project grows, you\u2019ll want to manage all the options and make it easy to share your code. Next, we\u2019ll introduce you to the Scarb tool, which will help you write real-world Cairo programs. [devtools]: appendix-04-useful-development-tools.md"}
{"title": "ch01-03-hello-scarb.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Hello, Scarb Scarb is the Cairo package manager and heavily inspired by [Cargo]( Rust\u2019s build system and package manager. Scarb handles a lot of tasks for you, such as building your code (either pure Cairo or Starknet contracts), downloading the libraries your code depends on, building those libraries, and provides LSP support for the VSCode Cairo 1 extension. If we were to build the 'Hello, world!' project using Scarb, only the part of Scarb that handles building the code would be used, since the program doesn't require any external dependencies. As you write more complex Cairo programs, you\u2019ll add dependencies, and if you start a project using Scarb, adding dependencies will be much easier to do. Let's start by installing Scarb. ## Installing Scarb ### Requirements Scarb requires a Git executable to be available in the `PATH` environment variable. ### Installation To install Scarb, please refer to the [installation instructions]( You can simply run the following command in your terminal, then follow the onscreen instructions. This will install the latest stable release. ```bash curl --proto '= --tlsv1.2 -sSf | sh ``` - Verify installation by running the following command in new terminal session, it should print both Scarb and Cairo language versions, e.g: ```bash $ scarb --version scarb 0.5.0 (1b109f1f6 2023-07-03) cairo: 2.0.0 ( ``` ### Creating a Project with Scarb Let\u2019s create a new project using Scarb and look at how it differs from our original \u201cHello, world!\u201d project. Navigate back to your projects directory (or wherever you decided to store your code). Then run the following: ```bash $ scarb new hello_scarb ``` It creates a new directory and project called hello_scarb. We\u2019ve named our project hello_scarb, and Scarb creates its files in a directory of the same name. Go into the hello_scarb directory with the command `cd hello_scarb`. You\u2019ll see that Scarb has generated two files and one directory for us: a `Scarb.toml` file and a src directory with a `lib.cairo` file inside. It has also initialized a new Git repository along with a `.gitignore` file > Note: Git is a common version control system. You can stop using version control system by using the `--vcs` flag. > Run `scarb new -help` to see the available options. Open _Scarb.toml_ in your text editor of choice. It should look similar to the code in Listing 1-2. Filename: Scarb.toml ```toml [package] name = \"hello_scarb\" version = \"0.1.0\" # See more keys and their definitions at [dependencies] # foo = { path = \"vendor/foo\" } ``` Listing 1-2: Contents of Scarb.toml generated by `scarb new` This file is in the [TOML]( (Tom\u2019s Obvious, Minimal Language) format, which is Scarb\u2019s configuration format. The first line, `[package]`, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we\u2019ll add other sections. The next two lines set the configuration information Scarb needs to compile your program: the name and the version of Scarb to use. The last line, `[dependencies]`, is the start of a section for you to list any of your project\u2019s dependencies. In Cairo, packages of code are referred to as crates. We won\u2019t need any other crates for this project. > Note: If you're building contracts for Starknet, you will need to add the `starknet` dependency as mentioned in the [Scarb documentation]( The other file created by Scarb is `src/lib.cairo`, let's delete all the content and put in the following content, we will explain the reason later. ```rust mod hello_scarb; ``` Then create a new file called `src/hello_scarb.cairo` and put the following code in it: Filename: src/hello_scarb.cairo ```rust,file=hello_scarb.cairo use debug::PrintTrait; fn main() { 'Hello, Scarb!'.print(); } ``` We have just created a file called `lib.cairo`, which contains a module declaration referencing another module named \"hello_scarb\", as well as the file `hello_scarb.cairo`, containing the implementation details of the \"hello_scarb\" module. Scarb requires your source files to be located within the src directory. The top-level project directory is reserved for README files, license information, configuration files, and any other non-code-related content. Scarb ensures a designated location for all project components, maintaining a structured organization. If you started a project that doesn\u2019t use Scarb, as we did with the \u201cHello, world!\u201d project, you can convert it to a project that does use Scarb. Move the project code into the src directory and create an appropriate `Scarb.toml` file. ### Building a Scarb Project From your hello_scarb directory, build your project by entering the following command: ```bash $ scarb build Compiling hello_scarb v0.1.0 (file:///projects/Scarb.toml) Finished release target(s) in 0 seconds ``` This command creates a `sierra` file in `target/release`, let's ignore the `sierra` file for now. If you have installed Cairo correctly, you should be able to run and see the following output: ```bash $ cairo-run src/lib.cairo [DEBUG] Hello, Scarb! (raw: 5735816763073854913753904210465) Run completed successfully, returning [] ``` > Note: You will notice here that we didn't use a Scarb command, but rather a command from the Cairo binaries directly. > As Scarb doesn't have a command to execute Cairo code yet, we have to use the `cairo-run` command directly. > We will use this command in the rest of the tutorial, but we will also use Scarb commands to initialize projects. ### Defining Custom Scripts We can define Scarb scripts in `Scarb.toml` file, which can be used to execute custom shell scripts. Add the following line to your `Scarb.toml` file: ```toml [scripts] run-lib = \"cairo-run src/lib.cairo\" ``` Now you can run the following command to run the project: ```bash $ scarb run run-lib [DEBUG] Hello, Scarb! (raw: 5735816763073854913753904210465) Run completed successfully, returning [] ``` Using `scarb run` is a convenient way to run custom shell scripts that can be useful to run files and test your project. ### Running tests To run all the tests associated with a particular package, you can use the `scarb test` command. It is not a test runner by itself, but rather delegates work to a testing solution of choice. Scarb comes with preinstalled `scarb cairo-test` extension, which bundles Cairo's native test runner. It is the default test runner used by scarb test. To use third-party test runners, please refer to [Scarb's documentation]( For instance, if you want to use [Protostar]( as your testing framework, you can modify the `Scarb.toml` file as follows: ```toml [scripts] test = \"protostar test\" ``` Test functions are marked with the `#[test]` attributes, and running `scarb test` will run all test functions in your codebase under the `src/` directory. ```rust \u251c\u2500\u2500 Scarb.toml \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 lib.cairo \u2502 \u2514\u2500\u2500 file.cairo ``` A sample Scarb project structure Let\u2019s recap what we\u2019ve learned so far about Scarb: - We can create a project using `scarb new`. - We can build a project using `scarb build` to generate the compiled Sierra code. - We can define custom scripts in `Scarb.toml` and call them with the `scarb run` command. - We can run tests using the `scarb test` command. An additional advantage of using Scarb is that the commands are the same no matter which operating system you\u2019re working on. So, at this point, we\u2019ll no longer provide specific instructions for Linux and macOS versus Windows. # Summary You\u2019re already off to a great start on your Cairo journey! In this chapter, you\u2019ve learned how to: - Install the latest stable version of Cairo - Write and run a \u201cHello, world!\u201d program using `cairo-run` directly - Create and run a new project using the conventions of Scarb - Execute tests using the `scarb test` command This is a great time to build a more substantial program to get used to reading and writing Cairo code."}
{"title": "ch02-00-common-programming-concepts.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Common Programming Concepts This chapter covers concepts that appear in almost every programming language and how they work in Cairo. Many programming languages have much in common at their core. None of the concepts presented in this chapter are unique to Cairo, but we\u2019ll discuss them in the context of Cairo and explain the conventions around using these concepts. Specifically, you\u2019ll learn about variables, basic types, functions, comments, and control flow. These foundations will be in every Cairo program, and learning them early will give you a strong core to start from."}
{"title": "ch02-01-variables-and-mutability.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## Variables and Mutability Cairo uses an immutable memory model, meaning that once a memory cell is written to, it can't be overwritten but only read from. To reflect this immutable memory model, variables in Cairo are immutable by default. However, the language abstracts this model and gives you the option to make your variables mutable. Let\u2019s explore how and why Cairo enforces immutability, and how you can make your variables mutable. When a variable is immutable, once a value is bound to a name, you can\u2019t change that value. To illustrate this, generate a new project called _variables_ in your _cairo_projects_ directory by using `scarb new variables`. Then, in your new _variables_ directory, open _src/lib.cairo_ and replace its code with the following code, which won\u2019t compile just yet: Filename: src/lib.cairo ```rust,does_not_compile {{#include ../listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable.cairo}} ``` Save and run the program using `cairo-run src/lib.cairo`. You should receive an error message regarding an immutability error, as shown in this output: ```console error: Cannot assign to an immutable variable. --> lib.cairo:5:5 x = 6; ^***^ Error: failed to compile: src/lib.cairo ``` This example shows how the compiler helps you find errors in your programs. Compiler errors can be frustrating, but really they only mean your program isn\u2019t safely doing what you want it to do yet; they do _not_ mean that you\u2019re not a good programmer! Experienced Caironautes still get compiler errors. You received the error message `Cannot assign to an immutable variable.` because you tried to assign a second value to the immutable `x` variable. It\u2019s important that we get compile-time errors when we attempt to change a value that\u2019s designated as immutable because this specific situation can lead to bugs. If one part of our code operates on the assumption that a value will never change and another part of our code changes that value, it\u2019s possible that the first part of the code won\u2019t do what it was designed to do. The cause of this kind of bug can be difficult to track down after the fact, especially when the second piece of code changes the value only _sometimes_. The Cairo compiler guarantees that when you state that a value won\u2019t change, it really won\u2019t change, so you don\u2019t have to keep track of it yourself. Your code is thus easier to reason through. But mutability can be very useful, and can make code more convenient to write. Although variables are immutable by default, you can make them mutable by adding `mut` in front of the variable name. Adding `mut` also conveys intent to future readers of the code by indicating that other parts of the code will be changing this variable\u2019s value. However, you might be wondering at this point what exactly happens when a variable is declared as `mut`, as we previously mentioned that Cairo's memory is immutable. The answer is that Cairo's memory is immutable, but the memory address the variable points to can be changed. Upon examining the low-level Cairo Assembly code, it becomes clear that variable mutation is implemented as syntactic sugar, which translates mutation operations into a series of steps equivalent to variable shadowing. The only difference is that at the Cairo level, the variable is not redeclared so its type cannot change. For example, let\u2019s change _src/lib.cairo_ to the following: Filename: src/lib.cairo ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_02_adding_mut.cairo}} ``` When we run the program now, we get this: ```console \u276f cairo-run src/lib.cairo [DEBUG] (raw: 5) [DEBUG] (raw: 6) Run completed successfully, returning [] ``` We\u2019re allowed to change the value bound to `x` from `5` to `6` when `mut` is used. Ultimately, deciding whether to use mutability or not is up to you and depends on what you think is clearest in that particular situation. ### Constants Like immutable variables, _constants_ are values that are bound to a name and are not allowed to change, but there are a few differences between constants and variables. First, you aren\u2019t allowed to use `mut` with constants. Constants aren\u2019t just immutable by default\u2014they\u2019re always immutable. You declare constants using the `const` keyword instead of the `let` keyword, and the type of the value _must_ be annotated. We\u2019ll cover types and type annotations in the next section, [\u201cData Types\u201d][data-types], so don\u2019t worry about the details right now. Just know that you must always annotate the type. Constants can only be declared in the global scope, which makes them useful for values that many parts of code need to know about. The last difference is that constants may be set only to a constant expression, not the result of a value that could only be computed at runtime. Only literal constants are currently supported. Here\u2019s an example of a constant declaration: ```rust const ONE_HOUR_IN_SECONDS: u32 = 3600; ``` Cairo's naming convention for constants is to use all uppercase with underscores between words. Constants are valid for the entire time a program runs, within the scope in which they were declared. This property makes constants useful for values in your application domain that multiple parts of the program might need to know about, such as the maximum number of points any player of a game is allowed to earn, or the speed of light. Naming hardcoded values used throughout your program as constants is useful in conveying the meaning of that value to future maintainers of the code. It also helps to have only one place in your code you would need to change if the hardcoded value needed to be updated in the future. ### Shadowing Variable shadowing refers to the declaration of a new variable with the same name as a previous variable. Caironautes say that the first variable is _shadowed_ by the second, which means that the second variable is what the compiler will see when you use the name of the variable. In effect, the second variable overshadows the first, taking any uses of the variable name to itself until either it itself is shadowed or the scope ends. We can shadow a variable by using the same variable\u2019s name and repeating the use of the `let` keyword as follows: Filename: src/lib.cairo ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_03_shadowing.cairo}} ``` This program first binds `x` to a value of `5`. Then it creates a new variable `x` by repeating `let x =`, taking the original value and adding `1` so the value of `x` is then `6`. Then, within an inner scope created with the curly brackets, the third `let` statement also shadows `x` and creates a new variable, multiplying the previous value by `2` to give `x` a value of `12`. When that scope is over, the inner shadowing ends and `x` returns to being `6`. When we run this program, it will output the following: ```console cairo-run src/lib.cairo [DEBUG] Inner scope x value is: (raw: 7033328135641142205392067879065573688897582790068499258) [DEBUG] (raw: 12) [DEBUG] Outer scope x value is: (raw: 7610641743409771490723378239576163509623951327599620922) [DEBUG] (raw: 6) Run completed successfully, returning [] ``` Shadowing is different from marking a variable as `mut` because we\u2019ll get a compile-time error if we accidentally try to reassign to this variable without using the `let` keyword. By using `let`, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed. Another distinction between `mut` and shadowing is that when we use the `let` keyword again, we are effectively creating a new variable, which allows us to change the type of the value while reusing the same name. As mentioned before, variable shadowing and mutable variables are equivalent at the lower level. The only difference is that by shadowing a variable, the compiler will not complain if you change its type. For example, say our program performs a type conversion between the `u64` and `felt252` types. ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_04_shadowing_different_type.cairo}} ``` The first `x` variable has a `u64` type while the second `x` variable has a `felt252` type. Shadowing thus spares us from having to come up with different names, such as `x_u64` and `x_felt252`; instead, we can reuse the simpler `x` name. However, if we try to use `mut` for this, as shown here, we\u2019ll get a compile-time error: ```rust,does_not_compile {{#include ../listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type.cairo}} ``` The error says we were expecting a `u64` (the original type) but we got a different type: ```console \u276f cairo-run src/lib.cairo error: Unexpected argument type. Expected: \"core::u64\", found: \"core::felt252\". --> lib.cairo:6:9 x = x.into(); ^******^ Error: failed to compile: src/lib.cairo ``` Now that we\u2019ve explored how variables work, let\u2019s look at more data types they can have. [data-types]: ch02-02-data-types.md"}
{"title": "ch02-02-data-types.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## Data Types Every value in Cairo is of a certain _data type_, which tells Cairo what kind of data is being specified so it knows how to work with that data. This section covers two subsets of data types: scalars and compounds. Keep in mind that Cairo is a _statically typed_ language, which means that it must know the types of all variables at compile time. The compiler can usually infer the desired type based on the value and its usage. In cases when many types are possible, we can use a cast method where we specify the desired output type. ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_06_data_types.cairo}} ``` You\u2019ll see different type annotations for other data types. ### Scalar Types A _scalar_ type represents a single value. Cairo has three primary scalar types: felts, integers, and booleans. You may recognize these from other programming languages. Let\u2019s jump into how they work in Cairo. #### Felt Type In Cairo, if you don't specify the type of a variable or argument, its type defaults to a field element, represented by the keyword `felt252`. In the context of Cairo, when we say \u201ca field element\u201d we mean an integer in the range `0 Table 3-1: Integer Types in Cairo | Length | Unsigned | | ------- | -------- | | 8-bit | `u8` | | 16-bit | `u16` | | 32-bit | `u32` | | 64-bit | `u64` | | 128-bit | `u128` | | 256-bit | `u256` | | 32-bit | `usize` | Each variant has an explicit size. Note that for now, the `usize` type is just an alias for `u32`; however, it might be useful when in the future Cairo can be compiled to MLIR. As variables are unsigned, they can't contain a negative number. This code will cause the program to panic: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_07_integer_types.cairo}} ``` You can write integer literals in any of the forms shown in Table 3-2. Note that number literals that can be multiple numeric types allow a type suffix, such as `57_u8`, to designate the type. Table 3-2: Integer Literals in Cairo | Numeric literals | Example | | ---------------- | --------- | | Decimal | `98222` | | Hex | `0xff` | | Octal | `0o04321` | | Binary | `0b01` | So how do you know which type of integer to use? Try to estimate the max value your int can have and choose the good size. The primary situation in which you\u2019d use `usize` is when indexing some sort of collection. #### Numeric Operations Cairo supports the basic mathematical operations you\u2019d expect for all the integer types: addition, subtraction, multiplication, division, and remainder. Integer division truncates toward zero to the nearest integer. The following code shows how you\u2019d use each numeric operation in a `let` statement: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_08_numeric_operations.cairo}} ``` Each expression in these statements uses a mathematical operator and evaluates to a single value, which is then bound to a variable. [Appendix B][appendix_b] contains a list of all operators that Cairo provides. #### The Boolean Type As in most other programming languages, a Boolean type in Cairo has two possible values: `true` and `false`. Booleans are one felt252 in size. The Boolean type in Cairo is specified using `bool`. For example: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_09_boolean_type.cairo}} ``` The main way to use Boolean values is through conditionals, such as an `if` expression. We\u2019ll cover how `if` expressions work in Cairo in the [\u201cControl Flow\u201d][control-flow] section. #### The Short String Type Cairo doesn't have a native type for strings, but you can store characters forming what we call a \"short string\" inside `felt252`s. A short string has a max length of 31 chars. This is to ensure that it can fit in a single felt (a felt is 252 bits, one ASCII char is 8 bits). Here are some examples of declaring values by putting them between single quotes: ```rust {{#rustdoc_include ../listings/ch02-common-programming-concepts/no_listing_10_short_string_type.cairo:2:3}} ``` ### Type casting In Cairo, you can convert types scalar types from one type to another by using the `try_into` and `into` methods provided by the `TryInto` and `Into` traits, respectively. The `try_into` method allows for safe type casting when the target type might not fit the source value. Keep in mind that `try_into` returns an `Option` type, which you'll need to unwrap to access the new value. On the other hand, the `into` method can be used for type casting when success is guaranteed, such as when the source type is smaller than the destination type. To perform the conversion, call `var.into()` or `var.try_into()` on the source value to cast it to another type. The new variable's type must be explicitly defined, as demonstrated in the example below. ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_11_type_casting.cairo}} ``` ### The Tuple Type A _tuple_ is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size. We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don\u2019t have to be the same. We\u2019ve added optional type annotations in this example: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_12_tuple_type.cairo}} ``` The variable `tup` binds to the entire tuple because a tuple is considered a single compound element. To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_13_tuple_destructuration.cairo}} ``` This program first creates a tuple and binds it to the variable `tup`. It then uses a pattern with `let` to take `tup` and turn it into three separate variables, `x`, `y`, and `z`. This is called _destructuring_ because it breaks the single tuple into three parts. Finally, the program prints `y is six` as the value of `y` is `6`. We can also declare the tuple with value and types at the same time. For example: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_14_tuple_types.cairo}} ``` ### The unit type () A _unit type_ is a type which has only one value `()`. It is represented by a tuple with no elements. Its size is always zero, and it is guaranteed to not exist in the compiled code. [control-flow]: ch02-05-control-flow.md [appendix_b]: appendix-02-operators-and-symbols.md#operators"}
{"title": "ch02-03-functions.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## Functions Functions are prevalent in Cairo code. You\u2019ve already seen one of the most important functions in the language: the `main` function, which is the entry point of many programs. You\u2019ve also seen the `fn` keyword, which allows you to declare new functions. Cairo code uses _snake case_ as the conventional style for function and variable names, in which all letters are lowercase and underscores separate words. Here\u2019s a program that contains an example function definition: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_15_functions.cairo}} ``` We define a function in Cairo by entering `fn` followed by a function name and a set of parentheses. The curly brackets tell the compiler where the function body begins and ends. We can call any function we\u2019ve defined by entering its name followed by a set of parentheses. Because `another_function` is defined in the program, it can be called from inside the `main` function. Note that we defined `another_function` _before_ the `main` function in the source code; we could have defined it after as well. Cairo doesn\u2019t care where you define your functions, only that they\u2019re defined somewhere in a scope that can be seen by the caller. Let\u2019s start a new project with Scarb named _functions_ to explore functions further. Place the `another_function` example in _src/lib.cairo_ and run it. You should see the following output: ```console $ cairo-run src/lib.cairo [DEBUG] Hello, world! (raw: 5735816763073854953388147237921) [DEBUG] Another function. (raw: 22265147635379277118623944509513687592494) ``` The lines execute in the order in which they appear in the `main` function. First the \u201cHello, world!\u201d message prints, and then `another_function` is called and its message is printed. ### Parameters We can define functions to have _parameters_, which are special variables that are part of a function\u2019s signature. When a function has parameters, you can provide it with concrete values for those parameters. Technically, the concrete values are called _arguments_, but in casual conversation, people tend to use the words _parameter_ and _argument_ interchangeably for either the variables in a function\u2019s definition or the concrete values passed in when you call a function. In this version of `another_function` we add a parameter: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_16_single_param.cairo}} ``` Try running this program; you should get the following output: ```console $ cairo-run src/lib.cairo [DEBUG] (raw: 5) ``` The declaration of `another_function` has one parameter named `x`. The type of `x` is specified as `felt252`. When we pass `5` in to `another_function`, the `.print()` function outputs `5` in the console. In function signatures, you _must_ declare the type of each parameter. This is a deliberate decision in Cairo\u2019s design: requiring type annotations in function definitions means the compiler almost never needs you to use them elsewhere in the code to figure out what type you mean. The compiler is also able to give more helpful error messages if it knows what types the function expects. When defining multiple parameters, separate the parameter declarations with commas, like this: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_17_multiple_params.cairo}} ``` This example creates a function named `another_function` with two parameters. The first parameter is named `x` and is an `felt252`. The second is named `y` and is type `felt252` too. The function then prints the content of the felt `x` and then the content of the felt `y`. Let\u2019s try running this code. Replace the program currently in your _functions_ project\u2019s _src/lib.cairo_ file with the preceding example and run it using `cairo-run src/lib.cairo`: ```console $ cairo-run src/lib.cairo [DEBUG] (raw: 5) [DEBUG] (raw: 6) ``` Because we called the function with `5` as the value for `x` and `6` as the value for `y`, the program output contains those values. #### Named parameters In Cairo, named parameters allow you to specify the names of arguments when you call a function. This makes the function calls more readable and self-descriptive. If you want to use named parameters, you need to specify the name of the parameter and the value you want to pass to it. The syntax is `parameter_name: value`. If you pass a variable that has the same name as the parameter, you can simply write `:parameter_name` instead of `parameter_name: variable_name`. Here is an example: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_36_named_parameters.cairo}} ``` ### Statements and Expressions Function bodies are made up of a series of statements optionally ending in an expression. So far, the functions we\u2019ve covered haven\u2019t included an ending expression, but you have seen an expression as part of a statement. Because Cairo is an expression-based language, this is an important distinction to understand. Other languages don\u2019t have the same distinctions, so let\u2019s look at what statements and expressions are and how their differences affect the bodies of functions. - **Statements** are instructions that perform some action and do not return a value. - **Expressions** evaluate to a resultant value. Let\u2019s look at some examples. We\u2019ve actually already used statements and expressions. Creating a variable and assigning a value to it with the `let` keyword is a statement. In Listing 2-1, `let y = 6;` is a statement. ```rust {{#include ../listings/ch02-common-programming-concepts/listing_01_statement.cairo}} ``` Listing 2-1: A `main` function declaration containing one statement Function definitions are also statements; the entire preceding example is a statement in itself. Statements do not return values. Therefore, you can\u2019t assign a `let` statement to another variable, as the following code tries to do; you\u2019ll get an error: ```rust,does_not_compile,ignore_format {{#include ../listings/ch02-common-programming-concepts/no_listing_18_statements_dont_return_values.cairo}} ``` When you run this program, the error you\u2019ll get looks like this: ```console $ cairo-run src/lib.cairo error: Missing token TerminalRParen. --> src/lib.cairo:2:14 let x = (let y = 6); ^ error: Missing token TerminalSemicolon. --> src/lib.cairo:2:14 let x = (let y = 6); ^ error: Missing token TerminalSemicolon. --> src/lib.cairo:2:14 let x = (let y = 6); ^ error: Skipped tokens. Expected: statement. --> src/lib.cairo:2:14 let x = (let y = 6); ``` The `let y = 6` statement does not return a value, so there isn\u2019t anything for `x` to bind to. This is different from what happens in other languages, such as C and Ruby, where the assignment returns the value of the assignment. In those languages, you can write `x = y = 6` and have both `x` and `y` have the value `6`; that is not the case in Cairo. Expressions evaluate to a value and make up most of the rest of the code that you\u2019ll write in Cairo. Consider a math operation, such as `5 + 6`, which is an expression that evaluates to the value `11`. Expressions can be part of statements: in Listing 2-1, the `6` in the statement `let y = 6;` is an expression that evaluates to the value `6`. Calling a function is an expression. A new scope block created with curly brackets is an expression, for example: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_19_blocks_are_expressions.cairo}} ``` This expression: ```rust, does_not_compile, ignore_format { {{#include ../listings/ch02-common-programming-concepts/no_listing_19_blocks_are_expressions.cairo:4:5}} } ``` is a block that, in this case, evaluates to `4`. That value gets bound to `y` as part of the `let` statement. Note that the `x + 1` line doesn\u2019t have a semicolon at the end, which is unlike most of the lines you\u2019ve seen so far. Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement, and it will then not return a value. Keep this in mind as you explore function return values and expressions next. ### Functions with Return Values Functions can return values to the code that calls them. We don\u2019t name return values, but we must declare their type after an arrow (`->`). In Cairo, the return value of the function is synonymous with the value of the final expression in the block of the body of a function. You can return early from a function by using the `return` keyword and specifying a value, but most functions return the last expression implicitly. Here\u2019s an example of a function that returns a value: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_20_function_return_values.cairo}} ``` There are no function calls, or even `let` statements in the `five` function\u2014just the number `5` by itself. That\u2019s a perfectly valid function in Cairo. Note that the function\u2019s return type is specified too, as `-> u32`. Try running this code; the output should look like this: ```console $ cairo-run src/lib.cairo [DEBUG] (raw: 5) ``` The `5` in `five` is the function\u2019s return value, which is why the return type is `u32`. Let\u2019s examine this in more detail. There are two important bits: first, the line `let x = five();` shows that we\u2019re using the return value of a function to initialize a variable. Because the function `five` returns a `5`, that line is the same as the following: ```rust, does_not_compile let x = 5; ``` Second, the `five` function has no parameters and defines the type of the return value, but the body of the function is a lonely `5` with no semicolon because it\u2019s an expression whose value we want to return. Let\u2019s look at another example: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_21_function_return_values_2.cairo}} ``` Running this code will print `[DEBUG] (raw: 6)`. But if we place a semicolon at the end of the line containing `x + 1`, changing it from an expression to a statement, we\u2019ll get an error: ```rust,does_not_compile {{#include ../listings/ch02-common-programming-concepts/no_listing_22_function_return_invalid.cairo}} ``` Compiling this code produces an error, as follows: ```console error: Unexpected return type. Expected: \"core::u32\", found: \"()\". ``` The main error message, `Unexpected return type`, reveals the core issue with this code. The definition of the function `plus_one` says that it will return an `u32`, but statements don\u2019t evaluate to a value, which is expressed by `()`, the unit type. Therefore, nothing is returned, which contradicts the function definition and results in an error."}
{"title": "ch02-04-comments.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Comments In Cairo programs, you can include explanatory text within the code using comments. To create a comment, use the // syntax, after which any text on the same line will be ignored by the compiler. ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_23_comments.cairo}} ```"}
{"title": "ch02-05-control-flow.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## Control Flow The ability to run some code depending on whether a condition is true and to run some code repeatedly while a condition is true are basic building blocks in most programming languages. The most common constructs that let you control the flow of execution of Cairo code are if expressions and loops. ### `if` Expressions An if expression allows you to branch your code depending on conditions. You provide a condition and then state, \u201cIf this condition is met, run this block of code. If the condition is not met, do not run this block of code.\u201d Filename: main.cairo ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_24_if.cairo}} ``` All `if` expressions start with the keyword `if`, followed by a condition. In this case, the condition checks whether or not the variable `number` has a value equal to 5. We place the block of code to execute if the condition is `true` immediately after the condition inside curly brackets. Optionally, we can also include an `else` expression, which we chose to do here, to give the program an alternative block of code to execute should the condition evaluate to `false`. If you don\u2019t provide an `else` expression and the condition is `false`, the program will just skip the `if` block and move on to the next bit of code. Try running this code; you should see the following output: ```console $ cairo-run main.cairo [DEBUG] condition was false ``` Let\u2019s try changing the value of `number` to a value that makes the condition `true` to see what happens: ```rust, does_not_compile let number = 5; ``` ```console $ cairo-run main.cairo condition was true ``` It\u2019s also worth noting that the condition in this code must be a bool. If the condition isn\u2019t a bool, we\u2019ll get an error. ```console $ cairo-run main.cairo thread 'main' panicked at 'Failed to specialize: `enum_match`. Error: Could not specialize libfunc `enum_match` with generic_args: [Type(ConcreteTypeId { id: 1, debug_name: None })]. Error: Provided generic argument is unsupported.', crates/cairo-lang-sierra-generator/src/utils.rs:256:9 ``` ### Handling Multiple Conditions with `else if` You can use multiple conditions by combining if and else in an else if expression. For example: Filename: main.cairo ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_25_else_if.cairo}} ``` This program has four possible paths it can take. After running it, you should see the following output: ```console [DEBUG] number is 3 ``` When this program executes, it checks each `if` expression in turn and executes the first body for which the condition evaluates to `true`. Note that even though `number - 2 == 1` is `true`, we don\u2019t see the output `number minus 2 is 1'.print()`, nor do we see the `number not found` text from the `else` block. That\u2019s because Cairo only executes the block for the first true condition, and once it finds one, it doesn\u2019t even check the rest. Using too many `else if` expressions can clutter your code, so if you have more than one, you might want to refactor your code. Chapter 5 describes a powerful Cairo branching construct called `match` for these cases. ### Using `if` in a `let` statement Because if is an expression, we can use it on the right side of a let statement to assign the outcome to a variable. Filename: main.cairo ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_26_if_let.cairo}} ``` ```console $ cairo-run main.cairo [DEBUG] condition was true ``` The `number` variable will be bound to a value based on the outcome of the `if` expression. Which will be 5 here. ### Repetition with Loops It\u2019s often useful to execute a block of code more than once. For this task, Cairo provides a simple loop syntax, which will run through the code inside the loop body to the end and then start immediately back at the beginning. To experiment with loops, let\u2019s create a new project called loops. Cairo only has one kind of loop for now: `loop`. #### Repeating Code with `loop` The `loop` keyword tells Cairo to execute a block of code over and over again forever or until you explicitly tell it to stop. As an example, change the _src/lib.cairo_ file in your _loops_ directory to look like this: Filename: src/lib.cairo ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_27_loop.cairo}} ``` When we run this program, we\u2019ll see `again!` printed over and over continuously until we stop the program manually, because the stop condition is never reached. While the compiler prevents us from writing programs without a stop condition (`break` statement), the stop condition might never be reached, resulting in an infinite loop. Most terminals support the keyboard shortcut ctrl-c to interrupt a program that is stuck in a continual loop. Give it a try: ```console \u276f cairo-run src/lib.cairo --available-gas=20000000 [DEBUG] again (raw: 418346264942) [DEBUG] again (raw: 418346264942) [DEBUG] again (raw: 418346264942) [DEBUG] again (raw: 418346264942) Run panicked with err values: [375233589013918064796019] Remaining gas: 1050 ``` > Note: Cairo prevents us from running program with infinite loops by including a gas meter. The gas meter is a mechanism that limits the amount of computation that can be done in a program. By setting a value to the `--available-gas` flag, we can set the maximum amount of gas available to the program. Gas is a unit of measurements that expresses the computation cost of an instruction. When the gas meter runs out, the program will stop. In this case, the program panicked because it ran out of gas, as the stop condition was never reached. > It is particularly important in the context of smart contracts deployed on Starknet, as it prevents from running infinite loops on the network. > If you're writing a program that needs to run a loop, you will need to execute it with the `--available-gas` flag set to a value that is large enough to run the program. To break out of a loop, you can place the `break` statement within the loop to tell the program when to stop executing the loop. Let's fix the infinite loop by adding a making the stop condition `i > 10` reachable. ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_28_loop_break.cairo}} ``` The `continue` keyword tells the program to go to the next iteration of the loop and to skip the rest of the code in this iteration. Let's add a `continue` statement to our loop to skip the `print` statement when `i` is equal to `5`. ```rust use debug::PrintTrait; fn main() { let mut i: usize = 0; loop { if i > 10 { break; } if i == 5 { i += 1; continue; } i.print(); i += 1; } } ``` Executing this program will not print the value of `i` when it is equal to `5`. #### Returning Values from Loops One of the uses of a `loop` is to retry an operation you know might fail, such as checking whether an operation has succeeded. You might also need to pass the result of that operation out of the loop to the rest of your code. To do this, you can add the value you want returned after the `break` expression you use to stop the loop; that value will be returned out of the loop so you can use it, as shown here: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_29_loop_return_values.cairo}} ``` Before the loop, we declare a variable named `counter` and initialize it to `0`. Then we declare a variable named `result` to hold the value returned from the loop. On every iteration of the loop, we check whether the `counter` is equal to `10`, and then add `1` to the `counter` variable. When the condition is met, we use the `break` keyword with the value `counter * 2`. After the loop, we use a semicolon to end the statement that assigns the value to `result`. Finally, we print the value in `result`, which in this case is `20`."}
{"title": "ch02-06-common-collections.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## Common Collections Cairo1 provides a set of common collection types that can be used to store and manipulate data. These collections are designed to be efficient, flexible, and easy to use. This section introduces the primary collection types available in Cairo1: `Array` and `Felt252Dict` (coming soon). ### Array An array is a collection of elements of the same type. You can create and use array methods by importing the `array::ArrayTrait` trait. An important thing to note is that arrays have limited modifications options. Arrays are, in fact, queues whose values can't be modified. This has to do with the fact that once a memory slot is written to, it cannot be overwritten, but only read from it. You can only append items to the end of an array and remove items from the front using `pop_front`. #### Creating an Array Creating an Array is done with the `ArrayTrait::new()` call. Here is an example of the creation of an array to which we append 3 elements: ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_30_array_new_append.cairo}} ``` You can pass the expected type of items inside the array when instantiating the array like this ```rust, does_not_compile let mut arr = ArrayTrait::::new(); ``` #### Updating an Array ##### Adding Elements To add an element to the end of an array, you can use the `append()` method: ```rust {{#rustdoc_include ../listings/ch02-common-programming-concepts/no_listing_30_array_new_append.cairo:5}} ``` ##### Removing Elements You can only remove elements from the front of an array by using the `pop_front()` method. This method returns an `Option` containing the removed element, or `Option::None` if the array is empty. ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_31_array_pop_front.cairo}} ``` The above code will print `10` as we remove the first element that was added. In Cairo, memory is immutable, which means that it is not possible to modify the elements of an array once they've been added. You can only add elements to the end of an array and remove elements from the front of an array. These operations do not require memory mutation, as they involve updating pointers rather than directly modifying the memory cells. #### Reading Elements from an Array To access array elements, you can use `get()` or `at()` array methods that return different types. Using `arr.at(index)` is equivalent to using the subscripting operator `arr[index]`. The `get` function returns an `Option>`, which means it returns an option to a Box type (Cairo's smart-pointer type) containing a snapshot to the element at the specified index if that element exists in the array. If the element doesn't exist, `get` returns `None`. This method is useful when you expect to access indices that may not be within the array's bounds and want to handle such cases gracefully without panics. Snapshots will be explained in more detail in the [References and Snapshots](ch03-02-references-and-snapshots.md) chapter. The `at` function, on the other hand, directly returns a snapshot to the element at the specified index using the `unbox()` operator to extract the value stored in a box. If the index is out of bounds, a panic error occurs. You should only use at when you want the program to panic if the provided index is out of the array's bounds, which can prevent unexpected behavior. In summary, use `at` when you want to panic on out-of-bounds access attempts, and use `get` when you prefer to handle such cases gracefully without panicking. ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_32_array_at.cairo}} ``` In this example, the variable named `first` will get the value `0` because that is the value at index `0` in the array. The variable named `second` will get the value `1` from index `1` in the array. Here is an example with the `get()` method: ```rust,ignore_format {{#include ../listings/ch02-common-programming-concepts/no_listing_33_array_get.cairo}} ``` #### Size related methods To determine the number of elements in an array, use the `len()` method. The return is of type `usize`. If you want to check if an array is empty or not, you can use the `is_empty()` method, which returns `true` if the array is empty and `false` otherwise. #### Storing multiple types with Enums If you want to store elements of different types in an array, you can use an `Enum` to define a custom data type that can hold multiple types. ```rust {{#include ../listings/ch02-common-programming-concepts/no_listing_34_array_with_enums.cairo}} ``` #### Span `Span` is a struct that represents a snapshot of an `Array`. It is designed to provide safe and controlled access to the elements of an array without modifying the original array. Span is particularly useful for ensuring data integrity and avoiding borrowing issues when passing arrays between functions or when performing read-only operations (cf. [References and Snapshots](ch03-02-references-and-snapshots.md)) All methods provided by `Array` can also be used with `Span`, with the exception of the `append()` method. ##### Turning an Array into span To create a `Span` of an `Array`, call the `span()` method: ```rust {{#rustdoc_include ../listings/ch02-common-programming-concepts/no_listing_35_array_span.cairo:5}} ``` ## Summary You made it! This was a sizable chapter: you learned about variables, data types, functions, comments, `if` expressions, loops, and common collections! To practice with the concepts discussed in this chapter, try building programs to do the following: - Generate the _n_-th Fibonacci number. - Compute the factorial of a number _n_. When you\u2019re ready to move on, we\u2019ll talk about a concept that Cairo shares with Rust and that _doesn\u2019t_ commonly exist in other programming languages: ownership."}
{"title": "ch03-00-understanding-ownership.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Understanding Cairo's Ownership system Cairo is a language built around a linear type system that allows us to statically ensure that in every Cairo program, a value is used exactly once. This linear type system helps preventing runtime errors by ensuring that operations that could cause such errors, such as writing twice to a memory cell, are detected at compile time. This is achieved by implementing an ownership system and forbidding copying and dropping values by default. In this chapter, we\u2019ll talk about Cairo's ownership system as well as references and snapshots."}
{"title": "ch03-01-what-is-ownership.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## What Is Ownership? Cairo implements an ownership system to ensure the safety and correctness of its compiled code. The ownership mechanism complements the linear type system, which enforces that objects are used exactly once. This helps prevent common operations that can produce runtime errors, such as illegal memory address references or multiple writes to the same memory address, and ensures the soundness of Cairo programs by checking at compile time that all the dictionaries are squashed. Now that we\u2019re past basic Cairo syntax, we won\u2019t include all the `fn main() {` code in examples, so if you\u2019re following along, make sure to put the following examples inside a `main` function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code. ### Ownership Rules First, let\u2019s take a look at the ownership rules. Keep these rules in mind as we work through the examples that illustrate them: - Each value in Cairo has an _owner_. - There can only be one owner at a time. - When the owner goes out of scope, the value will be _dropped_. ### Variable Scope As a first example of ownership, we\u2019ll look at the _scope_ of some variables. A scope is the range within a program for which an item is valid. Take the following variable: ```rust let s = 'hello'; ``` The variable `s` refers to a short string, where the value of the string is hardcoded into the text of our program. The variable is valid from the point at which it\u2019s declared until the end of the current _scope_. Listing 3-1 shows a program with comments annotating where the variable `s` would be valid. ```rust {{#rustdoc_include ../listings/ch03-understanding-ownership/listing_03_01.cairo:here}} ``` Listing 3-1: A variable and the scope in which it is valid In other words, there are two important points in time here: - When `s` comes _into_ scope, it is valid. - It remains valid until it goes _out of_ scope. At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now we\u2019ll build on top of this understanding by using the `Array` type we introduced in the [previous chapter](ch02-06-common-collections.md). ### Ownership with the `Array` Type To illustrate the rules of ownership, we need a data type that is more complex. The types covered in the [\u201cData Types\u201d][data-types] section of Chapter 2 are of a known size, can be quickly and trivially copied to make a new, independent instance if another part of code needs to use the same value in a different scope, and can easily be dropped when they're no longer used. But what is the behavior with the `Array` type whose size is unknown at compile time and which can't be trivially copied? Here is a short reminder of what an array looks like: ```rust {{#rustdoc_include ../listings/ch03-understanding-ownership/no_listing_01_array.cairo:3:5}} ``` So, how does the ownership system ensure that each cell is never written to more than once? Consider the following code, where we try to pass the same instance of an array in two consecutive function calls: ```rust,does_not_compile {{#include ../listings/ch03-understanding-ownership/no_listing_02_pass_array_by_value.cairo}} ``` In this case, we try to pass the same array instance `arr` by value to the functions `foo` and `bar`, which means that the parameter used in both function calls is the same instance of the array. If you append a value to the array in `foo`, and then try to append another value to the same array in `bar`, what would happen is that you would attempt to try to write to the same memory cell twice, which is not allowed in Cairo. To prevent this, the ownership of the `arr` variable moves from the `main` function to the `foo` function. When trying to call `bar` with `arr` as a parameter, the ownership of `arr` was already moved to the first call. The ownership system thus prevents us from using the same instance of `arr` in `foo`. Running the code above will result in a compile-time error: ```console error: Variable was previously moved. Trait has no implementation in context: core::Copy::> --> array.cairo:6:9 let mut arr = ArrayTrait::::new(); ^*****^ ``` ### The `Copy` Trait If a type implements the `Copy` trait, passing it to a function will not move the ownership of the value to the function called, but will instead pass a copy of the value. You can implement the `Copy` trait on your type by adding the `#[derive(Copy)]` annotation to your type definition. However, Cairo won't allow a type to be annotated with Copy if the type itself or any of its components don't implement the Copy trait. While Arrays and Dictionaries can't be copied, custom types that don't contain either of them can be. ```rust,ignore_format {{#include ../listings/ch03-understanding-ownership/no_listing_03_copy_trait.cairo}} ``` In this example, we can pass `p1` twice to the foo function because the `Point` type implements the `Copy` trait. This means that when we pass `p1` to `foo`, we are actually passing a copy of `p1`, and the ownership of `p1` remains with the main function. If you remove the `Copy` trait derivation from the `Point` type, you will get a compile-time error when trying to compile the code. _Don't worry about the `Struct` keyword. We will introduce this in [Chapter 4](ch04-00-using-structs-to-structure-related-data.md)._ ### The `Drop` Trait You may have noticed that the `Point` type in the previous example also implements the `Drop` trait. In Cairo, a value cannot go out of scope unless it has been previously moved. For example, the following code will not compile, because the struct `A` is not moved before it goes out of scope: ```rust,does_not_compile {{#include ../listings/ch03-understanding-ownership/no_listing_04_no_drop_derive_fails.cairo}} ``` This is to ensure the soundness of Cairo programs. Soundness refers to the fact that if a statement during the execution of the program is false, no cheating prover can convince an honest verifier that it is true. In our case, we want to ensure the consistency of consecutive dictionary key updates during program execution, which is only checked when the dictionaries are `squashed` - which moves the ownership of the dictionary to the `squash` method, thus allowing the dictionary to go out of scope. Unsquashed dictionaries are dangerous, as a malicious prover could prove the correctness of inconsistent updates. However, types that implement the `Drop` trait are allowed to go out of scope without being explicitly moved. When a value of a type that implements the `Drop` trait goes out of scope, the `Drop` implementation is called on the type, which moves the value to the `drop` function, allowing it to go out of scope - This is what we call \"dropping\" a value. It is important to note that the implementation of drop is a \"no-op\", meaning that it doesn't perform any actions other than allowing the value to go out of scope. The `Drop` implementation can be derived for all types, allowing them to be dropped when going out of scope, except for dictionaries (`Felt252Dict`) and types containing dictionaries. For example, the following code compiles: ```rust {{#include ../listings/ch03-understanding-ownership/no_listing_05_drop_derive_compiles.cairo}} ``` ### The `Destruct` Trait Manually calling the `squash` method on a dictionary is not very convenient, and it is easy to forget to do so. To make it easier to use dictionaries, Cairo provides the `Destruct` trait, which allows you to specify the behavior of a type when it goes out of scope. While Dictionaries don't implement the `Drop` trait, they do implement the `Destruct` trait, which allows them to automatically be `squashed` when they go out of scope. This means that you can use dictionaries without having to manually call the `squash` method. Consider the following example, in which we define a custom type that contains a dictionary: ```rust,does_not_compile {{#include ../listings/ch03-understanding-ownership/no_listing_06_no_destruct_compile_fails.cairo}} ``` If you try to run this code, you will get a compile-time error: ```console error: Variable not dropped. Trait has no implementation in context: core::Drop::. Trait has no implementation in context: core::Destruct::. --> temp7.cairo:7:5 A { ^*^ ``` When A goes out of scope, it can't be dropped as it implements neither the `Drop` (as it contains a dictionary and can't `derive(Drop)`) nor the `Destruct` trait. To fix this, we can derive the `Destruct` trait implementation for the `A` type: ```rust {{#include ../listings/ch03-understanding-ownership/no_listing_07_destruct_compiles.cairo}} ``` Now, when `A` goes out of scope, its dictionary will be automatically `squashed`, and the program will compile. ### Copy Array data with Clone If we _do_ want to deeply copy the data of an `Array`, we can use a common method called `clone`. We\u2019ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you\u2019ve probably seen them before. Here\u2019s an example of the `clone` method in action. > Note: in the following example, we need to import the `Clone` trait from the corelib `clone` module, and its implementation for the array type from the `array` module. ```rust {{#include ../listings/ch03-understanding-ownership/no_listing_08_array_clone.cairo}} ``` > Note: you will need to run `cairo-run` with the `--available-gas=2000000` option to run this example, because it uses a loop and must be ran with a gas limit. When you see a call to `clone`, you know that some arbitrary code is being executed and that code may be expensive. It\u2019s a visual indicator that something different is going on. ### Ownership and Functions Passing a variable to a function will either move it or copy it. As seen in the Array section, passing an `Array` as a function parameter transfers its ownership; let's see what happens with other types. Listing 3-3 has an example with some annotations showing where variables go into and out of scope. Filename: src/main.cairo ```rust,ignore_format {{#include ../listings/ch03-understanding-ownership/listing_03_03.cairo}} ``` Listing 3-3: Functions with ownership and scope annotated If we tried to use `my_struct` after the call to `takes_ownership`, Cairo would throw a compile-time error. These static checks protect us from mistakes. Try adding code to `main` that uses `my_struct` and `x` to see where you can use them and where the ownership rules prevent you from doing so. ### Return Values and Scope Returning values can also transfer ownership. Listing 3-4 shows an example of a function that returns some value, with similar annotations as those in Listing 4-3. Filename: src/main.cairo ```rust,ignore_format {{#include ../listings/ch03-understanding-ownership/listing_03_04.cairo}} ``` Listing 3-4: Transferring ownership of return values When a variable goes out of scope, its value is dropped, unless ownership of the value has been moved to another variable. While this works, taking ownership and then returning ownership with every function is a bit tedious. What if we want to let a function use a value but not take ownership? It\u2019s quite annoying that anything we pass in also needs to be passed back if we want to use it again, in addition to any data resulting from the body of the function that we might want to return as well. Cairo does let us return multiple values using a tuple, as shown in Listing 3-5. Filename: src/main.cairo ```rust {{#include ../listings/ch03-understanding-ownership/listing_03_05.cairo}} ``` Listing 3-5: Returning ownership of parameters But this is too much ceremony and a lot of work for a concept that should be common. Luckily for us, Cairo has two features for using a value without transferring ownership, called _references_ and _snapshots_. [data-types]: ch02-02-data-types.html#data-types [method-syntax]: ch04-03-method-syntax.html#method-syntax"}
{"title": "ch03-02-references-and-snapshots.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## References and Snapshots The issue with the tuple code in Listing 3-5 is that we have to return the `Array` to the calling function so we can still use the `Array` after the call to `calculate_length`, because the `Array` was moved into `calculate_length`. ### Snapshots Instead, we can provide a _snapshot_ of the `Array` value. In Cairo, a snapshot is an immutable view of a value at a certain point in time. In the previous chapter, we talked about how Cairo's ownership system prevents us from using a value after we've moved it, protecting us from potentially writing twice to the same memory cell when appending values to arrays. However, it's not very convenient. Let's see how we can retain ownership of the value in the calling function using snapshots. Here is how you would define and use a `calculate_length` function that takes a snapshot to an array as a parameter instead of taking ownership of the underlying value. In this example, the `calculate_length` function returns the length of the array passed as parameter. As we're passing it as a snapshot, which is an immutable view of the array, we can be sure that the `calculate_length` function will not mutate the array, and ownership of the array is kept in the main function. Filename: src/lib.cairo ```rust,ignore_format {{#include ../listings/ch03-understanding-ownership/no_listing_09_snapshots.cairo}} ``` > Note: It is only possible to call the `len()` method on an array snapshot because it is defined as such in the `ArrayTrait` trait. If you try to call a method that is not defined for snapshots on a snapshot, you will get a compilation error. However, you can call methods expecting a snapshot on non-snapshot types. The output of this program is: ```console [DEBUG] (raw: 0) [DEBUG] (raw: 1) Run completed successfully, returning [] ``` First, notice that all the tuple code in the variable declaration and the function return value is gone. Second, note that we pass `@arr1` into `calculate_length` and, in its definition, we take `@Array` rather than `Array`. Let\u2019s take a closer look at the function call here: ```rust {{#rustdoc_include ../listings/ch03-understanding-ownership/no_listing_09_snapshots.cairo:11}} ``` The `@arr1` syntax lets us create a snapshot of the value in `arr1`. Because a snapshot is an immutable view of a value, the value it points to cannot be modified through the snapshot, and the value it refers to will not be dropped once the snapshot stops being used. Similarly, the signature of the function uses `@` to indicate that the type of the parameter `arr` is a snapshot. Let\u2019s add some explanatory annotations: ```rust fn calculate_length( array_snapshot: @Array ) -> usize { // array_snapshot is a snapshot of an Array array_snapshot.len() } // Here, array_snapshot goes out of scope and is dropped. // However, because it is only a view of what the original array `arr` contains, the original `arr` can still be used. ``` The scope in which the variable `array_snapshot` is valid is the same as any function parameter\u2019s scope, but the underlying value of the snapshot is not dropped when `array_snapshot` stops being used. When functions have snapshots as parameters instead of the actual values, we won\u2019t need to return the values in order to give back ownership of the original value, because we never had it. Snapshots can be converted back into regular values using the `desnap` operator `*`, as long as the value type is copyable (which is not the case for Arrays, as they don't implement `Copy`). In the following example, we want to calculate the area of a rectangle, but we don't want to take ownership of the rectangle in the `calculate_area` function, because we might want to use the rectangle again after the function call. Since our function doesn't mutate the rectangle instance, we can pass the snapshot of the rectangle to the function, and then transform the snapshots back into values using the `desnap` operator `*`. The snapshot type is always copyable and droppable, so that you can use it multiple times without worrying about ownership transfers. ```rust {{#include ../listings/ch03-understanding-ownership/no_listing_10_desnap.cairo}} ``` But, what happens if we try to modify something we\u2019re passing as snapshot? Try the code in Listing 3-6. Spoiler alert: it doesn\u2019t work! Filename: src/lib.cairo ```rust,does_not_compile {{#include ../listings/ch03-understanding-ownership/listing_03_06.cairo}} ``` Listing 3-6: Attempting to modify a snapshot value Here\u2019s the error: ```console error: Invalid left-hand side of assignment. --> ownership.cairo:15:5 rec.height = rec.width; ^********^ ``` The compiler prevents us from modifying values associated to snapshots. ### Mutable References We can achieve the behavior we want in Listing 3-6 by using a _mutable reference_ instead of a snapshot. Mutable references are actually mutable values passed to a function that are implicitly returned at the end of the function, returning ownership to the calling context. By doing so, they allow you to mutate the value passed while keeping ownership of it by returning it automatically at the end of the execution. In Cairo, a parameter can be passed as _mutable reference_ using the `ref` modifier. > **Note**: In Cairo, a parameter can only be passed as _mutable reference_ using the `ref` modifier if the variable is declared as mutable with `mut`. In Listing 3-7, we use a mutable reference to modify the value of the `height` and `width` fields of the `Rectangle` instance in the `flip` function. ```rust {{#include ../listings/ch03-understanding-ownership/listing_03_07.cairo}} ``` Listing 3-7: Use of a mutable reference to modify a value First, we change `rec` to be `mut`. Then we pass a mutable reference of `rec` into `flip` with `ref rec`, and update the function signature to accept a mutable reference with `ref rec: Rectangle`. This makes it very clear that the `flip` function will mutate the value of the `Rectangle` instance passed as parameter. The output of the program is: ```console [DEBUG] (raw: 10) [DEBUG] (raw: 3) ``` As expected, the `height` and `width` fields of the `rec` variable have been swapped. ### Small recap Let\u2019s recap what we\u2019ve discussed about ownership, snapshots, and references: - At any given time, a variable can only have one owner. - You can pass a variable by-value, by-snapshot, or by-reference to a function. - If you pass-by-value, ownership of the variable is transferred to the function. - If you want to keep ownership of the variable and know that your function won\u2019t mutate it, you can pass it as a snapshot with `@`. - If you want to keep ownership of the variable and know that your function will mutate it, you can pass it as a mutable reference with `ref`."}
{"title": "ch04-00-using-structs-to-structure-related-data.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Using Structs to Structure Related Data A struct, or structure, is a custom data type that lets you package together and name multiple related values that make up a meaningful group. If you\u2019re familiar with an object-oriented language, a struct is like an object\u2019s data attributes. In this chapter, we\u2019ll compare and contrast tuples with structs to build on what you already know and demonstrate when structs are a better way to group data. We\u2019ll demonstrate how to define and instantiate structs. We\u2019ll discuss how to define associated functions, especially the kind of associated functions called methods, to specify behavior associated with a struct type. Structs and enums (discussed in the next chapter) are the building blocks for creating new types in your program\u2019s domain to take full advantage of Cairo's compile-time type checking."}
{"title": "ch04-01-defining-and-instantiating-structs.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Defining and Instantiating Structs Structs are similar to tuples, discussed in [The Data Types](ch02-02-data-types.md) section, in that both hold multiple related values. Like tuples, the pieces of a struct can be different types. Unlike with tuples, in a struct you\u2019ll name each piece of data so it\u2019s clear what the values mean. Adding these names means that structs are more flexible than tuples: you don\u2019t have to rely on the order of the data to specify or access the values of an instance. To define a struct, we enter the keyword `struct` and name the entire struct. A struct\u2019s name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call fields. For example, Listing 4-1 shows a struct that stores information about a user account. Filename: structs.cairo ```rust {{#include ../listings/ch04-using-structs-to-structure-related-data/listing_04_01_user_struct.cairo:user}} ``` Listing 4-1: A `User` struct definition To use a struct after we\u2019ve defined it, we create an _instance_ of that struct by specifying concrete values for each of the fields. We create an instance by stating the name of the struct and then add curly brackets containing _key: value_ pairs, where the keys are the names of the fields and the values are the data we want to store in those fields. We don\u2019t have to specify the fields in the same order in which we declared them in the struct. In other words, the struct definition is like a general template for the type, and instances fill in that template with particular data to create values of the type. For example, we can declare a particular user as shown in Listing 4-2. Filename: structs.cairo ```rust {{#include ../listings/ch04-using-structs-to-structure-related-data/listing_04_01_user_struct.cairo:all}} ``` Listing 4-2: Creating an instance of the `User` struct To get a specific value from a struct, we use dot notation. For example, to access this user\u2019s email address, we use `user1.email`. If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field. Listing 4-3 shows how to change the value in the `email` field of a mutable `User` instance. Filename: structs.cairo ```rust {{#rustdoc_include ../listings/ch04-using-structs-to-structure-related-data/listing_04_03_mut_struct.cairo:main}} ``` Listing 4-3: Changing the value in the email field of a `User` instance Note that the entire instance must be mutable; Cairo doesn\u2019t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance. Listing 4-4 shows a `build_user` function that returns a `User` instance with the given email and username. The `active` field gets the value of `true`, and the `sign_in_count` gets a value of `1`. Filename: structs.cairo ```rust {{#rustdoc_include ../listings/ch04-using-structs-to-structure-related-data/listing_04_03_mut_struct.cairo:build_user}} ``` Listing 4-4: A `build_user` function that takes an email and username and returns a `User` instance It makes sense to name the function parameters with the same name as the struct fields, but having to repeat the `email` and `username` field names and variables is a bit tedious. If the struct had more fields, repeating each name would get even more annoying. Luckily, there\u2019s a convenient shorthand! ## Using the Field Init Shorthand Because the parameter names and the struct field names are exactly the same in Listing 4-4, we can use the field init shorthand syntax to rewrite `build_user` so it behaves exactly the same but doesn\u2019t have the repetition of `username` and `email`, as shown in Listing 4-5. Filename: structs.cairo ```rust {{#rustdoc_include ../listings/ch04-using-structs-to-structure-related-data/listing_04_03_mut_struct.cairo:build_user2}} ``` Listing 4-5: A `build_user` function that uses field init shorthand because the `username` and `email` parameters have the same name as struct fields Here, we\u2019re creating a new instance of the `User` struct, which has a field named `email`. We want to set the `email` field\u2019s value to the value in the `email` parameter of the `build_user` function. Because the `email` field and the `email` parameter have the same name, we only need to write `email` rather than `email: email`."}
{"title": "ch04-02-an-example-program-using-structs.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# An Example Program Using Structs To understand when we might want to use structs, let\u2019s write a program that calculates the area of a rectangle. We\u2019ll start by using single variables, and then refactor the program until we\u2019re using structs instead. Let\u2019s make a new project with Scarb called _rectangles_ that will take the width and height of a rectangle specified in pixels and calculate the area of the rectangle. Listing 4-6 shows a short program with one way of doing exactly that in our project\u2019s _src/lib.cairo_. Filename: src/lib.cairo ```rust {{#include ../listings/ch04-using-structs-to-structure-related-data/listing_04_06_no_struct.cairo}} ``` Listing 4-6: Calculating the area of a rectangle specified by separate width and height variables Now run the program with `cairo-run src/lib.cairo`: ```bash $ cairo-run src/lib.cairo [DEBUG] , (raw: 300) Run completed successfully, returning [] ``` This code succeeds in figuring out the area of the rectangle by calling the `area` function with each dimension, but we can do more to make this code clear and readable. The issue with this code is evident in the signature of `area`: ```rust {{#include ../listings/ch04-using-structs-to-structure-related-data/listing_04_06_no_struct.cairo:9}} ``` The `area` function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters, and it\u2019s not clear anywhere in our program that the parameters are related. It would be more readable and more manageable to group width and height together. We\u2019ve already discussed one way we might do that in [Chapter 3](ch02-02-data-types.html#the-tuple-type): using tuples. ## Refactoring with Tuples Listing 4-7 shows another version of our program that uses tuples. Filename: src/lib.cairo ```rust {{#include ../listings/ch04-using-structs-to-structure-related-data/listing_04_07_w_tuples.cairo}} ``` Listing 4-7: Specifying the width and height of the rectangle with a tuple In one way, this program is better. Tuples let us add a bit of structure, and we\u2019re now passing just one argument. But in another way, this version is less clear: tuples don\u2019t name their elements, so we have to index into the parts of the tuple, making our calculation less obvious. Mixing up the width and height wouldn\u2019t matter for the area calculation, but if we want to calculate the difference, it would matter! We would have to keep in mind that `width` is the tuple index `0` and `height` is the tuple index `1`. This would be even harder for someone else to figure out and keep in mind if they were to use our code. Because we haven\u2019t conveyed the meaning of our data in our code, it\u2019s now easier to introduce errors. ## Refactoring with Structs: Adding More Meaning We use structs to add meaning by labeling the data. We can transform the tuple we\u2019re using into a struct with a name for the whole as well as names for the parts. Filename: src/lib.cairo ```rust,ignore_format {{#include ../listings/ch04-using-structs-to-structure-related-data/listing_04_08_w_structs.cairo}} ``` Listing 4-8: Defining a `Rectangle` struct Here we\u2019ve defined a struct and named it `Rectangle`. Inside the curly brackets, we defined the fields as `width` and `height`, both of which have type `u64`. Then, in `main`, we created a particular instance of `Rectangle` that has a width of `30` and a height of `10`. Our `area` function is now defined with one parameter, which we\u2019ve named `rectangle` which is of type `Rectangle` struct. We can then access the fields of the instance with dot notation, and it gives descriptive names to the values rather than using the tuple index values of `0` and `1`. ## Adding Useful Functionality with Trait It\u2019d be useful to be able to print an instance of `Rectangle` while we\u2019re debugging our program and see the values for all its fields. Listing 4-9 tries using the `print` as we have used in previous chapters. This won\u2019t work. Filename: src/lib.cairo ```rust {{#include ../listings/ch04-using-structs-to-structure-related-data/listing_04_10_print_rectangle.cairo:0:11}} ``` Listing 4-9: Attempting to print a `Rectangle` instance When we compile this code, we get an error with this message: ```bash $ cairo-compile src/lib.cairo error: Method `print` not found on type \"../src::Rectangle\". Did you import the correct trait and impl? --> lib.cairo:16:15 rectangle.print(); ^***^ Error: Compilation failed. ``` The `print` trait is implemented for many data types, but not for the `Rectangle` struct. We can fix this by implementing the `PrintTrait` trait on `Rectangle` as shown in Listing 4-10. To learn more about traits, see [Traits in Cairo](ch07-02-traits-in-cairo.md). Filename: src/lib.cairo ```rust,ignore_format {{#rustdoc_include ../listings/ch04-using-structs-to-structure-related-data/listing_04_10_print_rectangle.cairo}} ``` Listing 4-10: Implementing the `PrintTrait` trait on `Rectangle` Nice! It\u2019s not the prettiest output, but it shows the values of all the fields for this instance, which would definitely help during debugging."}
{"title": "ch04-03-method-syntax.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## Method Syntax _Methods_ are similar to functions: we declare them with the `fn` keyword and a name, they can have parameters and a return value, and they contain some code that\u2019s run when the method is called from somewhere else. Unlike functions, methods are defined within the context of a type and their first parameter is always `self`, which represents the instance of the type the method is being called on. For those familiar with Rust, Cairo's approach might be confusing, as methods cannot be defined directly on types. Instead, you must define a trait and an implementation associated with the type for which the method is intended. ### Defining Methods Let\u2019s change the `area` function that has a `Rectangle` instance as a parameter and instead make an `area` method defined on the `RectangleTrait` trait, as shown in Listing 4-13. Filename: src/lib.cairo ```rust {{#include ../listings/ch04-using-structs-to-structure-related-data/listing_04_13_area_method.cairo}} ``` Listing 4-13: Defining an `area` method to use on the `Rectangle` To define the function within the context of `Rectangle`, we start by defining a `trait` block with the signature of the method that we want to implement. Traits are not linked to a specific type; only the `self` parameter of the method defines which type it can be used with. Then, we define an `impl` (implementation) block for `RectangleTrait`, that defines the behavior of the methods implemented. Everything within this `impl` block will be associated with the type of the `self` parameter of the method called. While it is technically possible to define methods for multiple types within the same `impl` block, it is not a recommended practice, as it can lead to confusion. We recommend that the type of the `self` parameter stays consistent within the same `impl` block. Then we move the `area` function within the `impl` curly brackets and change the first (and in this case, only) parameter to be `self` in the signature and everywhere within the body. In `main`, where we called the `area` function and passed `rect1` as an argument, we can instead use the _method syntax_ to call the `area` method on our `Rectangle` instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments. Methods must have a parameter named `self` of the type they will be applied to for their first parameter. Note that we used the `@` snapshot operator in front of the `Rectangle` type in the function signature. By doing so, we indicate that this method takes an immutable snapshot of the `Rectangle` instance, which is automatically created by the compiler when passing the instance to the method. Methods can take ownership of `self`, use `self` with snapshots as we\u2019ve done here, or use a mutable reference to `self` using the `ref self: T` syntax. We chose `self: @Rectangle` here for the same reason we used `@Rectangle` in the function version: we don\u2019t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we\u2019ve called the method on as part of what the method does, we\u2019d use `ref self: Rectangle` as the first parameter. Having a method that takes ownership of the instance by using just `self` as the first parameter is rare; this technique is usually used when the method transforms `self` into something else and you want to prevent the caller from using the original instance after the transformation. Observe the use of the desnap operator `*` within the area method when accessing the struct's members. This is necessary because the struct is passed as a snapshot, and all of its field values are of type `@T`, requiring them to be desnapped in order to manipulate them. The main reason for using methods instead of functions is for organization and code clarity. We\u2019ve put all the things we can do with an instance of a type in one combination of `trait` & `impl` blocks, rather than making future users of our code search for capabilities of `Rectangle` in various places in the library we provide. However, we can define multiple combinations of `trait` & `impl` blocks for the same type at different places, which can be useful for a more granular code organization. For example, you could implement the `Add` trait for your type in one `impl` block, and the `Sub` trait in another block. Note that we can choose to give a method the same name as one of the struct\u2019s fields. For example, we can define a method on `Rectangle` that is also named `width`: Filename: src/lib.cairo ```rust {{#include ../listings/ch04-using-structs-to-structure-related-data/listing_04_14_width_method.cairo}} ``` Here, we\u2019re choosing to make the `width` method return `true` if the value in the instance\u2019s `width` field is greater than `0` and `false` if the value is `0`: we can use a field within a method of the same name for any purpose. In `main`, when we follow `rect1.width` with parentheses, Cairo knows we mean the method `width`. When we don\u2019t use parentheses, Cairo knows we mean the field `width`. ### Methods with More Parameters Let\u2019s practice using methods by implementing a second method on the `Rectangle` struct. This time we want an instance of `Rectangle` to take another instance of `Rectangle` and return `true` if the second `Rectangle` can fit completely within `self` (the first `Rectangle`); otherwise, it should return `false`. That is, once we\u2019ve defined the `can_hold` method, we want to be able to write the program shown in Listing 4-14. Filename: src/lib.cairo ```rust,does_not_compile {{#include ../listings/ch04-using-structs-to-structure-related-data/listing_04_15_can_hold.cairo:no_method}} ``` Listing 4-14: Using the as-yet-unwritten `can_hold` method The expected output would look like the following because both dimensions of `rect2` are smaller than the dimensions of `rect1`, but `rect3` is wider than `rect1`: ```text \u276f cairo-run src/lib.cairo [DEBUG] Can rec1 hold rect2? (raw: 384675147322001379018464490539350216396261044799) [DEBUG] true (raw: 1953658213) [DEBUG] Can rect1 hold rect3? (raw: 384675147322001384331925548502381811111693612095) [DEBUG] false (raw: 439721161573) ``` We know we want to define a method, so it will be within the `trait RectangleTrait` and `impl RectangleImpl of RectangleTrait` blocks. The method name will be `can_hold`, and it will take a snapshot of another `Rectangle` as a parameter. We can tell what the type of the parameter will be by looking at the code that calls the method: `rect1.can_hold(@rect2)` passes in `@rect2`, which is a snapshot to `rect2`, an instance of `Rectangle`. This makes sense because we only need to read `rect2` (rather than write, which would mean we\u2019d need a mutable borrow), and we want `main` to retain ownership of `rect2` so we can use it again after calling the `can_hold` method. The return value of `can_hold` will be a Boolean, and the implementation will check whether the width and height of `self` are greater than the width and height of the other `Rectangle`, respectively. Let\u2019s add the new `can_hold` method to the `trait` and `impl` blocks from Listing 4-13, shown in Listing 4-15. Filename: src/lib.cairo ```rust {{#include ../listings/ch04-using-structs-to-structure-related-data/listing_04_15_can_hold.cairo:trait_impl}} ``` Listing 4-15: Implementing the `can_hold` method on `Rectangle` that takes another `Rectangle` instance as a parameter When we run this code with the `main` function in Listing 4-14, we\u2019ll get our desired output. Methods can take multiple parameters that we add to the signature after the `self` parameter, and those parameters work just like parameters in functions. ### Accessing implementation functions All functions defined within a `trait` and `impl` block can be directly addressed using the `::` operator on the implementation name. Functions in traits that aren\u2019t methods are often used for constructors that will return a new instance of the struct. These are often called `new`, but `new` isn\u2019t a special name and isn\u2019t built into the language. For example, we could choose to provide an associated function named `square` that would have one dimension parameter and use that as both width and height, thus making it easier to create a square `Rectangle` rather than having to specify the same value twice: Filename: src/lib.cairo ```rust {{#include ../listings/ch04-using-structs-to-structure-related-data/no_listing_01_implementation_functions.cairo:here}} ``` To call this function, we use the `::` syntax with the implementation name; `let square = RectangleImpl::square(10);` is an example. This function is namespaced by the implementation; the `::` syntax is used for both trait functions and namespaces created by modules. We\u2019ll discuss modules in [Chapter 7][modules]. > Note: It is also possible to call this function using the trait name, with `RectangleTrait::square(10)`. ### Multiple `impl` Blocks Each struct is allowed to have multiple `trait` and `impl` blocks. For example, Listing 5-15 is equivalent to the code shown in Listing 4-16, which has each method in its own `trait` and `impl` blocks. ```rust {{#include ../listings/ch04-using-structs-to-structure-related-data/no_listing_02_multiple_impls.cairo:here}} ``` Listing 4-16: Rewriting Listing 4-15 using multiple `impl` blocks There\u2019s no reason to separate these methods into multiple `trait` and `impl` blocks here, but this is valid syntax. We\u2019ll see a case in which multiple blocks are useful in [Chapter 7](ch07-00-generic-types-and-traits.md), where we discuss generic types and traits. ## Summary Structs let you create custom types that are meaningful for your domain. By using structs, you can keep associated pieces of data connected to each other and name each piece to make your code clear. In `trait` and `impl` blocks, you can define methods, which are functions associated to a type and let you specify the behavior that instances of your type have. But structs aren\u2019t the only way you can create custom types: let\u2019s turn to Cairo\u2019s enum feature to add another tool to your toolbox."}
{"title": "ch05-00-enums-and-pattern-matching.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Enums and Pattern Matching"}
{"title": "ch05-01-enums.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Enums Enums, short for \"enumerations,\" are a way to define a custom data type that consists of a fixed set of named values, called _variants_. Enums are useful for representing a collection of related values where each value is distinct and has a specific meaning. ## Enum Variants and Values Here's a simple example of an enum: ```rust {{#include ../listings/ch05-enums-and-pattern-matching/no_listing_01_enum_example.cairo:enum_example}} ``` Unlike other languages like Rust, every variant has a type. In this example, we've defined an enum called `Direction` with four variants: `North`, `East`, `South`, and `West`. The naming convention is to use PascalCase for enum variants. Each variant represents a distinct value of the Direction type and is associated with a unit type `()`. One variant can be instantiated using this syntax: ```rust {{#rustdoc_include ../listings/ch05-enums-and-pattern-matching/no_listing_01_enum_example.cairo:here}} ``` It's easy to write code that acts differently depending on the variant of an enum instance, in this example to run specific code according to a Direction. You can learn more about it on [The Match Control Flow Construct page](ch05-02-the-match-control-flow-construct.md). ## Enums Combined with Custom Types Enums can also be used to store more interesting data associated with each variant. For example: ```rust {{#include ../listings/ch05-enums-and-pattern-matching/no_listing_02_enum_message.cairo:message}} ``` In this example, the `Message` enum has three variants: `Quit`, `Echo` and `Move`, all with different types: - `Quit` is the unit type - it has no data associated with it at all. - `Echo` is a single felt. - `Move` is a tuple of two u128 values. You could even use a Struct or another Enum you defined inside one of your Enum variants. ## Trait Implementations for Enums In Cairo, you can define traits and implement them for your custom enums. This allows you to define methods and behaviors associated with the enum. Here's an example of defining a trait and implementing it for the previous `Message` enum: ```rs {{#include ../listings/ch05-enums-and-pattern-matching/no_listing_02_enum_message.cairo:trait_impl}} ``` In this example, we implemented the `Processing` trait for `Message`. Here is how it could be used to process a Quit message: ```rust {{#rustdoc_include ../listings/ch05-enums-and-pattern-matching/no_listing_02_enum_message.cairo:main}} ``` Running this code would print `quitting`. ## The Option Enum and Its Advantages The Option enum is a standard Cairo enum that represents the concept of an optional value. It has two variants: `Some: T` and `None: ()`. `Some: T ` indicates that there's a value of type `T`, while `None` represents the absence of a value. ```rust enum Option { Some: T, None: (), } ``` The `Option` enum is helpful because it allows you to explicitly represent the possibility of a value being absent, making your code more expressive and easier to reason about. Using `Option` can also help prevent bugs caused by using uninitialized or unexpected `null` values. To give you an example, here is a function which returns the index of the first element of an array with a given value, or None if the element is not present. We are demonstrating two approaches for the above function: - Recursive Approach `find_value_recursive` - Iterative Approach `find_value_iterative` > Note: in the future it would be nice to replace this example by something simpler using a loop and without gas related code. ```rust {{#include ../listings/ch05-enums-and-pattern-matching/no_listing_03_enum_option.cairo}} ``` Running this code would print `it worked`."}
{"title": "ch05-02-the-match-control-flow-construct.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# The Match Control Flow Construct Cairo has an extremely powerful control flow construct called `match` that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal values, variable names, wildcards, and many other things. The power of match comes from the expressiveness of the patterns and the fact that the compiler confirms that all possible cases are handled. Think of a match expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a match, and at the first pattern the value \u201cfits\u201d, the value falls into the associated code block to be used during execution. Speaking of coins, let\u2019s use them as an example using match! We can write a function that takes an unknown US coin and, in a similar way as the counting machine, determines which coin it is and returns its value in cents, as shown in Listing 5-3. ```rust {{#include ../listings/ch05-enums-and-pattern-matching/listing_05_03.cairo:all}} ``` Listing 5-3: An enum and a match expression that has the variants of the enum as its patterns Let\u2019s break down the `match` in the `value_in_cents` function. First we list the `match` keyword followed by an expression, which in this case is the value `coin`. This seems very similar to a conditional expression used with if, but there\u2019s a big difference: with if, the condition needs to evaluate to a Boolean value, but here it can be any type. The type of coin in this example is the `Coin` enum that we defined on the first line. Next are the `match` arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value `Coin::Penny(_)` and then the `=>` operator that separates the pattern and the code to run. The code in this case is just the value `1`. Each arm is separated from the next with a comma. When the `match` expression executes, it compares the resultant value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn\u2019t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in the above example, our match has four arms. In Cairo, the order of the arms must follow the same order as the enum. The code associated with each arm is an expression, and the resultant value of the expression in the matching arm is the value that gets returned for the entire match expression. We don\u2019t typically use curly brackets if the match arm code is short, as it is in our example where each arm just returns a value. If you want to run multiple lines of code in a match arm, you must use curly brackets, with a comma following the arm. For example, the following code prints \u201cLucky penny!\u201d every time the method is called with a `Coin::Penny(())`, but still returns the last value of the block, `1`: ```rust {{#include ../listings/ch05-enums-and-pattern-matching/no_listing_04_match_arms.cairo:here}} ``` ## Patterns That Bind to Values Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants. As an example, let\u2019s change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our `enum` by changing the `Quarter` variant to include a `UsState` value stored inside it, which we\u2019ve done in Listing 5-4. ```rust {{#include ../listings/ch05-enums-and-pattern-matching/listing_05_04.cairo}} ``` Listing 5-4: A `Coin` enum in which the `Quarter` variant also holds a `UsState` value Let\u2019s imagine that a friend is trying to collect all 50 state quarters. While we sort our loose change by coin type, we\u2019ll also call out the name of the state associated with each quarter so that if it\u2019s one our friend doesn\u2019t have, they can add it to their collection. In the match expression for this code, we add a variable called `state` to the pattern that matches values of the variant `Coin::Quarter`. When a `Coin::Quarter` matches, the `state` variable will bind to the value of that quarter\u2019s state. Then we can use `state` in the code for that arm, like so: ```rust {{#include ../listings/ch05-enums-and-pattern-matching/no_listing_05_print_enum.cairo:function}} ``` To print the value of a variant of an enum in Cairo, we need to add an implementation for the `print` function for the `debug::PrintTrait`: ```rust {{#include ../listings/ch05-enums-and-pattern-matching/no_listing_05_print_enum.cairo:print_impl}} ``` If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska(())))`, `coin` would be `Coin::Quarter(UsState::Alaska())`. When we compare that value with each of the match arms, none of them match until we reach `Coin::Quarter(state)`. At that point, the binding for state will be the value `UsState::Alaska()`. We can then use that binding in the `PrintTrait`, thus getting the inner state value out of the `Coin` enum variant for `Quarter`. ## Matching with Options In the previous section, we wanted to get the inner `T` value out of the `Some` case when using `Option`; we can also handle `Option` using `match`, as we did with the `Coin` enum! Instead of comparing coins, we\u2019ll compare the variants of `Option`, but the way the `match` expression works remains the same. You can use Options by importing the `option::OptionTrait` trait. Let\u2019s say we want to write a function that takes an `Option` and, if there\u2019s a value inside, adds `1` to that value. If there isn\u2019t a value inside, the function should return the `None` value and not attempt to perform any operations. This function is very easy to write, thanks to match, and will look like Listing 5-5. ```rust {{#include ../listings/ch05-enums-and-pattern-matching/listing_05_05.cairo}} ``` Listing 5-5: A function that uses a match expression on an `Option` Note that your arms must respect the same order as the enum defined in the `OptionTrait` of the core Cairo lib. ```rust enum Option { Some: T, None: (), } ``` Let\u2019s examine the first execution of `plus_one` in more detail. When we call `plus_one(five)`, the variable `x` in the body of `plus_one` will have the value `Some(5)`. We then compare that against each match arm: ```rust {{#include ../listings/ch05-enums-and-pattern-matching/listing_05_05.cairo:6}} ``` Does `Option::Some(5)` value match the pattern `Option::Some(val)`? It does! We have the same variant. The `val` binds to the value contained in `Option::Some`, so `val` takes the value `5`. The code in the match arm is then executed, so we add `1` to the value of `val` and create a new `Option::Some` value with our total `6` inside. Because the first arm matched, no other arms are compared. Now let\u2019s consider the second call of `plus_one` in our main function, where `x` is `Option::None(())`. We enter the match and compare to the first arm: ```rust {{#include ../listings/ch05-enums-and-pattern-matching/listing_05_05.cairo:6}} ``` The `Option::Some(val)` value doesn\u2019t match the pattern `Option::None`, so we continue to the next arm: ```rust {{#include ../listings/ch05-enums-and-pattern-matching/listing_05_05.cairo:7}} ``` It matches! There\u2019s no value to add to, so the program stops and returns the `Option::None(())` value on the right side of `=>`. Combining `match` and enums is useful in many situations. You\u2019ll see this pattern a lot in Cairo code: `match` against an enum, bind a variable to the data inside, and then execute code based on it. It\u2019s a bit tricky at first, but once you get used to it, you\u2019ll wish you had it in all languages. It\u2019s consistently a user favorite. ## Matches Are Exhaustive There\u2019s one other aspect of match we need to discuss: the arms\u2019 patterns must cover all possibilities. Consider this version of our `plus_one` function, which has a bug and won\u2019t compile: ```rust {{#include ../listings/ch05-enums-and-pattern-matching/no_listing_07_missing_match_arm.cairo:here}} ``` ```bash $ cairo-run src/test.cairo error: Unsupported match. Currently, matches require one arm per variant, in the order of variant definition. --> test.cairo:34:5 match x { ^*******^ Error: failed to compile: ./src/test.cairo ``` Cairo knows that we didn\u2019t cover every possible case, and even knows which pattern we forgot! Matches in Cairo are exhaustive: we must exhaust every last possibility in order for the code to be valid. Especially in the case of `Option`, when Cairo prevents us from forgetting to explicitly handle the `None` case, it protects us from assuming that we have a value when we might have null, thus making the billion-dollar mistake discussed earlier impossible. ## Match 0 and the \\_ Placeholder Using enums, we can also take special actions for a few particular values, but for all other values take one default action. Currently only `0` and the `_`operator are supported. Imagine we\u2019re implementing a game where, you get a random number between 0 and 7. If you have 0, you win. For all other values you lose. Here's a match that implements that logic, with the number hardcoded rather than a random value. ```rust {{#include ../listings/ch05-enums-and-pattern-matching/no_listing_06_match_zero.cairo:here}} ``` The first arm, the pattern is the literal values 0. For the last arm that covers every other possible value, the pattern is the character `_`. This code compiles, even though we haven\u2019t listed all the possible values a `felt252` can have, because the last pattern will match all values not specifically listed. This catch-all pattern meets the requirement that `match` must be exhaustive. Note that we have to put the catch-all arm last because the patterns are evaluated in order. If we put the catch-all arm earlier, the other arms would never run, so Cairo will warn us if we add arms after a catch-all!"}
{"title": "ch06-00-managing-cairo-projects-with-packages-crates-and-modules.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Managing Cairo Projects with Packages, Crates and Modules As you write large programs, organizing your code will become increasingly important. By grouping related functionality and separating code with distinct features, you\u2019ll clarify where to find code that implements a particular feature and where to go to change how a feature works. The programs we\u2019ve written so far have been in one module in one file. As a project grows, you should organize code by splitting it into multiple modules and then multiple files. As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques. We\u2019ll also discuss encapsulating implementation details, which lets you reuse code at a higher level: once you\u2019ve implemented an operation, other code can call your code without having to know how the implementation works. A related concept is scope: the nested context in which code is written has a set of names that are defined as \u201cin scope.\u201d When reading, writing, and compiling code, programmers and compilers need to know whether a particular name at a particular spot refers to a variable, function, struct, enum, module, constant, or other item and what that item means. You can create scopes and change which names are in or out of scope. You can\u2019t have two items with the same name in the same scope. Cairo has a number of features that allow you to manage your code\u2019s organization. These features, sometimes collectively referred to as the _module system_, include: - **Packages:** A Scarb feature that lets you build, test, and share crates - **Crates:** A tree of modules that corresponds to a single compilation unit. It has a root directory, and a root module defined at the file `lib.cairo` under this directory. - **Modules** and **use:** Let you control the organization and scope of items. - **Paths:** A way of naming an item, such as a struct, function, or module In this chapter, we\u2019ll cover all these features, discuss how they interact, and explain how to use them to manage scope. By the end, you should have a solid understanding of the module system and be able to work with scopes like a pro!"}
{"title": "ch06-01-packages-and-crates.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Packages and Crates ## What is a crate? A crate is the smallest amount of code that the Cairo compiler considers at a time. Even if you run `cairo-compile` rather than `scarb build` and pass a single source code file, the compiler considers that file to be a crate. Crates can contain modules, and the modules may be defined in other files that get compiled with the crate, as will be discussed in the subsequent sections. ## What is the crate root? The crate root is the `lib.cairo` source file that the Cairo compiler starts from and makes up the root module of your crate (we\u2019ll explain modules in depth in the [\u201cDefining Modules to Control Scope\u201d](./ch06-02-defining-modules-to-control-scope.md) section). ## What is a package? A cairo package is a bundle of one or more crates with a Scarb.toml file that describes how to build those crates. This enables the splitting of code into smaller, reusable parts and facilitates more structured dependency management. ## Creating a Package with Scarb You can create a new Cairo package using the scarb command-line tool. To create a new package, run the following command: ```bash scarb new my_package ``` This command will generate a new package directory named `my_package` with the following structure: ``` my_package/ \u251c\u2500\u2500 Scarb.toml \u2514\u2500\u2500 src \u2514\u2500\u2500 lib.cairo ``` - `src/` is the main directory where all the Cairo source files for the package will be stored. - `lib.cairo` is the default root module of the crate, which is also the main entry point of the package. By default, it is empty. - `Scarb.toml` is the package manifest file, which contains metadata and configuration options for the package, such as dependencies, package name, version, and authors. You can find documentation about it on the [scarb reference]( ```toml [package] name = \"my_package\" version = \"0.1.0\" [dependencies] # foo = { path = \"vendor/foo\" } ``` As you develop your package, you may want to organize your code into multiple Cairo source files. You can do this by creating additional `.cairo` files within the `src` directory or its subdirectories."}
{"title": "ch06-02-defining-modules-to-control-scope.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## Defining Modules to Control Scope In this section, we\u2019ll talk about modules and other parts of the module system, namely _paths_ that allow you to name items and the `use` keyword that brings a path into scope. First, we\u2019re going to start with a list of rules for easy reference when you\u2019re organizing your code in the future. Then we\u2019ll explain each of the rules in detail. ### Modules Cheat Sheet Here we provide a quick reference on how modules, paths and the `use` keyword work in the compiler, and how most developers organize their code. We\u2019ll be going through examples of each of these rules throughout this chapter, but this is a great place to refer to as a reminder of how modules work. You can create a new Scarb project with `scarb new backyard` to follow along. - **Start from the crate root**: When compiling a crate, the compiler first looks in the crate root file (_src/lib.cairo_) for code to compile. - **Declaring modules**: In the crate root file, you can declare new modules; say, you declare a \u201cgarden\u201d module with `mod garden;`. The compiler will look for the module\u2019s code in these places: - Inline, within curly brackets that replace the semicolon following `mod garden;`. ```rust // crate root file (lib.cairo) mod garden { // code defining the garden module goes here } ``` - In the file _src/garden.cairo_ - **Declaring submodules**: In any file other than the crate root, you can declare submodules. For example, you might declare `mod vegetables;` in _src/garden.cairo_. The compiler will look for the submodule\u2019s code within the directory named for the parent module in these places: - Inline, directly following `mod vegetables`, within curly brackets instead of the semicolon. ```rust // src/garden.cairo file mod vegetables { // code defining the vegetables submodule goes here } ``` - In the file _src/garden/vegetables.cairo_ - **Paths to code in modules**: Once a module is part of your crate, you can refer to code in that module from anywhere else in that same crate, using the path to the code. For example, an `Asparagus` type in the garden vegetables module would be found at `backyard::Asparagus`. - **The `use` keyword**: Within a scope, the `use` keyword creates shortcuts to items to reduce repetition of long paths. In any scope that can refer to `backyard::Asparagus`, you can create a shortcut with `use backyard::Asparagus;` and from then on you only need to write `Asparagus` to make use of that type in the scope. Here we create a crate named `backyard` that illustrates these rules. The crate\u2019s directory, also named `backyard`, contains these files and directories: ```text backyard/ \u251c\u2500\u2500 Scarb.toml \u251c\u2500\u2500 cairo_project.toml \u2514\u2500\u2500 src \u251c\u2500\u2500 garden \u2502 \u2514\u2500\u2500 vegetables.cairo \u251c\u2500\u2500 garden.cairo \u2514\u2500\u2500 lib.cairo ``` > Note: You will notice here a `cairo_project.toml` file. > This is the configuration file for \"vanilla\" Cairo projects (i.e. not managed by Scarb), > which is required to run the `cairo-run .` command to run the code of the crate. > It is required until Scarb implements this feature. The content of the file is: > > ```toml > [crate_roots] > backyard = \"src\" > ``` > > and indicates that the crate named \"backyard\" is located in the `src` directory. The crate root file in this case is _src/lib.cairo_, and it contains: Filename: src/lib.cairo ```rust {{#include ../listings/ch06-managing-cairo-projects-with-packages-crates-and-modules/no_listing_01_lib.cairo}} ``` The `mod garden;` line tells the compiler to include the code it finds in _src/garden.cairo_, which is: Filename: src/garden.cairo ```rust mod vegetables; ``` Here, `mod vegetables;` means the code in _src/garden/vegetables.cairo_ is included too. That code is: ```rust {{#include ../listings/ch06-managing-cairo-projects-with-packages-crates-and-modules/no_listing_02_garden.cairo}} ``` The line `use garden::Asparagus;` lets us use bring the `Asparagus` type into scope, so we can use it in the `main` function. Now let\u2019s get into the details of these rules and demonstrate them in action! ### Grouping Related Code in Modules _Modules_ let us organize code within a crate for readability and easy reuse. As an example, let\u2019s write a library crate that provides the functionality of a restaurant. We\u2019ll define the signatures of functions but leave their bodies empty to concentrate on the organization of the code, rather than the implementation of a restaurant. In the restaurant industry, some parts of a restaurant are referred to as _front of house_ and others as _back of house_. Front of house is where customers are; this encompasses where the hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work. To structure our crate in this way, we can organize its functions into nested modules. Create a new package named `restaurant` by running `scarb new restaurant`; then enter the code in Listing 6-1 into _src/lib.cairo_ to define some modules and function signatures. Here\u2019s the front of house section: Filename: src/lib.cairo ```rust {{#include ../listings/ch06-managing-cairo-projects-with-packages-crates-and-modules/listing_06_01.cairo}} ``` Listing 6-1: A `front_of_house` module containing other modules that then contain functions We define a module with the `mod` keyword followed by the name of the module (in this case, `front_of_house`). The body of the module then goes inside curly brackets. Inside modules, we can place other modules, as in this case with the modules `hosting` and `serving`. Modules can also hold definitions for other items, such as structs, enums, constants, traits, and\u2014as in Listing 6-1\u2014functions. By using modules, we can group related definitions together and name why they\u2019re related. Programmers using this code can navigate the code based on the groups rather than having to read through all the definitions, making it easier to find the definitions relevant to them. Programmers adding new functionality to this code would know where to place the code to keep the program organized. Earlier, we mentioned that _src/lib.cairo_ is called the crate root. The reason for this name is that the content of this file form a module named after the crate name at the root of the crate\u2019s module structure, known as the _module tree_. Listing 6-2 shows the module tree for the structure in Listing 6-1. ```text restaurant \u2514\u2500\u2500 front_of_house \u251c\u2500\u2500 hosting \u2502 \u251c\u2500\u2500 add_to_waitlist \u2502 \u2514\u2500\u2500 seat_at_table \u2514\u2500\u2500 serving \u251c\u2500\u2500 take_order \u251c\u2500\u2500 serve_order \u2514\u2500\u2500 take_payment ``` Listing 6-2: The module tree for the code in Listing 6-1 This tree shows how some of the modules nest inside one another; for example, `hosting` nests inside `front_of_house`. The tree also shows that some modules are _siblings_ to each other, meaning they\u2019re defined in the same module; `hosting` and `serving` are siblings defined within `front_of_house`. If module A is contained inside module B, we say that module A is the _child_ of module B and that module B is the _parent_ of module A. Notice that the entire module tree is rooted under the explicit name of the crate `restaurant`. The module tree might remind you of the filesystem\u2019s directory tree on your computer; this is a very apt comparison! Just like directories in a filesystem, you use modules to organize your code. And just like files in a directory, we need a way to find our modules."}
{"title": "ch06-03-paths-for-referring-to-an-item-in-the-module-tree.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## Paths for Referring to an Item in the Module Tree To show Cairo where to find an item in a module tree, we use a path in the same way we use a path when navigating a filesystem. To call a function, we need to know its path. A path can take two forms: - An _absolute path_ is the full path starting from a crate root. The absolute path begins with the crate name. - A _relative path_ starts from the current module. Both absolute and relative paths are followed by one or more identifiers separated by double colons (`::`). To illustrate this notion let's take back our example Listing 6-1 for the restaurant we used in the last chapter. We have a crate named `restaurant` in which we have a module named `front_of_house` that contains a module named `hosting`. The `hosting` module contains a function named `add_to_waitlist`. We want to call the `add_to_waitlist` function from the `eat_at_restaurant` function. We need to tell Cairo the path to the `add_to_waitlist` function so it can find it. Filename: src/lib.cairo ```rust {{#include ../listings/ch06-managing-cairo-projects-with-packages-crates-and-modules/listing_06_03.cairo}} ``` Listing 6-3: Calling the `add_to_waitlist` function using absolute and relative paths The first time we call the `add_to_waitlist` function in `eat_at_restaurant`, we use an absolute path. The `add_to_waitlist` function is defined in the same crate as `eat_at_restaurant`. In Cairo, absolute paths start from the crate root, which you need to refer to by using the crate name. The second time we call `add_to_waitlist`, we use a relative path. The path starts with `front_of_house`, the name of the module defined at the same level of the module tree as `eat_at_restaurant`. Here the filesystem equivalent would be using the path `./front_of_house/hosting/add_to_waitlist`. Starting with a module name means that the path is relative to the current module. ### Starting Relative Paths with `super` Choosing whether to use a `super` or not is a decision you\u2019ll make based on your project, and depends on whether you\u2019re more likely to move item definition code separately from or together with the code that uses the item. Filename: src/lib.cairo ```rust {{#include ../listings/ch06-managing-cairo-projects-with-packages-crates-and-modules/listing_06_04.cairo}} ``` Listing 6-4: Calling a function using a relative path starting with super Here you can see directly that you access a parent's module easily using `super`, which wasn't the case previously."}
{"title": "ch06-04-bringing-paths-into-scope-with-the-use-keyword.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Bringing Paths into Scope with the `use` Keyword Having to write out the paths to call functions can feel inconvenient and repetitive. Fortunately, there\u2019s a way to simplify this process: we can create a shortcut to a path with the `use` keyword once, and then use the shorter name everywhere else in the scope. In Listing 6-5, we bring the `restaurant::hosting` module into the scope of the `eat_at_restaurant` function so we only have to specify `hosting::add_to_waitlist` to call the `add_to_waitlist` function in `eat_at_restaurant`. Filename: src/lib.cairo ```rust {{#include ../listings/ch06-managing-cairo-projects-with-packages-crates-and-modules/listing_06_05.cairo}} ``` Listing 6-5: Bringing a module into scope with `use` Adding use and a path in a scope is similar to creating a symbolic link in the filesystem. By adding `use restaurant::hosting` in the crate root, hosting is now a valid name in that scope, just as though the `hosting` module had been defined in the crate root. Note that `use` only creates the shortcut for the particular scope in which the `use` occurs. Listing 6-6 moves the `eat_at_restaurant` function into a new child module named `customer`, which is then a different scope than the `use` statement, so the function body won\u2019t compile: Filename: src/lib.cairo ```rust {{#include ../listings/ch06-managing-cairo-projects-with-packages-crates-and-modules/listing_06_06.cairo}} ``` Listing 6-6: A `use` statement only applies in the scope it\u2019s in The compiler error shows that the shortcut no longer applies within the `customer` module: ```console \u276f scarb build error: Identifier not found. --> lib.cairo:11:9 hosting::add_to_waitlist(); ^*****^ ``` ## Creating Idiomatic `use` Paths In Listing 6-5, you might have wondered why we specified `use restaurant::hosting` and then called `hosting::add_to_waitlist` in `eat_at_restaurant` rather than specifying the `use` path all the way out to the `add_to_waitlist` function to achieve the same result, as in Listing 6-7. Filename: src/lib.cairo ```rust {{#include ../listings/ch06-managing-cairo-projects-with-packages-crates-and-modules/listing_06_07.cairo}} ``` Listing 6-7: Bringing the `add_to_waitlist` function into scope with `use`, which is unidiomatic Although both Listing 6-5 and 6-7 accomplish the same task, Listing 6-5 is the idiomatic way to bring a function into scope with `use`. Bringing the function\u2019s parent module into scope with `use` means we have to specify the parent module when calling the function. Specifying the parent module when calling the function makes it clear that the function isn\u2019t locally defined while still minimizing repetition of the full path. The code in Listing 6-7 is unclear as to where `add_to_waitlist` is defined. On the other hand, when bringing in structs, enums, traits, and other items with `use`, it\u2019s idiomatic to specify the full path. Listing 6-8 shows the idiomatic way to bring the core library\u2019s `ArrayTrait` trait into the scope. ```rust {{#include ../listings/ch06-managing-cairo-projects-with-packages-crates-and-modules/listing_06_08.cairo}} ``` Listing 6-8: Bringing `ArrayTrait` into scope in an idiomatic way There\u2019s no strong reason behind this idiom: it\u2019s just the convention that has emerged in the Rust community, and folks have gotten used to reading and writing Rust code this way. As Cairo shares many idioms with Rust, we follow this convention as well. The exception to this idiom is if we\u2019re bringing two items with the same name into scope with `use` statements, because Cairo doesn\u2019t allow that. ### Providing New Names with the `as` Keyword There\u2019s another solution to the problem of bringing two types of the same name into the same scope with `use`: after the path, we can specify `as` and a new local name, or _alias_, for the type. Listing 6-9 shows how you can rename an import with `as`: Filename: src/lib.cairo ```rust {{#include ../listings/ch06-managing-cairo-projects-with-packages-crates-and-modules/listing_06_09.cairo}} ``` Listing 6-9: Renaming a trait when it\u2019s brought into scope with the `as` keyword Here, we brought `ArrayTrait` into scope with the alias `Arr`. We can now access the trait's methods with the `Arr` identifier. ### Importing multiple items from the same module When you want to import multiple items (like functions, structs or enums) from the same module in Cairo, you can use curly braces `{}` to list all of the items that you want to import. This helps to keep your code clean and easy to read by avoiding a long list of individual use statements. The general syntax for importing multiple items from the same module is: ```rust use module::{item1, item2, item3}; ``` Here is an example where we import three structures from the same module: ```rust {{#include ../listings/ch06-managing-cairo-projects-with-packages-crates-and-modules/listing_06_10.cairo}} ``` Listing 6-10: Importing multiple items from the same module ## Re-exporting Names in Module Files When we bring a name into scope with the `use` keyword, the name available in the new scope can be imported as if it had been defined in that code\u2019s scope. This technique is called _re-exporting_ because we\u2019re bringing an item into scope, but also making that item available for others to bring into their scope. For example, let's re-export the `add_to_waitlist` function in the restaurant example: Filename: src/lib.cairo ```rust {{#include ../listings/ch06-managing-cairo-projects-with-packages-crates-and-modules/listing_06_11.cairo}} ``` Listing 6-11: Making a name available for any code to use from a new scope with `pub use` Before this change, external code would have to call the `add_to_waitlist` function by using the path `restaurant::add_to_waitlist()`. Now that this `use` has re-exported the `hosting` module from the root module, external code can now use the path `restaurant::add_to_waitlist()` instead. Re-exporting is useful when the internal structure of your code is different from how programmers calling your code would think about the domain. For example, in this restaurant metaphor, the people running the restaurant think about \u201cfront of house\u201d and \u201cback of house.\u201d But customers visiting a restaurant probably won\u2019t think about the parts of the restaurant in those terms. With `use`, we can write our code with one structure but expose a different structure. Doing so makes our library well organized for programmers working on the library and programmers calling the library. ## Using External Packages in Cairo with Scarb You might need to use external packages to leverage the functionality provided by the community. To use an external package in your project with Scarb, follow these steps: > The dependencies system is still a work in progress. You can check the official [documentation]("}
{"title": "ch06-05-separating-modules-into-different-files.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "## Separating Modules into Different Files So far, all the examples in this chapter defined multiple modules in one file. When modules get large, you might want to move their definitions to a separate file to make the code easier to navigate. For example, let\u2019s start from the code in Listing 6-11 that had multiple restaurant modules. We\u2019ll extract modules into files instead of having all the modules defined in the crate root file. In this case, the crate root file is _src/lib.cairo_. First, we\u2019ll extract the `front_of_house` module to its own file. Remove the code inside the curly brackets for the `front_of_house` module, leaving only the `mod front_of_house;` declaration, so that _src/lib.cairo_ contains the code shown in Listing 6-12. Note that this won\u2019t compile until we create the _src/front_of_house.cairo_ file in Listing 6-13. Filename: src/lib.cairo ```rust {{#include ../listings/ch06-managing-cairo-projects-with-packages-crates-and-modules/listing_06_12.cairo}} ``` Listing 6-12: Declaring the `front_of_house` module whose body will be in _src/front_of_house.cairo_ Next, place the code that was in the curly brackets into a new file named _src/front_of_house.cairo_, as shown in Listing 6-13. The compiler knows to look in this file because it came across the module declaration in the crate root with the name `front_of_house`. Filename: src/front_of_house.cairo ```rust, {{#include ../listings/ch06-managing-cairo-projects-with-packages-crates-and-modules/listing_06_13.cairo}} ``` Listing 6-13: Definitions inside the `front_of_house` module in _src/front_of_house.cairo_ Note that you only need to load a file using a `mod` declaration _once_ in your module tree. Once the compiler knows the file is part of the project (and knows where in the module tree the code resides because of where you\u2019ve put the `mod` statement), other files in your project should refer to the loaded file\u2019s code using a path to where it was declared, as covered in the [\u201cPaths for Referring to an Item in the Module Tree\u201d][paths] section. In other words, `mod` is _not_ an \u201cinclude\u201d operation that you may have seen in other programming languages. Next, we\u2019ll extract the `hosting` module to its own file. The process is a bit different because `hosting` is a child module of `front_of_house`, not of the root module. We\u2019ll place the file for `hosting` in a new directory that will be named for its ancestors in the module tree, in this case _src/front_of_house/_. To start moving `hosting`, we change _src/front_of_house.cairo_ to contain only the declaration of the `hosting` module: Filename: src/front_of_house.cairo ```rust mod hosting; ``` Then we create a _src/front_of_house_ directory and a file _hosting.cairo_ to contain the definitions made in the `hosting` module: Filename: src/front_of_house/hosting.cairo ```rust fn add_to_waitlist() {} ``` If we instead put _hosting.cairo_ in the _src_ directory, the compiler would expect the _hosting.cairo_ code to be in a `hosting` module declared in the crate root, and not declared as a child of the `front_of_house` module. The compiler\u2019s rules for which files to check for which modules\u2019 code means the directories and files more closely match the module tree. We\u2019ve moved each module\u2019s code to a separate file, and the module tree remains the same. The function calls in `eat_at_restaurant` will work without any modification, even though the definitions live in different files. This technique lets you move modules to new files as they grow in size. Note that the `use restaurant::hosting` statement in _src/lib.cairo_ also hasn\u2019t changed, nor does `use` have any impact on what files are compiled as part of the crate. The `mod` keyword declares modules, and Cairo looks in a file with the same name as the module for the code that goes into that module. ## Summary Cairo lets you split a package into multiple crates and a crate into modules so you can refer to items defined in one module from another module. You can do this by specifying absolute or relative paths. These paths can be brought into scope with a `use` statement so you can use a shorter path for multiple uses of the item in that scope. Module code is public by default. [paths]: ch06-03-paths-for-referring-to-an-item-in-the-module-tree.html"}
{"title": "ch07-00-generic-types-and-traits.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Generic Types and Traits Every programming language has tools for effectively handling the duplication of concepts. In Cairo, one such tool is generics: abstract stand-ins for concrete types or other properties. We can express the behaviour of generics or how they relate to other generics without knowing what will be in their place when compiling and running the code. Functions, structs, enums and traits can incorporate generic types as part of their definition instead of a concrete types like `u32` or `ContractAddress`. Generics allow us to replace specific types with a placeholder that represents multiple types to remove code duplication. For each concrete type that replaces a generic type the compiler creates a new definition, reducing development time for the programmer, but code duplication at compile level still exists. This may be of importance if you are writing Starknet contracts and using a generic for multiple types which will cause contract size to increment. Then you\u2019ll learn how to use traits to define behavior in a generic way. You can combine traits with generic types to constrain a generic type to accept only those types that have a particular behavior, as opposed to just any type."}
{"title": "ch07-01-generic-data-types.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Generic Data Types We use generics to create definitions for item declarations, such as structs and functions, which we can then use with many different concrete data types. In Cairo we can use generics when defining functions, structs, enums, traits, implementations and methods! In this chapter we are going to take a look at how to effectively use generic types with all of them. ## Generic Functions When defining a function that uses generics, we place the generics in the function signature, where we would usually specify the data types of the parameter and return value. For example, imagine we want to create a function which given two `Array` of items, will return the largest one. If we need to perform this operation for lists of different types, then we would have to redefine the function each time. Luckily we can implement the function once using generics and move on to other tasks. ```rust {{#include ../listings/ch07-generic-types-and-traits/no_listing_01_missing_tdrop.cairo}} ``` The `largest_list` function compares two lists of the same type and returns the one with more elements and drops the other. If you compile the previous code, you will notice that it will fail with an error saying that there are no traits defined for dropping an array of a generic type. This happens because the compiler has no way to guarantee that an `Array` is droppable when executing the `main` function. In order to drop an array of `T`, the compiler must first know how to drop `T`. This can be fixed by specifying in the function signature of `largest_list` that `T` must implement the drop trait. The correct function definition of `largest_list` is as follows: ```rust {{#include ../listings/ch07-generic-types-and-traits/no_listing_02_with_tdrop.cairo}} ``` The new `largest_list` function includes in its definition the requirement that whatever generic type is placed there, it must be droppable. The `main` function remains unchanged, the compiler is smart enough to deduct which concrete type is being used and if it implements the `Drop` trait. ### Constraints for Generic Types When defining generic types, it is useful to have information about them. Knowing which traits a generic type implements allow us to use them more effectively in a functions logic at the cost of constraining the generic types that can be used with the function. We saw an example of this previously by adding the `TDrop` implementation as part of the generic arguments of `largest_list`. While `TDrop` was added to satisfy the compilers requirements, we can also add constraints to benefit our function logic. Imagine that we want, given a list of elements of some generic type `T`, find the smallest element among them. Initially, we know that for an element of type `T` to be comparable, it must implement the `PartialOrd` trait. The resulting function would be: ```rust {{#include ../listings/ch07-generic-types-and-traits/no_listing_03_missing_tcopy.cairo}} ``` The `smallest_element` function uses a generic type `T` that implements the `PartialOrd` trait, takes a snapshot of an `Array` as a parameter and returns a copy of the smallest element. Because the parameter is of type `@Array`, we no longer need to drop it at the end of the execution and so we don't require to implement the `Drop` trait for `T` as well. Why it does not compile then? When indexing on `list`, the value results in a snap of the indexed element, unless `PartialOrd` is implemented for `@T` we need to desnap the element using `*`. The `*` operation requires a copy from `@T` to`T`, which means that `T` needs to implement the `Copy` trait. After copying an element of type `@T` to `T`, there are now variables with type `T` that need to be dropped, requiring for `T` to implement the `Drop` trait as well. We must then add both `Drop` and `Copy` traits implementation for the function to be correct. After updating the`smallest_element` function the resulting code would be: ```rs {{#include ../listings/ch07-generic-types-and-traits/no_listing_04_with_tcopy.cairo}} ``` ## Structs We can also define structs to use a generic type parameter for one or more fields using the `` syntax, similar to function definitions. First we declare the name of the type parameter inside the angle brackets just after the name of the struct. Then we use the generic type in the struct definition where we would otherwise specify concrete data types. The next code example shows the definition `Wallet` which has a `balance` field of type `T`. ```rust {{#include ../listings/ch07-generic-types-and-traits/no_listing_05_derive_generics.cairo}} ``` The above code derives the `Drop` trait for the `Wallet` type automatically. It is equivalent to writing the following code: ```rust {{#include ../listings/ch07-generic-types-and-traits/no_listing_06_drop_explicit.cairo}} ``` We avoid using the `derive` macro for `Drop` implementation of `Wallet` and instead define our own `WalletDrop` implementation. Notice that we must define, just like functions, an additional generic type for `WalletDrop` saying that `T` implements the `Drop` trait as well. We are basically saying that the struct `Wallet` is droppable as long as `T` is also droppable. Finally, if we want to add a field to `Wallet` representing its address and we want that field to be different than `T` but generic as well, we can simply add another generic type between the ``: ```rust {{#include ../listings/ch07-generic-types-and-traits/no_listing_07_two_generics.cairo}} ``` We add to `Wallet` struct definition a new generic type `U` and then assign this type to the new field member `address`. Notice that the derive attribute for the `Drop` trait works for `U` as well. ## Enums As we did with structs, we can define enums to hold generic data types in their variants. For example the `Option` enum provided by the Cairo core library: ```rust {{#include ../listings/ch07-generic-types-and-traits/no_listing_08_option.cairo}} ``` The `Option` enum is generic over a type `T` and has two variants: `Some`, which holds one value of type `T` and `None` that doesn't hold any value. By using the `Option` enum, it is possible for us to express the abstract concept of an optional value and because the value has a generic type `T` we can use this abstraction with any type. Enums can use multiple generic types as well, like definition of the `Result` enum that the core library provides: ```rust {{#include ../listings/ch07-generic-types-and-traits/no_listing_09_result.cairo}} ``` The `Result` enum has two generic types, `T` and `E`, and two variants: `Ok` which holds the value of type `T` and `Err` which holds the value of type `E`. This definition makes it convenient to use the `Result` enum anywhere we have an operation that might succeed (by returning a value of type `T`) or fail (by returning a value of type `E`). ## Generic Methods We can implement methods on structs and enums, and use the generic types in their definition, too. Using our previous definition of `Wallet` struct, we define a `balance` method for it: ```rust {{#include ../listings/ch07-generic-types-and-traits/no_listing_10_generic_methods.cairo}} ``` We first define `WalletTrait` trait using a generic type `T` which defines a method that returns a snapshot of the field `address` from `Wallet`. Then we give an implementation for the trait in `WalletImpl`. Note that you need to include a generic type in both definitions of the trait and the implementation. We can also specify constraints on generic types when defining methods on the type. We could, for example, implement methods only for `Wallet` instances rather than `Wallet`. In the code example we define an implementation for wallets which have a concrete type of `u128` for the `balance` field. ```rust {{#include ../listings/ch07-generic-types-and-traits/no_listing_11_constrained_generics.cairo}} ``` The new method `receive` increments the size of the balance of any instance of a `Wallet`. Notice that we changed the `main` function making `w` a mutable variable in order for it to be able to update its balance. If we were to change the initialization of `w` by changing the type of `balance` the previous code wouldn't compile. Cairo allows us to define generic methods inside generic traits as well. Using the past implementation from `Wallet` we are going to define a trait that picks two wallets of different generic types and create a new one with a generic type of each. First, let's rewrite the struct definition: ```rust {{#include ../listings/ch07-generic-types-and-traits/no_listing_12_not_compiling.cairo:1:4}} ``` Next we are going to naively define the mixup trait and implementation: ```rust {{#include ../listings/ch07-generic-types-and-traits/no_listing_12_not_compiling.cairo:6:15}} ``` We are creating a trait `WalletMixTrait` with the `mixup` methods which given an instance of `Wallet` and `Wallet` creates a new `Wallet`. As `mixup` signature specify, both `self` and `other` are getting dropped at the end of the function, which is the reason for this code not to compile. If you have been following from the start until now you would know that we must add a requirement for all the generic types specifying that they will implement the `Drop` trait in order for the compiler to know how to drop instances of `Wallet`. The updated implementation is as follow: ```rust {{#include ../listings/ch07-generic-types-and-traits/no_listing_13_compiling.cairo:trait_impl}} ``` We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl` declaration. Then we do the same for `T2` and `U2`, this time as part of `mixup` signature. We can now try the `mixup` function: ```rust {{#include ../listings/ch07-generic-types-and-traits/no_listing_13_compiling.cairo:main}} ``` We first create two instances: one of `Wallet` and the other of `Wallet`. Then, we call `mixup` and create a new `Wallet` instance."}
{"title": "ch07-02-traits-in-cairo.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Traits in Cairo Traits specify functionality blueprints that can be implemented. The blueprint specification includes a set of function signatures containing type annotations for the parameters and return value. This sets a standard to implement the specific functionality. ## Defining a Trait To define a trait, you use the keyword `trait` followed by the name of the trait in `PascalCase` then the function signatures in a pair of curly braces. For example, let's say that we have multiple structs representing shapes. We want our application to be able to perform geometry operations on these shapes, So we define a trait `ShapeGeometry` that contains a blueprint to implement geometry operations on a shape like this: ```rust trait ShapeGeometry { fn boundary(self: Rectangle) -> u64; fn area(self: Rectangle) -> u64; } ``` Here our trait `ShapeGeometry` declares signatures for two methods `boundary` and `area`. When implemented, both these functions should return a `u64` and accept parameters as specified by the trait. ## Implementing a Trait A trait can be implemented using `impl` keyword with the name of your implementation followed by `of` then the name of trait being implemented. Here's an example implementing `ShapeGeometry` trait. ```rust impl RectangleGeometry of ShapeGeometry { fn boundary(self: Rectangle) -> u64 { 2 * (self.height + self.width) } fn area(self: Rectangle) -> u64 { self.height * self.width } } ``` In the code above, `RectangleGeometry` implements the trait `ShapeGeometry` defining what the methods `boundary` and `area` should do. Note that the function parameters and return value types are identical to the trait specification. ## Implementing a trait, without writing its declaration. You can write implementations directly without definining the corresponding trait. This is made possible by using the `#[generate_trait]` attribute with on the implementation, which will make the compiler generate the trait corresponding to the implementation automatically. Remember to add `Trait` as a suffix to your trait name, as the compiler will create the trait by adding a `Trait` suffix to the implementation name. ```rust #[generate_trait] impl RectangleGeometry of RectangleGeometryTrait { fn boundary(self: Rectangle) -> u64 { 2 * (self.height + self.width) } fn area(self: Rectangle) -> u64 { self.height * self.width } } ``` In the aforementioned code, there is no need to manually define the trait. The compiler will automatically handle its definition, dynamically generating and updating it as new functions are introduced. ## Parameter `self` In the example above, `self` is a special parameter. When a parameter with name `self` is used, the implemented functions are also [attached to the instances of the type as methods](ch04-03-method-syntax.md#defining-methods). Here's an illustration, When the `ShapeGeometry` trait is implemented, the function `area` from the `ShapeGeometry` trait can be called in two ways: ```rust let rect = Rectangle { ... }; // Rectangle instantiation // First way, as a method on the struct instance let area1 = rect.area(); // Second way, from the implementation let area2 = RectangleGeometry::area(rect); // `area1` has same value as `area2` area1.print(); area2.print(); ``` And the implementation of the `area` method will be accessed via the `self` parameter. ## Generic Traits Usually we want to write a trait when we want multiple types to implement a functionality in a standard way. However, in the example above the signatures are static and cannot be used for multiple types. To do this, we use generic types when defining traits. In the example below, we use generic type `T` and our method signatures can use this alias which can be provided during implementation. ```rust use debug::PrintTrait; #[derive(Copy, Drop)] struct Rectangle { height: u64, width: u64, } #[derive(Copy, Drop)] struct Circle { radius: u64 } // Here T is an alias type which will be provided during implementation trait ShapeGeometry { fn boundary(self: T) -> u64; fn area(self: T) -> u64; } // Implementation RectangleGeometry passes in // to implement the trait for that type impl RectangleGeometry of ShapeGeometry { fn boundary(self: Rectangle) -> u64 { 2 * (self.height + self.width) } fn area(self: Rectangle) -> u64 { self.height * self.width } } // We might have another struct Circle // which can use the same trait spec impl CircleGeometry of ShapeGeometry { fn boundary(self: Circle) -> u64 { (2 * 314 * self.radius) / 100 } fn area(self: Circle) -> u64 { (314 * self.radius * self.radius) / 100 } } fn main() { let rect = Rectangle { height: 5, width: 7 }; rect.area().print(); // 35 rect.boundary().print(); // 24 let circ = Circle { radius: 5 }; circ.area().print(); // 78 circ.boundary().print(); // 31 } ``` ## Managing and using external trait implementations To use traits methods, you need to make sure the correct traits/implementation(s) are imported. In the code above we imported `PrintTrait` from `debug` with `use debug::PrintTrait;` to use the `print()` methods on supported types. In some cases you might need to import not only the trait but also the implementation if they are declared in separate modules. If `CircleGeometry` was in a separate module/file `circle` then to use `boundary` on `circ: Circle`, we'd need to import `CircleGeometry` in addition to `ShapeGeometry`. If the code was organised into modules like this, ```rust,does_not_compile,ignore_format use debug::PrintTrait; // struct Circle { ... } and struct Rectangle { ... } mod geometry { use super::Rectangle; trait ShapeGeometry { // ... } impl RectangleGeometry of ShapeGeometry:: { // ... } } // Could be in a different file mod circle { use super::ShapeGeometry; use super::Circle; impl CircleGeometry of ShapeGeometry { // ... } } fn main() { let rect = Rectangle { height: 5, width: 7 }; let circ = Circle { radius: 5 }; // Fails with this error // Method `area` not found on... Did you import the correct trait and impl? rect.area().print(); circ.area().print(); } ``` To make it work, in addition to, ```rust use geometry::ShapeGeometry; ``` you might also need to use `CircleGeometry`, ```rust use circle::CircleGeometry ```"}
{"title": "ch08-00-testing-cairo-programs.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Testing Cairo Programs"}
{"title": "ch08-01-how-to-write-tests.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# How To Write Tests ## The Anatomy of a Test Function Tests are Cairo functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions: - Set up any needed data or state. - Run the code you want to test. - Assert the results are what you expect. Let\u2019s look at the features Cairo provides specifically for writing tests that take these actions, which include the `test` attribute, the `assert` function, and the `should_panic` attribute. ### The Anatomy of a Test Function At its simplest, a test in Cairo is a function that\u2019s annotated with the `test` attribute. Attributes are metadata about pieces of Cairo code; one example is the derive attribute we used with structs in Chapter 4. To change a function into a test function, add `#[test]` on the line before `fn`. When you run your tests with the `cairo-test` command, Cairo builds a test runner binary that runs the annotated functions and reports on whether each test function passes or fails. Let's create a new project called `adder` that will add two numbers using Scarb with the command `scarb new adder`: ```shell adder \u251c\u2500\u2500 cairo_project.toml \u251c\u2500\u2500 Scarb.toml \u2514\u2500\u2500 src \u2514\u2500\u2500 lib.cairo ``` > Note: You will notice here a `cairo_project.toml` file. > This is the configuration file for \"vanilla\" Cairo projects (i.e. not managed by Scarb), > which is required to run the `cairo-test .` command to run the code of the crate. > It is required until Scarb implements this feature. The content of the file is: > > ```toml > [crate_roots] > adder = \"src\" > ``` > > and indicates that the crate named \"adder\" is located in the `src` directory. In _lib.cairo_, let's add a first test, as shown in Listing 8-1. Filename: lib.cairo ```rust {{#include ../listings/ch08-testing-cairo-programs/listing_08_01_02.cairo:it_works}} ``` Listing 8-1: A test module and function For now, let\u2019s ignore the top two lines and focus on the function. Note the `#[test]` annotation: this attribute indicates this is a test function, so the test runner knows to treat this function as a test. We might also have non-test functions in the tests module to help set up common scenarios or perform common operations, so we always need to indicate which functions are tests. The example function body uses the `assert` function, which contains the result of adding 2 and 2, equals 4. This assertion serves as an example of the format for a typical test. Let\u2019s run it to see that this test passes. The `cairo-test .` command runs all tests in our project, as shown in Listing 8-2. ```shell $ cairo-test . running 1 tests test adder::it_works ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out; ``` Listing 8-2: The output from running a test `cairo-test` compiled and ran the test. We see the line `running 1 tests`. The next line shows the name of the generated test function, called `it_works`, and that the result of running that test is `ok`. The overall summary `test result: ok.` means that all the tests passed, and the portion that reads `1 passed; 0 failed` totals the number of tests that passed or failed. It\u2019s possible to mark a test as ignored so it doesn\u2019t run in a particular instance; we\u2019ll cover that in the [Ignoring Some Tests Unless Specifically Requested](#ignoring-some-tests-unless-specifically-requested) section later in this chapter. Because we haven\u2019t done that here, the summary shows `0 ignored`. We can also pass an argument to the `cairo-test` command to run only a test whose name matches a string; this is called filtering and we\u2019ll cover that in the [Running Single Tests](#running-single-tests) section. We also haven\u2019t filtered the tests being run, so the end of the summary shows `0 filtered out`. Let\u2019s start to customize the test to our own needs. First change the name of the `it_works` function to a different name, such as `exploration`, like so: Filename: lib.cairo ```rust {{#include ../listings/ch08-testing-cairo-programs/listing_08_01_02.cairo:exploration}} ``` Then run `cairo-test -- --path src` again. The output now shows `exploration` instead of `it_works`: ```shell $ cairo-test . running 1 tests test adder::exploration ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out; ``` Now we\u2019ll add another test, but this time we\u2019ll make a test that fails! Tests fail when something in the test function panics. Each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed. Enter the new test as a function named `another`, so your _src/lib.cairo_ file looks like Listing 8-3. ```rust {{#include ../listings/ch08-testing-cairo-programs/listing_08_03.cairo:another}} ``` Listing 8-3: Adding a second test that will fail ```shell $ cairo-test . running 2 tests test adder::exploration ... ok test adder::another ... fail failures: adder::another - panicked with [1725643816656041371866211894343434536761780588 ('Make this test fail'), ]. Error: test result: FAILED. 1 passed; 1 failed; 0 ignored ``` Listing 8-4: Test results when one test passes and one test fails Instead of `ok`, the line `adder::another` shows `fail`. A new section appears between the individual results and the summary. It displays the detailed reason for each test failure. In this case, we get the details that `another` failed because it panicked with `[1725643816656041371866211894343434536761780588 ('Make this test fail'), ]` in the _src/lib.cairo_ file. The summary line displays at the end: overall, our test result is `FAILED`. We had one test pass and one test fail. Now that you\u2019ve seen what the test results look like in different scenarios, let\u2019s look at some functions that are useful in tests. ## Checking Results with the assert function The `assert` function, provided by Cairo, is useful when you want to ensure that some condition in a test evaluates to `true`. We give the `assert` function a first argument that evaluates to a Boolean. If the value is `true`, nothing happens and the test passes. If the value is `false`, the assert function calls `panic()` to cause the test to fail with a message we defined as the second argument of the `assert` function. Using the `assert` function helps us check that our code is functioning in the way we intend. In [Chapter 4, Listing 5-15](ch04-03-method-syntax.md#multiple-impl-blocks), we used a `Rectangle` struct and a `can_hold` method, which are repeated here in Listing 8-5. Let\u2019s put this code in the _src/lib.cairo_ file, then write some tests for it using the `assert` function. Filename: lib.cairo ```rust {{#include ../listings/ch08-testing-cairo-programs/listing_08_06.cairo:trait_impl}} ``` Listing 8-5: Using the `Rectangle` struct and its `can_hold` method from Chapter 5 The `can_hold` method returns a `bool`, which means it\u2019s a perfect use case for the assert function. In Listing 8-6, we write a test that exercises the `can_hold` method by creating a `Rectangle` instance that has a width of `8` and a height of `7` and asserting that it can hold another `Rectangle` instance that has a width of `5` and a height of `1`. Filename: lib.cairo ```rust {{#rustdoc_include ../listings/ch08-testing-cairo-programs/listing_08_06.cairo:test1}} ``` Listing 8-6: A test for `can_hold` that checks whether a larger rectangle can indeed hold a smaller rectangle Note that we\u2019ve added two new lines inside the tests module: `use super::Rectangle;` and `use super::RectangleTrait;`. The tests module is a regular module that follows the usual visibility rules. Because the tests module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We\u2019ve named our test `larger_can_hold_smaller`, and we\u2019ve created the two `Rectangle` instances that we need. Then we called the assert function and passed it the result of calling `larger.can_hold(@smaller)`. This expression is supposed to return `true`, so our test should pass. Let\u2019s find out! ```shell $ cairo-test . running 1 tests test adder::larger_can_hold_smaller ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out; ``` It does pass! Let\u2019s add another test, this time asserting that a smaller rectangle cannot hold a larger rectangle: Filename: lib.cairo ```rust {{#rustdoc_include ../listings/ch08-testing-cairo-programs/listing_08_06.cairo:test2}} ``` Because the correct result of the `can_hold` function in this case is `false`, we need to negate that result before we pass it to the assert function. As a result, our test will pass if `can_hold` returns false: ```shell $ cairo-test . running 2 tests test adder::smaller_cannot_hold_larger ... ok test adder::larger_can_hold_smaller ... ok test result: ok. 2 passed; 0 failed; 0 ignored; 0 filtered out; ``` Two tests that pass! Now let\u2019s see what happens to our test results when we introduce a bug in our code. We\u2019ll change the implementation of the `can_hold` method by replacing the greater-than sign with a less-than sign when it compares the widths: ```rust {{#include ../listings/ch08-testing-cairo-programs/no_listing_02_wrong_can_hold_impl.cairo:wrong_impl}} ``` Running the tests now produces the following: ```shell $ cairo-test . running 2 tests test adder::smaller_cannot_hold_larger ... ok test adder::larger_can_hold_smaller ... fail failures: adder::larger_can_hold_smaller - panicked with [167190012635530104759003347567405866263038433127524 ('rectangle cannot hold'), ]. Error: test result: FAILED. 1 passed; 1 failed; 0 ignored ``` Our tests caught the bug! Because `larger.width` is `8` and `smaller.width` is `5`, the comparison of the widths in `can_hold` now returns `false`: `8` is not less than `5`. ## Checking for Panics with `should_panic` In addition to checking return values, it\u2019s important to check that our code handles error conditions as we expect. For example, consider the Guess type in Listing 8-8. Other code that uses `Guess` depends on the guarantee that `Guess` instances will contain only values between `1` and `100`. We can write a test that ensures that attempting to create a `Guess` instance with a value outside that range panics. We do this by adding the attribute `should_panic` to our test function. The test passes if the code inside the function panics; the test fails if the code inside the function doesn\u2019t panic. Listing 8-8 shows a test that checks that the error conditions of `GuessTrait::new` happen when we expect them to. Filename: lib.cairo ```rust {{#include ../listings/ch08-testing-cairo-programs/listing_08_08.cairo}} ``` Listing 8-8: Testing that a condition will cause a panic We place the `#[should_panic]` attribute after the `#[test]` attribute and before the test function it applies to. Let\u2019s look at the result when this test passes: ```shell $ cairo-test . running 1 tests test adder::greater_than_100 ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out; ``` Looks good! Now let\u2019s introduce a bug in our code by removing the condition that the new function will panic if the value is greater than `100`: ```rust {{#rustdoc_include ../listings/ch08-testing-cairo-programs/no_listing_03_wrong_new_impl.cairo:here}} ``` When we run the test in Listing 8-8, it will fail: ```shell $ cairo-test . running 1 tests test adder::greater_than_100 ... fail failures: adder::greater_than_100 - expected panic but finished successfully. Error: test result: FAILED. 0 passed; 1 failed; 0 ignored ``` We don\u2019t get a very helpful message in this case, but when we look at the test function, we see that it\u2019s annotated with `#[should_panic]`. The failure we got means that the code in the test function did not cause a panic. Tests that use `should_panic` can be imprecise. A `should_panic` test would pass even if the test panics for a different reason from the one we were expecting. To make `should_panic` tests more precise, we can add an optional expected parameter to the `should_panic` attribute. The test harness will make sure that the failure message contains the provided text. For example, consider the modified code for `Guess` in Listing 8-9 where the new function panics with different messages depending on whether the value is too small or too large. Filename: lib.cairo ```rust {{#rustdoc_include ../listings/ch08-testing-cairo-programs/listing_08_09.cairo:test_panic}} ``` Listing 8-9: Testing for a panic with a panic message containing the error message string This test will pass because the value we put in the `should_panic` attribute\u2019s expected parameter is the array of string of the message that the `Guess::new` function panics with. We need to specify the entire panic message that we expect. To see what happens when a `should_panic` test with an expected message fails, let\u2019s again introduce a bug into our code by swapping the bodies of the if `value 100` blocks: ```rust {{#include ../listings/ch08-testing-cairo-programs/no_listing_04_new_bug.cairo:here}} ``` This time when we run the `should_panic` test, it will fail: ```shell $ cairo-test . running 1 tests test adder::greater_than_100 ... fail failures: adder::greater_than_100 - panicked with [6224920189561486601619856539731839409791025 ('Guess must be >= 1'), ]. Error: test result: FAILED. 0 passed; 1 failed; 0 ignored ``` The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string. The panic message that we did get in this case was `Guess must be >= 1`. Now we can start figuring out where our bug is! ## Running Single Tests Sometimes, running a full test suite can take a long time. If you\u2019re working on code in a particular area, you might want to run only the tests pertaining to that code. You can choose which tests to run by passing `cairo-test` the name of the test you want to run as an argument. To demonstrate how to run a single test, we\u2019ll first create two tests functions, as shown in Listing 8-10, and choose which ones to run. Filename: src/lib.cairo ```rust {{#include ../listings/ch08-testing-cairo-programs/listing_08_10.cairo}} ``` Listing 8-10: Two tests with two different names We can pass the name of any test function to `cairo-test` to run only that test using the `-f` flag: ```shell $ cairo-test . -f add_two_and_two running 1 tests test adder::add_two_and_two ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 1 filtered out; ``` Only the test with the name `add_two_and_two` ran; the other test didn\u2019t match that name. The test output lets us know we had one more test that didn\u2019t run by displaying 1 filtered out at the end. We can also specify part of a test name, and any test whose name contains that value will be run. ## Ignoring Some Tests Unless Specifically Requested Sometimes a few specific tests can be very time-consuming to execute, so you might want to exclude them during most runs of `cairo-test`. Rather than listing as arguments all tests you do want to run, you can instead annotate the time-consuming tests using the `ignore` attribute to exclude them, as shown here: Filename: src/lib.cairo ```rust {{#include ../listings/ch08-testing-cairo-programs/no_listing_05_ignore_tests.cairo}} ``` After `#[test]` we add the `#[ignore]` line to the test we want to exclude. Now when we run our tests, `it_works` runs, but `expensive_test` doesn\u2019t: ```shell $ cairo-test . running 2 tests test adder::expensive_test ... ignored test adder::it_works ... ok test result: ok. 1 passed; 0 failed; 1 ignored; 0 filtered out; ``` The `expensive_test` function is listed as ignored. When you\u2019re at a point where it makes sense to check the results of the ignored tests and you have time to wait for the results, you can run `cairo-test --include-ignored` to run all tests whether they\u2019re ignored or not."}
{"title": "ch08-02-test-organization.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Testing Organization We'll think about tests in terms of two main categories: unit tests and integration tests. Unit tests are small and more focused, testing one module in isolation at a time, and can test private functions. Integration tests use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test. Writing both kinds of tests is important to ensure that the pieces of your library are doing what you expect them to, separately and together. ## Unit Tests The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn\u2019t working as expected. You\u2019ll put unit tests in the `src` directory in each file with the code that they\u2019re testing. The convention is to create a module named tests in each file to contain the test functions and to annotate the module with `cfg(test)`. ### The Tests Module and `#[cfg(test)]` The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and run the test code only when you run `cairo-test`, not when you run `cairo-run`. This saves compile time when you only want to build the library and saves space in the resulting compiled artifact because the tests are not included. You\u2019ll see that because integration tests go in a different directory, they don\u2019t need the `#[cfg(test)]` annotation. However, because unit tests go in the same files as the code, you\u2019ll use `#[cfg(test)]` to specify that they shouldn\u2019t be included in the compiled result. Recall that when we created the new `adder` project in the first section of this chapter, we wrote this first test: Filename: lib.cairo ```rust {{#include ../listings/ch08-testing-cairo-programs/no_listing_06_cfg_attr.cairo}} ``` The attribute `cfg` stands for configuration and tells Cairo that the following item should only be included given a certain configuration option. In this case, the configuration option is `test`, which is provided by Cairo for compiling and running tests. By using the `cfg` attribute, Cairo compiles our test code only if we actively run the tests with `cairo-test`. This includes any helper functions that might be within this module, in addition to the functions annotated with `#[test]`. ## Integration Tests Integration tests use your library in the same way any other code would. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a `tests` directory. ### The `tests` Directory ```shell adder \u251c\u2500\u2500 cairo_project.toml \u251c\u2500\u2500 src \u251c\u2500\u2500 lib.cairo \u2502 \u2514\u2500\u2500 main.cairo \u2514\u2500\u2500 tests \u251c\u2500\u2500 lib.cairo \u2514\u2500\u2500 integration_test.cairo ``` > To successfully run your tests with `cairo-test` you will need to update your `cairo_project.toml` file to add the declaration of your `tests` crate. > > ```rust > [crate_roots] > adder = \"src\" > tests = \"tests\" > ``` Each test file is compiled as its own separate crate, that's why whenever you add a new test file you must add it to your _tests/lib.cairo_. Filename: tests/lib.cairo ```rust #[cfg(tests)] mod integration_tests; ``` Enter the code in Listing 8-11 into the _tests/integration_test.cairo_ file: Filename: tests/integration_test.cairo ```rust {{#include ../listings/ch08-testing-cairo-programs/no_listing_07_integration_test.cairo:here}} ``` Listing 8-11: Testing functions from other modules Each file in the tests directory is a separate crate, so we need to bring our library into each test crate\u2019s scope. For that reason we add `use adder::main` at the top of the code, which we didn\u2019t need in the unit tests. ```shell $ cairo-test tests/ running 1 tests test tests::it_adds_two ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out; ``` The result of the tests is the same as what we've been seeing: one line for each test."}
{"title": "ch09-00-error-handling.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Error handling In this chapter, we will explore various error handling techniques provided by Cairo, which not only allow you to address potential issues in your code, but also make it easier to create programs that are adaptable and maintainable. By examining different approaches to managing errors, such as pattern matching with the Result enum, using the ? operator for more ergonomic error propagation, and employing the unwrap or expect methods for handling recoverable errors, you'll gain a deeper understanding of Cairo's error handling features. These concepts are crucial for building robust applications that can effectively handle unexpected situations, ensuring your code is ready for production."}
{"title": "ch09-01-unrecoverable-errors-with-panic.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Unrecoverable Errors with panic In Cairo, unexpected issues may arise during program execution, resulting in runtime errors. While the panic function from the core library doesn't provide a resolution for these errors, it does acknowledge their occurrence and terminates the program. There are two primary ways that a panic can be triggered in Cairo: inadvertently, through actions causing the code to panic (e.g., accessing an array beyond its bounds), or deliberately, by invoking the panic function. When a panic occurs, it leads to an abrupt termination of the program. The `panic` function takes an array as argument, which can be used to provide an error message and performs an unwind process where all variables are dropped and dictionaries squashed to ensure the soundness of the program to safely terminate the execution. Here is how we can `panic` from inside a program and return the error code `2`: Filename: lib.cairo ```rust {{#include ../listings/ch09-error-handling/no_listing_01_panic.cairo}} ``` Running the program will produce the following output: ```console $ cairo-run test.cairo Run panicked with [2 (''), ]. ``` As you can notice in the output, the print statement is never reached, as the program terminates after encountering the `panic` statement. An alternative and more idiomatic approach to panic in Cairo would be to use the `panic_with_felt252` function. This function serves as an abstraction of the array-defining process and is often preferred due to its clearer and more concise expression of intent. By using `panic_with_felt252`, developers can panic in a one-liner by providing a felt252 error message as argument, making the code more readable and maintainable. Let's consider an example: ```rust {{#include ../listings/ch09-error-handling/no_listing_02_with_felt252.cairo}} ``` Executing this program will yield the same error message as before. In that case, if there is no need for an array and multiple values to be returned within the error, so `panic_with_felt252` is a more succinct alternative. ## nopanic notation You can use the `nopanic` notation to indicate that a function will never panic. Only `nopanic` functions can be called in a function annotated as `nopanic`. Example: ```rust {{#include ../listings/ch09-error-handling/no_listing_03_nopanic.cairo}} ``` Wrong example: ```rust {{#include ../listings/ch09-error-handling/no_listing_04_nopanic_wrong.cairo}} ``` If you write the following function that includes a function that may panic you will get the following error: ```console error: Function is declared as nopanic but calls a function that may panic. --> test.cairo:2:12 assert(1 == 1, 'what'); ^****^ Function is declared as nopanic but calls a function that may panic. --> test.cairo:2:5 assert(1 == 1, 'what'); ^********************^ ``` Note that there are two functions that may panic here, assert and equality. ## panic_with macro You can use the `panic_with` macro to mark a function that returns an `Option` or `Result`. This macro takes two arguments, which are the data that is passed as the panic reason as well as the name for a wrapping function. It will create a wrapper for your annotated function which will panic if the function returns `None` or `Err`, the panic function will be called with the given data. Example: ```rust {{#include ../listings/ch09-error-handling/no_listing_05_panic_with.cairo}} ``` ## Using assert The assert function from the Cairo core library is actually a utility function based on panics. It asserts that a boolean expression is true at runtime, and if it is not, it calls the panic function with an error value. The assert function takes two arguments: the boolean expression to verify, and the error value. The error value is specified as a felt252, so any string passed must be able to fit inside a felt252. Here is an example of its usage: ```rust {{#include ../listings/ch09-error-handling/no_listing_06_assert.cairo}} ``` We are asserting in main that `my_number` is not zero to ensure that we're not performing a division by 0. In this example, `my_number` is zero so the assertion will fail, and the program will panic with the string 'number is zero' (as a felt252) and the division will not be reached."}
{"title": "ch09-02-error-handling.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Recoverable Errors with `Result` Most errors aren\u2019t serious enough to require the program to stop entirely. Sometimes, when a function fails, it\u2019s for a reason that you can easily interpret and respond to. For example, if you try to add two large integers and the operation overflows because the sum exceeds the maximum representable value, you might want to return an error or a wrapped result instead of causing undefined behavior or terminating the process. ## The `Result` enum Recall from [\u201cGeneric data types\u201d](ch07-01-generic-data-types.md#enums) in Chapter 7 that the `Result` enum is defined as having two variants, `Ok` and `Err`, as follows: ```rust {{#include ../listings/ch09-error-handling/no_listing_07_result_enum.cairo}} ``` The `Result` enum has two generic types, `T` and `E`, and two variants: `Ok` which holds the value of type `T` and `Err` which holds the value of type `E`. This definition makes it convenient to use the `Result` enum anywhere we have an operation that might succeed (by returning a value of type `T`) or fail (by returning a value of type `E`). ## The `ResultTrait` The `ResultTrait` trait provides methods for working with the `Result` enum, such as unwrapping values, checking whether the `Result` is `Ok` or `Err`, and panicking with a custom message. The `ResultTraitImpl` implementation defines the logic of these methods. ```rust {{#include ../listings/ch09-error-handling/no_listing_08_result_trait.cairo}} ``` The `expect` and `unwrap` methods are similar in that they both attempt to extract the value of type `T` from a `Result` when it is in the `Ok` variant. If the `Result` is `Ok(x)`, both methods return the value `x`. However, the key difference between the two methods lies in their behavior when the `Result` is in the `Err` variant. The `expect` method allows you to provide a custom error message (as a `felt252` value) that will be used when panicking, giving you more control and context over the panic. On the other hand, the `unwrap` method panics with a default error message, providing less information about the cause of the panic. The `expect_err` and `unwrap_err` have the exact opposite behavior. If the `Result` is `Err(x)`, both methods return the value `x`. However, the key difference between the two methods is in case of `Result::Ok()`. The `expect_err` method allows you to provide a custom error message (as a `felt252` value) that will be used when panicking, giving you more control and context over the panic. On the other hand, the `unwrap_err` method panics with a default error message, providing less information about the cause of the panic. A careful reader may have noticed the `>` and `>` in the first four methods signatures. This syntax represents generic type constraints in the Cairo language. These constraints indicate that the associated functions require an implementation of the `Drop` trait for the generic types `T` and `E`, respectively. Finally, the `is_ok` and `is_err` methods are utility functions provided by the `ResultTrait` trait to check the variant of a `Result` enum value. `is_ok` takes a snapshot of a `Result` value and returns `true` if the `Result` is the `Ok` variant, meaning the operation was successful. If the `Result` is the `Err` variant, it returns `false`. `is_err` takes a reference to a `Result` value and returns `true` if the `Result` is the `Err` variant, meaning the operation encountered an error. If the `Result` is the `Ok` variant, it returns `false`. These methods are helpful when you want to check the success or failure of an operation without consuming the Result value, allowing you to perform additional operations or make decisions based on the variant without unwrapping it. You can find the implementation ot the `ResultTrait` [here]( It is always easier to understand with examples. Have a look at this function signature: ```rust fn u128_overflowing_add(a: u128, b: u128) -> Result; ``` It takes two u128 integers, a and b, and returns a `Result` where the `Ok` variant holds the sum if the addition does not overflow, and the `Err` variant holds the overflowed value if the addition does overflow. Now, we can use this function elsewhere. For instance: ```rust fn u128_checked_add(a: u128, b: u128) -> Option { match u128_overflowing_add(a, b) { Result::Ok(r) => Option::Some(r), Result::Err(r) => Option::None(()), } } ``` Here, it accepts two u128 integers, a and b, and returns an `Option`. It uses the `Result` returned by `u128_overflowing_add` to determine the success or failure of the addition operation. The match expression checks the `Result` from `u128_overflowing_add`. If the result is `Ok(r)`, it returns `Option::Some(r)` containing the sum. If the result is `Err(r)`, it returns `Option::None(())` to indicate that the operation has failed due to overflow. The function does not panic in case of an overflow. Let's take another example demonstrating the use of `unwrap`. First we import the necessary modules: ```rust use core::Into; use traits::TryInto; use option::OptionTrait; use result::ResultTrait; use result::ResultTraitImpl; ``` In this example, the `parse_u8` function takes a `felt252` integer and tries to convert it into a `u8` integer using the `try_into` method. If successful, it returns `Result::Ok(value)`, otherwise it returns `Result::Err('Invalid integer')`. ```rust {{#include ../listings/ch09-error-handling/listing_01.cairo:function}} ``` Listing 9-1: Using the Result type Our two test cases are: ```rust {{#rustdoc_include ../listings/ch09-error-handling/listing_01.cairo:tests}} ``` The first one tests a valid conversion from `felt252` to `u8`, expecting the `unwrap` method not to panic. The second test function attempts to convert a value that is out of the `u8` range, expecting the `unwrap` method to panic with the error message 'Invalid integer'. > We could have also used the #[should_panic] attribute here. ### The `?` operator ? The last operator we will talk about is the `?` operator. The `?` operator is used for more idiomatic and concise error handling. When you use the `?` operator on a `Result` or `Option` type, it will do the following: - If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the inner value `x` directly. - If the value is `Result::Err(e)` or `Option::None`, it will propagate the error or `None` by immediately returning from the function. The `?` operator is useful when you want to handle errors implicitly and let the calling function deal with them. Here is an example. ```rust {{#include ../listings/ch09-error-handling/listing_02.cairo:function}} ``` Listing 9-1: Using the `?` operator `do_something_with_parse_u8` function takes a `felt252` value as input and calls `parse_u8`. The `?` operator is used to propagate the error, if any, or unwrap the successful value. And with a little test case: ```rust {{#rustdoc_include ../listings/ch09-error-handling/listing_02.cairo:tests}} ``` The console will print the error \"Invalid Integer\". ### Summary We saw that recoverable errors can be handled in Cairo using the Result enum, which has two variants: `Ok` and `Err`. The `Result` enum is generic, with types `T` and `E` representing the successful and error values, respectively. The `ResultTrait` provides methods for working with `Result`, such as unwrapping values, checking if the result is `Ok` or `Err`, and panicking with custom messages. To handle recoverable errors, a function can return a `Result` type and use pattern matching to handle the success or failure of an operation. The `?` operator can be used to implicitly handle errors by propagating the error or unwrapping the successful value. This allows for more concise and clear error handling, where the caller is responsible for managing errors raised by the called function."}
{"title": "ch10-00-advanced-features.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Advanced Features"}
{"title": "ch10-01-operator-overloading.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Operator Overloading Operator overloading is a feature in some programming languages that allows the redefinition of standard operators, such as addition (+), subtraction (-), multiplication (\\*), and division (/), to work with user-defined types. This can make the syntax of the code more intuitive, by enabling operations on user-defined types to be expressed in the same way as operations on primitive types. In Cairo, operator overloading is achieved through the implementation of specific traits. Each operator has an associated trait, and overloading that operator involves providing an implementation of that trait for a custom type. However, it's essential to use operator overloading judiciously. Misuse can lead to confusion, making the code more difficult to maintain, for example when there is no semantic meaning to the operator being overloaded. Consider an example where two `Potions` need to be combined. `Potions` have two data fields, mana and health. Combining two `Potions` should add their respective fields. ```rust {{#include ../listings/ch10-advanced-features/no_listing_01_potions.cairo}} ``` In the code above, we're implementing the `Add` trait for the `Potion` type. The add function takes two arguments: `lhs` and `rhs` (left and right-hand side). The function body returns a new `Potion` instance, its field values being a combination of `lhs` and `rhs`. As illustrated in the example, overloading an operator requires specification of the concrete type being overloaded. The overloaded generic trait is `Add`, and we define a concrete implementation for the type `Potion` with `Add`."}
{"title": "ch15-00-dictionaries.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Dictionaries Cairo provides in its core library a dictionary-like type. The `Felt252Dict` data type represents a collection of key-value pairs where each key is unique and associated with a corresponding value. This type of data structure is known differently across different programming languages such as maps, hash tables, associative arrays and many others. The `Felt252Dict` type is useful when you want to organize your data in a certain way for which using an `Array` and indexing doesn't suffice. Cairo dictionaries also allow the programmer to easily simulate the existence of mutable memory when there is none. ## Basic Use of Dictionaries It is normal in other languages when creating a new dictionary to define the data types of both key and value. In Cairo, the key type is restricted to `felt252` leaving only the possibility to specify the value data type, represented by `T` in `Felt252Dict`. The core functionality of a `Felt252Dict` is implemented in the trait `Felt252DictTrait` which includes all basic operations. Among them we can find: 1. `insert(felt252, T) -> ()` to write values to a dictionary instance and 2. `get(felt252) -> T` to read values from it. These functions allow us to manipulate dictionaries like in any other language. In the following example, we create a dictionary to represent a mapping between individuals and their balance: ```rust {{#include ../listings/ch15-dictionaries/listing_15_00_intro.cairo}} ``` The first thing we do is import `Felt252DictTrait` which brings to scope all the methods we need to interact with the dictionary. Next, we create a new instance of `Felt252Dict` by using the `default` method of the `Default` trait and added two individuals, each one with their own balance, using the `insert` method. Finally, we checked the balance of our users with the `get` method. Until this point in the book, we have talked about how Cairo's memory is immutable, meaning you can only write to a memory cell once but the `Felt252Dict` type represents a way to overcome this obstacle. We will explain how this is implemented later on in [Dictionaries Underneath](#dictionaries-underneath). Building upon our previous example, let us show a code example where the balance of the same user changes: ```rust {{#include ../listings/ch15-dictionaries/listing_15_01_intro_rewrite.cairo}} ``` Notice how in this example we added the _Alex_ user twice, each time using a different balance and each time that we checked for its balance it had the last value inserted! `Felt252Dict` effectively allows us to \"rewrite\" the stored value for any given key. Before heading on and explaining how dictionaries are implemented it is worth mentioning that once you instantiate a `Fetl252Dict`, behind the scenes all keys have their associated values initialized as zero. This means that if for example, you tried to get the balance of an inexistent user you will get 0 instead of an error or an undefined value. This also means there is no way to delete data from a dictionary. Something to take into account when incorporating this structure into your code. Until this point, we have seen all the basic features of `Felt252Dict` and how it mimics the same behavior as the corresponding data structures in any other language, that is, externally of course. Cairo is at its core a non-deterministic Turing-complete programming language, very different from any other popular language in existence, which as a consequence means that dictionaries are implemented very differently as well! In the following sections, we are going to give some insights about `Felt252Dict` inner mechanisms and the compromises that were taken to make them work. After that, we are going to take a look at how to use dictionaries with other data structures as well as using the `entry` method to interact with it. ## Dictionaries Underneath One of the constraints of Cairo's non-deterministic design is that its memory system is immutable, so in order to simulate mutability, the language implements `Felt252Dict` as a list of entries. Each of the entries represents a time when a dictionary was accessed for reading/updating/writing purposes. An entry has three fields: 1. A `key` field that identifies the value for this key-value pair of the dictionary. 2. A `previous_value` field that indicates which previous value was held at `key`. 3. A `new_value` field that indicates the new value that is held at `key`. If we try implementing `Felt252Dict` using high-level structures we would internally define it as `Array>` where each `Entry` has information about what key-value pair it represents and the previous and new values it holds. The definition of `Entry` would be: ```rust {{#include ../listings/ch15-dictionaries/listing_15_02_entries.cairo:struct}} ``` For each time we interact with a `Felt252Dict` a new `Entry` will be registered: - A `get` would register an entry where there is no change in state, and previous and new values are stored with the same value. - An `insert` would register a new `Entry` where the `new_value` would be the element being inserted, and the `previous_value` the last element inserted before this. In case it is the first entry for a certain key, then the previous and current values will be the same. The use of this entry list shows how there isn't any rewriting, just the creation of new memory cells per `Felt252Dict` interaction. Let's show an example of this using the `balances` dictionary from the previous section and inserting the users 'Alex' and 'Maria': ```rust {{#include ../listings/ch15-dictionaries/listing_15_02_entries.cairo:inserts}} ``` These instructions would then produce the following list of entries: | key | previous | new | | | -------- | --- | | Alex | 0 | 100 | | Maria | 0 | 50 | | Alex | 100 | 200 | | Maria | 50 | 50 | Notice that since 'Alex' was inserted twice, it appears twice and the `previous` and `current` values are set properly. Also reading from 'Maria' registered an entry with no change from previous to current values. This approach to implementing `Felt252Dict` means that for each read/write operation, there is a scan for the whole entry list in search of the last entry with the same `key`. Once the entry has been found, its `new_value` is extracted and used on the new entry to be added as the `previous_value`. This means that interacting with `Felt252Dict` has a worst-case time complexity of `O(n)` where `n` is the number of entries in the list. If you pour some thought into alternate ways of implementing `Felt252Dict` you'd surely find them, probably even ditching completely the need for a `previous_value` field, nonetheless, since Cairo is not your normal language this won't work. One of the purposes of Cairo is, with the STARK proof system, to generate proofs of computational integrity. This means that you need to verify that program execution is correct and inside the boundaries of Cairo restrictions. One of those boundary checks consists of \"dictionary squashing\" and that requires information on both previous and new values for every entry. ### Squashing Dictionaries To verify that the proof generated by a Cairo program execution that used a `Felt252Dict` is correct we need to check that there wasn't any illegal tampering with the dictionary. This is done through a method called `squash_dict` that reviews each entry of the entry list and checks that access to the dictionary remains coherent throughout the execution. The process of squashing is as follows: given all entries with certain key `k`, taken in the same order as they were inserted, verify that the ith entry `new_value` is equal to the ith + 1 entry `previous_value`. For example, given the following entry list: | key | previous | new | | | -------- | --- | | Alex | 0 | 100 | | Maria | 0 | 150 | | Charles | 0 | 70 | | Maria | 100 | 250 | | Alex | 150 | 40 | | Alex | 40 | 300 | | Maria | 250 | 190 | | Alex | 300 | 90 | After squashing, the entry list would be reduced to: | key | previous | new | | | -------- | --- | | Alex | 0 | 90 | | Maria | 0 | 190 | | Charles | 0 | 70 | In case of a change on any of the values of the first table, squashing would have failed during runtime. ### Dictionary Destruction If you run the examples from [Basic Use of Dictionaries](#basic-use-of-dictionaries) you'd notice that there was never a call to squash dictionary, but the program compiled successfully nonetheless. What happened behind the scene was that squash was called automatically via the `Felt252Dict` implementation of the `Destruct` trait. This call occurred just before the `balance` dictionary went out of scope. The `Destruct` trait represents another way of removing instances out of scope apart from `Drop`. The main difference between these two is that `Drop` is treated as a no-op operation, meaning it does not generate new CASM while `Destruct` does not have this restriction. The only type which actively uses the `Destruct` trait is `Felt252Dict`, for every other type `Destruct` and `Drop` are synonyms. You can read more about these traits in [Drop and Destruct](/appendix-03-derivable-traits.md#drop-and-destruct). In the following section, we will have a hands-on example using the `Destruct` trait. ## More Dictionaries Up to this point, we have given a comprehensive overview of the functionality of `Felt252Dict` as well as how and why it is implemented in a certain way. If you haven't understood all of it, don't worry because in this section we will have some more examples using dictionaries. We will start by explaining the `entry` method which is part of a dictionary basic functionality included in `Felt252DictTrait` which we didn't mention at the beginning. Soon after, we will see examples of how `Felt252Dict` interacts with other types such as structs and enums. ### Entry and Finalize In the [Dictionaries Underneath](#dictionaries-underneath) section, we explained how `Felt252Dict` internally worked. It was a list of entries for each time the dictionary was accessed in any manner. It would first find the last entry given a certain `key` and then update it accordingly to whatever operation it was executing. The Cairo language gives us the tools to replicate this ourselves through the `entry` and `finalize` methods. The `entry` method comes as part of `Felt252DictTrait` with the purpose of creating a new entry given a certain key. Once called, this method takes ownership of the dictionary and returns the entry to update. The method signature is as follows: ```rust fn entry(self: Felt252Dict, key: felt252) -> (Felt252DictEntry, T) nopanic ``` The first input parameter takes ownership of the dictionary while the second one is used to create the appropriate entry. It returns a tuple containing a `Felt252DictEntr`, which is the type used by Cairo to represent dictionary entries, and a `T` representing the value held previously. The next thing to do is to update the entry with the new value. For this, we use the `finalize` method which inserts the entry and returns ownership of the dictionary: ```rust fn finalize(self: Felt252DictEntry, new_value: T) -> Felt252Dict { ``` The method receives the entry and the new value as a parameter and returns the updated dictionary. Let us see an example using `entry` and `finalize`. Imagine we would like to implement the `get` method from a dictionary. We then should do the following: 1. Create the new entry to add using the `entry` method 2. Insert back the entry where the `new_value` equals the `previous_value`. 3. Return the value. Implementing our custom get would look like this: ```rust {{#include ../listings/ch15-dictionaries/listing_15_03_custom_methods.cairo:imports}} {{#include ../listings/ch15-dictionaries/listing_15_03_custom_methods.cairo:custom_get}} ``` Implementing the `insert` method would follow a similar workflow, except for the part where we insert a new value when finalizing. If were to implement it, it would look like the following: ```rust {{#include ../listings/ch15-dictionaries/listing_15_03_custom_methods.cairo:imports}} {{#include ../listings/ch15-dictionaries/listing_15_03_custom_methods.cairo:custom_insert}} ``` As a finalizing note, these two methods are implemented in a similar way to how `insert` and `get` are implemented for `Felt252Dict`. This code shows some example usage: ```rust {{#include ../listings/ch15-dictionaries/listing_15_03_custom_methods.cairo:main}} ``` ### Dictionaries of Complex Types One restriction of `Felt252Dict` that we haven't talked about is the trait `Felt252DictValue`. This trait defines the `zero_default` method which is the one that gets called when a value does not exist in the dictionary. This is implemented by all data types except for complex ones such as arrays and structs. This means that making a dictionary of complex types is not a straightforward task because you would need to write a couple of traits in order to make the data type a valid dictionary value type. To compensate for this the language introduces the `Nullable` type. `Nullable` represents the absence of value, and it is usually used in Object Oriented Programming Languages when a reference doesn't point anywhere. The difference with `Option` is that the wrapped value is stored inside a `Box` data type. The `Box` type, inspired by Rust, allows us to store recursive data types. Let's show using an example. We will try to store a `Span` inside a dictionary. For that, we will use `Nullable` and `Box`. Also, we are storing a `Span` and not an `Array` because the latter does not implement the `Copy` trait which is required for reading from a dictionary. ```rust {{#include ../listings/ch15-dictionaries/listing_15_04_dict_of_complex.cairo:imports}} {{#include ../listings/ch15-dictionaries/listing_15_04_dict_of_complex.cairo:header}} ... ``` In this code snippet, the first thing we did was to create a new dictionary `d`. We want it to hold a `Nullable`. After that, we created an array and filled it with values. The last step is inserting the array as a span inside the dictionary. Notice that we don't directly do that, but instead, we make some steps in between: 1. We wrapped the array inside a `Box` using the `new` method from `BoxTrait`. 2. We wrapped the `Box` inside a nullable using the `nullable_from_box` function. 3. Finally, we inserted the result. Once the element is inside the dictionary, and we want to get it, we follow the same steps but in reverse order. The following code shows how to achieve that: ```rust ... {{#include ../listings/ch15-dictionaries/listing_15_04_dict_of_complex.cairo:footer}} ``` Here we: 1. Read the value using `get`. 2. Verified it is non-null using the `match_nullable` function. 3. Unwrapped the value inside the box and asserted it was correct. The complete script would look like this: ```rust {{#include ../listings/ch15-dictionaries/listing_15_04_dict_of_complex.cairo:all}} ``` ### Dictionaries as Struct Members Defining dictionaries as struct members is possible in Cairo but correctly interacting with them may not be entirely seamless. Let us show an example where we implement a `UserDatabase` that allows us to add users and query them. ```rust {{#include ../listings/ch15-dictionaries/listing_15_05_dict_struct_member.cairo:struct}} {{#include ../listings/ch15-dictionaries/listing_15_05_dict_struct_member.cairo:trait}} ``` First, we define `UserDatabase`, our defined type which will represent a database of users. It will have two members: the amount of users currently inserted, and a mapping of each user to its balance. Next, we defined `UserDatabaseTrait`, the trait which will represent all the core functionality of `UserDatabase`. We now have to implement each of the methods in `UserDatabaseTrait`, but since we are working with [generic types](/src/ch07-00-generic-types-and-traits.md) we need to correctly establish the requirements of `T` so it can be a valid `Felt252Dict` value type: 1. `T` should implement the `Copy` since it's required for getting values from a `Felt252Dict`. 2. All value types of a dictionary implement the `Felt252DictValue`, our generic type should do as well. 3. To insert values, `Felt252DictTrait` requires all value types to be destructible. The implementation, with all restriction in place, would be as follow: ```rust {{#include ../listings/ch15-dictionaries/listing_15_05_dict_struct_member.cairo:imports}} {{#include ../listings/ch15-dictionaries/listing_15_05_dict_struct_member.cairo:impl}} ``` Our database implementation is almost complete, except for one thing: the compiler doesn't know how to drop a `UserDatabase` out of scope. Since it has a `Felt252Dict` as a member it cannot be dropped, so we are forced to implement the `Destruct` trait. Using `#[derive(Destruct)]` on top of the `UserDatabase` definition won't work because of the use of [genericity](/src/ch07-00-generic-types-and-traits.md). We need to code the `Destruct` trait implementation by ourselves: ```rust {{#include ../listings/ch15-dictionaries/listing_15_05_dict_struct_member.cairo:destruct}} ``` After adding the implementation we have now a fully functional `UserDatabase`: ```rust {{#include ../listings/ch15-dictionaries/listing_15_05_dict_struct_member.cairo:main}} ```"}
{"title": "ch99-00-starknet-smart-contracts.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Starknet Smart Contracts All through the previous sections, you've mostly written programs with a `main` entrypoint. In the coming sections, you will learn to write and deploy Starknet contracts. Starknet contracts, in simple words, are programs that can run on the Starknet VM. Since they run on the VM, they have access to Starknet\u2019s persistent state, can alter or modify variables in Starknet\u2019s states, communicate with other contracts, and interact seamlessly with the underlying L1. Starknet contracts are denoted by the `#[contract]` attribute. We'll dive deeper into this in the next sections. If you want to learn more about the Starknet network itself, its architecture and the tooling available, you should read the [Starknet Book]( This section will focus on writing smart contracts in Cairo."}
{"title": "ch99-01-01-introduction-to-smart-contracts.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Introduction to smart-contracts This chapter will give you a high level introduction to what smart-contracts are, what are they used for and why would blockchain developers use Cairo and Starknet. If you are already familiar with blockchain programming, feel free to skip this chapter. The last part might still be interesting though. ## Smart-contracts Smart contracts gained popularity and became more widespread with the birth of Ethereum. Smart contracts are essentially programs deployed on a blockchain. The term \"smart contract\" is somewhat misleading, as they are neither \"smart\" nor \"contracts\" but rather code and instructions that are executed based on specific inputs. They primarily consist of two components: storage and functions. Once deployed, users can interact with smart contracts by initiating blockchain transactions containing execution data (which function to call and with what input). Smart contracts can modify and read the storage of the underlying blockchain. A smart contract has its own address and is considered a blockchain account, meaning it can hold tokens. The programming language used to write smart contracts varies depending on the blockchain. For example, on Ethereum and the [EVM-compatible ecosystem]( the most commonly used language is Solidity, while on Starknet, it is Cairo. The way the code is compiled also differs based on the blockchain. On Ethereum, Solidity is compiled into bytecode. On Starknet, Cairo is compiled into Sierra and then into Cairo Assembly (casm). Smart contracts possess several unique characteristics. They are **permissionless**, meaning anyone can deploy a smart contract on the network (within the context of a decentralized blockchain, of course). Smart contracts are also **transparent**; the data stored by the smart contract is accessible to anyone. The code that composes the contract can also be transparent, enabling **composability**. This allows developers to write smart contracts that use other smart contracts. Smart contracts can only access and interact with data from the blockchain they are deployed on. They require third-party softwares (called `oracles`) to access external data (the price of a token for instance). For developers to build smart contracts that can interact with each other, it is required to know what the other contracts look like. Hence, Ethereum developers started to build standards for smart contract development, the `ERCxx`. The two most used and famous standards are the `ERC20`, used to build tokens like `USDC`, `DAI` or `STARK`, and the `ERC721`, for NFTs (Non-fungible tokens) like `CryptoPunks` or `Everai`. ## Use cases There are many possible use cases for smart-contracts. The only limits are the technical constraints of the blockchain and the creativity of developers. #### DeFi Right now, the principal use case for smart contracts is similar to that of Ethereum or Bitcoin, which is essentially handling money. In the context of the alternative payment system promised by Bitcoin, smart contracts on Ethereum enable the creation of decentralized financial applications that no longer rely on traditional financial intermediaries. This is what we call DeFi (decentralized finance). DeFi consists of various projects such as lending/borrowing apps, decentralized exchanges (DEX), on-chain derivatives, stablecoins, decentralized hedge funds, insurance, and many more. #### Tokenization Smart contracts can facilitate the tokenization of real-world assets, such as real estate, art, or precious metals. Tokenization divides an asset into digital tokens, which can be easily traded and managed on blockchain platforms. This can increase liquidity, enable fractional ownership, and simplify the buying and selling process. #### Voting Smart contracts can be used to create secure and transparent voting systems. Votes can be recorded on the blockchain, ensuring immutability and transparency. The smart contract can then automatically tally the votes and declare the results, minimizing the potential for fraud or manipulation. #### Royalties Smart contracts can automate royalty payments for artists, musicians, and other content creators. When a piece of content is consumed or sold, the smart contract can automatically calculate and distribute the royalties to the rightful owners, ensuring fair compensation and reducing the need for intermediaries. #### Decentralized identities DIDs Smart contracts can be used to create and manage digital identities, allowing individuals to control their personal information and share it with third parties securely. The smart contract could verify the authenticity of a user's identity and automatically grant or revoke access to specific services based on the user's credentials. As Ethereum continues to mature, we can expect the use cases and applications of smart contracts to expand further, bringing about exciting new opportunities and reshaping traditional systems for the better. ## The rise of Starknet and Cairo Ethereum, being the most widely used and resilient smart-contract platform, became a victim of its own success. With the rapid adoption of some previously mentioned use cases, mainly DeFi, the cost of performing transactions became extremely high, rendering the network almost unusable. Engineers and researchers in the ecosystem began working on solutions to address this scalability issue. A famous theorem in the blockchain space states that it is impossible to achieve a high level of scalability, decentralization, and security simultaneously; trade-offs must be made. Ethereum is at the intersection of decentralization and security. Eventually, it was decided that Ethereum's purpose would be to serve as a secure settlement layer, while complex computations would be offloaded to other networks built on top of Ethereum. These are called Layer 2s (L2s). The two primary types of L2s are optimistic rollups and validity rollups. Both approaches involve compressing and batching numerous transactions together, computing the new state, and settling the result on Ethereum (L1). The difference lies in the way the result is settled on L1. For optimistic rollups, the new state is considered valid by default, but there is a 7-day window for nodes to identify malicious transactions. In contrast, validity rollups, such as Starknet, use cryptography to prove that the new state has been correctly computed. This is the purpose of STARKs, this cryptographic technology could permit validity rollups to scale significantly more than optimistic rollups. You can learn more about STARKs from Starkware's Medium [article]( which serves as a good primer. Remember Cairo? It is, in fact, a language developed specifically to work with STARKs and make them general-purpose. With Cairo, we can write **provable code**. In the context of Starknet, this allows proving the correctness of computations from one state to another. Unlike most (if not all) of Starknet's competitors that chose to use the EVM (either as-is or adapted) as a base layer, Starknet employs its own VM. This frees developers from the constraints of the EVM, opening up a broader range of possibilities. Coupled with decreased transaction costs, the combination of Starknet and Cairo creates an exciting playground for developers. Native account abstraction enables more complex logic for accounts and transaction flows. Emerging use cases include **transparent AI** and artificial intelligence and machine learning applications. Finally, **blockchain games** can be developed entirely **on-chain**. Starknet has been specifically designed to maximize the capabilities of STARK proofs for optimal scalability."}
{"title": "ch99-01-02-writing-starknet-contracts.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Writing Starknet Contracts This chapter will guide you on how to create smart contracts in Cairo, and will clarify the distinction between Cairo programs and Starknet contracts. ## Cairo programs and Starknet contracts Starknet contracts are a special subset of Cairo programs, so the concepts previously learned in this book are still applicable to write Starknet contracts. As you may have already noticed, a Cairo program must always have a function `main` that serves as the entry point for this program: ```rust fn main() {} ``` Starknet contracts are essentially programs that can run on the Starknet OS, and as such, have access to Starknet's state. For a module to be handled as a contract by the compiler, it must be annotated with the `#[contract]` attribute: ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_03_example_contract.cairo:all}} ``` Listing 99-1: A simple naming service contract > Note: Starknet contracts are defined within [modules](./ch06-02-defining-modules-to-control-scope.md). ## Starknet Contract Attributes Attributes are special annotations that modify the behavior of certain functions or methods. They are placed preceding a function and are denoted by the `#[]` symbol. Here is a list of common attributes used in Starknet contracts: 1. `#[contract]`: This attribute is used to annotate a module to be compiled as a Starknet contract. The compiler recognizes this attribute and prepares the module with necessary contract elements, such as the logic to handle external contract calls or how to access storage variables. 2. `#[constructor]`: This attribute marks a function as a constructor. The constructor function is called only once upon deploying a contract, setting the initial state of the contract. 3. `#[external]`: This attribute marks a function as an external function. External functions can be called by other contracts or externally and can modify the contract's state. 4. `#[view]`: This attribute marks a function as a view function. View functions are read-only functions that allow you to access data from the contract, but prevent you from modifying the state of the blockchain. 5. `#[event]`: This is used to define events that can be emitted by the contract. 6. `#[l1_handler]`: This attribute is used to mark functions which can receive messages from L1s. ## Storage Variables Storage variables allow you to store data that will be stored on the blockchain in the contract's storage. These data are persistent and can be accessed and modified anytime once the contract is deployed. Storage variables in Starknet contracts are stored in a special struct called `Storage`: ```rust {{#rustdoc_include ../listings/ch99-starknet-smart-contracts/listing_99_02.cairo:here}} ``` Listing 99-2: A Storage Struct The storage struct is a [struct](./ch04-00-using-structs-to-structure-related-data.md) like any other, except that it allows you to define mappings using the `LegacyMap` type. ### Storage Mappings Mappings are a key-value data structure that you can use to store data within a smart contract. They are essentially hash tables that allow you to associate a unique key with a corresponding value. Mappings are also useful to store sets of data, as it's impossible to store arrays in storage. A mapping is a variable of type LegacyMap, in which the key and value types are specified within angular brackets . It is important to note that the `LegacyMap` type can only be used inside the `Storage` struct, and can't be used to define mappings in user-defined structs. The syntax for declaring a mapping is as follows in Listing 99-2. You can also create more complex mappings than that found in Listing 99-2 like the popular `allowances` storage variable in the ERC20 Standard which maps the `owner` and `spender` to the `allowance` using tuples: ```rust {{#include ../listings/ch99-starknet-smart-contracts/no_listing_01_storage_mapping.cairo:here}} ``` In mappings, the address of the value at key `k_1,...,k_n` is `h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)` where \u210e is the Pedersen hash and the final value is taken `mod2251\u2212256`. You can learn more about the contract storage layout in the [Starknet Documentation]( ### Reading from Storage To read the value of the storage variable `names`, we call the `read` function on the `names` storage variable, passing in the key `_address` as a parameter. ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_03_example_contract.cairo:read}} ``` Listing 99-3: Calling the `read` function on the `names` variable > Note: When the storage variable does not store a mapping, its value is accessed without passing any parameters to the read method ### Writing to Storage To write a value to the storage variable `names`, we call the `write` function on the `names` storage variable, passing in the key and values as arguments. ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_03_example_contract.cairo:write}} ``` Listing 99-4: Writing to the `names` variable ## Functions In this section, we are going to be looking at some popular function types you'd encounter with most contracts: ### 1. Constructors Constructors are a special type of function that runs only once when deploying a contract, and can be used to initialize the state of the contract. ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_03_example_contract.cairo:constructor}} ``` Some important rules to note: 1. Your contract can't have more than one constructor. 2. Your constructor function must be named `constructor`. 3. Lastly, it must be annotated with the `#[constructor]` attribute. ### 2. External functions External functions are functions that can modify the state of a contract. They are public and can be called by any other contract or externally. You can define external functions by annotating them with the `#[external]` attribute: ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_03_example_contract.cairo:external}} ``` ### 3. View functions View functions are read-only functions allowing you to access data from the contract while ensuring that the state of the contract is not modified. They can be called by other contracts or externally. You can define view functions by annotating them with the `#[view]` attribute: ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_03_example_contract.cairo:view}} ``` > **Note:** It's important to note that, both external and view functions are public. To create an internal function in a contract, you simply don't annotate it with any attribute. ## Events Events are custom data structures that are emitted by smart contracts during execution. They provide a way for smart contracts to communicate with the external world by logging information about specific occurrences in a contract. Events play a crucial role in the creation of smart contracts. Take, for instance, the Non-Fungible Tokens (NFTs) minted on Starknet. All of these are indexed and stored in a database, then displayed to users through the use of these events. Neglecting to include an event within your NFT contract could lead to a bad user experience. This is because users may not see their NFTs appear in their wallets (wallets use these indexers to display a user's NFTs). ### Defining events An event is defined as an empty function annotated with the `#[event]` attribute. The parameters of this function are the data that will be emitted by the event. In Listing 99-1, `StoredName` is an event that emits information when names are stored in the contract: ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_03_example_contract.cairo:event}} ``` We pass in the emitted data types as parameters within the parentheses. In this example, our event will emit the contract address of the caller and the name stored within the contract. ### Emitting events After defining events, we can emit them by simply calling the event name like we'll call functions, passing in the values to be emitted as parameters: ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_03_example_contract.cairo:emit_event}} ```"}
{"title": "ch99-02-00-abis-and-cross-contract-interactions.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Starknet contracts: ABIs and cross-contract interactions The ability of contracts to interact with other smart contracts on the blockchain is a common pattern found in smart contract development. This chapter covers how cross-contract interactions between Starknet contracts can be achieved. Specifically, you'll learn about ABIs, contract interfaces, the contract and library dispatchers and their low-level system call equivalents!"}
{"title": "ch99-02-01-abis-and-interfaces.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# ABIs and Contract Interfaces Cross-contract interactions between smart contracts on a blockchain is a common practice which enables us to build flexible contracts that can speak with each other. Achieving this on Starknet requires something we call an interface. ## Interface An interface is a list of a contract's function definitions without implementations. In other words, an interface specifies the function declarations (name, parameters, visibility and return value) contained in a smart contract without including the function body. Interfaces in Cairo are traits with the `#[abi]` attribute. If you are new to traits, check out the dedicated chapter on [traits](./ch07-02-traits-in-cairo.md). For your Cairo code to qualify as an interface, it must meet the following requirements: 1. Must be appended with the `#[abi]` attribute. 2. Your interface functions should have no implementations. 3. You must explicitly declare the function's decorator. 4. Your interface should not declare a constructor. 5. Your interface should not declare state variables. Here's a sample interface for an ERC20 token contract: ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_04_interface.cairo}} ``` Listing 99-4: A simple ERC20 Interface ## ABIs ABI stands for Application Binary Interface. ABIs gives a smart contract the ability to communicate and interact with external applications or other smart contracts. ABIs can be likened to APIs in traditional web development, which helps data flow between applications and servers. While we write our smart contract logics in high-level Cairo, they are stored on the VM as executable bytecodes which are in binary formats. Since this bytecode is not human readable, it requires interpretation to be understood. This is where ABIs come into play, defining specific methods which can be called to a smart contract for execution. Every contract on Starknet has an Application Binary Interface (ABI) that defines how to encode and decode data when calling its methods. In the next chapter, we are going to be looking into how we can call other smart contracts using a `Contract Dispatcher`, `Library Dispatcher`, and `System calls`."}
{"title": "ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Contract Dispatcher, Library Dispatcher and System calls Each time a contract interface is created on Starknet, two dispatchers are automatically created and exported: 1. The Contract Dispatcher 2. The Library Dispatcher In this chapter, we are going to extensively discuss how these dispatchers work and their usage. To effectively break down the concepts in this chapter, we are going to be using the IERC20 interface from the previous chapter (refer to Listing 99-4): ## Contract Dispatcher Traits annotated with the `#[abi]` attribute are programmed to automatically generate and export the relevant dispatcher logic on compilation. The compiler also generates a new trait, two new structs (one for contract calls, and the other for library calls) and their implementation of this trait. Our interface is expanded into something like this: **Note:** The expanded code for our IERC20 interface is a lot longer, but to keep this chapter concise and straight to the point, we focused on one view function `get_name`, and one external function `transfer`. ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_05_dispatcher_trait.cairo}} ``` Listing 99-5: An expanded form of the IERC20 trait It's also worthy of note that all these are abstracted behind the scenes thanks to the power of Cairo plugins. ### Calling Contracts using the Contract Dispatcher This is an example of a contract named `Dispatcher` using the Contract interface dispatcher to call an ERC-20 contract in the ERC-20 contract's context and, in the case of `transfer_token`, altering the state of the ERC-20 contract: ```rust {{#rustdoc_include ../listings/ch99-starknet-smart-contracts/listing_99_06_sample_contract.cairo:here}} ``` Listing 99-6: A sample contract which uses the Contract Dispatcher As you can see, we had to first import the `IERC20DispatcherTrait` and `IERC20Dispatcher` which was generated and exported on compiling our interface, then we make calls to the methods implemented for the `IERC20Dispatcher` struct (`name`, `transfer`, etc), passing in the `contract_address` parameter which represents the address of the contract we want to call. ## Library Dispatcher The key difference between the contract dispatcher and the library dispatcher is that while the contract dispatcher calls an external contract's logic in the external contract's context, the library dispatcher calls the target contract's classhash, whilst executing the call in the calling contract's context. So unlike the contract dispatcher, calls made using the library dispatcher have no possibility of tampering with the target contract's state. As stated in the previous chapter, contracts annotated with the `#[abi]` macro on compilation generates a new trait, two new structs (one for contract calls, and the other for library calls) and their implementation of this trait. The expanded form of the library traits looks like: ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_07_library_dispatcher.cairo}} ``` Listing 99-7: An expanded form of the IERC20 trait ### Calling Contracts using the Library Dispatcher Below's a sample code on calling contracts using the Library Dispatcher: ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_08_using_library_dispatcher.cairo:here}} ``` Listing 99-8: A sample contract using the Library Dispatcher As you can see, we had to first import the `IERC20DispatcherTrait` and `IERC20LibraryDispatcher` which was generated and exported on compiling our interface, then we make calls to the methods implemented for the `IERC20LibraryDispatcher` struct (`name`, `transfer`, etc), passing in the `class_hash` parameter which represents the class of the contract we want to call. ## Calling Contracts using low-level System calls Another way to call other contracts is to use the `starknet::call_contract_syscall` system call. The Dispatchers we described in the previous sections are high-level syntaxes for this low-level system call. Using the system call `starknet::call_contract_syscall` can be handy for customized error handling or possessing more control over the serialization/deserialization of the call data and the returned data. Here's an example demonstrating a low-level `transfer` call: ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_09_call_contract_syscall.cairo}} ``` Listing 99-9: A sample contract implementing system calls As you can see, rather than pass our function arguments directly, we passed in the contract address, function selector (which is a keccak hash of the function name), and the calldata (function arguments). At the end, we get returned a serialized value which we'll need to deserialize ourselves!"}
{"title": "ch99-03-security-considerations.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# Security Considerations When developing software, ensuring it functions as intended is usually straightforward. However, preventing unintended usage and vulnerabilities can be more challenging. In smart contract development, security is very important. A single error can result in the loss of valuable assets or the improper functioning of certain features. Smart contracts are executed in a public environment where anyone can examine the code and interact with it. Any errors or vulnerabilities in the code can be exploited by malicious actors. This chapter presents general recommendations for writing secure smart contracts. By incorporating these concepts during development, you can create robust and reliable smart contracts. This reduces the chances of unexpected behavior or vulnerabilities. ## Disclaimer This chapter does not provide an exhaustive list of all possible security issues, and it does not guarantee that your contracts will be completely secure. If you are developing smart contracts for production use, it is highly recommended to conduct external audits performed by security experts. ## Mindset Cairo is a highly safe language inspired by rust. It is designed in a way that force you to cover all possible cases. Security issues on Starknet mostly arise from the way smart contracts flows are designed, not much from the language itself. Adopting a security mindset is the initial step in writing secure smart contracts. Try to always consider all possible scenarios when writing code. ### Viewing smart contract as Finite State Machines Transactions in smart contracts are atomic, meaning they either succeed or fail without making any changes. Think of smart contracts as state machines: they have a set of initial states defined by the constructor constraints, and external function represents a set of possible state transitions. A transaction is nothing more than a state transition. The `assert` or `panic` functions can be used to validate conditions before performing specific actions. You can learn more about these on the [Unrecoverable Errors with panic](./ch09-01-unrecoverable-errors-with-panic.md) page. These validations can include: - Inputs provided by the caller - Execution requirements - Invariants (conditions that must always be true) - Return values from other function calls For example, you could use the `assert` function to validate that a user has enough funds to perform a withdraw transaction. If the condition is not met, the transaction will fail and the state of the contract will not change. ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_10_assert_balance.cairo:withdraw}} ``` Using these functions to check conditions adds constraints that help clearly define the boundaries of possible state transitions for each function in your smart contract. These checks ensure that the behavior of the contract stays within the expected limits. ## Recommendations ### Checks Effects Interactions Pattern The Checks Effects Interactions pattern is a common design pattern used to prevent reentrancy attacks on Ethereum. While reentrancy is harder to achieve in Starknet, it is still recommended to use this pattern in your smart contracts. The pattern consists of following a specific order of operations in your functions: 1. **Checks**: Validate all conditions and inputs before performing any state changes. 2. **Effects**: Perform all state changes. 3. **Interactions**: All external calls to other contracts should be made at the end of the function. ### Access control Access control is the process of restricting access to certain features or resources. It is a common security mechanism used to prevent unauthorized access to sensitive information or actions. In smart contracts, some functions may often be restricted to specific users or roles. You can implement the access control pattern to easily manage permissions. This pattern consists of defining a set of roles and assigning them to specific users. Each function can then be restricted to specific roles. ```rust {{#include ../listings/ch99-starknet-smart-contracts/listing_99_11_simple_access_control.cairo}} ``` ### Static analysis tool Static analysis refers to the process of examining code without its execution, focusing on its structure, syntax, and properties. It involves analyzing the source code to identify potential issues, vulnerabilities, or violations of specified rules. By defining rules, such as coding conventions or security guidelines, developers can utilize static analysis tools to automatically check the code against these standards. Reference: - [Semgrep Cairo 1.0 support]("}
{"title": "title-page.md", "repo_owner": "cairo-book", "repo_name": "cairo-book.github.io", "text": "# The Cairo Programming Language by the Cairo Community and its [contributors]( Special thanks to [Starkware]( through [OnlyDust]( and [Voyager]( for supporting the creation of this book. This version of the text assumes you\u2019re using Cairo v2.0.0. See the \u201cInstallation\u201d section of Chapter 1 to install or update Cairo."}
{"title": "index.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "= Welcome to The Starknet Book The Starknet Book ==== IMPORTANT: The Starknet Book is a work in progress, and its content is rapidly evolving as the community contributes to its development. As a result, some sections may be incomplete or contain information that is still green. We highly encourage readers to contribute by suggesting improvements, providing feedback, or submitting new content to help us expand and refine the book. Your contributions are invaluable in making The Starknet Book a comprehensive and reliable resource for the community. ==== The Starknet Book is a curriculum created to teach the Cairo programming language and Starknet development. It is divided by Chapters and built by the Starknet community (you!). Finish the resume and you will conquer the Ethereum world. == Contents [.chapter-titles] |=== |Chapter | Objective |1: Introduction to Starknet | Grasp Starknet's basics and get introduced to deploying smart contracts. |2: Smart Contracts in Cairo | Write Cairo smart contracts suited for Starknet. |3: Starknet Tooling | Learn to work with tools such as Protostar or Hardhat, and languages like Javascript, Python, Rust for interacting with Starknet. |4: Starknet Architecture | Discover the inner workings of Starknet, including the transaction lifecycle and the interaction of Sequencer, Prover, and Nodes. |5: Account Abstraction | Understand the concept of user accounts in Starknet and the process of creating custom accounts. |6: Pioneering Applications | Delve into cutting-edge applications on Starknet like On-Chain AI and Storage Proofs. |7: Cairo CPU Architecture | Deep dive into the architecture of the Cairo virtual machine, its memory model, opcodes, and compiler. |8: STARKs | Understand STARKs and their integration into various aspects of Starknet. |=== == Where to Start? Depending on your goals and interests, you can choose different paths through the Starknet Book. Here are some recommendations based on various objectives: * If you're a *complete beginner* and want to start learning about Cairo and Starknet from scratch, follow the book in its entirety, starting with *Introduction to Starknet*. * If you're an *experienced developer* looking to quickly dive into writing scalable and decentralized smart contracts, focus on *Smart Contracts in Cairo and Starknet Tooling*. * If you're a *frontend developer* wanting to integrate Starknet with a React frontend using Javascript, prioritize the *starknet-js* and *starknet-react* subchapters in *Starknet Tooling* * If you're a *DevOps engineer* or *node operator* interested in running a Starknet node and indexer, head straight to *Starknet Architecture*. * If you're a *security researcher* or *smart contract auditor* wanting to learn about the Account Abstraction feature and its implications, go for *Account Abstraction*. * If you're a *blockchain enthusiast* curious about the underlying architecture and mechanics of Starknet and Cairo, explore *Starknet and Cairo CPU Arquitecture*. * If you're a *cryptography expert* or *researcher* eager to understand the fundamentals of STARKs and their connection to the Starknet ecosystem, delve into *STARKs*. Feel free to mix and match these paths based on your unique interests and requirements. == Your Contributions Matter We're thrilled to have you join us on this incredible journey to create the ultimate resource for Cairo and Starknet development. By contributing to the Starknet Book, you're not only sharing your knowledge and expertise with the world, but you're also helping shape the future of decentralized technology. Together, we'll build a comprehensive, accessible, and engaging curriculum that will empower developers everywhere to harness the full potential of Starknet. As a contributor, you'll be part of a vibrant and growing community dedicated to pushing the boundaries of what's possible with decentralized technology. You'll have the opportunity to collaborate with like-minded individuals from around the globe, share your unique insights, and learn from one another. Your contributions will not only enrich the Starknet community but also leave a lasting impact on the broader field of blockchain technology. So, are you ready to embark on this epic adventure? Let's dive in and explore the vast and exciting world of Starknet together. Here's to the countless discoveries, breakthroughs, and innovations that await us! Please refer to the existing Guide] for detailed instructions on how to contribute. Remember, every contribution, no matter how small, makes a difference. Your expertise and passion are invaluable in helping us create a truly exceptional resource for the Starknet community. Let's make history together! Here are things you can do to help: * In most sections there is a message for builders who want to collaborate with content. * Empty section in a Chapter? Go for it! * Do you think the Starknet Book needs an additional section? Propose it. * Can a section be improved? Feel free to modify it. * Do you want to add an alternative programming language for the examples? Yes please. * Correct the bugs if you find any. * Please add an explanation in the exercise comments if you feel they need them. * Add exercises that show your favorite feature of Cairo. == Additional Key Educational Resources We've compiled a list of valuable educational resources that will help deepen your understanding and enhance your skills in coding with Cairo and staying abreast with Starknet developments: 1. **Starklings**: A resource specifically designed to guide you through learning Cairo programming, ensuring that you reach a proficient level. You can access it 2. **Starknet Community Forum**: An online platform where you can engage in discussions about the latest developments in Starknet. Join the conversation 3. **Starknet Documentation**: You can browse through the documentation 4. **Cairo Documentation**: Explore it 5. **Starknet Developer Telegram (English)**: A community for English-speaking Starknet developers. This is a great platform for networking, sharing ideas, and troubleshooting together. Join us on Telegram == Starknet Book Authors We extend our sincere gratitude to these exceptional individuals who have made invaluable contributions to the Starknet Book: [cols=\"5*\"] |=== a| image:: link=\" Omar Espejel + a| image:: link=\" James Stark + a| image:: link=\" Dr Spaceman + a| image:: link=\" Gyan + a| image:: link=\" Henri + a| image:: link=\" David Barreto + a| image:: link=\" Remedcu + a| image:: link=\" Omahs + a| image:: link=\" Lucas @ Starkware + a| image:: link=\" Qd-Qd + a| image:: link=\" Oboulant + a| image:: link=\" Code Whizperer + a| image:: link=\" Avi Mak + a| image:: link=\" Robert Kodra + a| image:: link=\" Manmit Singh + a| image:: link=\" Lvis Wang + a| image:: link=\" Leablock + a| image:: link=\" Carlos Lira + a| image:: link=\" Artur Vargas + a| image:: link=\" Lorcan-codes + a| image:: link=\" Devnet0x + a| image:: link=\" Ivan Pavi\u010di\u0107 + a| image:: link=\" Raphael Ndonga + a| image:: link=\" Asten + a| image:: link=\" Trangnv + a| image:: link=\" 0xKubitus + a| image:: link=\" Evolve Art + a| image:: link=\" Nadai + a| image:: link=\" Prince Anuragi + a| image:: link=\" Ccolorado + a| image:: link=\" Diego Hermida + a| image:: link=\" 0x180db + a| image:: link=\" Shramee Srivastav + a| image:: link=\" Santala + a| image:: link=\" Satyam Bansal + a| image:: link=\" Z\u00e9 Diogo + a| image:: link=\" Pikkuherkko + a| image:: link=\" Davide Silva + a| image:: link=\" Leapalazzolo + a| image:: link=\" Keivin + a| image:: link=\" lambda-0x + a| image:: link=\" David Lange a| image:: link=\" 0xlenny a| image:: link=\" razlandau a| image:: link=\" neelkamath a| image:: link=\" Mohamed Abdessamed a| a| a| a| a| |==="}
{"title": "compute_costs.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "= Lower computation costs with Starknet == The Problem: High Compute Costs in Blockchains Blockchains, despite their revolutionary implications, have been hitherto limited by high computational costs, translating to expensive transaction fees for users. This challenge becomes especially pronounced during peak network activities when congestion leads to sky-high gas prices. In 2021 and during the 'Pepe season' in May 2023, gas prices on Ethereum could soar up to 200 Gwei or more, making even a simple transaction, such as transferring 10 USDC, exorbitantly expensive. High computation costs do not just inconvenience users but also restrain the full potential of blockchain applications. The impacts of these costs are far-reaching and include: * Regular Transactions: The dream of using crypto for daily transactions remains largely unfulfilled, primarily due to prohibitive transaction fees. For instance, no user wants to pay a transaction fee of $1 for a $2 cup of coffee. * Oracles: Oracles, which fetch off-chain data for blockchains, cannot refresh data as frequently due to expensive transaction costs, leading to stale and inaccurate data on-chain. * Governance: On-chain governance, a transparent, decentralized decision-making method, is affected as users are dissuaded from voting due to high costs, leading to lower participation and less effective governance. * Gaming: The potential of truly decentralized gaming is limited as high computation costs restrict on-chain components in games. == The Solution: Starknet's Approach to Lower Computation Costs Starknet, as a pioneering Layer 2 solution, addresses these problems head-on. By dramatically reducing the computation costs, Starknet makes blockchain applications more accessible and efficient, thereby unlocking their true potential. === Leveraging Affordable Transactions and Account Abstraction The advent of affordable transactions and account abstraction paves the way for more commonplace, day-to-day usage of blockchain technologies. This transformation breaks down into several critical elements: 1. **Microtransactions**: The reduced cost of transactions on Starknet allows for the feasibility of small transactions, or microtransactions. These are transactions of a very small value, such as buying a cup of coffee, which would have been prohibitively expensive with higher transaction fees. Now, such transactions only cost you a couple of cents or even a fraction of a cent. 2. **Familiar Wallet Experience**: Account abstraction allows your crypto wallet to function similarly to a traditional wallet, bringing a sense of familiarity to users. Key points include: * Users can store the majority of their assets in a highly secure wallet, akin to a savings account in traditional banking. * This wallet can incorporate multiple layers of security. For instance, it may require a trusted individual to co-sign large transfers, or use a unique private key for access. * This ensures that users' assets are well protected, enhancing the overall user experience and fostering trust in the system. By bridging the gap between traditional financial systems and blockchain technology, affordable transactions and account abstraction are set to usher in a new era of daily, practical blockchain usage. === Revolutionizing Data Feeds with Affordable On-Chain Computation The advent of economical on-chain computation has the potential to significantly transform the functionality of oracles in the blockchain ecosystem: 1. **Frequent Updates**: With lower transaction costs, oracles can now afford to update their data feeds more frequently. This offers the promise of: * Higher accuracy in the data feeds, thereby enabling users to build more sophisticated market structures based on this data, including intricate options protocols and prediction markets. 2. **Efficient State Commitments**: As Starknet operates as a rollup, it must periodically send a commitment to the Ethereum mainnet to update the state of the rollup. However, rollups only need to commit the most recent state to Layer 1, meaning: * If the same storage slot is overwritten multiple times in a single block, it doesn't result in high storage costs. * For instance, in the case of oracles, if a variable (such as the price of an asset) is updated frequently within the same commitment, the Layer 1 cost would be equivalent to a single write, as only the final state is published to the mainnet as calldata. 3. **Computational Feeds**: The lower cost of execution also opens the door for computational feeds, which are feeds of aggregated and calculated data. * Traditional financial applications often rely on sophisticated data feeds that provide information on risk, yield, and volatility. * Teams like Pragma are dedicated to bringing these types of feeds to the web3 space. Currently, Pragma has already launched two computational feeds on the Starknet testnet, including a volatility index and a yield curve. 4. **Storage Proofs**: In the realm of oracles, storage proofs promise to revolutionize how data is handled and verified. These cryptographic measures help to maintain an accurate record of storage. * With these cryptographic commitments, it is possible to trustlessly prove that a particular state existed at a specific time or block. * While these proofs require some computation to verify, the low computational cost greatly enhances user experience. * Storage proofs not only allow for the transfer of information between different chains in a decentralized manner but also offer access to historical data from the blockchain and much more. * For a deeper dive into storage proofs, be sure to check out our article]. === Realization of On-Chain Gaming Gaming is a mammoth industry, with the largest gaming market, the United States, generating a staggering 54 billion USD annually in revenue. Recently, blockchain games have garnered significant attention, yet many fall short of being fully realized web3 experiences, existing instead within a liminal \"web2.5\" space. For a game to earn the title of a \"blockchain game\", it must satisfy certain criteria: 1. The game's logic should be entirely on-chain. 2. The game should remain functional, even if the developers were to suddenly disappear. The litmus test for the second criterion is reminiscent of the independence smart contracts possess. Much like how a smart contract lives autonomously on-chain, a true web3 game should also endure regardless of the activity of its creators. This means the foundational mechanics and rules of the game are embedded on-chain, allowing different interfaces to be constructed atop the unalterable game logic. To facilitate the creation of games that meet these benchmarks, developers are motivated through the issuance of game-specific tokens. While no major game currently exists fully on-chain, several projects on Starknet are progressing in the right direction. Notable among these are Realms and Influence. Supporting this transformative shift in game development is Dojo, an ecosystem developer providing an open-source Entity-Component-System (ECS) framework for the Starknet ecosystem. In the game development sphere, the ECS is a time-honored design pattern, crucial for constructing games in a modular fashion. To illustrate, let's take a popular game like Mario Kart as an example. In ECS parlance, \"Mario\" and \"his car\" would be referred to as entities. The position and velocity of the car would be considered components, and the logic that determines the outcomes of car collisions would be implemented as a System. Game developers would then use these components to create their games. As the Starknet ecosystem expands, the requirement for projects like Dojo will increase. With more game developers entering the Starknet landscape, foundational tools like ECS frameworks will be instrumental in establishing a new era of web3 games that marry the thrill of gaming with the decentralized ethos of blockchain. === Paving the Way for Transparent AI Applications The ever-evolving landscape of artificial intelligence (AI) signals that AI integration into our digital existence is imminent. Although it's not yet a certainty that AI models will be placed on-chain, there are compelling reasons why this could be advantageous. Cheap computation is an essential requirement for these potential use cases: 1. **Verifiable Inference**: This concept relies on models being pre-trained on centralized servers. However, the benefits include: * Once training is completed, the model weights could be published on-chain. * Inputs could then be passed to the model on-chain, with the outputs providing a transparent and verifiable outcome. Users have proof that the model generated a specific output. 2. **On-Chain Model Ensembles**: If computation becomes cheap enough, it becomes feasible to run models on-chain to generate outputs. The benefits of this approach include: * Outputs from multiple models could be aggregated on-chain to form an \"ensemble\" model. This approach is commonly used in machine learning (ML) applications to improve accuracy and predictive performance. 3. **Verifiable Training**: This means that models could potentially be trained on-chain, offering verifiable proof of benign training without introducing external biases. However, this is the most computationally intensive application and the least likely to be implemented soon due to: * Current large AI/ML models take days (or even years) to train on GPUs with significant resources. * Generating zk-SNARK proofs for the computation done during training would add additional overhead. * Cairo, the language used for Starknet smart contracts, is designed to run on CPUs, which are considerably slower than GPUs. Research teams such as Giza and Modulus Labs are leading the way in exploring the potential of bringing AI on-chain using zero-knowledge (ZK) proofs. == Conclusion In essence, Starknet's groundbreaking approach to reducing computation costs has wide-ranging implications for the blockchain ecosystem. This chapter mainly focused on its impact on transaction costs and usability improvements for blockchain applications. However, Starknet's relevance does not end here. In the next chapter, we will explore Starknet's approach to data security, its evolution, and how it furthers the blockchain revolution."}
{"title": "README.md", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "Bitcoin ### [Proof of Work](./proof_of_work) In `GO`: ```bash cd proof_of_work/go go run main.go ``` In `Python`: ```bash # proof of work example cd proof_of_work/python python main.py ``` ### [Block Verification](./block_verification) In `GO`: Run verify benchmark ```bash cd block_verification/go/ GO111MODULE=off go test ./... -bench=. -count 5 ``` In `Rust`: ```bash cd block_verification/rust/ cargo run # or run the tests with cargo test ``` In `Elixir`: ```bash cd block_verification/elixir/ elixir bitcoin_validator.exs ``` #### Sources - - - --- upper_tags: [protocol, peer_to_peer, network, ledger, database, cryptocurrency] lower_tags: [merkle_tree, transaction, node, client, miner, block, hash, secure_hashing_algorithm_256, application_specific_integrated_circuit, timestamp, consensus, proof_of_work, unspent_transaction_output]"}
{"title": "compatibility.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "= Starknet CLI and Cairo Compiler Versions The Starknet Command Line Interface (CLI), known as `cairo-lang` (named after the GitHub repository), and the Cairo compiler are integral tools in the Starknet ecosystem. To ensure they function optimally and take advantage of the latest features, it's essential to periodically check their versions and update them if needed. This section guides you through these tasks. == Checking Versions To check the version of your installed Starknet CLI, execute the following command in your terminal: [source,bash] ---- starknet --version ---- Similarly, to check the version of the Cairo compiler you're currently using, run: [source,bash] ---- cairo-compile --version ---- If you want to compile using Scarb, you can check the version of Scarb with: [source,bash] ---- scarb --version ---- Finally, to check the version of Protostar, run: [source,bash] ---- protostar --version ---- == Upgrading to the Latest Versions To upgrade your Starknet CLI to the latest version, use the `pip install` command with the `--upgrade` flag: [source, bash] ---- pip install cairo-lang --upgrade ---- For updating the Cairo compiler, first navigate to your Cairo cloned repository (the path was provided in the Environment Setup chapter). Then, fetch the newest tags and checkout the newest tag: [source, bash] ---- cd ~/.cairo git fetch git checkout tags/v2.0.1 cargo build --all --release ---- Remember, the tag version (`v2.0.1` in the example above) may change as new versions are released, so be sure to replace it with the latest version. Alternatively, if you want to compile using Scarb, you can update `scarb` with: [source, bash] ---- curl --proto '= --tlsv1.2 -sSf | sh ---- == Version Features and Changelog To keep up to date with the newest features and improvements of these tools, you can review the release notes and changelogs on the CLI (cairo-lang)] and compiler] GitHub repositories. == Compatibility Across Environments Starknet CLI and the Cairo compiler form the backbone of the Starknet ecosystem. These tools, being at the heart of Starknet's infrastructure, are under active development, with new versions being frequently released. However, it's noteworthy that the releases of Starknet CLI and the Cairo compiler do not always coincide. As a result, the latest version of Starknet CLI may not be compatible with the latest Cairo compiler, which typically precedes the CLI release by a few days. Consequently, if you install the most recent version of the Starknet CLI, it may not function correctly with the latest Cairo compiler. Below is a table detailing the compatibility between the versions of Starknet CLI and Cairo compiler across various environments \u2013 Mainnet, Goerli Testnet, and Devnet. The table guides you in choosing the compatible versions of Starknet CLI and Cairo compiler for each environment. In addition, it outlines the compatible versions of the Cairo compiler with the Scarb package manager and Protostar toolchain, both of which will be discussed in later chapters. [cols=\"3\", options=\"header\"] |=== |Environment | CLI version] | compiler version] |Mainnet |0.11.2 |1.1.0 |Testnet |0.12.0 |2.0.0 |Devnet |0.12.0 |2.0.0 |Scarb |- |2.0.1 |Protostar |0.11.1.1 |1.1.0 |==="}
{"title": "compute_costs.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "= Lower computation costs with Starknet == The Problem: High Compute Costs in Blockchains Blockchains, despite their revolutionary implications, have been hitherto limited by high computational costs, translating to expensive transaction fees for users. This challenge becomes especially pronounced during peak network activities when congestion leads to sky-high gas prices. In 2021 and during the 'Pepe season' in May 2023, gas prices on Ethereum could soar up to 200 Gwei or more, making even a simple transaction, such as transferring 10 USDC, exorbitantly expensive. High computation costs do not just inconvenience users but also restrain the full potential of blockchain applications. The impacts of these costs are far-reaching and include: * Regular transactions: The dream of using crypto for daily transactions remains largely unfulfilled, primarily due to prohibitive transaction fees. For instance, no user wants to pay a transaction fee of $1 for a $2 cup of coffee. * Oracles: Oracles, which fetch off-chain data for blockchains, cannot refresh data as frequently due to expensive transaction costs, leading to stale and inaccurate data on-chain. * Governance: On-chain governance, a transparent, decentralized decision-making method, is affected as users are dissuaded from voting due to high costs, leading to lower participation and less effective governance. * Gaming: The potential of truly decentralized gaming is limited as high computation costs restrict on-chain components in games. == The Solution: Starknet's Approach to Lower Computation Costs Starknet, as a pioneering Layer 2 solution, addresses these problems head-on. By dramatically reducing computation costs, Starknet makes blockchain applications more accessible and efficient, thereby unlocking their true potential. === Leveraging Affordable Transactions and Account Abstraction The advent of affordable transactions and account abstraction paves the way for more commonplace, day-to-day usage of blockchain technologies. This transformation breaks down into several critical elements: 1. **Microtransactions**: The reduced cost of transactions on Starknet allows for the feasibility of transactions of a very small value, such as buying a cup of coffee, which would have been prohibitively expensive with higher transaction fees. Now, such transactions only cost you a couple of cents or even a fraction of a cent. 2. **Familiar Wallet Experience**: Account abstraction allows your crypto wallet to function similarly to a traditional wallet, bringing a sense of familiarity to users. Key points include: * Users can store the majority of their assets in a highly secure wallet, akin to a savings account in traditional banking. * This wallet can incorporate multiple layers of security. For instance, it may require a trusted individual to co-sign large transfers or use a unique private key for access. * This ensures that users' assets are well protected, enhancing the overall user experience and fostering trust in the system. By bridging the gap between traditional financial systems and blockchain technology, affordable transactions and account abstraction are set to usher in a new era of daily, practical blockchain usage. === Revolutionizing Data Feeds with Affordable On-Chain Computation The advent of economical on-chain computation has the potential to significantly transform the functionality of oracles in the blockchain ecosystem: 1. **Frequent Updates**: With lower transaction costs, oracles can now afford to update their data feeds more frequently. This offers the promise of higher accuracy in the data feeds, thereby enabling users to build more sophisticated market structures based on this data, including intricate options protocols and prediction markets. 2. **Efficient State Commitments**: As Starknet operates as a rollup, it must periodically send a commitment to the Ethereum mainnet to update the state of the rollup. However, rollups only need to commit the most recent state to L1, meaning that if the same storage slot is overwritten multiple times in a single block, it doesn't incur high storage costs. For instance, in the case of oracles, if a variable (such as the price of an asset) is updated frequently within the same commitment, the L1 cost would be equivalent to a single write, as only the final state is published to the mainnet as calldata. 3. **Computational Feeds**: The lower cost of execution also opens the door for feeds of aggregated and calculated data. For instance, traditional financial applications often rely on sophisticated data feeds that provide information on risk, yield, and volatility. Teams like Pragma are dedicated to bringing these types of feeds to the web3 space. Currently, Pragma has already launched two computational feeds on the Starknet testnet, including a volatility index and a yield curve. 4. **Storage Proofs**: With these cryptographic commitments, it is possible to trustlessly prove that a particular state existed at a specific time or block. While these proofs require some computation to verify, the low computational cost greatly enhances user experience. Storage proofs not only allow for the transfer of information between different chains in a decentralized manner but also offer access to historical data from the blockchain and much more. In the realm of oracles, storage proofs promise to revolutionize how data is handled and verified. For a deeper dive into storage proofs, be sure to check out **Chapter 6: Pioneering Applications**. === Realization of On-Chain Gaming Gaming is a mammoth industry, with the largest gaming market, the United States, generating a staggering 54 billion USD annually in revenue. Recently, blockchain games have garnered significant attention, yet many fall short of being fully realized web3 experiences, existing instead within a liminal \"web2.5\" space. For a game to earn the title of a \"blockchain game\", it must satisfy certain criteria: 1. The game's logic should be entirely on-chain. 2. The game should remain functional, even if the developers were to suddenly disappear. The litmus test for the second criterion is reminiscent of the independence smart contracts possess. Much like how a smart contract lives autonomously on-chain, a true web3 game should also endure regardless of the activity of its creators. This means the foundational mechanics and rules of the game are embedded on-chain, allowing different interfaces to be constructed atop the unalterable game logic. To facilitate the creation of games that meet these benchmarks, developers are motivated by issuing game-specific tokens. While no major game currently exists fully on-chain, several projects on Starknet are progressing in the right direction, such as Realms and Influence. Supporting this transformative shift in game development is Dojo, an ecosystem developer providing an open-source Entity-Component-System (ECS) framework for the Starknet ecosystem. In the game development sphere, the ECS is a time-honored design pattern that is crucial for constructing games in a modular fashion. To illustrate, let's take a popular game like Mario Kart as an example. In ECS parlance, Mario and his car would be referred to as entities, the position and velocity of the car would be considered components, and the logic that determines the outcomes of car collisions would be implemented as a system. Game developers would then use these components to create their games. As the Starknet ecosystem expands, the requirement for projects like Dojo will increase. With more game developers entering the Starknet landscape, foundational tools like ECS frameworks will be instrumental in establishing a new era of web3 games that marry the thrill of gaming with the decentralized ethos of blockchain. === Paving the Way for Transparent AI Applications The ever-evolving landscape of artificial intelligence (AI) signals that AI integration into our digital existence is imminent. Although it's not yet a certainty that AI models will be placed on-chain, there are compelling reasons why this could be advantageous. Cheap computation is an essential requirement for these potential use cases: 1. **Verifiable Inference**: Once a model's training is completed, its weights can be published on-chain. Inputs could then be passed to the model on-chain, with the outputs providing a transparent and verifiable outcome. That way, users have proof that the model generated a specific output. 2. **On-Chain Model Ensembles**: If computation becomes cheap enough, it becomes feasible to run models on-chain to generate outputs. Outputs from multiple models could then be aggregated on-chain to form an \"ensemble\" model, an approach commonly used in machine learning (ML) applications to improve accuracy and predictive performance. 3. **Verifiable Training**: Potentially, models could be trained on-chain, offering verifiable proof of benign training without introducing external biases. However, this is the most computationally intensive application and the least likely to be implemented soon. Research teams such as Giza and Modulus Labs are leading the way in exploring the potential of bringing AI on-chain using zero-knowledge (ZK) proofs. For a deeper dive into on-chain AI, be sure to check out **Chapter 6: Pioneering Applications**. == Conclusion In essence, Starknet's groundbreaking approach to reducing computation costs has wide-ranging implications for the blockchain ecosystem. This chapter mainly focused on its impact on transaction costs and usability improvements for blockchain applications. However, Starknet's relevance does not end here. In the next chapter, we will explore Starknet's approach to data security, its evolution, and how it furthers the blockchain revolution."}
{"title": "data_security.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "= The need of Starknet from a data security perspective This chapter will provide an overview of the evolution of data security and how Starknet addresses the challenges posed by the blockchain trilemma. In the repo of the Book], you'll find code examples to enhance your learning experience. We welcome contributions from the community, so if you can provide examples in other languages, please feel free to submit a PR. The topics covered in this chapter have been thoroughly explored and analyzed by countless experts in the field. We will reference their invaluable resources throughout the book to ensure you receive the most comprehensive and accurate information. [quote, The Starknet Community] ____ As we venture into the captivating world of Cairo and Starknet, let's remember that we stand on the shoulders of giants who have paved the way for our understanding and growth. ____ == What are we solving for? Blockchain technology has brought about computational systems characterized by absolute transparency and inclusive accountability. However, to achieve these features, blockchain systems have had to make significant trade-offs that affect usability. Vitalik Buterin encapsulated this issue in \"The Blockchain Trilemma\": [quote, Vitalik Buterin] ____ Blockchains are forced to make trade-offs that prevent them from being decentralized, scalable, and secure. ____ Throughout this course, you will learn how Starknet addresses the Blockchain Trilemma, aiming to deliver a system that is not only secure, inclusively accountable, and decentralized but also scalable and expressive. This is achieved through the use of zero-knowledge STARK proofs. ++++++Goals: ++++++ Secure, inclusively accountable, decentralized, scalable, expressive == Evolution of Data Security image::evolution.png[evolution] For a more concrete example of the trilemma, we can move outside of the blockchain context entirely. Say Alice has an important piece of data she needs access to. To start, we will represent this data as ASCII characters in YAML format: [,yaml] ---- alice_account: 5.00 ---- Let's write it to a file on our computers disk and measure performance: [,bash] ---- time echo \"alice_account: 5.00\" >> bank.yaml ---- Let's read that information: [,bash] ---- time cat bank.yaml ---- It's obviously very fast to read and write this data from our local disk, and database mechanisms] can be applied to optimize access to the data. BUT if you drop your computer or get too close to a large ACME magnet, Alice loses her valuable bank account information. ++++++Goals: ++++++ ++++++secure++++++, ++++++inclusively accountable++++++, ++++++decentralized++++++, scalable, expressive *Let's replicate Alice's account on another computer* If we replicate Alice's bank account YAML file on multiple computers, then when one fails we haven't lost the data! Sender Questions: * How do I locate a receiving host to send to? * How do I know the receiving host successfully wrote Alice's account data? * If I change Alice's account value, how will the receiving host know to update the same value? Receiver Questions: * Who will I receive data from? * If I change Alice's account value, how will the sending host know to update the same value? == Distributed Systems These questions form the basis of distributed systems and distributed computing across a network and have been studied since the inception of the Internet. Let's look briefly at how one of the more popular distributed databases, handles these issues. You can see when configuring the system, you are required to whitelist the `seed node` IP Addresses that will form our trusted cluster that partakes in a limited peer-to-peer Although this is suitable for many traditional systems, we strive to build inclusive and permissionless systems. Once the distributed database is set up, we gain \"Fault Tolerance\" for Alice's valuable bank data. If someone accidentally brings their large ACME magnet into one data center, the data is easily accessible on redundant hosts. Similar to blockchains, these distributed systems made tradeoffs to the simple I/O example above. So what did we give up for this fault tolerance? Banks Perspective: * Network overhead impacts performance * Redundancy and replication impact performance * Infrastructure maintenance (stem:[]) Alice's Perspective: * Delegates trust to the bank: ** Database is configured correctly ** Operational security can handle attackers or intruders ** Is not doing anything duplicitous ** Etc. * Costs typically get passed to Alice ++++++Goals: ++++++ secure, ++++++inclusively accountable++++++, ++++++decentralized++++++, scalable, expressive *Let's replicate Alice's account on ANY computer* Bitcoin brings various computer science concepts together with theory] to create a truly peer-to-peer network and negates the need to delegate our trust to a central part. The nodes trust the block producer based on its valid of work], and the network collectively agrees on a set of canonical updates to the state of the Bitcoin ledger and the state of Alice's account. In `GO` (remember all code examples can be found at the repo of the Book]. Feel free to add your own examples and submit a PR!): [,bash] ---- # proof of work example cd bitcoin/proof_of_work/go go run main.go ---- In `Python`: [,bash] ---- # proof of work example cd bitcoin/proof_of_work/python python main.py ---- The Bitcoin nodes themselves listen for and validate blocks of transactions that are broadcast to the network by the miner of that block. They form a data structure called a Merkle Tree to obtain a root hash corresponding to all the transactions (and their order) in that block. If one tx changes by even a single bit the Merkle root will be completely different. In `GO`: [,bash] ---- # block verification example cd bitcoin/block_verification/go && go mod tidy go run main.go utils.go ---- In `Rust`: [,bash] ---- cd block_verification/rust/ cargo run # or run the tests with cargo test ---- Alice's information gets formatted as a and is replicated on all of the on the Bitcoin network. She can even validate that everything is accurate herself by rehashing the Merkle tree of every block of transactions from genesis to now. *NO DELEGATION OF TRUST* Let's revisit the trilemma. What did we give up to get this trustless data security? * Miners expend energy as they attempt to get the nonce * Full trustless verification requires EACH node to replicate the canonical state: ** Hash the Merkle tree of transactions ** Hash the block header For a naive demonstration of \"The Evolution of Data Security\", run the following: [,bash] ---- cd bitcoin/block_verification/go && go mod tidy go test ./... -bench=. -count 5 ---- ++++++Goals: ++++++ secure, inclusively accountable, decentralized, ++++++scalable++++++, ++++++expressive++++++ *Let's let Alice use her data* == Smart Contracts Smart contracts were first proposed by Szabo] as a transaction protocol that executes the terms of a contract, giving all parties transparency into the rule set and execution. Bitcoin facilitates a version of smart contracts, but the expressive smart contract model of Ethereum has been more widely adopted. == Ethereum Ethereum provides a platform to implement these smart contracts with the use of the Virtual Machine]. In the Ethereum paradigm, Alice's bank account information is stored in a 20-byte address called Her account balance, along with a few more fields (nonce, storage root, and code hash), becomes a \"node\" in a data structure called a Patricia Trie (where Patricia stands for \"Practical Algorithm to Retrieve Information Coded in Alphanumeric\"). This `Trie` is a specific type of tree that encodes a `key` as a path of common prefixes to its corresponding `value`. So Alice's Bank Account can be found at an address (\"key\") that points to an account (\"value\") in Ethereum's World State (trie). The tree structure of the trie allows us to obtain a cryptographic hash of each node all the way up to a single hash corresponding to the `root`, similar to the Merkle tree we saw in the Bitcoin block verification. For an example of the MPT data structure, you can use this diagram for reference: image::trie.png[trie] and run the following: [,bash] ---- cd ethereum/block_verification/go && go mod tidy go run *.go ---- Ethereum then propagates its state by verifying transactions are well-formed and applying them to accounts. Alice has a public/private key pair to manage her \"externally owned account\" and can sign transactions that involve her balance or involve interacting with other contracts in the state. In addition to EOAs, Ethereum has \"contract accounts\", which are controlled by the contract code associated with them. Every time the contract account receives a message, the bytecode that is stored as an encoded] value in the account storage trie begins to execute according to the rules of the EVM. Trilemma visit: what did we give up to add expressivity? * Every transaction still needs to be processed by every node in the network. * With the addition of world state storage, the blockchain can \"bloat\", leading to centralization risk * Alice may pay $100 to use the money in her account ++++++Goals: ++++++ secure, inclusively accountable, decentralized, ++++++scalable++++++, expressive *Let's optimize Alice's data utility* == Rollups As demand for block space increases, the cost to execute on full consensus protocols (e.g. Bitcoin, Ethereum), also known as `Layer 1 (L1)`, will become increasingly expensive, and until certain expiry mechanisms] are implemented, we can expect the state of the L1 to continue to bloat over time. This will require an increasingly robust machine to maintain the state and subsequently verify the blocks. Rollups are one solution in which business logic is executed and stored in a protocol outside the Ethereum context and then proves its successful execution in the Ethereum context. Typically this involves compressing a larger number of transactions at this `Layer 2 (L2)` and committing the state diffs to a smart contract deployed on L1. For full interoperability with the L1, rollups also typically implement a messaging component for deposits and withdrawals. There are currently two types of rollups that are being widely adopted: * Optimistic Rollups * Zero-Knowledge Rollups Vitalik provides a good comparison of the two and touches on the final pieces of our long trilemma journey: *_No matter how large the computation, the proof can be very quickly verified on-chain._* This allows Alice to move her money freely between L1 and L2 (...soon to be L3) and operate on a low-cost, expressive blockchain layer. All while inheriting the highest form of data security evolution from the L1 and not having to delegate trust to any centralized party! ++++++Goals: ++++++ secure, inclusively accountable, decentralized, scalable, expressive *Let's explore Starknet* == Starknet Starknet is a decentralized, permissionless, and scalable Layer-2 solution built on Ethereum. It utilizes zk-STARKs, a type of zero-knowledge proof, to achieve these goals. By using zk-STARKs, Starknet allows for increased transaction throughput, more expressive smart contracts, and reduced gas fees compared to L1. With Starknet, Alice can interact with a more efficient and cost-effective blockchain layer that maintains the security and decentralization of Ethereum. Starknet is composed of various components, including: * Starknet Contracts: Smart contracts written in Cairo, a Turing-complete language designed specifically for creating zk-STARK proofs. * Starknet Nodes: Nodes that process and validate Starknet transactions and proofs, as well as submit them to Ethereum. * Starknet Bridge: A bridge that enables the communication between Ethereum and Starknet, allowing for deposits, withdrawals, and contract interactions. Starknet offers a promising solution to the trilemma, achieving the goals of security, inclusively accountability, decentralization, scalability, and expressivity. ++++++Goals: ++++++ secure, inclusively accountable, decentralized, scalable, expressive By diligently following the Starknet book and exploring the available resources, you will gain the knowledge required to work with Starknet and its components and become proficient in developing and deploying Starknet contracts. Armed with the power of Starknet, you can create scalable, secure, and expressive applications that take advantage of the benefits provided by L2 technology. == Conclusion Throughout the history of data security, various solutions have been developed to address the challenges posed by the blockchain trilemma. From the early days of Bitcoin to the more expressive Ethereum, and now to L2 solutions like Starknet, the industry has made significant strides in achieving secure, inclusively accountable, decentralized, scalable, and expressive systems. With Starknet, developers can harness the power of zk-STARKs to build applications that are both scalable and expressive while maintaining the security and decentralization of the underlying L1 Ethereum network. As the technology continues to evolve and mature, we can expect Starknet to play a significant role in shaping the future of blockchain and decentralized applications."}
{"title": "deploying_contracts.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "= Deploying Starknet contracts In this chapter, you will learn to compile, deploy and interact with a Starknet contract written in Cairo. Follow the below steps in order to accomplish your goal! == Setting up environment variables The following commands must run every time you open a new terminal to interact with Starknet. Setting them saves you time when using the CLI within the same terminal session. [source, bash] ---- # Use Starknet testnet export STARKNET_NETWORK=alpha-goerli # Set the default wallet implementation to be used by the CLI export STARKNET_WALLET=starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount # Set the path to the cairo 1 compiler binary. Adapt this path to fit your installation if needed export CAIRO_COMPILER_DIR=~/.cairo/target/release/ # Compiler arguments export CAIRO_COMPILER_ARGS=--add-pythonic-hints ---- == Setting up an account You need to set up your CLI with an account contract and fund it. [NOTE] ==== Starknet accounts are smart contracts. As such, creating one involves sending a transaction, and takes a bit longer than creating an EOA on other networks. You can learn more in the section of the documentation. ==== This process will involve three steps: * Generating your account address locally * Funding it * Deploying it The Starknet account declared through the CLI are stored on your machine in folder `~/.starknet_accounts/`. [source, bash] ---- # Creating a new account. starknet new_account --account account_name ---- Your terminal will return your account's address. [source, bash] ---- Account address: 0x00d9d851f600d539a9f7811de4d9613a6b3c2634f8c0386a305c03216bd67559 Public key: 0x0293d6625d860b9a37a0319d1e3c1eecc27685075cbeaae4ef29ed717d93c58b Move the appropriate amount of funds to the account, and then deploy the account by invoking the 'starknet deploy_account' command. NOTE: This is a modified version of the OpenZeppelin account contract. The signature is computed differently. ---- Next step is to fund it. Use one of the following methods: * Use the to get some funds and send them to the account * Bridge funds using However you chose to do it, please make sure that the funding transaction reaches the \"PENDING\" status before moving on. You can look for it on or [source, bash] ---- # Deploying your account starknet deploy_account --account account_name ---- Your sample output should look something like this: [source, bash] ---- Sending the transaction with max_fee: 0.000568 ETH (568383605914463 WEI). Sent deploy account contract transaction. Contract address: 0x03f42fc2355be54197a8b270ff2cb8e2eb7902e777b3498f8ad58c6c147cce60 Transaction hash: 0x3d15e05389ecd1ff65555220be57f0ab43729877b20ca086048276917ed2838 ---- Monitor the transaction until it passes the \"PENDING\" state. == Create and compile a contract Before we get started, make sure that the below commands are working properly on your system. If they don't, please check the xref:chapter_1:environment_setup.adoc[Setting up your environment] section. [source, bash] ---- starknet --version starknet-compile --version ---- You can now create a folder of your choice (in any location) where you would like to practice your Cairo skills . Inside the new folder, create a file name `hello_starknet.cairo`. [source, bash] ---- #Create a new folder for practicing your cairo skills cd ~/ mkdir cairo_practice && cd cairo_practice #Create a new file called hello_starknet.cairo touch hello_starknet.cairo ---- Copy and paste the following piece of code into your `hello_starknet.cairo` file: [source, rust] ---- #[contract] mod HelloStarknet { use starknet::get_caller_address; use starknet::ContractAddress; #[event] fn Hello(from:ContractAddress, value:felt252) {} #[external] fn say_hello(message:felt252) { let caller=get_caller_address(); Hello(caller, message); } } ---- Customize the above code by adding a new type of event. Find a name that is unique (this is important). Add the following code: [source, rust] ---- #[event] fn My_Unique_Event_Name(from:ContractAddress, value:felt252) {} ---- Compile the above Starknet contract using the following command: [source, bash] ---- starknet-compile hello_starknet.cairo hello_starknet.json ---- The above command should compile to produce a `hello_starknet.json` file in the same folder. == Declare a contract class On Starknet, the deployment process is in two steps: * Declaring the class of your contract, or sending your contract's code to the network * Deploying a contract, or creating an instance of the code you previously declared Let's start with declaring the above code. [source, bash] ---- starknet declare --contract hello_starknet.json --account account_name ---- [NOTE] ==== The above command may fail if you are using code that has already been declared by someone else! Please make sure to add custom code to your contract to create a new contract class. ==== You will see something like (if you get an error, see the next section on troubleshooting): [source, bash] ---- Sending the transaction with max_fee: 0.000132 ETH (131904173791637 WEI). Declare transaction was sent. Contract class hash: 0x8ceb9796d2809438d1e992b8ac17cfe83d0cf5944dbad948a370e0b5d5924f Transaction hash: 0x334f16d9da30913c4a30194057793379079f35efa6bf5753bc6e724a591e9f0 ---- The transaction hash allows you to track when the network will have received your contract's code. Once this transaction has moved to \"PENDING\", you can deploy an instance of your contract. === Troubleshooting: Contract Declaration Process In the contract declaration process, you may encounter hiccups due to diverse factors such as software compatibility, architectural discrepancies, and execution errors. Here is an error that can arise during the contract declaration: [source,bash] ---- Error: OSError: [Errno 8] Exec format error: '/opt/homebrew/lib/python3.9/site-packages/starkware/starknet/compiler/v1/bin/starknet-sierra-compile' ---- This error is generated when cairo-lang attempts to compile your Sierra code using an imported Rust binary, 'starknet-sierra-compile'. However, in some instances, the imported binary may not be compatible with your system architecture. The solution is to replace the incompatible Rust binary with a locally built version. The following steps can guide you through this process: . *Build the 'starknet-sierra-compile' binary locally.* We did this before when we set up our environment by cloning the starknet repository and building the binary. If you have not done this yet, please refer to the Setting Up Your Environment subchapter. . *Replace the incompatible binary in the Python package.* The locally built 'starknet-sierra-compile' binary can be moved into the Python package directory. Here's an example of how to do this: [source,bash] ---- cp ~/.cairo/target/release/starknet-sierra-compile /opt/homebrew/lib/python3.9/site-packages/starkware/starknet/compiler/v1/bin/starknet-sierra-compile ---- . *Retry the contract declaration.* After replacing the binary, try declaring your contract again. The process should work without any issues. This section is by no means exhaustive, and it is possible to encounter a multitude of different issues during the contract declaration process. When facing issues, remember to check for any updates or changes in the documentation and don't hesitate to add an issue on the starknet book repository. == Deploy a contract Using the above generated class hash, deploy the contract: [source, bash] ---- starknet deploy --class_hash 0x8ceb9796d2809438d1e992b8ac17cfe83d0cf5944dbad948a370e0b5d5924f --account account_name ---- [NOTE] ==== If you run into any fee related issues, please add the flag `--max_fee 100000000000000000` to your CLI commands to set an arbitrary high gas limit for your deploy transaction. ==== You will see something like: [source, bash] ---- Sending the transaction with max_fee: 0.000197 ETH (197273405375932 WEI). Invoke transaction for contract deployment was sent. Contract address: 0x03a5cac216edec20350e1fd8369536fadebb20b83bfceb0c33aab0175574d35d Transaction hash: 0x7895267b3e967e1c9c2f7da145e323bed60dfdd1b8ecc8efd243c9d587d579a ---- Monitor the deploy transaction. Once it has passed \"PENDING\", your contract has been successfully deployed! Wohooo! You have just deployed your first Cairo 1.0 contract on Starknet! Congratulations. == Interact with your contract If you quickly browse through the above contract (`hello_starknet.cairo`), you can see the contract has a simple function: `say_hello` which we are going to learn to trigger. [source, rust] ---- #Function that we will be invoking #[external] fn say_hello(message:felt252) { let caller=get_caller_address(); Hello(caller, message); } ---- The syntax to invoke a function in your contract is: [source, bash] ---- starknet invoke --function --address --account # Invoking our say_hello function starknet invoke --function say_hello --address 0x03a5cac216edec20350e1fd8369536fadebb20b83bfceb0c33aab0175574d35d --input 152 --account account_name ---- You will see something like: [source, bash] ---- Sending the transaction with max_fee: 0.000080 ETH (79590795788372 WEI). Invoke transaction was sent. Contract address: 0x03a5cac216edec20350e1fd8369536fadebb20b83bfceb0c33aab0175574d35d Transaction hash: 0xbfb3ec183b4ee58db67113cf8832c31e78fe8000f091cc598d5aa9ca6a62af ---- [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ===="}
{"title": "environment_setup.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[#setup] = Setting Up Your Starknet Development Environment == Installing the Starknet CLI and the Cairo Compiler Manually We'll be installing the Cairo compiler, a fundamental tool for this task, and the Starknet Command Line Interface (CLI), a utility to interact with the Starknet network. . The Starknet CLI is a command-line interface that allows you to interact with Starknet. This is one of the tools that allow us to interact with Starknet, however, it is not the only one. We will cover other tools in later chapters (e.g., the Starknet JavaScript/Python/Rust SDK or Protostar). . The Cairo compiler is a tool that compiles Cairo code to Sierra. The setup process can be accomplished through two different methods: setting up a local development environment or using a Docker container (if you are using Windows, you will need to follow this approach). Both options are covered in this subchapter, allowing you to choose the one that best suits your needs and preferences. [NOTE] ==== For support or feedback regarding this critical section, please visit our section of the Book's GitHub repository] or reach out to espejelomar directly on Telegram. ==== === Without Docker Follow this section if you're setting up the local development environment without Docker. ==== Prerequisites Before you proceed, ensure that you have the following prerequisites installed on your system: * 3.9] * ==== Starknet CLI Installation To install the Starknet CLI, follow these steps: * *Set up your virtual environment*: We recommend working inside a Python virtual environment. This isolates your project's dependencies from your system's global Python installation. To create and activate a virtual environment, you can use either `venv` or `pyenv`. a. Using `venv`: [source, bash] ---- # Create a virtual environment named \"cairo_venv\" python3.9 -m venv ~/cairo_venv # Activate the virtual environment source ~/cairo_venv/bin/activate ---- a. Using `pyenv`: If you encounter any issues with missing dependencies or have problems during the installation process, please refer to the / Troubleshooting section] of the `pyenv` documentation. [source, bash] ---- # Install pyenv curl | bash # Add the following lines to your .bashrc or .zshrc export PATH=\"$HOME/.pyenv/bin:$PATH\" eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" # Restart your terminal and run the following commands pyenv install 3.9.0 pyenv virtualenv 3.9.0 cairo_venv pyenv activate cairo_venv ---- After creating and activating the virtual environment, you should see `(cairo_venv)` in the command line prompt, indicating that the virtual environment is active, for example: [source, bash] ---- (cairo_venv) satoshi@nakamoto-notebook % ---- * *Install the necessary dependencies for your operating system*: Before installing the Starknet CLI, you need to install some system-specific dependencies. Follow the instructions for your operating system: a. Ubuntu: [source, bash] ---- sudo apt install -y libgmp3-dev ---- a. Mac: [source, bash] ---- brew install gmp ---- Once you have installed the system-specific dependencies, proceed with installing the Python packages required for Starknet CLI: [source, bash] ---- pip install ecdsa fastecdsa sympy ---- These Python packages provide cryptographic and mathematical functionality needed by the Starknet CLI. * *Install the Starknet CLI*: Now that you have set up the environment and installed the dependencies, you can install the Starknet CLI. Follow these steps: a. Uninstall any previous version of `cairo-lang` (`cairo-lang` is the name of the package that contains the Starknet CLI): [source, bash] ---- pip uninstall cairo-lang ---- a. Install the latest version of `cairo-lang`: [source, bash] ---- pip install cairo-lang ---- After you have installed the Starknet CLI, verify your installation by checking the version: [source, bash] ---- starknet --version ---- If you get the following error: [source, bash] ---- ImportError: urllib3 v2.0 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with LibreSSL 2.8.3. See: ---- Try downgrading the version of urllib3: [source, bash] --- pip install urllib3==1.26.6 --- Then check the version again: [source, bash] ---- starknet --version ---- The output should show the installed version of Starknet CLI. Make sure the version matches latest release]. To upgrade to the latest version of the Starknet CLI, run the following command: [source, bash] ---- pip install cairo-lang --upgrade ---- [NOTE] ==== You can receive updates about the Starknet versions and releases by joining the list]. ==== ==== Cairo Compiler Installation To install the Cairo compiler, follow these steps: * Clone the Cairo repository and set it up: [source, bash] ---- # Go to your $HOME directory cd ~/ # Clone the Cairo compiler repo to a folder called .cairo in your home directory git clone .cairo # Checkout the working branch and generate the release binaries cd .cairo/ git checkout tags/v1.1.0 cargo build --all --release ---- * Add Cairo executables to your PATH: Update your `.bashrc` or `.zshrc` file to add the Cairo binaries to your `PATH` environment variable: [source, bash] ---- # Add the command below to your .bashrc or .zshrc export PATH=\"$HOME/.cairo/target/release:$PATH\" ---- Open a new shell and check that the following command returns a version number: [source, bash] ---- cairo-compile --version ---- * To update the Cairo compiler we just need to checkout the newest tag, run the following commands: [source, bash] ---- # Go to your Cairo cloned repo cd ~/.cairo # Fetch the newest tags git fetch # Checkout the newest tag git checkout tags/v1.1.0 cargo build --all --release ---- Open a new shell and check that the you have the intended version: [source, bash] ---- cairo-compile --version ---- Your local development environment for Starknet is now set up. You can now start building, deploying, and interacting with Cairo smart contracts. === With Docker Follow this section if you're setting up the local development environment with Docker. [NOTE] ==== If you encounter any issues or difficulties while setting up Starknet and Cairo using the Docker method, we encourage you to reach out for assistance. Please report your concerns in the section of the Book's GitHub repository], or contact espejelomar directly on Telegram. Your feedback is invaluable for improving this critical section, which plays a key role in onboarding developers to the Starknet ecosystem. ==== Using a Docker environment for Starknet development offers several benefits compared to setting up the development environment locally. These benefits include: - *Isolation*: Docker containers provide an isolated environment for your Starknet development, ensuring that dependencies and configurations do not interfere with other projects or your system's global settings. - *Portability*: A Docker container can run on any system with Docker installed, allowing you to easily share your development environment with others or move it between different machines without reconfiguring the environment from scratch. - *Reproducibility*: Docker images ensure that your development environment is consistent across different systems, helping to eliminate issues arising from differences in dependencies or configurations. - *Versioning*: You can use different Docker images or tags for different versions of the Starknet development tools, allowing you to easily switch between versions as needed. - *Easier management*: Docker simplifies managing development environments, allowing you to start, stop, and restart containers with ease. It also makes it easy to clean up your environment by removing containers and images. With these benefits in mind, the following sections will guide you through setting up a Docker environment for Starknet development. This environment will allow you to easily build, deploy, and interact with Cairo smart contracts using Docker. *Before you proceed, ensure that you have the following prerequisites installed on your system:* - ==== Pulling the Docker Image The first step is to pull the Docker image containing the necessary tools for Starknet development. Execute the following command in your terminal: [source, bash] ---- docker pull artudev19/cairo-env:latest ---- This command downloads the Starknet Docker image. ==== Running the Docker Container To run a container from the image, execute the `docker run` command. To make certain information persistent, use a volume by passing the flag `-v from_host_path:to_container_path`. This will reflect the content in the host_path inside the container. If you specify a path in the container that does not exist, Docker will create it automatically. [source, bash] ---- docker run -it --name stark-env -v /Desktop/stark-apps/contracts:/contracts artudev19/cairo-env:latest ---- This command runs a container named `stark-env` (ensure your Docker daemon is running) and opens a terminal where you can execute Starknet and Cairo commands. In the example above, the Cairo contracts from your local machine will be in the `stark-app/contracts` directory, while in the container, they will be in the `contracts` path. ==== Verifying the Installation Check the installed versions of Starknet CLI and Cairo compiler: [source, bash] ---- starknet --version cairo-compile --version ---- The output should show the installed version of Starknet CLI and Cairo compiler. Ensure the versions match latest release]. ==== Managing the Docker Container To start the container in the future, execute: [source, bash] ---- docker start stark-env ---- To connect to the running container, execute: [source, bash] ---- docker exec -it stark-env zsh ---- Your Docker development environment for Starknet is now set up. You can now start building, deploying, and interacting with Cairo smart contracts. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "README.md", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "Ethereum #### Sources - - - - - - - --- upper_tags: [protocol, peer_to_peer, network, ledger, database, cryptocurrency, virtual_machine] lower_tags: [merkle_patricia_trie, transaction, account, node, client, miner, block, hash, keccak, application_specific_integrated_circuit, timestamp, consensus, proof_of_work, proof_of_stake, solidity, smart_contract, memory_pool]"}
{"title": "hello_world.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "= Writing your first Starknet contract In this chapter, you will learn to write your first Starknet contract. We know you are super excited and so are we! This contract is a simple read/write contract where you will learn to read and write from storage using Cairo. Our contract will be called `SimpleStorage`. Follow the below steps to learn to write your first Starknet contract. == Step 1: Contract [#macro] and modules You can create a new folder to write this new contract or create it inside your `.cairo/` folder. Let us create a new file called `simple_storage.cairo`. [source, bash] ---- touch simple_storage.cairo ---- You can open this empty file in your editor of choice (eg: VS Code) and start writing the below lines of code - your first Cairo contract. A Starknet contract will always start with the `[#contract]` macro to indicate that this is a Starknet contract. Remember that you can also create other Cairo files that are *NOT* contracts because Cairo is a programming language by itself. All the Cairo contracts are defined by the keyword `mod` which implies that it's a module containing some logical piece of code. You can write first below lines of contract in the `simple_storage.cairo` file. [source, rust] ---- #[contract] mod SimpleStorage {} ---- == Step 2: Creating the Storage In order to store variables on-chain, we need to create a storage structure called `Storage`. This struct will have all the variables that you would like to have in contract/permanent storage. Create a Storage struct within your `SimpleStorage` contract as shown below. [source, rust] ---- struct Storage { balance: felt252 } ---- [NOTE] ==== The storage struct will always be named `Storage`. ==== == Step 3: Defining events Yes! You read it right. Events are now supported in Cairo. You can define an event just like a function with the name of the event, in this case it is `BalanceIncreased` and the values you would like to emit within the bracket as arguments. [source, rust] ---- //The keyword to define a function is \"fn\" #[event] fn BalanceIncreased(balance: felt252) {} ---- == Step 4: Writing your first function Below is a simple function called `increase_balance` which takes in the amount as the argument of type `felt252`. The function is fairly simple. We read the balance variable(defined earlier in the storage struct) using `::read()` function and simple increase the balance by adding the amount to it. We then write the new balance to the existing storage variable and update the value. Last but not the least, we log/emit the event with the updated balance using the name of the event function. [source, rust] ---- #[external] fn increase_balance(amount: felt252) { let new_balance = balance::read() + amount; balance::write(new_balance); BalanceIncreased(new_balance); } ---- You might have noticed a macro called `external` that is added to this function. This means that the function called be called externally or outside of the contract. For functions that are modifying a storage variable, you would need to add the external macro. There are other types of macros as well that you can add to a function: * event * external * view * constructor Let us see another function in the next step and the macro used. == Step 5: Writing your view function As you saw in Step 4, we are able to write to our storage using `balance::write()`, but how do we read from the storage? (Hint: That's also being done in the above function). In the below function, we are reading the current balance of the storage variable _balance_ and returning it. You can observe that we use a `->` symbol to return the variable, similar to Rust. This function can be a `view` function because it does not modify any variables. [source, rust] ---- #[view] fn get_balance() -> felt252 { balance::read() } ---- == Step 6: Putting it all together Your final contract should look something like this. [source, rust] ---- #[contract] mod SimpleStorage { struct Storage { balance: felt252 } #[event] fn BalanceIncreased(balance: felt252) {} #[external] fn increase_balance(amount: felt252) { let new_balance = balance::read() + amount; balance::write(new_balance); BalanceIncreased(new_balance); } #[view] fn get_balance() -> felt252 { balance::read() } } ---- You can now follow the steps given in the xref:deploying_contracts.adoc[Deploying smart contracts] section to compile and deploy the above contract. Congratulations on successfully writing and deploying your first Cairo contract! == Quick Challenge Once you have deployed the above contract, you would need to invoke the contract and also `call` the `get_balance` function. The _call_ syntax has not been mentioned in the previous section but it's fairly easy to use and that's your **challenge**! [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "index.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"introduction\"] = Introduction to Starknet Welcome to the Starknet Book, a comprehensive guide to understanding and navigating the world of Starknet. This introduction provides a high-level overview of key concepts, including what Starknet is, its core philosophy, roadmap (in the next section), the organizations behind it, and the unique role of Cairo in the ecosystem. We will delve deeper into these concepts throughout the rest of the book. So whether you\u2019re a developer, a crypto enthusiast, or a curious newcomer, you\u2019re in the right place to start your journey with Starknet. == What is Starknet? Starknet is a permissionless network that leverages the power of zk-STARKs technology for scalability, privacy, and security. As a Layer-2 scalability solution for Ethereum, Starknet offers fast, secure, and low-cost transactions. It functions as a Validity Rollup (commonly known as a zero-knowledge Rollup) that uses cryptographic systems called STARKs to reduce computation costs. Critical features of Starknet include: * Low transaction costs: Starknet\u2019s transaction costs are significantly lower than Ethereum\u2019s. With forthcoming upgrades and enhancements such as Volition (off-chain data availability) and the implementation of EIP 4844 on L1, these transaction costs are expected to decrease even further. * Developer-friendly platform: Starknet provides an environment that empowers developers to build decentralized applications using STARKs and the Cairo programming language. * High throughput and low latency: Starknet\u2019s upcoming releases aim to increase the network\u2019s throughput, reduce transaction latency, and lower transaction costs. === The Starknet Philosophy: A Developer-friendly Approach Starknet\u2019s philosophy is centered around being developer-friendly. The network is designed with a clear focus on providing developers with a robust, secure, and powerful platform for building the future of decentralized infrastructure and applications. Fundamental principles of this approach include: * Performance: Starknet offers faster throughput, lower latency, and reduced transaction costs, thus facilitating the creation of compute-intensive applications. * Cairo: Starknet\u2019s core programming language, Cairo, is constantly updated and enhanced to provide developers with the best tools for leveraging validity proofs and zk-STARKs technology. * Community focus: Starknet maintains active communication channels and feedback with the developer community via platforms like Telegram and Discord. * Creativity: Starknet aims to remove limitations and empower developers to build the future of decentralized applications. Build things that have never been built before just because of the limitations of the underlying technology. * Tooling: Starknet is committed to providing a comprehensive suite of development tools, including SDKs for various languages, a testing and deployment framework inspired by Foundry (Protostar), and package managers (Scarb). The philosophy of Starknet is materialized with its roadmap, which is discussed in the next section. == What is Cairo? Cairo is a Turing-complete programming language designed for creating STARK-provable programs for general computation. As the native smart contract language for Starknet, a permissionless Validity Roll-up, Cairo plays a crucial role in enabling scalable and secure decentralized applications. During the Smart Contracts Chapter of the Book, we will explore Cairo in more detail. Several resources exist to learn about Cairo, including the Book] and Cairo is inspired by the Rust programming language. It allows developers to write Starknet smart contracts in a safe, convenient, and familiar manner. === Why Cairo? Starknet's scalability solution, Validity rollups, introduces a new paradigm called Provable Computation. This approach allows programs to prove their correct execution without needing to be re-run. To develop such provable programs, a specialized programming language that is both effective and easily learnable by developers is necessary. Some benefits of Cairo include: * Specially designed as a provable language for smart contracts * Unbounded by the limitations of the Ethereum Virtual Machine (EVM) * Utilizes traits for a more loosely-coupled relationship compared to inheritance == What is the Starknet Foundation? The Starknet Foundation serves as the steward of Starknet, ensuring that the network remains accountable to its community of developers and users. As a non-profit organization, it carries out several key roles in the ecosystem. === Governance The Foundation is responsible for the governance of Starknet. Its governance duties involve: * Overseeing the development and operations of Starknet, including network upgrades and improvements. * Regulating the Starknet DAO, a decentralized autonomous organization that facilitates community participation in Starknet\u2019s governance. * Establishing rules and regulations to ensure fair practices and maintain the integrity of the network. === Development Beyond governance, the Starknet Foundation also plays an active role in fostering development within the Starknet ecosystem: * The Foundation supports and facilitates research, development, and innovation in the Starknet network and the broader Starknet ecosystem. * It champions the expansion of Starknet technology and promotes the adoption of the Starknet network. * The Foundation provides financial and logistical support for user and developer conferences and events, fostering collaboration and knowledge sharing within the community. === Community Engagement The Starknet Foundation recognizes the importance of a strong, vibrant community in the success of Starknet. It takes several measures to fuel Starknet community participation and project governance: * The Foundation is deeply involved in organizing and facilitating community events, meetups, and discussions. * It encourages collaboration with allied and related communities, nurturing a sense of unity and shared purpose among those involved in the broader blockchain space. * The Foundation makes efforts to create opportunities for community members to contribute to the growth and development of Starknet, be it through development, governance, or community building. === Board of Directors A board of seven directors oversees the governance of the Starknet Foundation, each contributing unique expertise to the table. These directors come from diverse backgrounds and bring a wide array of insights and perspectives: * Andrew McLaughlin: Specializes in tech policy, digital rights, and community self-governance. He brings his entrepreneurial experience to the Foundation\u2019s governance. * Eli Ben-Sasson: Co-founder, President of StarkWare, and co-inventor of STARKs. His technical expertise is invaluable in guiding the development of Starknet. * Eric Wall: An independent blockchain researcher and thought leader, contributing his insights on the blockchain space to the Foundation\u2019s strategies. * Heather Meeker: An expert on open-source software licensing, ensuring that the Foundation\u2019s open-source initiatives are legally sound. * Shubhangi Saraf: A professor of math and theoretical computer science. She contributed to the mathematics underpinning STARKs and brought her academic expertise to the Foundation. * Tomasz Stanczak: A blockchain engineer, leader, and CEO of Nethermind, one of the largest teams building on Starknet. His practical development experience provides invaluable insights. * Uri Kolodny: Co-founder and CEO of StarkWare. His leadership and understanding of Starknet\u2019s core technology help guide the Foundation\u2019s strategic direction. These seven individuals work together to guide the Starknet Foundation\u2019s activities and ensure that Starknet continues to grow and evolve in the best interest of its community. == What is Starkware? Starkware is a technology company in the blockchain industry that focuses on developing and deploying zk-STARK technology. Starkware was founded in 2018, and since then, it has been at the forefront of the advancement of STARK-based technologies in the blockchain industry. Starkware\u2019s first key innovation was StarkEx, which, based on a Software as a Service (SaaS) business model, has become one of the most significant Layer 2 solutions in production on Ethereum since its inception in June 2020. It has achieved this through leveraging STARK proofs, which ensure the validity of large batches of transactions processed off-chain with a minimal on-chain footprint. Starkware\u2019s second significant contribution to the blockchain industry is Cairo, a programming language optimized for writing efficient STARK proofs, enabling scalable computation for decentralized applications. With its efficiency and Turing completeness, Cairo became a vital tool for developers, both off-chain and on Starknet. Starknet, which is Starkware\u2019s latest accomplishment, represents a significant leap in the field of Layer 2 solutions. Starkware decided to establish Starknet as a permissionless, decentralized network governed by the Starknet Foundation. The goal is to ensure that Starknet becomes a community-driven project where many entities contribute to its evolution and development. == Learning Resources To get deeper into Starknet and Cairo, developers and users are encouraged to refer to the following: * Starknet Book]: This comprehensive guide to Starknet covers everything from the basics to the most advanced concepts and tooling. It is a living document that will be updated regularly to reflect the latest developments in Starknet. * Cairo Book]: This resource is handy for developers looking to master Cairo, Starknet\u2019s core programming language. * This is a collection of practical tutorials and examples designed to help developers start with Cairo and Starknet. == Conclusion Starknet presents a promising future for developing scalable, secure, and low-cost decentralized applications. Built upon the solid Foundation of zk-STARKs technology, Starknet is a powerful Layer-2 scalability solution for Ethereum. It\u2019s not only about its technology. At its core, Starknet highly emphasizes supporting and empowering its developer community, providing robust tooling, resources, and open communication channels. Moreover, Starknet\u2019s roadmap illustrates a clear and ambitious path toward increased performance, reduced transaction costs, and continuous network enhancements. This book is meant to serve as a comprehensive guide for developers, enthusiasts, and anyone interested in diving deeper into Starknet\u2019s technologies and philosophies."}
{"title": "roadmap.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"roadmap\"] = The Starknet Roadmap - A Developer-Focused Approach Starknet's roadmap is a testament to the network's commitment to developers, placing performance and transaction cost as its highest priorities. image::roadmap.png[roadmap] This is a general overview of the Starknet roadmap. For more details, please refer to Starknet documentation]. == Throughput and Latency The core focus of Starknet's immediate future developments is enhancing performance, with a major emphasis on boosting throughput and decreasing latency. * The upcoming Starknet v0.12.0, planned for release soon, will incorporate substantial throughput and latency improvements, primarily attributed to transitioning to a Rust-based Sequencer and the new Rust-Cairo Virtual Machine (VM). * This transition is expected to dramatically reduce block execution time, thereby significantly increasing the throughput of transactions. As Starknet continues to grow and evolve, throughput and latency will remain top priorities as the network strives to offer an increasingly performant platform for developers to build upon. == Transaction Costs Reducing transaction costs is another paramount aspect of Starknet's roadmap. Lower transaction costs equate to a more accessible network, a critical factor in promoting the broader adoption of Starknet's technology. * Starknet v0.13.0 is expected to greatly reduce transaction costs by minimizing L1 (Ethereum) data cost, which currently accounts for 95% of the total transaction cost. * A key driver of this cost reduction is the introduction of Volition, Starknet's mechanism for a hybrid Data Availability (DA) mode that allows both on-chain and off-chain data. * In addition to Volition, Starknet plans to leverage Ethereum's EIP-4844 (Shard Blob Transaction), anticipated for release in Q4 of 2023. This Ethereum improvement proposal is expected to help further reduce the cost of data. In line with Starknet's principle of transparent and open communication, more details about these developments will be shared as they emerge. == Beyond v0.13.0 While the immediate focus is on performance and transaction costs, Starknet's roadmap extends beyond these areas. Future developments will be directed by the requirements and feedback of the Starknet community, upholding the network's dedication to a developer-focused approach. * Cairo, Starknet's powerful programming language, will continue to receive enhancements, making it an ever more effective tool for developers. * Decentralization is another key aspect of Starknet's future developments, with plans to further decentralize the various components of the network, including the Sequencer and the Prover. * The Starknet Foundation will play a pivotal role in the governance of these initiatives, ensuring that the network continues to grow in a manner that is in the best interest of its community. Detailed timelines and updates will be provided regularly to ensure that the community is informed about the progress and direction of Starknet."}
{"title": "README.md", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "Rollups ### Sources - - - - --- upper_tags: [] lower_tags: []"}
{"title": "arrays.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"arrays\"] = Arrays, Spans and Snapshots in Cairo ==== OWNERSHIP: After completing this subchapter, we strongly recommend exploring the concept of Ownership in Cairo by referring to the Book]. Ownership is a crucial concept, inspired by and inherited from Rust, that governs resource management and prevents common programming errors such as double-free, use-after-free, and data races. Mastering the concept of Ownership in Cairo is essential for developing robust and secure smart contracts and becoming a proficient Cairo developer. ==== An array in Cairo is a collection of multiple values of the same type, stored sequentially in memory. Similar to Rust, Cairo arrays are append-only, meaning that you can only add elements to the end of an array. Once a memory slot is written to, it cannot be overwritten, but you can still read from it. Arrays in Cairo are useful for storing and managing data that requires a fixed-size or dynamically growing data structure. To use arrays in Cairo, you'll need to import the `array::ArrayTrait` trait: [source, rust] ---- use array::ArrayTrait; // import the ArrayTrait trait ---- We'll use a Pok\u00e9mon example to illustrate the concepts. You can find the documented contract code in the repository] at the contracts folder. == Creating and Initializing Arrays To create an array in Cairo, you can use the `ArrayTrait::new()` method. Arrays are mutable by default, which means you can modify their contents. Here's an example of creating an array with Pok\u00e9mon names and appending elements to it (remember the actual contract is in the repository]): [source, rust] ---- fn create_pokemon_array() -> Array:: { let mut pokemons = ArrayTrait::new(); // create a new array of type felt252 pokemons.append('Pikachu'); // append 'Pikachu' to the pokemons array pokemons.append('Charmander'); pokemons.append('Bulbasaur'); pokemons.append('Squirtle'); pokemons // return the array } ---- In this example: * `let mut pokemons = ArrayTrait::new()` creates a new mutable array of type `felt252`. * The `append()` method is used to add elements (Pok\u00e9mon names) to the array. * The function returns the array after appending the Pok\u00e9mon names. In the Strings chapter, we review parts of the contract dealing with short strings, e.g., `'Pikachu'`. === Key Concepts * Use the `ArrayTrait` trait to work with arrays in Cairo. * Arrays are mutable by default. * The `append()` method is used to add elements to an array. * Arrays can be used to store and manage collections of elements in a sequential manner. * Arrays are append-only, meaning that you can only add elements to the end of an array. * Arrays are indexed starting from 0. == Removing Elements and Obtaining the Length of an Array In Cairo, you can remove elements from the front of an array using the `pop_front()` method. This method returns an `Option` containing the removed value if the array is not empty, and `None` if the array is empty. It's important to note that elements can only be removed from the front of an array in Cairo. To obtain the length of an array, you can use the `len()` method. Here's an example of removing an element and obtaining the length of a Pok\u00e9mon array: [source, rust] ---- fn pop_pokemon_array() { let mut pokemons: Array = create_pokemon_array(); assert(pokemons.len() == 4_usize, \"Unexpected length\"); let first_pokemon = pokemons.pop_front().unwrap(); assert(pokemons.len() == 3_usize, \"Unexpected length\"); assert(first_pokemon == 'Pikachu', \"Unexpected pokemon\"); } ---- In this example: * `pokemons.len()` is used to obtain the length of the `pokemons` array. * `pokemons.pop_front()` is used to remove the first element (front) from the `pokemons` array. * `unwrap()` is used to get the removed value from the `Option` returned by `pop_front()`. * The assertions check if the array length and removed element are as expected. == Accessing Array Elements To access elements in an array, you can use the `get()` and `at()` methods. The `get()` method returns an `Option` that contains the value if the index is valid, and `None` if the index is out of bounds. The `at()` method directly returns the value at the specified index, but it will cause an error if the index is out of bounds. Here's an example of accessing elements in a Pok\u00e9mon array: [source, rust] ---- fn index_pokemon_array() { let mut pokemons: Array = create_pokemon_array(); assert(*pokemons.get(0_usize).unwrap().unbox() == 'Pikachu', \"Wrong pokemon\"); assert(*pokemons.at(1_usize) == 'Charmander', \"Wrong pokemon\"); } ---- == Understanding Snapshots and Spans In this chapter, we will explore the concepts of snapshots and Spans in Starknet. A `Span` is a lightweight view of an array that allows you to access the underlying data without modifying the original array. You can create a span from an array using the `span()` method. Before diving into `Span`, it's essential to understand snapshots (defined by the operator `@`), as a `Span` struct is built upon them: [source, rust] ---- struct Span { snapshot: @Array } ---- A `Span` of `T` values (e.g., `Span`) is a struct with one element: a snapshot of an `Array` of the same value `T` (e.g., `Array`). === Snapshots Snapshots are a powerful feature in Cairo, providing read-only instances of an object without taking ownership when passed to a function. Every type `T` has a snapshot version `@T`, which is always droppable and duplicatable. To create a snapshot of a value `x` of type `T`, simply use `@x`. ==== Snapshots vs. Rust References While snapshots may appear similar to Rust references (`&`) at first glance, there are critical differences between the two: 1. **Object type**: Unlike Rust references, which are pointers, snapshots are full objects. As a result, using snapshots does not yield performance improvements associated with pointer usage. 2. **Object immutability**: When an object is modified after creating a snapshot, the snapshot remains unaffected. This behavior contrasts with Rust references, which reflect changes to the underlying object. ==== Practical Usage of Snapshots Snapshots have various use cases, particularly when working with arrays and data structures in Cairo. Here are some practical examples of how snapshots can be beneficial: * **Preserving original data**: When writing a function that accepts an array and returns the sum of the first two elements, you might not want to modify the original array. In this case, using a snapshot of the array as a parameter instead of the actual array allows you to preserve the original data. * **Immutable data views**: If you take a snapshot of an array and then add a value to the original array, the snapshot will remain unaffected, maintaining the original values without the newly added value. This feature is useful when you need an immutable view of the data at a specific point in time. * **Read-only instances**: Some functions, such as `Array::get` and `Array::at`, require a snapshot of the object instead of the object itself. By using snapshots, you can create read-only instances that do not take ownership of the object when invoking the function. This approach is helpful when you need to access data without modifying the underlying data structure. In summary, snapshots enable developers to work with data more efficiently, offering a way to preserve original data, create immutable views, and access read-only instances without modifying the original object. === Spans Spans provide a convenient way to work with arrays without modifying the original array or worrying about ownership. To use spans, you must import the `array::SpanTrait` trait: [source, rust] ---- use array::SpanTrait; ---- Consider the following example, which demonstrates how to access elements in a Pok\u00e9mon span: [source, rust] ---- fn index_pokemon_span() { let pokemons_span: Span = create_pokemon_array().span(); assert(*pokemons_span.get(2_usize).unwrap().unbox() == 'Bulbasaur', \"Wrong pokemon\"); assert(*pokemons_span.at(3_usize) == 'Squirtle', \"Wrong pokemon\"); } ---- Both functions `get` and `at` from the `SpanTrait` expect the use of a snapshot. If the Pok\u00e9mon contract used `pokemons.at(1_usize)` instead of a snapshot, `*pokemons.at(1_usize)`, the compiler would return an error: [source, rust] ---- error: Plugin diagnostic: Unexpected argument type. Expected: \"@core::felt252\", found: \"core::felt252\". --> pokemon_array.cairo:41:40 assert(pokemons.at(1_usize) == \"Charmander\", \"Wrong pokemon\"); ^**********^ ---- In this case, the `at` method expected a snapshot (`@core::felt252`) rather than the actual value (`core::felt252`). To avoid such errors and write efficient smart contracts, Cairo developers should have a thorough understanding of ownership, which is inspired by Rust. Refer to the Book] for more information on this topic. == Conclusion and Summary In this chapter, we delved into the world of arrays in Cairo, using Pok\u00e9mon as an example to make the concepts more approachable and fun. We've learned how to create arrays, add elements, remove elements, and obtain the length of an array. To quickly recap, here's what we covered: * *Create an array*: Use `ArrayTrait::new()` to create a new mutable array of a specific type. * *Add elements*: Use the `append()` method to add elements to an array. Remember, Cairo arrays are append-only. * *Remove elements*: In Cairo, you can only remove elements from the front of an array. Use the `pop_front()` method, which returns an `Option` containing the removed value or `None` if the array is empty. * *Obtain array length*: Use the `len()` method to get the length of an array. * *Access elements*: Use the `get()` and `at()` methods to access elements in an array. The `get()` method returns an `Option` that contains the value if the index is valid, and `None` if the index is out of bounds. The `at()` method directly returns the value at the specified index, but it will cause an error if the index is out of bounds. In the following subchapter we will test our assertions in the Pokemon contract by deploying it to the Starknet testnet. This is the worst way to test a contract, but it is the only way to test it with our current knowledge. In the next chapter we will review the Protostar and Cairo testing framework, which will allow us to test our contracts locally. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "asserts.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"asserts\"] = Asserts and Error Handling in Cairo In Cairo, the `assert` statement is used to validate inputs, enforce constraints, and handle errors. This statement checks if a given condition is true and throws an error message if it is not. In the Vote contract, the `assert` statement is used in several places to ensure proper input validation and error handling: [source,rust] ---- assert(vote == 0_u8 | vote == 1_u8, 'VOTE_0_OR_1'); assert(is_voter == true, 'USER_NOT_REGISTERED'); assert(can_vote == true, 'USER_ALREADY_VOTED'); ---- Some key points about the `assert` statement in Cairo are: 1. The `assert` statement checks if a condition is true. If the condition is not true, the contract execution is halted, and an error message is thrown. 2. Error messages are specified as strings, following the condition. In the example above, 'VOTE_0_OR_1', 'USER_NOT_REGISTERED', and 'USER_ALREADY_VOTED' are the error messages. 3. The `assert` statement is helpful for input validation, ensuring that only valid inputs are processed by the contract. 4. The compiler will not notice if an assertions is not complied with. That is, the compiler will not check if the condition is true or false. The assertion is only checked at runtime: for example, in tests (more on this in a following chapter) or when the contract is deployed. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "constants.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"constants\"] = Constants in Cairo Contracts In this chapter, we will discuss the use of constants in Cairo contracts. Constants are useful for defining values that do not change throughout the execution of a contract. We will continue using the modified Vote contract. == Defining Constants To define a constant in a Cairo contract, you use the `const` keyword followed by the name of the constant, its type, and its value. Constants can be of any Cairo supported data type, such as `u8`, `u16`, `u256`, etc. In the Vote contract, we define two constants to represent the voting options. This helps us improve the readability of the contract code by providing meaningful names for the values 0 and 1: [source,cairo] ---- const YES: u8 = 1_u8; const NO: u8 = 0_u8; ---- Here, we define two constants `YES` and `NO` with values 1 and 0, respectively, both of type `u8`. == Using Constants Constants can be used in the same way as any other variables in the contract. The main difference is that their values cannot be changed during the contract's execution. In our Vote contract, the constants `YES` and `NO` are used in the `vote` function to validate the submitted vote and update the vote count accordingly. The `vote` function is called by the voters to submit their votes. The function checks if the submitted vote is valid (either `YES` or `NO`) and updates the vote count accordingly: [source,cairo] ---- #[external] fn vote(vote: u8) { // Check if the vote is valid (0 or 1) assert(vote == NO | vote == YES, 'VOTE_0_OR_1'); // ... (rest of the function) } ---- By using constants, we improve the readability and maintainability of the contract code. If we need to change the values of the vote options, we only need to modify the constants' definitions. == Advantages of Using Constants There are several advantages of using constants in your Cairo contracts: 1. Readability: Constants make the code more readable by providing meaningful names for values. 2. Maintainability: By defining values in one place, you can easily change them without having to search and replace the values throughout the code. 3. Performance: Constants can improve performance, as they are known at compile-time and do not consume storage or memory at runtime. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "deploy_call_invoke.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"calling_invoking\"] = Deploying, Calling and Invoking Contracts In this chapter, we'll explore how to interact with deployed Starknet contracts using _calling_ and _invoking_. We'll use the voting contract as an example. * Calling contracts: Interacting with contract functions marked with the `#[view]` entry point. These functions do not alter the state of the network, so they don't require fees or signing. This is similar to a `call` in the Ethereum API. * Invoking contracts: Interacting with contract functions marked with the `#[external]` entry point. These functions do alter the state of the network and require fees and signing. This is similar to a `deploy` in the Ethereum API. == Deploying Account Contracts for Voters Before interacting with the voting contract, we need to ensure that voter accounts are deployed as account contracts on Starknet. Each voter account must be registered and funded to participate in the voting process. This process is required since we are using Account Abstraction (more in this later in the book). To deploy an account contract for a voter, follow these steps: 1) Create a new account with a name, for example, \"voter_1\": [source,bash] ---- starknet new_account --account voter_1 ---- 2) Fund the newly created account (this can be done using a or transferring funds from another account). Wait for the transaction to be confirmed in L2. You can check the status of the transaction by copying the transaction hash into a block explorer such as or the transaction should be confirmed in a few minutes. 3) Deploy the account contract: [source,bash] ---- starknet deploy_account --account voter_1 ---- Repeat these steps for each voter account you want to register in the voting contract. Once we have deployed account contracts for all the voters, we can proceed with deploying and interacting with the voting contract. == Deploying the Voting Contract Before deploying you need to declare the contract. However, note that the contract has already been declared (Class Hash: 0x748762322d0ee8ee30e924ba68b0633ea704fa419e86a51bc1d75be4a115ca5) so you can skip this step. If you try to declare a contract that has been declared before you will receive an error, however, here is how you declare it: [source,bash] ---- \u276f starknet declare --contract target/dev/scarb_project_Vote.sierra.json --account ---- Wait for the transaction to be confirmed in L2. You can check the status of the transaction by copying the transaction hash into a block explorer such as or the transaction should be confirmed in a few minutes at most. Here's the command to deploy the voting contract, which will register voter_1, voter_2, and voter_3 as eligible voters. Note these are arguments that the constructor takes. Add as a voter an account that you have access to so you can vote with it later. [source,bash] ---- starknet deploy --class_hash 0x748762322d0ee8ee30e924ba68b0633ea704fa419e86a51bc1d75be4a115ca5 --inputs --account --max_fee 100000000000000000 ---- The contract that we would be interacting has been deployed at address: *0x027f4989d3cbf1654bc95f3e0083bb4542634c7cc8c7c406f17a4335fa5860a9*. You can find it on Starkscan. == Verifying Voter Eligibility Let's confirm that the registered voters are eligible to vote. We can use the `voter_can_vote` and `is_voter_registered` functions to do this. Since both functions are view functions, we can utilize the `starknet call` syntax to interact with them. To check if a registered voter can vote, use the following command: [source,bash] ---- starknet call --function voter_can_vote --inputs --address 0x027f4989d3cbf1654bc95f3e0083bb4542634c7cc8c7c406f17a4335fa5860a9 --account ---- Since we provided a registered voter address as an input, the result is 1 (boolean true), indicating the voter is eligible to vote. Next, let's call the `is_voter_registered` function using an unregistered account address to observe the output: [source, bash] ---- starknet call --function is_voter_registered --inputs --address 0x027f4989d3cbf1654bc95f3e0083bb4542634c7cc8c7c406f17a4335fa5860a9 --account ---- With an unregistered account address, the terminal output is 0 (i.e., false), confirming that the account is not eligible to vote. ==== FUN ASSIGNMENT: Before proceeding to vote, ensure that all three voter accounts are registered and eligible to vote! ==== == Voting With voter eligibility confirmed, we can now proceed to cast votes using the `vote` function. This function is marked as external, so we'll use the `starknet invoke` command to interact with it. This process is comparable to using `send` in the Ethereum API when interacting with a contract function that modifies the contract state. The syntax for `invoke` is similar to `call`, but in this case, we'll provide the input as either 1 (Yes) or 0 (No) to represent our vote. [source,bash] ---- //Voting Yes starknet invoke --function vote --address 0x027f4989d3cbf1654bc95f3e0083bb4542634c7cc8c7c406f17a4335fa5860a9 --inputs 1 --account voter_2 //Voting No starknet invoke --function vote --address 0x027f4989d3cbf1654bc95f3e0083bb4542634c7cc8c7c406f17a4335fa5860a9 --inputs 0 --account voter_3 ---- Don't forget to cast a vote with the voter_1 account before moving on to the next step. == Viewing Vote Results To view the results, we can call the `get_vote_results` function, which is a view function. We'll use the `starknet call` command. [source,bash] ---- starknet call --function get_vote_status --address 0x027f4989d3cbf1654bc95f3e0083bb4542634c7cc8c7c406f17a4335fa5860a9 --account //Example output if one voted Yes 1 0 100 0 //Example output if 2 votes Yes and 1 voted No 2 1 66 33 ---- The output will display the number of \"Yes\" votes, the number of \"No\" votes, and their respective percentages. Congratulations! You've successfully deployed and interacted with a voting smart contract on Starknet! [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "enums.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"enums\"] = Enums in Cairo Contracts Enums, short for `enumeration`` are a way to define custom data types that consists of a fixed set of named values, called variants. What are enums useful for? Enums are useful for representing a collection of related values where each value is distinct and has a specific meaning. == Defining an Enum Here\u2019s an example of an enum: [source, bash] ---- enum Status{ Pending:(), Processing:(), Delivered:(), Failed:(), } ---- Unlike other languages like rust, every rust has a type. In the example above, we\u2019ve defined an enum called ProductStatus with four variants: `Pending`, `Processing`, `Delivered`, `Failed`. The naming convention is to use PascalCase for enum variants. Each variant represents a distinct value of the Status type and is associated with a unit type `()` . One variant can be instantiated using this syntax: [source, bash] ---- let status = Status::Pending(()); ---- == Enums Combined with Custom Types Enums can also be used to store more data associated with each variant. For example: [source, bash] ---- enum Message{ Quit:(), Echo:(felt252), Move:(u128,u128), } ---- In the example above, the Message enum has three variants: Quit, Echo, and Move, all with different types: - `Quit` has no data associated with it - `Echo` includes a single felt - `Move` includes two u128 values == Traits Implementation for Enums You can define traits and implement them for your custom enums, this allows you to define methods and behavior associated with the enum. Here\u2019s an example of defining a trait and implementing it. [source, bash] ---- trait Processing { fn process(self:Message); } impl ProcessingImpl of Processing { fn process(self:Message){ match self{ Message::Quit(())=>{ 'I quit'.print(); }, Message::Echo(value) =>{ value.print(); }, Message::Move((x,y)) =>{ 'moving'.print(); } } } } ---- In the example above, we implemented the Processing traits for Message .Hers is ow it could be used to process a Quit message: [source, bash] ---- let msg: Message = Message::Quit(()); msg.process(); //The code will print out: quitting ---- == The Option Enum and its Advantages: The `Option` enum represents the concept of an optional value. it has two variants: `Some: T` and `None: ()`. Some: T indicates that there's a value of type T, while None indicates the absence of a value. The `Option` enums allow you to explicitly represent the possibility of a value being absent. Using `Option` can also help prevent bugs caused by using uninitialized or unexpected `null` values. Let\u2019s take a look at the example below: [source, bash] ---- #[contract] mod Enum{ use option::OptionTrait; // This function returns how much icecream there is left in the fridge. // If it is before 10PM, there is 5 pieces left. At 10PM, someone eats them all, so there will be no more left. fn maybe_icecream(time_of_day: u32) -> Option { if time_of_day 23_u32 { Option::None(()) } else{ Option::Some(0_u32) } } } ----"}
{"title": "erc1155.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"erc721\"] = Deploying an ERC1155 == Contributing == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "erc20.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"erc20\"] = Deploying an ERC20 == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "erc721.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"erc721\"] = Deploying an ERC721 == Contributing == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "event.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"event\"] = Events in Starknet Contracts In this chapter, we will focus on events in a Starknet contract, using an extended version of the voting contract as an example. Events are a useful tool for logging and notifying external entities about specific occurrences within a contract. They emit data that can be accessed by clients. == Defining Events To define an event in a Starknet contract, you can use the **`#[event]`** attribute followed by the event definition. In our extended voting contract, we have two events, **`VoteCast`** and **`UnauthorizedAttempt`**. The **`VoteCast`** event is emitted when a vote is cast. The event takes two parameters: the voter's address and the vote value (0 for No, 1 for Yes). [source,rust] ---- [derive(Drop, starknet::Event)] struct VoteCast { voter: ContractAddress, vote: u8, } ---- The **`UnauthorizedAttempt`** event is emitted when an unauthorized attempt to vote is detected. The event takes one parameter: the address of the unauthorized caller. [source,rust] ---- #[derive(Drop, starknet::Event)] struct UnauthorizedAttempt { unauthorized_address: ContractAddress, } ---- == Emitting Events To emit an event, simply call the **`emit`** method with the appropriate event structure as an argument. In our voting contract, the **`VoteCast`** event is emitted after the vote has been processed in the **`vote`** function. [source,rust] ---- // Emit the VoteCast event after the vote has been processed self.emit(VoteCast { voter: caller, vote: vote, }); ---- Similarly, the **`UnauthorizedAttempt`** event is emitted if an unauthorized attempt to vote is detected. [source,rust] ---- // Emit the UnauthorizedAttempt event after detecting an unauthorized attempt to vote self.emit(UnauthorizedAttempt { unauthorized_address: address, }); ---- Events in Starknet contracts are not directly readable from within the contract itself. Instead, events are designed to be consumed by external off-chain entities, such as clients or other services that are listening to the contract. To get the value from an event, you need to set up an off-chain service or client to listen for the event emitted by the contract. This can be achieved using SDKs. For example, the Starknet SDK for Python provides a **`listen_for_event`** function that can be used to listen for events emitted by a contract. In following sections, we will see how to use Starknet SDKs to listen for events emitted by our voting contract.\" [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "functions.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"functions\"] = Functions and Traits in Cairo for Starknet [NOTE] ==== The Chapters in the Starknet Book explain Cairo in the Starknet context. For a deeper understanding of Cairo not necessarily applied to Starknet, please refer to the Book]. ==== In Starknet, functions serve as modular blocks of logic, allowing for code structuring and reusability. They bear similarity to Solidity's functions and contracts but feature distinctive usage and implementation traits. Functions in Cairo are declared using the `fn` keyword within an implementation block, `impl`, or with the attribute `#[constructor]`. The functions' attributes may vary, they can be `#[constructor]`, `#[generate_trait]`, or `#[external(v0)]`, depending on their function. These functions can accept arguments, return values, and interact with the contract's storage. Moreover, the function execution context can be specified in the function signature using `self: @T` or `ref self: T`. [NOTE] ==== In Cairo, function visibility is not explicitly specified. Functions are considered internal by default unless marked with the `#[external(v0)]` attribute. This is different from Solidity where visibility is defined using keywords (public, external, internal, or private). ==== The Vote contract, available in the Book's repository], is used to illustrate different types of functions in Starknet. But first, let's take a look at the traits. == Traits Traits in Starknet are used to define a group of methods that may belong to different types. They are similar to interfaces in languages like Rust, Java, and TypeScript. In our Vote contract, the `VoteTrait` trait defines the set of external methods (more below) that the contract will implement. [source,cairo] ---- #[starknet::interface] trait VoteTrait { fn get_vote_status(self: @T) -> (u8, u8, u8, u8); fn voter_can_vote(self: @T, user_address: ContractAddress) -> bool; fn is_voter_registered(self: @T, address: ContractAddress) -> bool; fn vote(ref self: T, vote: u8); } ---- In the trait definition, the `T` parameter represents the contract's state. In each method signature, the context is specified using either `self: @T` (pass-by-reference context), for functions that only need to read the state `T`, or `ref self: T` (mutable pass-by-reference context), for functions that would modify the state, `ref self: T`, of the contract. == Attributes in Cairo Functions Attributes in Cairo functions are used to specify metadata about the functions, such as their visibility or special functionality. In Starknet, the used function attributes include: - `#[constructor]`: This attribute marks a function that is used to initialize a contract's state upon deployment. - `#[external(v0)]`: Functions with this attribute are callable externally, such as from user transactions or other contracts. - `#[generate_trait]`: This attribute generates a trait based on the functions defined in the impl block. The generated trait can be used to group functions that have similar functionalities and will be internal; not callable from outside the contract. == Constructor Functions Constructor functions are defined using the `#[constructor]` attribute and are used to initialize the contract. They can only be executed once upon contract deployment. In the example contract, `constructor` sets up the initial state of the contract by registering voters and setting vote counts to 0. They can be defined directly in the contract without need of an implementation block. In this case the constructor alters the state of the contract and so it receives the state of the contract, `ContractState`, as a mutable reference to it, `ref self: ContractState`. Then it receives the rest of the arguments that need to be defined when the contract is deployed to Starknet. Note the Contract State will be automatically feed to the constructor, that is, when the contract is deployed it does not need to be defined. [source,cairo] ---- #[constructor] fn constructor( ref self: ContractState, voter_1: ContractAddress, voter_2: ContractAddress, voter_3: ContractAddress ) { self._register_voters(voter_1, voter_2, voter_3); self.yes_votes.write(0_u8); self.no_votes.write(0_u8); } ---- == External Functions External functions are defined with the `#[external(v0)]` attribute and can be invoked within the same contact or by other contracts. In the Vote contract, there are several external functions defined, for instance, `get_vote_status` returns the current voting results, and `vote` accepts a vote from a registered and eligible voter. There are two main types of external functions, which are differentiated by how they can interact with the contract's state: read functions and write functions. They should be defined in an impl block. The impl should be done for the trait that defined what external functions the contract woyld have. [source,cairo] ---- #[external(v0)] impl VoteImpl of super::VoteTrait { fn get_vote_status(self: @ContractState) -> (u8, u8, u8, u8) { // Implementation } fn vote(ref self: ContractState, vote: u8) { // Implementation } } ---- === Read Functions Read functions in Starknet are functions that interact with a contract's storage without modifying it. They are commonly used to retrieve the contract's state information. This type of function is invoked with the `self: @T` notation, which provides the function with a reference (non-modifiable) to the contract's state. In our Vote contract, the function `get_vote_status` and `voter_can_vote` are examples of read functions. The `get_vote_status` function returns the number of yes votes, no votes, and their percentages. The `voter_can_vote` function checks if a particular voter, given by their address, is eligible to vote. [source,cairo] ---- fn get_vote_status(self: @ContractState) -> (u8, u8, u8, u8) { let (n_yes, n_no) = self._get_voting_result(); let (yes_percentage, no_percentage) = self._get_voting_result_in_percentage(); return (n_yes, n_no, yes_percentage, no_percentage); } fn voter_can_vote(self: @ContractState, user_address: ContractAddress) -> bool { self.can_vote.read(user_address) } ---- ==== Write Functions Write functions, in contrast, are functions that can modify the contract's storage. They can be invoked from an external context, such as a user transaction or a call from another contract, or an internal context. The `ref self: T` notation is used to provide the function with a mutable reference to the contract's state; that is, we can modify it. The `vote` function in our Vote contract is an example of a write function. It updates the voting count based on the provided vote and sets the voter's eligibility to false. [source,cairo] ---- fn vote(ref self: ContractState, vote: u8) { assert(vote == NO || vote == YES, 'VOTE_0_OR_1'); let caller: ContractAddress = get_caller_address(); self._assert_allowed(caller); self.can_vote.write(caller, false); if (vote == NO) { self.no_votes.write(self.no_votes.read() + 1_u8); } if (vote == YES) { self.yes_votes.write(self.yes_votes.read() + 1_u8); } } ---- == Internal Functions In addition to external functions, Starknet contracts can also define internal functions. Internal functions are the default type of functions in a Starknet contract. They can be invoked only from within the contract and are primarily used to perform specific computations or actions that are used by multiple external functions. The notion of internal functions matches closely with Solidity's internal visibility. The signature of internal functions can use the **`self: @T`** or **`ref self: T`** notation, similar to external functions, depending on whether they need to read or write the contract's state. For internal functions, we can use an `impl` block annotated with `#[generate_trait]`. The `#[generate_trait]` attribute generates a trait corresponding to the functions within the block. [source, rust] ---- #[generate_trait] impl InternalFunctions of InternalFunctionsTrait { // Implementation of the internal functions } ---- We don't need to manually define a trait for these functions. The functions within this block can only be called by other functions within the contract. We can also use multiple **`impl`** blocks to better organize our internal functions. For instance, we could have separate **`impl`** blocks for vote validation, vote registration, and vote counting. This pattern of using **`impl`** blocks allows us to structure our Starknet contracts in a clean and organized manner, with a clear separation between the different types of functions and their implementations. Let's look at an example from our Vote contract. The **`_register_voters`** function is an internal function used to register voters and set their eligibility to true. Note that it can alter the contract's state. [source,cairo] ---- fn _register_voters(ref self: ContractState, voter_1: ContractAddress, voter_2: ContractAddress, voter_3: ContractAddress) { self.can_vote.write(voter_1, true); self.can_vote.write(voter_2, true); self.can_vote.write(voter_3, true); } ---- The **`_get_voting_result`** function is another internal function that calculates the total votes for 'yes' and 'no' options. It is a read function as it does not alter the contract's state. [source,cairo] ---- fn _get_voting_result(self: @ContractState) -> (u8, u8) { return (self.yes_votes.read(), self.no_votes.read()); } ---- [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "fundamentals.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"structure\"] = Fundamentals of Cairo for Starknet In this chapter, we'll review the features of the Cairo language as it pertains to Starknet, a Layer 2 solution for Ethereum. We will use a series of practical smart contract examples from voting systems to Pokemon contracts. For those seeking a more in-depth exploration of Cairo, outside its Starknet application, the ** Book]** and ** are your go-to resources. We also recommend you finish the automated workshop to get a better understanding of the structure of a smart contract, however, neither of these resources are required to understand the content of the following subchapters or the Starknet Book in general. Our journey begins with a 'Vote' contract. The Vote contract represents a straightforward demonstration of the foundational elements of a Cairo contract. It serves as an on-chain voting system, enabling a pre-defined set of voters to cast votes ('1' for 'Yes' and '0' for 'No') on a given proposal. Primarily, the Vote contract maintains a record of the count of 'Yes' and 'No' votes and offers functions that read and write from the contract's state. These functions are crucial for examining the voting status and voter eligibility. The contract is initialized with three registered voters and is deployed on the Starknet testnet. == Structure of a Cairo Contract A Cairo contract is made up of several sections, which are outlined and discussed in the Vote contract: * Imports: These represent the necessary libraries and dependencies required for the contract's operation. * Trait Interfaces: Defines the functions that can be implemented or called by the Cairo contract. They are characterized by the `#[starknet::interface]` attribute. * Contract Definition: The core part of the contract where the contract's functionalities are defined. It's marked with the `#[starknet::contract]` attribute. * Storage: It represents the state variables that the contract uses to store data. * Constructor: The function that sets the initial state of the contract. * Functions: These are categorically divided into read functions (which only fetch data from the contract's state) and write functions (which can alter the state of the contract). Both types of functions can be external (callable from outside the contract) or internal (used within the contract). * Event: An event is a way to notify the outside world about the contract's state changes. It's marked with the `#[event]` attribute. == Starknet Modules The **`mod`** keyword is used to define a module in Cairo, and modules provide a way to organize code into namespaces. In the context of Starknet, a module represents a smart contract. To declare a Starknet contract, the **`mod`** keyword is used in combination with the **`#[starknet::contract]`** attribute. The **`#[starknet::contract]`** attribute informs the compiler that the following module should be compiled as a Starknet contract. For example, here's how we declare a Starknet contract: ``` #[starknet::contract] mod Vote { // contract definition goes here } ``` In this example, **`Vote`** is the name of the Starknet contract. All the contract's storage variables, functions (constructor, external and internal), and any associated `impl` are defined within this module. The contract can then be deployed to the Starknet network, where it will have its own unique contract address and state, and its functions can be called by users and other contracts in the network. === Functions Functions in Cairo contracts are defined within implementation blocks (`impls`), except for the constructor (more in following subchapters): * External functions are prefixed with `#[external(v0)]` and defined in an `impl` block for the interface trait (`VoteTrait` in our example). These functions can be called from outside the contract and can modify the contract's state if necessary. * Internal functions are defined in `impl` blocks marked with `#[generate_trait]`. These functions are helper functions and can only be called by other functions within the contract. The Vote contract provides an example of these principles, featuring a clear division between functions that read data (`get_vote_status`, `voter_can_vote`, `is_voter_registered`) and those that write data (`vote`). Note: The `VoteTrait` in our example outlines the primary interface of the Vote contract, providing a blueprint for the external functions that the contract can perform. Here is the Vote contract's code, however, we will break down the code in the following subchapters: [source,rust] ---- /// The Contract Class Hash is 0x8873aa28af0a0e6ac6aa647aa8e8c02cea7752bb7950284dbbbae1be35e9cb /// The contract is deployed on the Starknet testnet. The contract address is 0x056d42ddcc1c85959989aaef369e284804a8e59cc5ce519e579fcb121b18f724 /// @dev Core Library Imports for the Traits outside the Starknet Contract use starknet::ContractAddress; /// @dev Trait defining the functions that can be implemented or called by the Starknet Contract #[starknet::interface] trait VoteTrait { /// @dev Function that returns the current vote status fn get_vote_status(self: @T) -> (u8, u8, u8, u8); /// @dev Function that checks if the user at the specified address is allowed to vote fn voter_can_vote(self: @T, user_address: ContractAddress) -> bool; /// @dev Function that checks if the specified address is registered as a voter fn is_voter_registered(self: @T, address: ContractAddress) -> bool; /// @dev Function that allows a user to vote fn vote(ref self: T, vote: u8); } /// @dev Starknet Contract allowing three registered voters to vote on a proposal #[starknet::contract] mod Vote { use starknet::ContractAddress; use starknet::get_caller_address; const YES: u8 = 1_u8; const NO: u8 = 0_u8; /// @dev Structure that stores vote counts and voter states #[storage] struct Storage { yes_votes: u8, no_votes: u8, can_vote: LegacyMap::, registered_voter: LegacyMap::, } /// @dev Contract constructor initializing the contract with a list of registered voters and 0 vote count #[constructor] fn constructor( ref self: ContractState, voter_1: ContractAddress, voter_2: ContractAddress, voter_3: ContractAddress ) { // Register all voters by calling the _register_voters function self._register_voters(voter_1, voter_2, voter_3); // Initialize the vote count to 0 self.yes_votes.write(0_u8); self.no_votes.write(0_u8); } /// @dev Event that gets emitted when a vote is cast #[event] #[derive(Drop, starknet::Event)] enum Event { VoteCast: VoteCast, UnauthorizedAttempt: UnauthorizedAttempt, } /// @dev Represents a vote that was cast #[derive(Drop, starknet::Event)] struct VoteCast { voter: ContractAddress, vote: u8, } /// @dev Represents an unauthorized attempt to vote #[derive(Drop, starknet::Event)] struct UnauthorizedAttempt { unauthorized_address: ContractAddress, } /// @dev Implementation of VoteTrait for ContractState #[external(v0)] impl VoteImpl of super::VoteTrait { /// @dev Returns the voting results fn get_vote_status(self: @ContractState) -> (u8, u8, u8, u8) { let (n_yes, n_no) = self._get_voting_result(); let (yes_percentage, no_percentage) = self._get_voting_result_in_percentage(); return (n_yes, n_no, yes_percentage, no_percentage); } /// @dev Check whether a voter is allowed to vote fn voter_can_vote(self: @ContractState, user_address: ContractAddress) -> bool { self.can_vote.read(user_address) } /// @dev Check whether an address is registered as a voter fn is_voter_registered(self: @ContractState, address: ContractAddress) -> bool { self.registered_voter.read(address) } /// @dev Submit a vote fn vote(ref self: ContractState, vote: u8) { assert(vote == NO || vote == YES, 'VOTE_0_OR_1'); let caller: ContractAddress = get_caller_address(); self._assert_allowed(caller); self.can_vote.write(caller, false); if (vote == NO) { self.no_votes.write(self.no_votes.read() + 1_u8); } if (vote == YES) { self.yes_votes.write(self.yes_votes.read() + 1_u8); } self.emit(VoteCast { voter: caller, vote: vote, }); } } /// @dev Internal Functions implementation for the Vote contract #[generate_trait] impl InternalFunctions of InternalFunctionsTrait { /// @dev Registers the voters and initializes their voting status to true (can vote) fn _register_voters( ref self: ContractState, voter_1: ContractAddress, voter_2: ContractAddress, voter_3: ContractAddress ) { self.registered_voter.write(voter_1, true); self.can_vote.write(voter_1, true); self.registered_voter.write(voter_2, true); self.can_vote.write(voter_2, true); self.registered_voter.write(voter_3, true); self.can_vote.write(voter_3, true); } } /// @dev Asserts implementation for the Vote contract #[generate_trait] impl AssertsImpl of AssertsTrait { // @dev Internal function that checks if an address is allowed to vote fn _assert_allowed(ref self: ContractState, address: ContractAddress) { let is_voter: bool = self.registered_voter.read((address)); let can_vote: bool = self.can_vote.read((address)); if (can_vote == false) { self.emit(UnauthorizedAttempt { unauthorized_address: address, }); } assert(is_voter == true, 'USER_NOT_REGISTERED'); assert(can_vote == true, 'USER_ALREADY_VOTED'); } } /// @dev Implement the VotingResultTrait for the Vote contract #[generate_trait] impl VoteResultFunctionsImpl of VoteResultFunctionsTrait { // @dev Internal function to get the voting results (yes and no vote counts) fn _get_voting_result(self: @ContractState) -> (u8, u8) { let n_yes: u8 = self.yes_votes.read(); let n_no: u8 = self.no_votes.read(); return (n_yes, n_no); } // @dev Internal function to calculate the voting results in percentage fn _get_voting_result_in_percentage(self: @ContractState) -> (u8, u8) { let n_yes: u8 = self.yes_votes.read(); let n_no: u8 = self.no_votes.read(); let total_votes: u8 = n_yes + n_no; let yes_percentage: u8 = (n_yes * 100_u8) / (total_votes); let no_percentage: u8 = (n_no * 100_u8) / (total_votes); return (yes_percentage, no_percentage); } } } ---- Before we proceed with the Vote contract, let's get an understanding of types and imports. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "imports.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"imports\"] = Imports in Cairo Imports in Cairo play an essential role in organizing and structuring your code, allowing you to reuse functionality from other modules and libraries. If you are familiar with Rust, you will find Cairo's import system quite similar. Cairo comes with a core library, known as `corelib`, which contains essential modules and functionalities like `starknet` and `array`. You can refer to the Cairo documentation for more details on `corelib`. Importing these core libraries does not require any additional installation, as they are built-in. To import modules, functions, or types in Cairo, you can use the `use` keyword, followed by the path to the item you want to import. In the example provided, we have an `Ex01` module, and we are importing several items from the `corelib` and custom modules (as example, we are using the repository]): [source,rust] ---- mod Ex01 { // Core Library imports use starknet::get_caller_address; use starknet::ContractAddress; // Internal imports use starknet_cairo_101::ex00_base::Ex00Base::validate_exercise; use starknet_cairo_101::ex00_base::Ex00Base::ex_initializer; use starknet_cairo_101::ex00_base::Ex00Base::distribute_points; use starknet_cairo_101::ex00_base::Ex00Base::update_class_hash_by_admin; } ---- We are importing `get_caller_address` and `ContractAddress` from the starknet core library. Additionally, we are importing custom modules from the `starknet_cairo_101::utils` repository, making them part of the `Ex01` contract's set of functions. It is important to take into account the structure of the repository and the path to the modules you want to import. The file structure of the `starknet_cairo_101` repository is as follows: [source] ---- . \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 ex01.cairo \u2502 \u251c\u2500\u2500 utils.cairo \u2502 \u251c\u2500\u2500 lib.cairo \u2502 \u251c\u2500\u2500 ... \u2502 \u251c\u2500\u2500 utils \u2502 \u2502 \u251c\u2500\u2500 ex00_base.cairo ---- Inside the `utils` folder, we have the `ex00_base.cairo` file, which contains the `Ex00Base` module. At the same time, we create a cairo file of the same name as the utils directory, `utils.cairo`, with the following code: [source,rust] ---- mod ex00_base; ---- Here we are referring to the `ex00_base.cairo` library. Every time we want to import a module (cairo file) from the `utils` folder, we will add the following line to the `utils.cairo` file: [source,rust] ---- mod NAME_OF_MODULE; ---- Additionally, the file library `lib.cairo` contains the following code: [source,rust] ---- // Utils module mod utils; // Contracts mod ex01; ---- These are the paths we will use to import the `utils` and `ex01` modules. The `lib.cairo` file is the entry point for the Cairo compiler, and it is the file we will use to import all the modules we want to use in our contract. Every time we want to import a module, we will add the following line to the `lib.cairo` file: [source,rust] ---- mod NAME_OF_MODULE; ---- To import custom modules or external libraries not included in `corelib`, you will need to have the necessary files within your project repository or specify the appropriate paths. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "index.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"index\"] = Smart Contracts in Cairo As we delve into the world of Starknet, we find that the platform relies on a powerful and expressive programming language called Cairo. Designed specifically for scaling decentralized applications (dApps) using STARKs, Cairo is a Turing-complete language that enables developers to harness the power of highly efficient and scalable zero-knowledge proofs. In this chapter, we will explore Cairo in the context of Starknet. We will learn about the core concepts of Cairo, its differences from Solidity, the structure and components of Cairo smart contracts, and the unique features of the Starknet network. By the end of this chapter, you will have a comprehensive understanding of the fundamental concepts and components of Cairo, enabling you to build robust and efficient smart contracts on Starknet. == What Is a Cairo Smart Contract? In the Starknet ecosystem, the term _smart contract_ refers to immutable computer programs that run deterministically within the context of a Starknet Operating System. These programs are written in the Cairo language and are deployed on Starknet. Let\u2019s break down the key aspects of Cairo smart contracts: Computer programs:: Cairo smart contracts are simply computer programs, designed to execute within the context of Starknet. Immutable:: Once deployed, the code of a Cairo smart contract cannot change. Just as with Ethereum smart contracts, the only way to modify a Cairo smart contract is to deploy a new instance. Deterministic:: The outcome of the execution of a Cairo smart contract is the same for everyone who runs it, given the context of the transaction that initiated its execution and the state of the Starknet network at the moment of execution. Starknet Operating System context:: Cairo smart contracts operate within the context of a Starknet Operating System (Starknet OS). They can access their own state, the context of the transaction that called them, and some information about the most recent blocks. == Solidity vs. Cairo: Overcoming Limitations and Embracing Scalability While Solidity is a widely adopted language for smart contract development and supports a range of applications, it was not designed for provable computation. As a result, compilers that translate idiomatic Solidity code into proofs encounter several challenges: 1. Reliance on inefficient data structures, such as uint256, and operations on them 2. Mutability at the language level 3. Lack of efficient built-ins 4. No low-level access In practice, there are two different technologies for proving general programs: SNARKs and STARKs. Instruction sets favored by SNARKs are better suited as a compilation target for languages like Solidity. However, STARKs offer more scalability while having a less natural instruction set. This means that Solidity can be efficiently encoded to SNARKs but not as optimally to STARKs, as constructs common in Solidity are \"costly\" for STARKs. Cairo addresses these limitations and offers more efficient solutions: 1. A low-level field data type called \"felt252\" is available, alongside a several types of uints 2. Cairo is idiomatically write-once, resembling a functional programming language 3. Cairo provides full low-level access to underlying primitives Although the ecosystem tools are still maturing, it is essential to transcend existing limitations and build better composable applications. Cairo's focus on overcoming Solidity's limitations in provable computation and embracing the scalability of STARKs makes it a more suitable choice for developers looking to create the next generation of decentralized applications. == Programming in Cairo One of the key inspirations for Cairo's syntax is Rust, a popular systems programming language known for its performance, reliability, and strong focus on safety. Developers familiar with Rust will find it easy to transition to Cairo, as many of the language's features and concepts are similar. However, even if you are not familiar with Rust, learning Cairo is still a straightforward process. The language is designed with simplicity and clarity in mind, making it accessible to developers with varying levels of experience. As you delve into Cairo, you'll discover a growing community of passionate developers who are constantly creating new educational materials, tools, and resources to make the learning experience as smooth as possible for newcomers. This ecosystem continues to grow and thrive. Each week, new materials and tooling are developed to help both experienced programmers and beginners alike to learn, understand, and build with Cairo. In the following sections, we will explore the core concepts and components of Cairo. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "kakarot.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"kakarot\"] = Cairo and the Ethereum Virtual Machine: The Kakarot ZKEVM == What is Kakarot? Kakarot is a groundbreaking zkEVM (Zero-Knowledge Ethereum Virtual Machine) built on the CairoVM. Overall, it aims to present to developers an abstraction layer they're familiar with: the EVM. === Introduction Kakarot is meant for developers to build and deploy as if they were working on Ethereum: its purpose is to allow Solidity contracts to be forward compatible with Starknet and the CairoVM. The project plans to bring **EVM compatibility** to Starknet and build a *zkRollup-as-a-service tool*. It began in October 2022 and aims to create an open-source, provable zkEVM in Cairo, with a concise codebase. It is designed with the belief that the CairoVM will provide the best zero-knowledge toolbox in the coming years and that the Ethereum network effect will remain dominant in the meantime. In a remarkable display of skill and dedication, the Kakarot team achieved an impressive milestone (with the support of the Starknet Foundation and the collaborative efforts of over 40 unique contributors) by implementing 100% of EVM opcodes and 8 out of 9 EVM precompiles in just six months and with less than 5,000 lines of code! Kakarot is on track to become a type 2.5 zkEVM (as per Buterin's typology]), offering compatibility with existing EVM code. Its innovative solution combines the benefits of zero-knowledge cryptography and the efficiency of the EVM, paving the way for scalable and secure decentralized applications. In simple words, Kakarot allows developers to easily and seamlessly run Ethereum smart-contracts written in Solidity on Starknet, **without requiring any modifications to their code**! ==== Note that Kakarot is currently a work in progress - not yet ready for production. The testnet version is expected to be released at the end of summer 2023\u2026 Stay tuned! === Project Architecture image::Kakarot-architecture.png[] * Kakarot is a smart contract, currently deployed on Starknet (goerli testnet). It is written in Cairo. * Kakarot is an EVM bytecode interpreter. * Kakarot can: .. execute arbitrary EVM bytecode, .. deploy an EVM smart contract as is, .. call a Kakarot-deployed EVM smart contract's functions (views and write methods). * Kakarot is not a blockchain. * Kakarot is not a compiler: it will not convert your Solidity code into Cairo code (check out for a Solidity -> Cairo transpiler). == Exploring some Use cases of Kakarot === Allowing already-existing Ethereum smart-contracts to be ran on Starknet Despite Starknet running on the CairoVM instead of the EVM, thanks to Kakarot zkRollup-as-a-service tool, any Solidity smart-contract deployed on Ethereum will be able to be ran on Starknet without any change of its code. This means that the decentralized applications that are already running on Ethereum will be able to be ran on Starknet very easily, allowing their users to take advantage of both the efficiency of the EVM and the benefits of zero-knowledge cryptography. Thus, Kakarot will massively reduce the time to migrate any existing Solidity smart-contract to Starknet: instead of re-writing your whole protocol from Solidity to Cairo, you will just have to use Kakarot to run your Solidity contract in the CairoVM. It's that simple! === Allowing Solidity blockchain developers to deploy provable contracts on Starknet without learning Cairo Perhaps one does not necessarily wishes to learn a whole new language just for a tiny side project, for example. In that case, even though Cairo is, for many different reasons, wonderful language] thanks to Kakarot, developers will not be totally obligated to learn Cairo in order to create and deploy smart-contracts on Starknet: they will have the possibility to make their Solidity smart-contracts become provable and will also be able to be ran them on Starknet with no effort! == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "loops.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"loops\"] = Loops in Cairo == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "openzeppelin.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"openzeppelin\"] = Open Zeppelin == Contributing == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "scarb.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"scarb\"] = Scarb and the Structure of a Cairo Project Scarb is the Cairo package manager specifically created to streamline your Cairo and Starknet development process. Scarb is capable of managing project dependencies, compiling projects (both pure Cairo and Starknet contracts), downloading the necessary libraries, building these libraries, and integrating seamlessly with other essential development tools such as Protostar. == Integrating Scarb into Your Development Workflow The steps below illustrate a typical workflow in developing a Starknet contract using Scarb: 1. **Initializing the Project:** Start by running `scarb new` to create a new project. This command will automatically generate the project's basic structure, including a `Scarb.toml` configuration file and an initial `src/lib.cairo` file. 2. **Developing the Contract:** Write your Cairo code and store it in the `src` directory. 3. **Managing Dependencies:** If your contract depends on external libraries, use `scarb add` to effortlessly include these dependencies in your project. 4. **Compiling the Contract:** Run `scarb build` to compile your contract into Sierra code. This resulting code can then be examined further, or used as input for other tools or processes. 5. **Automating Tasks with Custom Scripts:** Take advantage of the `[scripts]` feature in `Scarb.toml` to define custom scripts that automate common tasks or consolidate multiple commands into a single command. By integrating Scarb into your workflow, you leverage its features to make your development process more efficient and manageable. == Installation Scarb is compatible with macOS, Linux, and Windows operating systems. === macOS and Linux For macOS and Linux users, open your terminal and execute the following command: [source, bash] ---- $ curl --proto '= --tlsv1.2 -sSf | sh ---- If you wish to install a specific version of Scarb, such as a preview version, use this command instead: [source, bash] ---- $ curl --proto '= --tlsv1.2 -sSf | bash -s -- -v 0.2.0-alpha.2 ---- === Windows Scarb's installation on Windows requires manual setup. Follow the steps below to install Scarb on Windows: - Download the release archive matching your operating system and CPU architecture from the Scarb website] or the Github repository]. Make sure to select the most recent version. - Extract the downloaded file to your desired location, for instance, `%LOCALAPPDATA%\\Programs\\scarb`. - Add the path to the `scarb/bin` directory to your `PATH` environment variable. - Confirm the installation by running `scarb --version` in a new terminal. The output should indicate both the Scarb and Cairo language versions. [source, bash] ---- $ scarb --version scarb 0.3.0 (182a9019d 2023-05-29) cairo: 1.1.0 ( ---- If you encounter any issues with Scarb, please open an issue on the starknetbook repository. == Structure of a Cairo Project A Cairo project includes several crucial components that help create and manage a smart contract. Let's explore each part in detail. === Cairo Packages Cairo packages, also referred to as \"crates\" in some contexts, are the building blocks of a Cairo project. Each package must follow several rules: * A package must include a `Scarb.toml` file, which is Scarb's manifest file. It contains the dependencies for your package. * A package must include a `src/lib.cairo` file, which is the root of the package tree. It allows you to define functions and declare used modules. Package structures might look like the following: [source,bash] ---- my_package/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 module1.cairo \u2502 \u251c\u2500\u2500 module2.cairo \u2502 \u2514\u2500\u2500 lib.cairo \u2514\u2500\u2500 Scarb.toml ---- Within the `Scarb.toml` file, you might have: [source,toml] ---- [package] name = \"my_package\" version = \"0.1.0\" [dependencies] other_package = { path = \"../other_package\" } ---- == Setting Up a Project with Scarb To create a new project using Scarb, navigate to your desired project directory and execute the following command: [source, bash] ---- $ scarb new hello_scarb ---- This command will create a new project directory named `hello_scarb`, including a `Scarb.toml` file, a `src` directory with a `lib.cairo` file inside, and initialize a new Git repository with a `.gitignore` file. [source, bash] ---- hello_scarb/ \u251c\u2500\u2500 src/ \u2502 \u2514\u2500\u2500 lib.cairo \u2514\u2500\u2500 Scarb.toml ---- Upon opening `Scarb.toml` in a text editor, you should see something similar to the code snippet below: [source, bash] ---- [package] name = \"hello_scarb\" version = \"0.1.0\" # See more keys and their definitions at [dependencies] # foo = { path = \"vendor/foo\" } ---- == Understanding Scarb.toml The `Scarb.toml` file uses [TOML]( an easy-to-read configuration format. * `[package]`: This section carries information about your project. ** `name`, `version`: These keys set your program's name and the Scarb version to use for compilation. * `[dependencies]`: This section is designed for listing your project\u2019s dependencies. == Building a Scarb Project Clear all content in `src/lib.cairo` and replace with the following: [source, rust] ---- // src/lib.cairo mod hello_scarb; ---- Next, create a new file titled `src/hello_scarb.cairo` and add the following: [source, rust] ---- // src/hello_scarb.cairo use debug::PrintTrait; fn main() { 'Hello, Scarb!'.print(); } ---- In this instance, the `lib.cairo` file contains a module declaration referencing 'hello_scarb', which includes the 'hello_scarb.cairo' file's implementation. For more on modules, imports, and the `lib.cairo` file, please refer to the subchapter on imports in Chapter 2. Scarb mandates that your source files be located within the `src` directory, while the top-level project directory is designated for README files, license information, configuration files, and any other non-code content. To build your project from your `hello_scarb` directory, use the following command: [source, bash] ---- scarb build ---- This command compiles your project and produces the Sierra code in the `target/dev/hello_scarb.sierra` file. Sierra serves as an intermediate layer between high-level Cairo and compilation targets such as Cairo Assembly (CASM). To understand more about Sierra, check out this To remove the build artifacts and delete the target directory, use the `scarb clean` command. The resulting Sierra code file will be located in the `target/release/` directory. To run your Cairo program, execute the following command: [source, bash] ---- $ cairo-run src/lib.cairo [DEBUG] Hello, Scarb! (raw: 5735816763073854913753904210465) Run completed successfully, returning [] ---- In case you encounter this error: [source,bash] ---- error: Found argument 'src/lib.cairo' which wasn't expected, or isn't valid in this context Usage: cairo-run [OPTIONS] --path ---- You need to have Cairo the most recent version of Cairo installed. To install Cairo, review the setup section subsection on 1]. Alternatively, you could try running: [source, bash] ---- $ cairo-run --path src/lib.cairo ---- === Defining Custom Scripts Scarb scripts can be defined in the `Scarb.toml` file, which can then be utilized to execute custom shell scripts. You can add the following line to your `Scarb.toml` file: [source, toml] ---- [scripts] run-lib = \"cairo-run src/lib.cairo\" ---- Now, running the command `scarb run run-lib` will output [source, bash] ---- [DEBUG] Hello, Scarb! (raw: 5735816763073854913753904210465) Run completed successfully, returning [] ---- Using `scarb run` offers a convenient method for executing custom shell scripts. This can be extremely useful for running files and testing your project. === Adding Dependencies Scarb facilitates the seamless management of dependencies for your Cairo packages. Here are two methods to add dependencies to your project: * Edit Scarb.toml File Open the Scarb.toml file in your project directory and locate the `[dependencies]` section. If it doesn't exist, add it. To include a dependency hosted on a Git repository, use the following format: [source, toml] ---- [dependencies] alexandria_math = { git = \" } ---- For consistency, it's recommended to pin Git dependencies to specific commits. This can be done by adding the `rev` field with the commit hash: [source, toml] ---- [dependencies] alexandria_math = { git = \" rev = \"81bb93c\" } ---- After adding the dependency, remember to save the file. * Use the scarb add Command Alternatively, you can use the `scarb add` command to add dependencies to your project. Open your terminal and execute the following command: [source, bash] ---- $ scarb add alexandria_math --git ---- This command will add the alexandria_math dependency from the specified Git repository to your project. To remove a dependency, you can use the `scarb rm` command. Once a dependency is added, the Scarb.toml file will be automatically updated with the new dependency information. === Using Dependencies in Your Code After dependencies are added to your project, you can start utilizing them in your Cairo code. For example, let\u2019s assume you have added the alexandria_math dependency. Now, you can import and utilize functions from the alexandria_math library in your `src/hello_scarb.cairo` file: [source, rust] ---- // src/hello_scarb.cairo use alexandria_math::fibonacci; fn main() -> felt252 { fibonacci::fib(0, 1, 10) } ---- In the above example, we import the fibonacci function from the alexandria_math library and utilize it in the main function. === Recap Let's recap what we've learned about Scarb: * The `scarb new` command can be used to create a new project. * The `scarb build` command can be used to build a project and generate the compiled Sierra code. * Custom scripts can be defined in the `Scarb.toml` file and executed using the `scarb run` command. * Dependencies for our Cairo packages can be managed easily. We've covered the basics of the Scarb package manager and its role in the Starknet ecosystem. By integrating Scarb into your workflow, you can take advantage of its powerful features to simplify and streamline your Cairo development process. == Scarb Cheat Sheet Here's a quick cheat sheet of some of the most commonly used Scarb commands: * `scarb new `: Initialize a new project with the given project name. * `scarb build`: Compile your Cairo code into Sierra code. * `scarb add --git `: Add a dependency to your project from a specified Git repository. * `scarb rm `: Remove a dependency from your project. * `scarb run `: Run a custom script defined in your `Scarb.toml` file. Scarb is a versatile tool, and this is just the beginning of what you can achieve with it. As you gain more experience in the Cairo language and the Starknet platform, you'll discover how much more you can do with Scarb. To stay updated on Scarb and its features, be sure to check the Scarb documentation] regularly. Happy coding! [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "security_considerations.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"security_considerations\"] = Security Considerations in Cairo When working with any blockchain programming language, it's crucial to be aware of potential vulnerabilities in smart contracts in order to protect your projects from threats that could compromise the trust users place in your systems. Cairo is no exception. This chapter will explain some common security issues and vulnerabilities specific to Starknet and Cairo, and provide recommendations on how to prevent them from affecting your contracts. Contributions to this chapter are welcome. If you have any suggestions, please submit a pull request to the repo]. [NOTE] ==== Please note that some of the code examples provided in this chapter are written in pseudo-code for the sake of simplicity and clarity when explaining the concepts. They are not meant to be used in production. ==== == 1. Access Control Access control vulnerabilities arise when a smart contract's functions are inadequately secured, allowing unauthorized users to perform actions that should be restricted. This can lead to unintended smart contract behavior and manipulation of sensitive data. For example, consider a smart contract that handles token minting without proper access control: [source,rust] ---- #[external] fn mint_tokens(amount: u256) { total_supply::write(total_supply::read() + amount); } ---- In this example, any user can call the `mint_tokens` function and mint new tokens, potentially leading to an exploit or manipulation of the token supply. To mitigate access control vulnerabilities, implement proper authorization mechanisms such as role-based access control (RBAC) or ownership checks. You can create your own custom solution or use existing templates like those provided by In the example above, we can add an owner variable, set the owner value in the constructor, and add an assert condition in the `mint_tokens` function to ensure that only the owner can mint new tokens. [source,rust] ---- struct Storage { owner: ContractAddress, } #[constructor] fn constructor() { let sender = get_caller_address(); owner::write(sender); } #[external] fn mint_tokens(amount: u256) { let sender = get_caller_address(); assert(sender == owner::read()); total_supply::write(total_supply::read() + amount); } ---- By implementing proper access control, you can ensure that your smart contract functions are only executed by authorized parties, reducing the risk of unauthorized manipulation. **Recommendation** To mitigate access control vulnerabilities, implement proper authorization mechanisms such as role-based access control (RBAC) or ownership checks. You can create your own custom solution or use existing templates like those provided by In the example above, we can add an owner variable, set the owner value in the constructor, and add an assert condition in the `mint_tokens` function to ensure that only the owner can mint new tokens. [source,rust] ---- struct Storage { owner: ContractAddress, } #[constructor] fn constructor() { let sender = get_caller_address(); owner::write(sender); } #[external] fn mint_tokens(amount: u256) { let sender = get_caller_address(); assert(sender == owner::read()); total_supply::write(total_supply::read() + amount); } ---- By implementing proper access control, you can ensure that your smart contract functions are only executed by authorized parties, reducing the risk of unauthorized manipulation. == 2. Reentrancy Reentrancy vulnerabilities occur when a smart contract's function calls an external contract before updating its internal state, allowing the external contract to recursively call the initial function before it has completed execution. For example, consider a game contract where whitelisted addresses can mint an NFT sword and execute an `on_receive_sword()` function to use it before returning it to the contract. However, the NFT contract is vulnerable to reentrancy attacks, allowing an attacker to mint multiple NFT swords. [source,rust] ---- #[constructor] fn constructor() { available_swords::write(100); } #[external] fn mint_one_sword() { let sender = get_caller_address(); if whitelisted::read(sender) == true { // Update sword count let sword_count = available_swords::read(); available_swords::write(sword_count - 1); // Mint one sword to caller sword::write(sender, 1); // Callback to sender let callback = ICallerDispatcher { contract_address: sender }.on_receive_sword(); // Remove sender from whitelist whitelisted::write(sender, false); } } ---- An attacker's contract can implement the `on_receive_sword` function to exploit the reentrancy vulnerability and mint multiple swords: [source,rust] ---- #[external] fn on_receive_sword() { let nft_sword_contract = get_caller_address(); let call_number: felt252 = total_calls::read(); total_calls::write(call_number + 1); if call_number felt252 { // Assign max felt252 value = 2^251 + 17 * 2^192 let max: felt252 = 3618502788666131106986593281521497120414687020801267626233049500247285301248 + 17 * 6277101735386680763835789423207666416102355444464034512896; return (max + 3); } #[view] fn underflow_felt252() -> felt252 { let min: felt252 = 0; // Assign max felt252 value = 2^251 + 17 * 2^192 let substract = (3618502788666131106986593281521497120414687020801267626233049500247285301248 + 17 * 6277101735386680763835789423207666416102355444464034512896); return (min - substract); } ---- We will get wrong values: image::sec_over_felt.png[felt252] **Recommendation.** To avoid incorrect results, *use protected data types*: Utilize data types like `u128` or `u256` that are designed to handle overflows and underflows. Here's an example of how to use the `u256` data type to handle overflow and underflow: [source,rust] ---- #[view] fn overflow_u256() -> u256 { let max_u128: u128 = 0xffffffffffffffffffffffffffffffff_u128; let max: u256 = u256 { low: max_u128, high: max_u128 }; // Assign max u256 value let three: u256 = u256 { low: 3_u128, high: 0_u128 }; // Assign 3 value return (max + three); } #[view] fn underflow_u256() -> u256 { let min: u256 = u256 { low: 0_u128, high: 0_u128 }; // Assign 0 value let three: u256 = u256 { low: 3_u128, high: 0_u128 }; // Assign 3 value return (min - three); } ---- Executing these functions will revert the transaction if an overflow is detected: image::sec_over_u256.png[u256] image::sec_over_u256.png[u256] * *Failure reasons for u256*: - `0x753235365f616464204f766572666c6f77=u256_add Overflow` - `0x753235365f737562204f766572666c6f77=u256_sub Overflow` Similarly, the `u128` data type can be used to handle overflow and underflow: [source,rust] ---- #[view] fn overflow_u128() -> u128 { let max: u128 = 0xffffffffffffffffffffffffffffffff_u128; // Assign max u128 value return (max + 3_u128); } #[view] fn underflow_u128() -> u128 { let min: u128 = 0_u128; return (min - 3_u128); } ---- If an overflow or underflow occurs, the transaction will be reverted with a corresponding failure reason: image::sec_over_u128.png[u128] image::sec_over_u128.png[u128] * *Failure reasons for u128*: - `0x753132385f616464204f766572666c6f77=u128_add Overflow` - `0x753132385f737562204f766572666c6f77=u128_sub Overflow` == 5. Private Data On-Chain. In some cases, a smart contracts may needs to store secret values that can't be revelead to users, however this is not possible if you store data on chain because all stored data is public and can be retrieved even if you don't publish your code. In the next example, our smart contract will use a contructor parameter to set a password (12345678) and store it on chain: [source,rust] ---- #[contract] mod StoreSecretPassword { struct Storage { password: felt252, } #[constructor] fn constructor(_password: felt252) { password::write(_password); } } ---- image::sec_priv01.png[deploy] Then, understanding how layout,window=_blank] works in Cairo, let's build a script to read stored smart contract variables: [source,javascript] ---- import {Provider, hash} from 'starknet'; const provider = new Provider({ sequencer: { network: 'goerli-alpha' // or 'goerli-alpha' } }) var passHash = hash.starknetKeccak(\"password\"); console.log(\"getStor=\",await provider.getStorageAt('0x032d0392eae7440063ea0f3f50a75dbe664aaa1df76b4662223430851a113369',passHash,812512)) ---- And we will get the stored value (hex value of 12345678): image::sec_priv02.png[getStorage] Also, in a block explorer we can go to the deploy transaction and watch deployed parameters values: image::sec_priv03.png[block_explorer] **Recommendation.** If your smart contract needs to store private data on chain, then you must use off chain encryption before to send data to the blockchain or may explore some alternatives like using hashes, merkle trees or commit-reveal patterns. == Call for Contributions: Additional Vulnerabilities We've covered a few common vulnerabilities in Cairo smart contracts, but there are several more security considerations that developers should be aware of. We are currently seeking contributions from the community to expand this chapter and cover more vulnerabilities, as listed in our To-Do section: - Storage Collision - Flash Loan Attacks - Oracle Manipulation - Bad Randomness - Denial of Service - Untrusted Delegate Calls - Public Burn If you have expertise in any of these areas, we encourage you to contribute to this chapter by adding explanations and examples of the respective vulnerabilities. Your contributions will help educate and inform the Starknet and Cairo developer community, promoting the creation of more secure and robust smart contracts. Please submit your contributions through the of the Book] on GitHub or reach out to us directly via our communication channels (default espejelomar on Telegram). Thank you for your support in making the Starknet ecosystem safer and more secure for all developers and users. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "storage.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"storage\"] = Storage in Cairo The \"Storage\" section in a Starknet contract defines the persistent data that will be stored on the blockchain and accessible by the contract functions. This data represents the state of the contract and can be manipulated throughout the contract's lifecycle. In Starknet, you define a struct and annotate it with **`#[storage]`** to represent the contract's storage. The struct can contain scalar types like **`u8`** or **`felt252`**, as well as collections like **`LegacyMap`**. The **`LegacyMap`** in Starknet is similar to a mapping in Solidity, allowing you to associate keys with values. However, unlike Solidity where you use the **`mapping`** keyword to declare a mapping, in Starknet you declare it within a struct and use the **`LegacyMap`** type. Here's the storage struct for the Vote contract: [source,rust] ``` #[storage] struct Storage { yes_votes: u8, no_votes: u8, can_vote: LegacyMap::, registered_voter: LegacyMap::, } ``` In this struct: - **`yes_votes`** and **`no_votes`** are **`u8`** (unsigned 8-bit integer) variables to store the number of yes and no votes respectively. - **`can_vote`** and **`registered_voter`** are **`LegacyMap`**s that map each registered voter's **`ContractAddress`** to a **`bool`** value. For **`can_vote`**, the **`bool`** value indicates whether the voter is allowed to vote (true) or not (false). For **`registered_voter`**, it represents whether the voter is registered (true) or not (false). To read and write to the storage, you use the read and write methods on the `self` variable, which is a reference to the contract state. For instance, to check if a voter is registered, you can do (note the double parentheses): [source,rust] ``` let is_voter: bool = self.registered_voter.read((address)); ``` To register a voter, you can do (no need for double parentheses): [source,rust] ``` self.registered_voter.write(voter_address, true); ``` Here are some key points about how Cairo for Starknet handles storage: 1. Cairo uses a **`struct`** to define the storage, unlike Solidity which uses state variables and mappings directly within the contract. 2. Cairo employs the **`LegacyMap`** type to create a mapping, while Solidity uses the **`mapping`** keyword. 3. Cairo accesses storage fields using the **`read`** and **`write`** methods on the storage variable. In contrast, Solidity uses assignment and indexing to access storage fields. 4. Variables in Starknet are stored in memory according to their name rather than their type or their order of declaration. For more details, please refer to the **[ documentation]. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "strings.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"strings\"] = Strings in Cairo Cairo currently has limited support for strings, which makes it challenging to work with long strings. However, you can use short strings in your Cairo contracts, as we did in the example]. These short strings are ultimately converted into `felt252`. == Working with Short Strings As we mentioned, Cairo can handle only short strings, like 'Wrong pokemon' in our Pok\u00e9mon contract. Keep in mind that, unlike other programming languages, Cairo doesn't have built-in support for string manipulation or complex string operations. [source, rust] ---- fn index_pokemon_array() { let mut pokemons: Array = create_pokemon_array(); assert(*pokemons.get(0_usize).unwrap().unbox() == 'Pikachu', \"Wrong pokemon\"); assert(*pokemons.at(1_usize) == 'Charmander', \"Wrong pokemon\"); } ---- In this example: * The short strings 'Pikachu', 'Charmander', and 'Wrong pokemon' are used in the code. This is how the short strings are converted into `felt252`: * 'Pikachu' is converted into: 22633908053174389. * 'Charmander' is converted into: 318324037530966278038898. * 'Wrong pokemon' is converted into: 6928266141989273178278057570158. Currently, when coding with Cairo we need to constantly be converting between felt252s and strings. You can use the Utils] converter for this. image::starkutils.png[starkutils] This is a tedious process, which the Cairo community is improving in the near the future. == Conclusion and Summary In this chapter, we explored strings in Cairo and learned about their limitations. As a quick recap: * *Short strings*: Cairo can handle only short strings, which can be used directly in your contracts. * *Conversion to felt252*: When working with short strings in Cairo, they are converted into `felt252`. * *Limited string manipulation*: Cairo doesn't offer built-in support for complex string manipulation or operations. * *Convert between felt252 and short strings*: You can use the Utils] converter to convert between felt252s and strings. Despite its limitations, Cairo provides basic string handling capabilities, which can be sufficient for simple use cases in your contracts. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "testing_testnet.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"testing_testnet\"] = Testing Using a Deployed Contract Testing is a crucial aspect of smart contract development, as it ensures that your contract operates as intended and helps detect potential bugs or security vulnerabilities. The optimal approach to local testing involves using unit tests within our code and interacting with the contract through a local development network. In the next chapter of the book, we will cover both of these methods. For now, in this subchapter, we will demonstrate how to interact with the Pokemon contract and its assertions on the testnet. In this subchapter, we will guide you through testing a deployed contract using view functions, either with the Starknet CLI or a block explorer. The contract we will be examining is the contract], which showcases basic operations with Array and Span in Cairo. Ensure that you have completed the Calling, and Invoking Contracts] subchapter before proceeding. == Deploying to Goerli Testnet As we review in Chapter 1, to deploy a Cairo contract to the Goerli testnet, follow these steps once you have set up an account contract (review the \"Deploying, Calling and Invoking Contracts\" subchapter in Chapter 2 for more details): * Set the `STARKNET_NETWORK` environment variable to `alpha-goerli` and the `STARKNET_WALLET` environment variable to `starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount`. [source, shell] ---- export STARKNET_NETWORK=alpha-goerli export STARKNET_WALLET=starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount ---- * Use the `starknet declare` command to declare your contract. Replace `` with the path to your compiled contract JSON file, and `` with the account you want to use for deployment. In order to get the compiled contract JSON file you need to compile the contract, e.g. using `scarb build`. In the particular case of the Pokemon contract you can go to the repo] and run `scarb build` inside the contracts directory of Chapter 2 to obtain the JSON in the path \"target/release/starknetbook_chapter_2_PokeArray.json\". Bare in mind that if you declare exactly the same Pokemon contract you will get an error stating that this contract was previously declared. This error will also return the contract class hash, save it for the deployment. [source, shell] ---- starknet declare --contract --account --max_fee 100000000000000000 ---- This command returns the contract class hash and the transaction hash. * Deploy your contract using the `starknet deploy` command. Replace `` with the class hash you received in the previous step, and `` with the account you want to use for deployment. [source, shell] ---- starknet deploy --class_hash --account --max_fee 100000000000000000 ---- This command returns the contract address and the transaction hash. == Using View Functions for Testing In the `PokeArray` contract, we have created view functions to test various aspects of our contract, such as `pop_pokemon_array`, `index_pokemon_array`, and `index_pokemon_span`. These view functions can be called using the Starknet CLI or a block explorer. If the view functions return a value of 1, it indicates that our assertions within the functions have passed. If the assertions fail or an error occurs, the execution will stop, and an error message will be displayed. == Testing the Deployed Contract After deploying your contract, you can use a block explorer or the `starknet` CLI to call and invoke functions to test the assertions. Follow these steps to test your deployed contract: 1. *Using a block explorer*: Interact with your contract by employing a Starknet block explorer, such as or Input the contract address and call the view functions through the Read tab. 2. *Using Starknet CLI*: As an alternative, utilize the `starknet call` command to call the view functions. For more information on using the CLI, consult the Calling, and Invoking Contracts] subchapter. == Handling Errors in View Functions If an error occurs in your code and an assertion fails, you will encounter an error message similar to the one shown below: image::errorExplorer.png[errorExplorer] In this situation, the execution is reverted, and an error reason is provided in the felt252 format. To convert the felt252 value into a more readable string, follow these steps: 1. Visit the Utils] converter. 2. Copy the felt252 value into the converter's input field. 3. The converter will translate the felt252 value into a human-readable string, such as \"Wrong pokemon\", providing clarity on the error. image::translateError.png[translateError] For more information on how Cairo handles text, refer to the subchapter. Cairo is expected to offer support for strings in the near future, which will streamline this process. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "types.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"types\"] = Types in Cairo and The Relevance of Typing Cairo is a strongly typed language, similar to Rust, which means that every variable, constant, function arguments and funtion return's type be known at compile time. This enforces strict type checking, providing increased safety and reducing the likelihood of runtime errors. Cairo has a rich type system that includes several types of integers, booleans, arrays, and contract addresses. Cairo also supports user-defined types, which are useful for modeling complex data structures. A list of primitive types in Cairo (not all), along with a brief description of each type's purpose and functionality: [cols=\"1,2\",options=\"header\"] |=== | Primitive Type | Description | u8 | Represents an unsigned 8-bit integer. | usize | Unsigned size integer (typically used for representing indices and lengths) | u16 | Represents an unsigned 16-bit integer. | u32 | Represents an unsigned 32-bit integer. | u64 | Represents an unsigned 64-bit integer. | u128 | Represents an unsigned 128-bit integer. | u256 | Represents an unsigned 256-bit integer. | bool | Represents a boolean value, which can be either true or false. | felt252 | Represents a field element. | ContractAddress | A type representing a Starknet contract address, used for identifying and interacting with smart contracts. | T | Represents a generic type placeholder, which can be replaced with any specific type during compilation. | Option | Represents a value that may or may not be present, used for optional values and error handling. | Result | Represents the outcome of a computation that may result in an error, used for error handling and control flow. | Array | A dynamic array data structure for elements of type T, used for creating and manipulating arrays. |=== Similar to Rust, Cairo also supports type inference so the compiler will try to guess the type of a variable based on how the value is used. Incases where its not possible for compiler to guess the type of a variable, explicit annotation must be added. Here is an example of using types in Cairo: [source,rust] ---- fn example_function(value: u32) -> u32 { let doubled_value: u32 = value * 2_u32; return doubled_value; } ---- In this example, `value` and `doubled_value` are explicitly typed as `u32`, and the function `example_function` has a return type of `u32`. This ensures that the types are correctly enforced and that the code is easier to read and understand. In the next section we will review what definitions like `2_u32` mean. == Typing integer literals in Cairo In Cairo, you can specify the type of an integer literal by using an underscore followed by the desired type, similar to Rust. Here are some examples: [source,rust] ---- # Unsigned 8-bit integer let value_u8 = 1_u8; # Unsigned 16-bit integer let value_u16 = 1_u16; # Unsigned 32-bit integer let value_u32 = 1_u32; # Unsigned 64-bit integer let value_u64 = 1_u64; # Unsigned 128-bit integer let value_u128 = 1_u128; # Unsigned 256-bit integer let value_u256 = 1_u256; # Unsigned size integer (typically used for representing indices and lengths) let value_usize = 1_usize; ---- In these examples, the type of the integer literals is specified using the underscore notation, which makes it easier to work with different integer types without the need for explicit type casting. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "warp.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"warp\"] = Transpiling Solidity into Cairo using WARP == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "README.md", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "# Protostar and Cairo 1.0 Protostar has always been a favorite with Cairo developers, and just like Cairo, it too has undergone some changes recently. This template covers some of the most important changes, and should help familiarize you with the new and improved version. Some important take-aways from this lesson ... - Protostar currently allows you to compile and test Cairo 1.0 - Multiple contracts can be included in a single Protostar build - The framework provides `cheatcodes` which streamline testing ## Why Protostar ? There are two major ways to test Cairo smart contracts - you can test them in Cairo itself, or in Python. I prefer the Cairo approach since it means I do not have to deploy contracts everytime I test them OR have to worry about using a new language here. In this case, we can also benefit massively from the cheatcodes made available to us by Protostar. These are ways to make mock functionality for a smart contract without having to go through the bottlenecks of the real system. Please read more [here]( To learn best practices for testing, I highly recommend you take a look at the tests in `tests/test_erc20.cairo` and compare it with the original contract in `erc20/src/contracts/erc20.cairo`. ## Debugging Code In order to debug code, it is very useful to be able to print out values or isolate errors in `match` statements. In order to be able to print out, please use - ``` use array::ArrayTrait; use array::ArrayTCloneImpl; use array::SpanTrait; use debug::PrintTrait; use clone::Clone; array.span().snapshot.clone().print(); // Print an array value felt.print() // Print an individual value ``` You can also use match statements as mentioned over [here]( ## Common Gotchas - Each test has to be named with a `test_.cairo` so the framework can recognize and run it - Test needs to be decorated with `#[test]`, be without parameters and have an assertion - `contract_address_const::()` address is the default caller - A `Prank` needs to be used to change the caller address - `u256` values need to be split into two felt252 values when invoking a call - Protostar is not able to handle `#[external]` functions which emit an event for testing. Please wait for the next release."}
{"title": "bridges.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"bridges\"] = Bridges Bridges play a crucial role in connecting Starknet with other chains or exchanges, enabling seamless token transfers across different platforms. Not only are they valuable for testing purposes, but they also provide a practical learning opportunity for understanding Starknet's inter-blockchain messaging capabilities. == StarkGate StarkGate ( is a token bridge between Ethereum and Starknet. It allows users to deposit and withdraw ETH and ERC-20 tokens between both networks using L1 and L2 bridge contracts. === L1 \u2192 L2 Transfer (Deposit) Users call the deposit function on L1, providing the recipient address on Starknet and the amount for ERC-20 tokens. The deposit is triggered on Starknet, with sequencers triggering the handle_deposit function on the L2 bridge. The sequencer completes the block construction, and Starknet's provers submit a state update to L1. === L2 \u2192 L1 Transfer (Withdraw) Users call the `initiate_withdraw` function on the L2 bridge contract, providing the recipient address on Ethereum and the transfer amount. Starknet's provers validate the block and submit a state update to L1. Anyone can finalize the transfer on L1 by calling the withdraw function. StarkGate Alpha on Mainnet has limitations on deposit amounts and total value locked in the L1 bridge contract to minimize risks associated with its alpha version. == Orbiter Orbiter Finance ( is a decentralized cross-rollup bridge designed for transferring Ethereum-native assets between various networks, including Ethereum, Layer 2 solutions, and sidechains. The system consists of two main roles: Sender and Maker. The 'Maker' deposits excess margin into Orbiter's contract to act as a cross-rollup service provider for the 'Sender'. The 'Sender' sends assets to the 'Maker' on the 'Source Network', and the 'Maker' sends them back to the 'Sender' on the 'Destination Network'. Orbiter's security model relies on three types of smart contracts: Maker Deposit Contract (MDC), Event Binding Contract (EBC), and Simple Payment Verification (SPV). == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "devnet.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"devnet\"] = Devnet Transactions on the testnet take time to complete, so it's best to start developing and testing locally. We will use the developed by Shard Labs]. We can think of this step as an equivalent of Ganache. That is, it emulates the testnet (alpha goerli) of Starknet. Install using: [,Bash] ---- pip install starknet-devnet ---- Restart your terminal and run `starknet-devnet --version` to check that the installation was successful. Check that you have most up-to-date version]. If you don't have it, run `pip install --upgrade starknet-devnet`. is the documentation]. Initialize the devnet in a separate shell (or tab) with [,Bash] ---- starknet-devnet \\ --accounts 3 \\ --gas-price 250 \\ --seed 0 \\ --port 5000 ---- We get: [,Bash] ---- Account #0 Address: 0x7e00d496e324876bbc8531f2d9a82bf154d1a04a50218ee74cdd372f75a551a Public key: 0x7e52885445756b313ea16849145363ccb73fb4ab0440dbac333cf9d13de82b9 Private key: 0xe3e70682c2094cac629f6fbed82c07cd Account #1 Address: 0x69b49c2cc8b16e80e86bfc5b0614a59aa8c9b601569c7b80dde04d3f3151b79 Public key: 0x175666e92f540a19eb24fa299ce04c23f3b75cb2d2332e3ff2021bf6d615fa5 Private key: 0xf728b4fa42485e3a0a5d2f346baa9455 Account #2 Address: 0x7447084f620ba316a42c72ca5b8eefb3fe9a05ca5fe6430c65a69ecc4349b3b Public key: 0x58100ffde2b924de16520921f6bfe13a8bdde9d296a338b9469dd7370ade6cb Private key: 0xeb1167b367a9c3787c65c1e582e2e662 Initial balance of each account: 1000000000000000000000 WEI Seed to replicate this account sequence: 0 WARNING: Use these accounts and their keys ONLY for local testing. DO NOT use them on the mainnet or live networks because you will LOSE FUNDS. * Listening on (Press CTRL+C to quit) ---- We can run `+curl to check if the devnet is active. You will receive `Alive!!!%` if it is active. We created three accounts, with transaction costs of 250 wei per gas. The seed number will help us get the same accounts every time we activate our devnet and add that seed number. In other words, we can choose any seed number, but if we want to get the same accounts, we should select the same seed. We indicated we want to use port `5000`, however, feel free to add any convenient port. Our accounts are based on the code and standards developed by Zepellin for Cairo]. Please keep track of the address where our devnet is running. The example above is: `+ We will use it later. The interaction with the devnet and the testnet is very similar. If you want to see all the arguments available in the `starknet-devnet` call, you can call `starknet-devnet --help` or go to the == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "hardhat.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"hardhat\"] = Starknet Hardhat Plugin Hardhat is a popular JS development environment for Ethereum, and if you are already familiar with it and want to use it on Starknet, then this plugin will come in hand! == Getting Started Follow these high-level steps to get started with the Starknet Hardhat Plugin: * Install Hardhat itself ( this official guide]) * Include the plugin] inside the Hardhat project you created, per instructions in the * Create a new project (in our case, we called it hardhat-tutorial) * Navigate to the newly created project * Be sure to run: [source, bash] ---- npm i @shardlabs/starknet-hardhat-plugin --save-dev ---- * After successfully installing everything, make sure you have docker running as well, or if you have `cairo-lang` installed locally, you can set up venv in your hardhat config file - like * Next, add the following line to the top of your `hardhat.config.ts` (or `hardhat.config.js): [source, bash] ---- import \"@shardlabs/starknet-hardhat-plugin\"; ---- Or: [source, bash] ---- require(\"@shardlabs/starknet-hardhat-plugin\"); ---- == Using the Plugin With this setup, you can now run Starknet CLI commands as tasks in Hardhat. For instance, to compile a Cairo contract, execute: [source, bash] ---- npx hardhat starknet-compile-cairo1 [PATH...] ---- == Example [NOTE] ==== TODO: We would love to see a simple example of how to use the plugin. If you have one, please submit a PR! ==== In the meantime, you can check the the OxSpaceShard example repository The repository contains examples of the capacities of the plugin. You can check the `/scripts` folder with various scenarios. == Additional Resources - Official Hardhat Setup Guide: - Starknet Hardhat Plugin Repository: - Starknet Hardhat Plugin Documentation: - Starknet Hardhat Example Repository: [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "index.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"chapter_3\"] = Starknet Tooling Today, you will find all the necessary tools you need to build decentralized applications (dApps) on Starknet. Even using different languages such as JavaScript, Rust, and Python, you can still develop on Starknet. You can also use the Starknet SDK to build your applications. For a front-end developer, you can use the Starknet.js SDK paired with React; however, you can also make the back-end with Rust or Python. Contributors are always welcome to join the Starknet community and help improve the existing tooling or create new solutions. In this chapter, you can expect to learn about the following topics: * Wallets: Using Starknet wallets interfaces such as Argent and Braavos * Frameworks: Use Protostar (inspired by Foundry) or Hardhat to build Starknet applications * Common SDKs: Using Starknet.js, Starknet-rs, Starknet_py, and Caigo for different programming languages * Front-end SDKs: Using Starknet.js and React to build front-end applications * Testing: Learn how to test your Starknet applications using Protostar and the Devnet By the end of this chapter, you will have a comprehensive understanding of the tools available in the Starknet ecosystem and how they can help you build and deploy dApps efficiently. == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "indexers-explorers.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"indexers-and-explorers\"] = Indexers and Explorers == Explorers A block explorer, or blockchain explorer, enables you to see transactions, blockchain metrics and other information. The following block explorers provide information on Starknet. .Starknet block explorers, in alphabetical order |=== |Name|Mainnet|Goerli|Goerli 2 |Starkscan| |Viewblock| | |=== == Indexers [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "oracles.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"oracles\"] = Oracles Blockchains inherently lack the ability to read data from the internet. Nevertheless, many blockchain applications, such as DeFi apps, require constant access to up-to-date information from various online sources. Oracles bridge the gap between blockchains and external systems, allowing smart contracts to execute based on real-world inputs and outputs. The largest oracle on Starknet is == Pragma Network is a fully open-source and audited oracle network. It provides over 20 price feeds for popular crypto assets and has a well-established community of data providers, ensuring frequent updates. Pragma is a fully on-chain oracle which leverages Starknet's cheap computation to provide fully transparent and composable data feeds (yield curve, realized volatility, etc.) Note that once 0.13.0 is released, Pragma will also leverage Volition mode to increase frequency of updates and reduce costs. == Chainlink Price Feeds] are available on the Starknet testnet, with plans for availability on the Starknet mainnet in the near future. Chainlink provides decentralized oracle services. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "protostar.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"protostar\"] = Protostar is a highly practical development platform for the Starknet universe. This tool eases the process of managing dependencies, compiling projects, running tests, and interacting with the Starknet chain. Protostar allows developers to write, test and deploy their Cairo contracts in a streamlined manner. == Installation To begin, you'll need to install Protostar on your local machine. This process currently supports Linux and MacOS systems (Windows support is in progress). Install Protostar by opening a terminal and running the following command: [source,bash] ---- curl -L | bash ---- After the installation process, restart the terminal. Check that the version of your installed Protostar matches the recent version]. If it does not, update your Protostar version using the command: [source,bash] ---- # Check your current version protostar -v # Update to the latest version protostar upgrade ---- == Supported Software Versions Ensure you're keeping your Protostar upgraded to the latest version. Protostar doesn't currently support Windows. == Verifying Installation Once Protostar is installed, verify it by checking the version with the command: [source,bash] ---- protostar -v ---- The output should be as follows: [source,bash] ---- Protostar version: 0.13.0 Cairo-lang version: 0.11.1.1 Cairo 1 compiler version: 1.1.0 ---- Note that Cairo-lang is the version of the Starknet network and Cairo 1 compiler is the version of the Cairo compiler. == Initiating a New Cairo Project After successful installation and verification of Protostar, initiate a new project by running: [source,bash] ---- protostar init my_project cd my_project ---- The structure of your project directory should be similar to: [source,bash] ---- my_project/ . \u251c\u2500\u2500 Scarb.toml \u251c\u2500\u2500 protostar.toml \u251c\u2500\u2500 src \u2502 \u251c\u2500\u2500 business_logic \u2502 \u2502 \u2514\u2500\u2500 utils.cairo \u2502 \u251c\u2500\u2500 business_logic.cairo \u2502 \u251c\u2500\u2500 contract \u2502 \u2502 \u2514\u2500\u2500 hello_starknet.cairo \u2502 \u251c\u2500\u2500 contract.cairo \u2502 \u2514\u2500\u2500 lib.cairo \u2514\u2500\u2500 tests \u251c\u2500\u2500 test_hello_starknet.cairo \u2514\u2500\u2500 test_utils.cairo ---- The most important thing to notice is how we have structured both these contracts as standalone crates. Each smart contract in Protostar must be built as its own crate and each contract is its own module decorated with the `[contract]` decorator. Explore the official Protostar documentation for more details on structuring your project: Protostar uses Scarb and its manifest files to manage dependencies in your project. In order to use Protostar with Cairo 1, you must have Scarb executable added to the PATH environment variable. The PATH variable is a list of directories that your system searches for executables. It is practically the main goal of Scarb within a Protostar project; compiling can be done with Scarb, but Protostar will do it for you. == Structure of a Cairo Project A Cairo project includes several crucial components that help create and manage a smart contract. Let's explore each part in detail. === Cairo Packages Cairo packages, also referred to as \"crates\" in some contexts, are the building blocks of a Cairo project. Each package must follow several rules: * A package must include a `Scarb.toml` file, which is Scarb's manifest file. It contains the dependencies for your package. * A package must include a `src/lib.cairo` file, which is the root of the package tree. It allows you to define functions and declare used modules. Package structures might look like the following: [source,bash] ---- my_package/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 module1.cairo \u2502 \u251c\u2500\u2500 module2.cairo \u2502 \u2514\u2500\u2500 lib.cairo \u2514\u2500\u2500 Scarb.toml ---- Within the `Scarb.toml` file, you might have: [source,toml] ---- [package] name = \"my_package\" version = \"0.1.0\" [dependencies] other_package = { path = \"../other_package\" } ---- === Protostar and Scarb: Working Together Protostar and Scarb are both instrumental in managing a Cairo project. While Scarb primarily handles dependencies, Protostar manages project compilation, testing, and interaction with the Starknet chain. Scarb is a tool for managing dependencies in your Cairo packages. When you use Protostar with Cairo 1, you need to have the Scarb executable added to your `PATH` environment variable. `PATH` is a list of directories that your system searches for executables. Protostar, on the other hand, uses Scarb and its manifest files to compile your project. Even though Scarb could technically handle this process independently, Protostar streamlines it for you, making the entire process more manageable and efficient. == The protostar.toml File The `protostar.toml` file is a configuration file located at the root of your project. It defines several key attributes for your project, such as the version of Protostar to be used, contract names, configuration profiles, and command-specific configurations. Here's an example of what a `protostar.toml` file might look like: [source,toml] ---- [project] protostar-version = \"PROTOSTAR_VERSION\" [contracts] hello_starknet = [\"hello_starknet\"] [profile.integration.test] target = [\"tests/integration\"] report-slowest-tests = 5 [profile.devnet.project] gateway-url = \" chain-id = 1536727068981429685321 [profile.testnet.project] network = \"testnet\" ---- Each section within the `protostar.toml` file has its specific function: * `[project]` section: This allows you to specify global options and settings for your project, such as the Protostar version (`protostar-version`). * `[contracts]` section: This defines the packages containing contracts to be used by Protostar commands. * `Command Arguments Configuration Section`: This section allows you to specify arguments for a specific Protostar command. * `Configuration Profiles`: Configuration profiles allow you to easily switch between different Protostar configurations. Overall, the `protostar.toml` file plays an essential role in managing project settings and configurations, contributing to a smoother development process. == Testing Contracts In the realm of Cairo smart contracts, there are two predominant ways to test your contracts: within Cairo itself, or with Python, Javascript, or Rust. The Cairo approach is often preferred, as it prevents developers from having to deploy contracts each time they need to be tested and eliminates the necessity of learning a new language for testing purposes. Execute tests using the command: [source,bash] ---- protostar test ---- A successful test execution will provide an output resembling: [source,bash] ---- Collected 2 suites, and 3 test cases (11.32) [PASS] tests/test_utils.cairo test_returns_two (time=0.00s) [PASS] tests/test_hello_starknet.cairo test_increase_balance (time=25.81s) [PASS] tests/test_hello_starknet.cairo test_cannot_increase_balance_with_zero_value (time=25.19s) Test suites: 2 passed, 2 total Tests: 3 passed, 3 total Seed: 720541691 21:17:52 [INFO] Execution time: 66.70 s ---- == Compile the Project == Project Compilation Before a project can be deployed on the network, it must be compiled into a form that the Starknet network can understand and execute. Protostar makes this process easy with its `build` command. To compile your Cairo1 project, use the build command: [source,bash] ---- protostar build ---- If your compilation was successful, the output will be similar to this: [source,bash] ---- 21:00:22 [INFO] Building cairo1 contracts 21:00:27 [INFO] Contracts built successfully 21:00:27 [INFO] Execution time: 6.22 s ---- == Contract Declaration After successfully compiling your project, the next step is to declare your contracts. This process informs the network of your intention to deploy a new contract (review Chapter 2 for more details on the contract declaration process). Before declaring contracts, it's essential to first set the environment variable for your private key: [source,bash] ---- export PROTOSTAR_ACCOUNT_PRIVATE_KEY=0x... ---- You can then declare your contracts with the following command: [source,bash] ---- protostar declare hello_starknet \\ --network testnet \\ --account-address YOUR_ACCOUNT_ADDRESS \\ --max-fee auto ---- Note: Replace `YOUR_ACCOUNT_ADDRESS` with your actual account address. Successful declaration will generate a class hash and output similar to: [source,bash] ---- Declare transaction was sent. Class hash: 0x04ad47b818e8811a8c1df2a03a26381da0232bb7da3cba274831c2cfc9953acd StarkScan Voyager Transaction hash: 0x03d048f8dc599c7d9bad1e5a7a039c35463b9479f0966766bc0df03cd89d6d7d StarkScan Voyager 21:01:23 [INFO] Execution time: 27.95 s ---- == Contract Deployment After declaring your contract, the next step is to deploy it on the network. Deployment makes your contract live and interactable on the Starknet. To deploy your contract, use the class hash generated from the declaration step and the `protostar deploy` command: [source,bash] ---- protostar deploy \\ 0x04ad47b818e8811a8c1df2a03a26381da0232bb7da3cba274831c2cfc9953acd \\ --network testnet \\ --account-address YOUR_ACCOUNT_ADDRESS \\ --max-fee auto ---- Note: Replace `YOUR_ACCOUNT_ADDRESS` with your actual account address. The '0x' address following the deploy command is the Class Hash that was generated during contract declaration. Successful deployment will provide a contract address and output similar to this: [source,bash] ---- Invoke transaction was sent to the Universal Deployer Contract. Contract address: 0x02341c459847cf220671ab873e14d853197c74e239c3b5815b0aa2e85bc37ebd StarkScan Voyager Transaction hash: 0x03406b79b189d8752cff632ea8e0df332d7be7e27ffbc453fbf210c7384c0676 StarkScan Voyager 21:25:26 [INFO] Execution time: 3.22 s ---- == A Simple Demo To learn how you can get started with Protostar, let's create a simple project. First, navigate to your terminal and execute: [source,bash] ---- git clone cd protostar-cairo1-template ---- Now, you have access to a basic Protostar project that implements two smart contracts along with additional business logic in `Cairo 1.0`. Before proceeding, it's advisable to familiarize yourself with the code in both `erc20.cairo` and `hello_starknet.cairo`. For a deeper understanding of testing, it is highly recommended to examine the tests in `tests/test_erc20.cairo` and compare them with the original contract in `contracts/erc20.cairo`. == Debugging For code debugging, it's beneficial to be able to print out values or isolate errors in match statements. Protostar already provides these functionalities. To print out values, use the following: [source,bash] ---- use array::ArrayTrait; use array::ArrayTCloneImpl; use array::SpanTrait; use debug::PrintTrait; use clone::Clone; array.span().snapshot.clone().print(); // Print an array value felt.print() // Print an individual value ---- You can also use match statements like so: [source,bash] ---- match invoke(deployed_contract_address, 'panic_with', @panic_data) { Result::Ok(x) => assert(false, 'Shouldnt have succeeded'), Result::Err(x) => { assert(x.first() == 'error', 'first datum doesnt match'); assert(*x.panic_data.at(1_u32) == 'data', 'second datum doesntmatch'); } } ---- Finally, to make your code interact with Starknet, you can utilize the comprehensive list of commands provided by Protostar. You can find these commands [here]( == Common Gotchas - Each test should be named `test_.cairo` so that the framework can recognize it. - Tests need to be decorated with `#[test]`, be without parameters, and include an assertion. - `contract_address_const::()` is the default caller for all invocations. - A `Prank` needs to be used to change the caller address. - `u256` values need to be split into two `felt252` values when making a call. - Protostar currently does not support `#[external]` functions that emit an event for testing. Please wait for the next release. == Conclusion Protostar represents a powerful toolset for developing, testing, and deploying smart contracts on the Starknet network. This guide has introduced you to its main features and demonstrated how to use it in the context of a simple project. Although there are some nuances and \"gotchas\" to be aware of, the benefits of using Protostar are evident. As the Starknet ecosystem evolves, tools like Protostar will continue to play a critical role in helping developers build robust, reliable, and secure decentralized applications. Happy coding! [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "starknet-react.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"starknet-react\"] = Starknet React: A Pathway to Robust Decentralized Applications Several tools exist in the starknet ecosystem to build the front-end for your application. The most popular ones are: * ( Collection of React hooks for Starknet. It is inspired by powered by * A JavaScript library for interacting with Starknet contracts. It would be the equivalent of for Ethereum. For Vue developers, vue-stark-boil, created by the team at [Don't Panic DAO]( is a great option. For a deeper understanding of Vue, visit their [website]( The vue-stark-boil boilerplate enables various functionalities, such as connecting to a wallet, listening for account changes, and calling a contract. Authored by the team, React] is an open-source collection of React providers and hooks meticulously designed for Starknet. To immerse in the real-world application of Starknet React, we recommend exploring the comprehensive example dApp project at == Integrating Starknet React Embarking on your Starknet React journey necessitates the incorporation of vital dependencies. Let's start by adding them to your project. [source,shell] ---- yarn add @starknet-react/core starknet get-starknet ---- [NOTE] ==== is an essential SDK facilitating interactions with Starknet. In contrast, is a package adept at managing wallet connections. ==== Proceed by swaddling your app within the `StarknetConfig` component. This enveloping action offers a degree of configuration, while simultaneously providing a React Context for the application beneath to utilize shared data and hooks. The `StarknetConfig` component accepts a connectors prop, allowing the definition of wallet connection options available to the user. [source,typescript] ---- const connectors = [ new InjectedConnector({ options: { id: \"braavos\" } }), new InjectedConnector({ options: { id: \"argentX\" } }), ]; return ( ) ---- == Establishing Connection and Managing Account Once the connectors are defined in the config, the stage is set to use a hook to access these connectors, enabling users to connect their wallets: [source,typescript] ---- export default function Connect() { const { connect, connectors, disconnect } = useConnectors(); return ( {connectors.map((connector) => ( connect(connector)} disabled={!connector.available()} > Connect with {connector.id()} ))} ); } ---- Observe the `disconnect` function that terminates the connection when invoked. Post connection, access to the connected account is provided through the `useAccount` hook, offering insight into the current state of connection: [source,typescript] ---- const { address, isConnected, isReconnecting, account } = useAccount(); return ( {isConnected ? ( Hello, {address} ) : ( )} ); ---- The state values, such as `isConnected` and `isReconnecting`, receive automatic updates, simplifying UI conditional updates. This convenient pattern shines when dealing with asynchronous processes, as it eliminates the need to manually manage the state within your components. Having established a connection, signing messages becomes a breeze using the account value returned from the `useAccount` hook. For a more streamlined experience, the `useSignTypedData` hook is at your disposal. [source,typescript] ---- const { data, signTypedData } = useSignTypedData(typedMessage) return ( Sign {data && Signed: {JSON.stringify(data)}} ) ---- Starknet React supports signing an array of `BigNumberish` values or an object. While signing an object, it is crucial to ensure that the data conforms to the EIP712 type. For a more comprehensive guide on signing, refer to the Starknet.js documentation: == Displaying StarkName After an account has been connected, the `useStarkName` hook can be used to retrieve the StarkName of this connected account. Related to it permits to display the user address in a more user friendly way. [source,typescript] ---- const { data, isError, isLoading, status } = useStarkName({ address }); // You can track the status of the request with the status variable ('idle' | 'error' | 'loading' | 'success') if (isLoading) return Loading... return Account: {isError ? address : data} ---- You also have additional information you can get from this hook -> **error**, **isIdle**, **isFetching**, **isSuccess**, **isFetched**, **isFetchedAfterMount**, **isRefetching**, **refetch** which can give you more precise information on what is happening. == Fetching address from StarkName You could also want to retrieve an address corresponding to a StarkName. For this purpose, you can use the `useAddressFromStarkName` hook. [source,typescript] ---- const { data, isLoading, isError } = useAddressFromStarkName({ name: 'vitalik.stark' }) if (isLoading) return Loading... if (isError) return Something went wrong return Address: {data} ---- If the provided name does not have an associated address, it will return **\"0x0\"** == Navigating the Network In addition to wallet and account management, Starknet React equips developers with hooks for network interactions. For instance, useBlock enables the retrieval of the latest block: [source,typescript] ---- const { data, isError, isFetching } = useBlock({ refetchInterval: 10_000, blockIdentifier: \"latest\", }); if (isError) { return ( Something went wrong ) } return ( Current block: {isFetching ? \"Loading...\" : data?.block_number} ) ---- In the aforementioned code, refetchInterval controls the frequency of data refetching. Behind the scenes, Starknet React harnesses for managing state and queries. In addition to useBlock, Starknet React offers other hooks like useContractRead and useWaitForTransaction, which can be configured to update at regular intervals. The useStarknet hook provides direct access to the ProviderInterface: [source,typescript] ---- const { library } = useStarknet(); // library.getClassByHash(...) // library.getTransaction(...) ---- == Tracking Wallet changes To improve your dApp User Experience, you can track the user wallet changes, especially when the user changes the wallet account (or connects/disconnects). But also when the user changes the network. You could want to reload correct balances when the user changes the account, or to reset the state of your dApp when the user changes the network. To do so, you can use a previous hook we already looked at: `useAccount` and a new one `useNetwork`. The `useNetwork` hook will give you the current Chain currently used. [source,typescript] ---- const { chain: {id, name} } = useNetwork(); return ( Connected chain: {name} Connected chain id: {id} ) ---- You also have additional information you can get from this hook -> **blockExplorer**, **testnet** which can give you more precise information about the current using network. After knowing this you have all you need to track user interaction on the using account and network. You can use the `useEffect` hook to do some work on changes. [source,typescript] ---- const { chain } = useNetwork(); const { address } = useAccount(); useEffect(() => { if(address) { // Do some work when the user changes the account on the wallet // Like reloading the balances }else{ // Do some work when the user disconnects the wallet // Like reseting the state of your dApp } }, [address]); useEffect(() => { // Do some work when the user changes the network on the wallet // Like reseting the state of your dApp }, [chain]); ---- == Contract Interactions === Read Functions Starknet React presents useContractRead, a specialized hook for invoking read functions on contracts, akin to wagmi. This hook functions independently of the user's connection status, as read operations do not necessitate a signer. [source,typescript] ---- const { data: balance, isLoading, isError, isSuccess } = useContractRead({ abi: abi_erc20, address: CONTRACT_ADDRESS, functionName: \"allowance\", args: [owner, spender], // watch: true Balance: {data?.formatted} {data?.symbol} ) ---- === Write Functions The useContractWrite hook, designed for write operations, deviates slightly from wagmi. The unique architecture of Starknet facilitates multicall transactions natively at the account level. This feature enhances the user experience when executing multiple transactions, eliminating the need to approve each transaction individually. Starknet React capitalizes on this functionality through the useContractWrite hook. Below is a demonstration of its usage: [source,typescript] ---- const calls = useMemo(() => { // compile the calldata to send const calldata = stark.compileCalldata({ argName: argValue, }); // return a single object for single transaction, // or an array of objects for multicall** return { contractAddress: CONTRACT_ADDRESS, entrypoint: functionName, calldata, }; }, [argValue]); // Returns a function to trigger the transaction // and state of tx after being sent const { write, isLoading, data } = useContractWrite({ calls, }); function execute() { // trigger the transaction write(); } return ( Make a transaction ) ---- The code snippet begins by compiling the calldata using the compileCalldata utility provided by Starknet.js. This calldata, along with the contract address and entry point, are passed to the useContractWrite hook. The hook returns a write function that is subsequently used to execute the transaction. The hook also provides the transaction's hash and state. === A Single Contract Instance In certain use cases, working with a single contract instance may be preferable to specifying the contract address and ABI in each hook. Starknet React accommodates this requirement with the useContract hook: [source,typescript] ---- const { contract } = useContract({ address: CONTRACT_ADDRESS, abi: abi_erc20, }); // Call functions directly on contract // contract.transfer(...); // contract.balanceOf(...); ---- == Tracking Transactions The useTransaction hook allows for the tracking of transaction states given a transaction hash. This hook maintains a cache of all transactions, thereby minimizing redundant network requests. [source,typescript] ---- const { data, isLoading, error } = useTransaction({ hash: txHash }); return ( {JSON.stringify(data?.calldata)} ) ---- The full array of available hooks can be discovered in the Starknet React documentation, accessible here: == Conclusion The Starknet React library offers a comprehensive suite of React hooks and providers, purpose-built for Starknet and the Starknet.js SDK. By taking advantage of these well-crafted tools, developers can build robust decentralized applications that harness the power of the Starknet network. Through the diligent work of dedicated developers and contributors, Starknet React continues to evolve. New features and optimizations are regularly added, fostering a dynamic and growing ecosystem of decentralized applications. It's a fascinating journey, filled with innovative technology, endless opportunities, and a growing community of passionate individuals. As a developer, you're not only building applications, but contributing to the advancement of a global, decentralized network. Have questions or need help? The Starknet community is always ready to assist. Join the Discord] or explore the GitHub repository] for resources and support. == Further Reading * * React Docs] * Ethereum] * Bitcoin] [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "starknetjs.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"starknetjs\"] = Starknet.js - Starknet JavaScript SDK Starknet.js is a JavaScript/TypeScript library designed to connect your website or decentralized application (D-App) to Starknet. It aims to mimic the architecture of so if you are familiar with ethers, you should find Starknet.js easy to work with. image::starknet-js.png[starknet-js] == Installation To install Starknet.js, follow these steps: * For the latest official release (main branch): [source, bash] ---- npm install starknet ---- * To use the latest features (merges in develop branch): [source, bash] ---- npm install starknet@next ---- == Getting Started To build an app that users are able to connect to and interact with Starknet, we recommend adding the library, which allows you to manage wallet connections. With these tools ready, there are basically 3 main concepts to know on the frontend: Account, Provider, and Contracts. ### Account We can generally think of the account as the \"end user\" of a dapp, and some user interaction will be involved to gain access to it. Think of a dapp where the user connects their browser extension wallet (such as ArgentX or Braavos) - if the user accepts the connection, that gives us access to the account and signer, which can sign transactions and messages. Unlike Ethereum, where user accounts are Externally Owned Accounts, Starknet **accounts are contracts**. This might not necessarily impact your dapp's frontend, but you should definitely be aware of this difference. ```ts async function connectWallet() { const starknet = await connect(); console.log(starknet.account); const nonce = await starknet.account.getNonce(); const message = await starknet.account.signMessage(...) } ``` The snippet above uses the `connect` function provided by `get-starknet` to establish a connection to the user wallet. Once connected, we are able to access account methods, such as `signMessage` or `execute`. ### Provider The provider allows you to interact with the Starknet network. You can think of it as a \"read\" connection to the blockchain, as it doesn't allow signing transactions or messages. Just like in Ethereum, you can use a default provider, or use services such as Infura or Alchemy, both of which support Starknet, to create an RPC provider. By default, the Provider is a sequencer provider. ```ts export const provider = new Provider({ sequencer: { network: \"goerli-alpha\", }, // rpc: { // nodeUrl: INFURA_ENDPOINT // } }); const block = await provider.getBlock(\"latest\"); // <- Get latest block console.log(block.block_number); ``` ### Contracts Your frontend will likely be interacting with deployed contracts. For each contract, there should be a counterpart on the frontend. To create these instances, you will need the contract's address and ABI, and either a provider or signer. ```ts const contract = new Contract( abi_erc20, contractAddress, starknet.account ); const balance = await contract.balanceOf(starknet.account.address); const transfer = await contract.transfer(recipientAddress, amountFormatted); //or: const transfer = await contract.invoke(\"transfer\", [to, amountFormatted]); console.log(`Tx hash: ${transfer.transaction_hash}`); ``` If you create a contract instance with a provider, you'll be limited to calling read functions on the contract - only with a signer can you change the state of the blockchain. However, you are able to connect a previously created `Contract` instance with a new account: ```ts const contract = new Contract( abi_erc20, contractAddress, provider ); contract.connect(starknet.account); ``` In the snippet above, after calling the `connect` method, it would be possible to call read functions on the contract, but not before. ## Units If you have previous experience with web3, you know dealing with units requires care, and Starknet is no exception. Once again, the docs are very useful here, in particular section on data transformation]. Very often you will need to convert Cairo structs (such as Uint256) that are returned from contracts into numbers: ```ts // Uint256 shape: // { // type: 'struct', // low: Uint256.low, // high: Uint256.high // // } const balance = await contract.balanceOf(address); // <- uint256 const asBN = uint256.uint256ToBN(uint256); // <- uint256 into BN const asString = asBN.toString() //<- BN into string ``` And vice versa: ```ts const amount = 1; const amountFormatted = { type: \"struct\", ...uint256.bnToUint256(amount), }; ``` There are other helpful utils, besides `bnToUint256` and `uint256ToBN`, provided by Starknet.js. We now have a solid foundation to build a Starknet dapp. However, there are framework specific tools that help us build Starknet dapps, which are covered in chaper 5. == Additional Resources - Starknet.js GitHub Repository: - Official Starknet.js Website and documentation: Stay tuned for more updates on Starknet.js, including detailed guides, examples, and comprehensive documentation. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "starknetpy.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"starknetpy\"] = Starknet_py - Python SDK for Starknet == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "starknetrs.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"starknetrs\"] = Starknet-rs - a Rust library for Starknet == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "testing.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"index\"] = Introduction to Testing on Starknet ==== CALL FOR CONTRIBUTIONS: Your knowledge and expertise can significantly enrich this chapter. Specifically, we're seeking practical examples illustrating the testing process of contracts at each stage - unit testing, devnet, testnet, and mainnet deployment. If you're interested in contributing, kindly submit a Request (PR) on our GitHub repository]. We greatly appreciate your interest in contributing to this open-source project, and we look forward to learning from your experiences. ==== In this subchapter, we will explore various tools available for testing Cairo and Starknet contracts. Please note that this is a rapidly evolving space with new tools and methodologies being introduced regularly. As of the time of writing, the tools we will cover represent a significant portion of those available, but we encourage readers to stay updated with the latest developments. At present, we have the ability to interact with the Starknet Alpha. The suggested steps for contract deployment are: . *Unit Testing*: Begin by writing unit tests for your contracts. Tools such as Protostar, Nile, or starknet.py can be employed for this purpose. . *Devnet Deployment*: Once your unit tests are passing, the next step is to deploy your contracts on a devnet. Shard Lab's `starknet-devnet`, available on is a good choice for this. . *Testnet Deployment*: Following successful devnet deployment, contracts can be deployed to a testnet such as Goerli, `alpha-goerli`, or Goerli 2. This can be achieved using tools such as Protostar, Nile, Hardhat, and more. . *Mainnet Deployment*: Lastly, after rigorous testing on the testnets, contracts can be deployed to the Alpha Starknet (`alpha-mainnet`). The tools used for testnet deployment can also be used for mainnet deployment. Remember, the purpose of this progression is to thoroughly test and debug contracts in a controlled and cost-effective manner before deploying them in a live environment. == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "wallets.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"wallets\"] = Wallets Once you have deployed your first account on Starknet - you are going to need a wallet UI to manage it. Here are some common choices which work well across browsers - .Starknet wallets |=== |Name|Extension|Mobile | X]| Extension]|- | |=== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "blocks.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"blocks\"] = Blocks in Starknet In Starknet, a block consists of a list of transactions and a block header. Blocks represent batches of transactions linked together by the hash of the preceding block in the chain. This connection of blocks forms a chain, as hashes are cryptographically generated from the block data. This structure ensures security and prevents fraud, as any alteration in a historical block would invalidate all subsequent blocks due to changes in their hashes. Consequently, every participant in the blockchain would quickly detect the discrepancy. image::tx-block.png[tx-block] == Block Header The block header consists of the following fields: [cols=\"1,1,4,1\",options=\"header\"] |=== | Name | Type | Description | Implemented | parent_block_hash | FieldElement | The hash of this block\u2019s parent | \u2713 | block_number | Integer | The number (height) of this block | \u2713 | global_state_root | FieldElement | The state commitment after this block | \u2713 | sequencer_address | FieldElement | The Starknet address of the sequencer who created this block | \u2713 | block_timestamp | Timestamp | The time the sequencer created this block before executing transactions | \u2713 | transaction_count | Integer | The number of transactions in a block | \u2713 | transaction_commitment | FieldElement | A commitment to the transactions included in the block | \u2713 | event_count | Integer | The number of events | \u2713 | event_commitment | FieldElement | A commitment to the events produced in this block | \u2713 | protocol_version | Integer | The version of the Starknet protocol used when creating this block | | extra_data | FieldElement | Extraneous data that might be useful for running transactions | |=== [NOTE] ==== The commitment fields *event_commitment* and *transaction_commitment* are the roots of a height 64 binary Merkle Patricia tree. The leaf at index _i_ corresponds to the hash of the *_i\u2032th_* event for *event_commitment* and *_h(transaction hash,signature)_* for *invoke transaction_commitment*. For other types of transactions, we use *h(0,0)*. ==== == Block Hash The block hash is defined as the Pedersen hash over the header\u2019s elements. Poseidon is a family of hash functions designed for being very efficient as algebraic circuits. As such, they may be very useful in ZK proving systems such as STARKs and others. [.formula, frame=\"single\", options=\"header\", background_color=\"#e6f3ff\"] |=== | latexmath:[h(B) = h(block_number, global_state_root, sequencer_address, block_timestamp, transaction_count, transaction_commitment, event_count, event_commitment, 0, 0, parent_block_hash)] |=== Where *_h_* is the Pedersen hash. [NOTE] ==== Zeros inside the hash computation of an object are used as placeholders, to be replaced in the future by meaningful fields. ==== [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "index.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "= Starknet Architecture As you embark on your journey to build scalable web3 applications, it's essential to understand the architecture of Starknet and its various components. This chapter aims to provide an in-depth understanding of the key building blocks of Starknet, which will enable you to develop and deploy decentralized applications (dApps) efficiently. In this chapter, we will cover topics such as: * L2 Nodes: A high-level overview of the different Starknet nodes (Sequencer, Prover, Full Nodes, and Indexer) and their roles within the network. * Tx Lifecycle: A detailed explanation of the various states an L2 transaction goes through, discussing the benefits and risks of considering a particular state as \"finality.\" * Starknet OS: An exploration of how the Sequencer validates and executes transactions, and its connection with Account Abstraction (AA). * SHARP: An examination of the Prover's workflow for generating proofs for Starknet and Starkex using recursion, focusing on the workflow rather than the math behind STARKs. * L1 Components: A comprehensive analysis of the on-chain Verifier and Fact Registry, and a discussion on how an L1 escape hatch would work. * Bridges: An explanation of how L1-L2 communication works and how it can be used to create bridges between networks. By the end of this chapter, you will have a deep understanding of the architecture and components of the Starknet ecosystem, empowering you to make informed decisions when building and deploying dApps on the platform. == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "innovations.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "= Future Innovations in the Starknet Architecture This chapter, while optional, offers a glimpse into the exciting developments expected to shape Starknet's future. If you're intrigued about the imminent advancements in Starknet, this chapter is for you. For those eager to delve into Cairo programming, feel free to move to the next chapter. Starknet, ever-evolving, has a roadmap replete with ambitious goals, all aimed at honing its performance, increasing throughput, reducing latency, and progressing towards decentralization. In this chapter, we explore these significant future developments and their expected impact on the Starknet topology. == The Rust Sequencer: Powering Up Performance A significant update is the Rust sequencer which will be part of version 0.12 of Starknet. The original sequencer was written in Python which, while user-friendly and quick for development, isn't as efficient for production-level applications. Rust will bring a substantial performance boost, increasing throughput and reducing latency, and this will be a significant step in the progression towards decentralization. The fact that parts of the Rust sequencer were developed by community members outside of StarkWare is a testament to the power of open-source development and decentralization. This upgrade is expected to be live by the end of May or the beginning of June. == Madara and Kakarot: Propelling Throughput Madara, a sequencer based on the Substrate tech stack, aims to facilitate the operation of individual Starknet instances. It allows users to operate their own network and then prove its honest operation on Layer 1 or Layer 2. Madara is reaching high throughput benchmarks and is expected to scale Starknet massively. Kakarot is a Zero-Knowledge Ethereum Virtual Machine (ZKEVM) written in Cairo, able to interpret and process Solidity bytecode. The Kakarot team is exploring the possibility of running Kakarot on top of Madara as an L3 on Starknet, and this functionality could be live by the end of the year. == Decentralization: Two-Pronged Approach StarkWare is considering two paths for increasing decentralization on Starknet. The first involves developing a unique proof-of-stake algorithm for the network. The second, more gradual approach would start with adding another sequencer to the network, moving from a single-sequence proof-of-authority (PoA) network to a multiple-sequence one, and eventually adopting a Byzantine Fault Tolerant (BFT) protocol for consensus. The community's input is valued in this discussion, as more people thinking about these things will make the network more resilient and efficient. == Layer 3 (L3): Flexibility at Its Core Layer 3 offers a wide range of possibilities, from users generating proofs on their own devices to running backend architecture on a small Cairo state machine. The keyword here is flexibility. This layer can scale the network in various directions and allows developers to execute off-chain and on-chain operations using the same language, Cairo. In summary, Starknet is a network in progress with ambitious future plans. Its focus on increased efficiency, community involvement, scalability, and eventual decentralization is poised to make it a force to be reckoned with in the world of blockchain technology. == Conclusion Starknet stands at the cusp of significant transformation, underpinned by enhanced efficiency, scalability, and an unwavering pursuit of decentralization. The network's vision, painted with developments like the Rust Sequencer, Madara, Kakarot, and Layer 3, among others, is set to make it a the Starknet ecosystem an interesting space to watch. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "node.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "= Running a Starknet Node This chapter will guide you through setting up and running a Starknet node, illustrating the layered tech stack concept, and explaining how to operate these protocols locally. Starknet, as a Layer 2 Validity Rollup, operates on top of Ethereum Layer 1, creating a protocol stack that each addresses different functionalities, similar to the OSI model for internet connections. This chapter is an edit of blog. ==== CONTRIBUTE: This guide shows how to run a Starknet node locally with a particular setup. You can contribute to this guide by adding more options for hardware and software, as well as other ways to run a Starknet nod (for example using You can also contribute by adding more information about the Starknet stack and the different layers. Feel free to a PR]. ==== == What is a Node in the Context of Ethereum and Blockchain? In the context of Ethereum and blockchain, a node is an integral part of the network that validates and relays transactions. Nodes download a copy of the entire blockchain and are interconnected with other nodes to maintain and update the blockchain state. There are different types of nodes, such as full nodes, light nodes, and mining nodes, each having different roles and responsibilities within the network. == Overview of Starknet Technology Starknet is a permissionless, zk-STARK-based Layer-2 network, aiming for full decentralization. It enables developers to build scalable decentralized applications (dApps) and utilizes Ethereum's Layer 1 for proof verification and data availability. Key aspects of Starknet include: * *Cairo execution environment*: Cairo, the execution environment of Starknet, facilitates writing and execution of complex smart contracts. * *Scalability*: Starknet achieves scalability through zk-STARK proofs, minimizing the data needed to be posted on-chain. * *Node network*: The Starknet network comprises nodes that synchronize and process transactions, contributing to the network's overall security and decentralization. == Starknet Stack The Starknet stack can be divided into various layers, similar to OSI or TCP/IP models. The most appropriate model depends on your understanding and requirements. A simplified version of the modular blockchain stack might look like this: - Layer 1: Data Layer - Layer 2: Execution Layer - Layer 3: Application Layer - Layer 4: Transport Layer image::node1.png[node1] == Setup There are various hardware specifications, including packaged options, that will enable you to run an Ethereum node from home. The goal here is to build the most cost-efficient Starknet stack possible ( here more options]). *Minimum Requirements:* - CPU: 2+ cores - RAM: 4 GB - Disk: 600 GB - Connection Speed: 8 mbps/sec *Recommended Specifications:* - CPU: 4+ cores - RAM: 16 GB+ - Disk 2 TB - Connection Speed: 25+ mbps/sec *You can refer to these links for the hardware:* - \u2014 $193 - (can attempt w/ Raspberry Pi) \u2014 $110 - \u2014 $100 - \u2014 $60 - \u2014 $40 - \u2014 $50 Total \u2014 $553 Recommended operating system and software: Ubuntu LTS, and Compose]. Ensure you have the necessary tools installed with: [source,bash] ---- sudo apt install -y jq curl net-tools ---- == Layer 1: Data Layer The bottom-most layer of the stack is the data layer. Here, Starknet's L2 leverages Ethereum's L1 for proof verification and data availability. Starknet utilizes Ethereum as its L1, so the first step is setting up an Ethereum Full Node. As this is the data layer, the hardware bottleneck is usually the disk storage. It's crucial to have a high capacity I/O SSD over an HDD because Ethereum Nodes require both an Execution Client and a Consensus Client for communication. Ethereum provides several options for Execution and Consensus clients. Execution clients include Geth, Erigon, Besu (used here), Nethermind, and Akula. Consensus clients include Prysm, Lighthouse (used here), Lodestar, Nimbus, and Teku. Your Besu/Lighthouse node will take approximately 600 GB of disk space. Navigate to a partition on your machine with sufficient capacity and run the following commands: [source,bash] ---- git clone git@github.com:starknet-edu/starknet-stack.git cd starknet-stack docker compose -f dc-l1.yaml up -d ---- This will begin the fairly long process of spinning up our Consensus Client, Execution Client, and syncing them to the current state of the Goerli Testnet. If you would like to see the logs from either process you can run: [source,bash] ---- # tail besu logs docker container logs -f $(docker ps | grep besu | awk '{print $1}') # tail lighthouse logs docker container logs -f $(docker ps | grep lighthouse | awk '{print $1}') ---- Lets make sure that everything that should be listening is listening: [source,bash] ---- # should see all ports in commanad output # besu ports sudo netstat -lpnut | grep -E '30303|8551|8545' # lighthouse ports sudo netstat -lpnut | grep -E '5054|9000' [source,bash] ---- We\u2019ve used docker to abscract a lot of the nuance of running a Eth L1 node, but the important things to note are how the two processes EL/CL point to each other and communicate via JSON-RPC: [source,bash] ---- services: lighthouse: image: sigp/lighthouse:latest container_name: lighthouse volumes: - ./l1_consensus/data:/root/.lighthouse - ./secret:/root/secret network_mode: \"host\" command: - lighthouse - beacon - --network=goerli - --metrics - --checkpoint-sync-url= - --execution-endpoint= - --execution-jwt=/root/secret/jwt.hex besu: image: hyperledger/besu:latest container_name: besu volumes: - ./l1_execution/data:/var/lib/besu - ./secret:/var/lib/besu/secret network_mode: \"host\" command: - --network=goerli - --rpc- - --data-path=/var/lib/besu - --data-storage-format=BONSAI - --sync-mode=X_SNAP - --engine-rpc-enabled=true - --engine-jwt-enabled=true - --engine-jwt-secret=/var/lib/besu/secret/jwt.hex ---- Once this is done, your Ethereum node should be up and running, and it will start syncing with the Ethereum network. == Layer 2: Execution Layer The next layer in our Starknet stack is the Execution Layer. This layer is responsible for running the Cairo VM, which executes Starknet smart contracts. The Cairo VM is a deterministic virtual machine that allows developers to write complex smart contracts in the Cairo language. Starknet uses a similar spec] as in order to interact with the execution layer. In order to stay current with the propagation of the Starknet blockchain we need a client similar to Besu that we are using for L1. The efforts to provide full nodes for the Starknet ecosystem are: (used here), and However, different implementations are still in development and not yet ready for production. Check that your L1 has completed its sync: [source,bash] ---- # check goerli etherscan to make sure you have the latest block curl --location --request POST ' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"jsonrpc\":\"2.0\", \"method\":\"eth_blockNumber\", \"params\":[], \"id\":83 }' ---- Start your L2 Execution Client and note that we are syncing Starknet\u2019s state from our LOCAL ETH L1 NODE! [note] ==== PATHFINDER_ETHEREUM_API_URL= ==== [source,bash] ---- # from starknet-stack project root docker compose -f dc-l2.yaml up -d ---- To follow the sync: [source,bash] ---- docker container logs -f $(docker ps | grep pathfinder | awk '{print $1}') ---- Starknet Testnet_1 currently comprises ~600,000 blocks so this will take some time to sync fully. To check L2 sync: [source,bash] ---- # compare `current_block_num` with `highest_block_num` curl --location --request POST ' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"jsonrpc\":\"2.0\", \"method\":\"starknet_syncing\", \"params\":[], \"id\":1 }' ---- To check data sizes: [source,bash] ---- sudo du -sh ./* | sort -rh ---- == Layer 3: Application Layer We see the same need for data refinement as we did in the OSI model. On L1 packets come over the wire in a raw stream of bytes and are then processed and filtered by higher-level protocols. When designing a decentralized application Bob will need to be cognizant of interactions with his contract on chain, but doesn\u2019t need to be aware of all the information occurring on Starknet. This is the role of an indexer. To process and filter useful information for an application. Information that an application MUST be opinionated about and the underlying layer MUST NOT be opinionated about. Indexers provide applications flexibility as they can be written in any programming language and have any data layout that suites the application. To start our toy run: [source,bash] ---- ./indexer/indexer.sh ---- Again notice that we don\u2019t need to leave our local setup for these interactions ( == Layer 4: Transport Layer The transport layer comes into play when the application has parsed and indexed critical information, often leading to some state change based on this information. This is where the application communicates the desired state change to the Layer 2 sequencer to get that change into a block. This is achieved using the same full-node/RPC spec implementation, in our case, Pathfinder. When working with our local Starknet stack, invoking a transaction locally might look like this: [source,bash] ---- curl --location --request POST ' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"jsonrpc\": \"2.0\", \"method\": \"starknet_addInvokeTransaction\", \"params\": { \"invoke_transaction\": { \"type\": \"INVOKE\", \"max_fee\": \"0x4f388496839\", \"version\": \"0x0\", \"signature\": [ \"0x7dd3a55d94a0de6f3d6c104d7e6c88ec719a82f4e2bbc12587c8c187584d3d5\", \"0x71456dded17015d1234779889d78f3e7c763ddcfd2662b19e7843c7542614f8\" ], \"contract_address\": \"0x23371b227eaecd8e8920cd429d2cd0f3fee6abaacca08d3ab82a7cdd\", \"calldata\": [ \"0x1\", \"0x677bb1cdc050e8d63855e8743ab6e09179138def390676cc03c484daf112ba1\", \"0x362398bec32bc0ebb411203221a35a0301193a96f317ebe5e40be9f60d15320\", \"0x0\", \"0x1\", \"0x1\", \"0x2b\", \"0x0\" ], \"entry_point_selector\": \"0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad\" } }, \"id\": 0 }' ---- However, this process involves setting up a local wallet and signing the transaction. For simplicity, we will use a browser wallet and StarkScan. Steps: . Navigate to the contract on StarkScan and connect to your wallet. . Enter a new value and write the transaction: image::node2.png[node2] Once the transaction is accepted on the Layer 2 execution layer, the event data should come through our application layer indexer. Example Indexer Output: [source,bash] ---- Pulled Block #: 638703 Found transaction: 0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5 Events to Index: [ { \"from_address\": \"0x806778f9b06746fffd6ca567e0cfea9b3515432d9ba39928201d18c8dc9fdf\", \"keys\": [ \"0x1fee98324df9b8703ae8de6de3068b8a8dce40c18752c3b550c933d6ac06765\" ], \"data\": [ \"0xa\" ] }, { \"from_address\": \"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\", \"keys\": [ \"0x5ad857f66a5b55f1301ff1ed7e098ac6d4433148f0b72ebc4a2945ab85ad53\" ], \"data\": [ \"0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\", \"0x0\" ] }, { \"from_address\": \"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\", \"keys\": [ \"0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9\" ], \"data\": [ \"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\", \"0x46a89ae102987331d369645031b49c27738ed096f2789c24449966da4c6de6b\", \"0x17c1e31c270\", \"0x0\" ] } ] ---- Once the transaction is accepted on Layer 1, we can query the Starknet Core Contracts from our Layer 1 node to see the storage keys that have been updated on our data layer! You have successfully navigated through the entire Starknet stack, from setting up your node, through executing and monitoring a transaction, to inspecting its effects on the data layer. This journey has equipped you with the understanding and the skills to interact with Starknet on a deeper level. == Conclusion: Understanding the Modular Nature of Starknet Conceptual models, such as the ones used in this guide, are incredibly useful in helping us understand complex systems. They can be refactored, reformed, and nested to provide a clear and comprehensive view of how a platform like Starknet operates. For instance, the OSI Model, a foundational model for understanding network interactions, underpins our modular stack. A key concept to grasp is 'Fractal Scaling.' This concept allows us to extend our model to include additional layers beyond Layer 2, such as Layer 3. In this extended model, the entire stack recurs above our existing stack, as shown in the following diagram: image::node3.png[node3] Just as Layer 2 compresses its transaction throughput into a proof and state change that is written to Layer 1, we can apply the same compression principle at Layer 3, proving and writing to Layer 2. This not only gives us more control over the protocol rules but also allows us to achieve higher compression ratios, enhancing the scalability of our applications. In essence, Starknet's modular and layered design, combined with the power of Fractal Scaling, offers a robust and scalable framework for building decentralized applications. Understanding this structure is fundamental to effectively leveraging Starknet's capabilities and contributing to its ecosystem. This concludes our journey into running a Starknet node and traversing its layered architecture. We hope that you now feel equipped to explore, experiment with, and innovate within the Starknet ecosystem. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "sequencers.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "= Sequencers in Starknet == Introduction to Sequencers A sequencer is a crucial component in blockchain and Layer-2 solutions responsible for managing the ordering and execution of transactions. In Starknet, sequencers ensure that transactions are executed in a specific order to prevent double-spending and maintain the network's state consistency. Sequencers receive transactions, process them according to predetermined rules, and produce a series of ordered actions or state changes. These actions are then bundled into blocks and are included in the blockchain. image::sequencer.png[sequencer] == The Role of Sequencers in Starknet Sequencers play a vital role in Starknet's performance and security by executing transactions and applying state changes according to the protocol's rules and requirements. Starknet's sequencer is particularly relevant due to the network's use of zero-knowledge proofs (ZKPs). The sequencer's proper functioning ensures that transactions are executed in a manner compatible with the generation of ZKPs, contributing to Starknet's overall scalability and security. Users interact with sequencers when submitting transactions to Starknet as the first step towards STARK scaling. Once a sequencer assembles a block, the consensus protocol approves it, and provers generate a proof for Layer 1 (L1). In Ethereum, miners order and execute transactions, while sequencers serve a similar purpose in Starknet. Sequencers process transactions, aggregate them, and produce blocks, making them a critical infrastructure piece in the Starknet ecosystem. As Starknet evolves, enhancing the sequencer's performance is crucial. This is where the transition to Rust-based sequencers becomes essential. By rewriting the core sequencer components in Rust, the network can achieve improved performance, throughput, and resilience. Examples of sequencer implementations include the link: Tendermint Sequencer] by LambdaClass and link: a Rust-powered Starknet sequencer using Substrate. == Evolution of Starknet and Sequencers Originally, sequencers were written in Python, which proved inefficient for large-scale operations. As the network reached capacity, developers sought to improve sequencer performance. The first milestone was establishing a fully functioning blockchain, followed by a focus on performance optimization. The initial performance enhancement involved implementing optimistic concurrency for parallel transaction execution. However, the most significant advancement came from rewriting sequencers in Rust, a more efficient and faster language. Rewriting sequencers in Rust has shown promising results in performance and scalability. The throughput and latency of the Starknet network are expected to improve dramatically, benefiting the network and those working with related infrastructure and development tools. link: of the new sequencers] is based on Papyrus, an open-source Starknet full node responsible for state management. Early benchmarks for projects like Madara reveal a remarkable 76 TPS (transactions per second) for ERC20 transfers, showcasing the potential improvements Rust-based sequencers bring to the Starknet ecosystem. Optimistic concurrency implementation also contributes to sequencer performance improvements by executing transactions in parallel, checking for conflicts in touched storage cells, and invalidating subsequent transactions when necessary. == Future Developments As Starknet evolves, sequencer development will progress, focusing on enhancing capabilities and ensuring seamless integration with the network. Developers will work on new features, such as fee mechanisms, to be implemented in upcoming releases like Memphis. Continuous improvement and optimization of sequencers are vital for the sustained growth of Starknet. The transition to Rust-based sequencers and ongoing efforts to enhance their performance will undoubtedly contribute == Conclusion Sequencers play a pivotal role in the Starknet ecosystem by managing transaction ordering and execution. As the network continues to evolve, enhancing sequencer performance through optimizations and transitions to more efficient languages like Rust is essential to ensure scalability, security, and throughput. The ongoing development and improvement of sequencers will support the growth of the Starknet network and empower developers and users to harness the full potential of this innovative Layer-2 solution. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "sharp.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"sharp\"] = SHARP (Shared Prover) in Starknet SHARP is like public transportation for proofs on Starknet, aggregating multiple Cairo programs to save costs and boost efficiency. It uses recursive proofs, allowing parallelization and optimization, making it more affordable for all users. Critical services like the gateway, validator, and Prover work together with a stateless design for flexibility. SHARP\u2019s adoption by StarkEx, Starknet, and external users (trough the Cairo Playground) highlights its significance and potential for future optimization. This chapter will discuss SHARP, how it has evolved to incorporate recursive proofs, and its role in reducing costs and improving efficiency within the Starknet network. == What is SHARP? SHARP, which stands for \"Shared Prover\", is a mechanism used in Starknet that aggregates multiple Cairo programs from different users, each containing different logic. These Cairo programs are then executed together, generating a single proof common to all the programs. Rather than sending the proof directly to the Solidity Verifier in Ethereum, it is initially sent to a STARK Verifier program written in Cairo. The STARK Verifier generates a new proof to confirm that the initial proofs were verified, which can be sent back into SHARP and the STARK Verifier. This recursive proof process will be discussed in more detail later in this chapter. Ultimately, the last proof in the series is sent to the Solidity Verifier on Ethereum. In other words, there are many proofs generated until we reach Ethereum and the Solidity Verifier. The primary benefit of SHARP system lies in its ability to decrease costs and enhance efficiency within the Starknet network. It achieves this by aggregating multiple Cairo jobs, which are individual sets of computations. This aggregation allows the protocol to leverage the exponential amortization offered by STARK proofs. Exponential amortization means that as the computational load of the proofs increases, the cost of verifying those proofs rises at a slower logarithmic rate than the computation increase. In other words, the computation itself grows slower than the verification cost. As a result, the cost of each transaction within the aggregated set is significantly reduced, making the overall process more cost-effective and accessible for users. [NOTE] ==== In SHARP and Cairo context, \"jobs\" refer to the individual Cairo programs or tasks submitted by different users. These jobs contain specific logic or computations that must be executed on the Starknet network. ==== Additionally, SHARP allows smaller users with limited computation to benefit from joining other jobs and share the cost of generating the proofs. This collaborative approach is similar to using public transportation instead of a private car, where the cost is distributed among all participants, making it more affordable for everyone. == Recursive Proofs in SHARP One of the most powerful features of SHARP is its use of recursive proofs. Rather than directly sending the generated proofs to the Solidity Verifier, they are first sent to a STARK Verifier program written in Cairo. This Verifier, which is also a Cairo Program, receives the proof and creates a new Cairo job that is sent to the Prover. The Prover then generates a new proof to confirm that the initial proofs were verified. These new proofs can be sent back into SHARP and the STARK Verifier, restarting the process. This process continues recursively, with each new proof being sent to the Cairo Verifier until a trigger is reached. At this point, the last proof in the series is sent to the Solidity Verifier on Ethereum. This approach allows for greater parallelization of the computation and reduces the time and cost associated with generating and verifying proofs. Generated Proofs | V STARK Verifier program (in Cairo) | V Cairo Job | V Prover | V New Proof Generated | V Repeat Process | V Trigger Reached (last proof) | V Solidity Verifier At first glance, recursive proofs may seem more complex and time-consuming. However, there are several benefits to this approach: . *Parallelization*: Recursive proofs allow for work parallelization, reducing user latency and improving SHARP efficiency. . *Cheaper on-chain costs*: Parallelization enables SHARP to create larger proofs, which would have previously been limited by the availability of large cloud machines (which are rare and limited). As a result, on-chain costs are reduced. . *Lower cloud costs*: Since each job is shorter, the required memory for processing is reduced, resulting in lower cloud costs. . *Optimization*: Recursive proofs enable SHARP to optimize for various factors, including latency, on-chain costs, and time to proof. . *Cairo support*: Recursive proofs only require support in Cairo, without the need to add support in the Solidity Verifier. [NOTE] ==== Latency in Starknet encompasses the time taken for processing, confirming, and including transactions in a block. It is affected by factors like network congestion, transaction fees, and system efficiency. Minimizing latency ensures faster transaction processing and user feedback. Time to proof, however, specifically pertains to the duration required to generate and verify cryptographic proofs for transactions or operations. ==== == SHARP Backend Architecture and Data Pipeline SHARP back end architecture consists of several services that work together to process Cairo jobs and generate proofs. These services include: . *Gateway*: Cairo jobs enter SHARP through the gateway. . *Job Creator*: It prevents job duplication and ensures that the system operates consistently, regardless of multiple identical requests. . *Validator*: This is the first important step. The validator service runs validation checks on each job, ensuring they meet the requirements and can fit within the prover machines. Invalid jobs are tagged as such and do not proceed to the Prover. . *Scheduler*: The scheduler service creates \"trains\" that aggregate jobs and send them to the Prover. Recursive jobs are paired and sent to the Prover together. . *Cairo Runner*: This service runs Cairo for the Prover\u2019s needs. The Cairo Runner service runs Cairo programs, executing the necessary computations and generating the execution trace as an intermediate result. The Prover then uses this execution trace. . *Prover*: The Prover computes the proofs for each train (that contains a few jobs). . *Dispatcher*: The Dispatcher serves two functions in the SHARP system. .. In the case of a recursive proof, the Dispatcher runs the Cairo Verifier program on the proof it has received from the Prover, resulting in a new Cairo job that goes back to the Validator. .. In the case of a proof that needs to go on chain (e.g., to Ethereum), the Dispatcher creates \"packages\" from the proof, which can then be sent to the Blockchain Writer. . *Blockchain Writer*: Once the packages have been created by the Dispatcher, they are sent to the Blockchain Writer. The Blockchain Writer is responsible for sending the packages to the appropriate blockchain (e.g., Ethereum) for verification. This is an important step in the SHARP system, as it ensures that the proofs are properly verfied and that the transactions are securely recorded on the blockchain. . *Catcher*: The Catcher monitors blockchain (e.g., Ethereum) transactions to ensure that they have been accepted. While the Catcher is relevant for internal monitoring purposes, it is important to note that if a transaction fails, the fact won't be registered on-chain in the fact registry. As a result, the soundness of the system is still preserved even without the catcher. SHARP is designed to be stateless (each Cairo job is executed in its own context and has no dependency on other jobs), allowing for greater flexibility in processing jobs. == Current SHARP Users Currently, the primary users of SHARP include: * StarkEx * Starknet * External users who use the Cairo Playground == Challenges and Optimization Optimizing the Prover involves numerous challenges and potential projects on which the Starkware team and the community are currently working: * Exploring more efficient hash functions: SHARP is constantly exploring more efficient hash functions for Cairo, the Prover, and Solidity. * Investigating smaller fields: Investigating smaller fields for recursive proof steps could lead to more efficient computations. * Adjusting various parameters: SHARP is continually adjusting various parameters of the STARK protocol, such as FRI parameters and block factors. * Optimizing the Cairo code: SHARP is optimizing the Cairo code to make it faster, resulting in a faster recursive prover. * Developing dynamic layouts: This will allow Cairo programs to scale resources depending on their needs. * Improving scheduling algorithm: This is another optimization path that can be taken. It is not within the Prover itself. In particular, dynamic layouts (you can learn more about layouts here (TODO)) will allow Cairo programs to scale resources depending on their needs. This can lead to more efficient computation and better utilization of resources. Dynamic layouts allow SHARP to determine the required resources for a specific job and adjust the layout accordingly instead of relying on predefined layouts with fixed resources. This approach can provide tailored solutions for each job, improving overall efficiency. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Conclusion In conclusion, SHARP is a critical component of Starknet\u2019s architecture, providing a more efficient and cost-effective solution for processing Cairo programs and verifying their proofs. By leveraging the power of STARK technology and incorporating recursive proofs, SHARP plays a vital role in improving the overall performance and scalability of the Starknet network. The stateless nature of SHARP and the reliance on the cryptographic soundness of the STARK proving system make it an innovative and valuable addition to the blockchain ecosystem."}
{"title": "solidity_verifier.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"verifiers_solidity\"] = Verifiers in Solidity L1 smart contract that verifies STARK proofs from SHARP. In the discussion below, we will encounter several contracts: - Sharp Verifier]: Proxy contract - Contract that verifies a proof and registers the corresponding facts. - - == Example of a Verifier transaction Let's take a look at a transaction that was sent to the Verifier contract on Ethereum mainnet. === Transaction trace * Verifier contract is a proxy contract so when it's called, implementation contract is called instead. Implementation contract is GpsStatementVerifier contract. The transaction that set the latest implementation can be find * On GpsStatementVerifier contract, function `verifyProofAndRegister` got executed with the following trace, you can check its code - `call` MemoryPageFactRegistry.registerRegularMemoryPage(), code This function . Computes and stores the factHash in the mapping verifiedFact; . Emits an event LogMemoryPageFactRegular with factHash = `0x72C8D723081B60693B32D77A369782FF189754A5897002314FB1569B7E2EE1E2` - `call` CpuFrilessVerifier.verifyProofExternal(), code that leads to the contract. - Then that makes a `staticcall` to MemoryPageFactRegistry.isValid() with argument is the factHash mentioned above, and get the respond true - You can check by yourself by querying the `isValid` function on MemoryPageFactRegistry contract with input `0x72C8D723081B60693B32D77A369782FF189754A5897002314FB1569B7E2EE1E2` to have `true` as output. == Verifier contract in Starknet architecture The example above shows the example of verifying/registering proof on Ethereum and gives a glimpse of how the Verifier contract is used in the Starknet architecture. In general, SHARP takes the Cairo program\u2019s execution trace, proves that it\u2019s valid, and sends this proof to the Verifier contract on Ethereum. After verifying the proof, the on-chain verifier takes an important extra step: it writes a fact attesting to the validity of the proof in the Fact Registry. This fact is like a trustless stamp of approval, certifying that the Cairo program was computed correctly. Now all that is left for the dApp\u2019s smart contract is to check that this fact exists, in order to rely on the computation that was executed off-chain. Here is the overall diagram of the how each component interacts with each other in the Starknet architecture. image::starknet_architecture.png[starknet architecture] == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "topology.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"topology\"] = Starknet's Structure: Sequencers, Provers, and Nodes Starknet, with its innovative architecture, ushers in a new era of Layer 2 solutions, promising higher scalability and security. This chapter provides a high-level overview of the Starknet network structure and its transaction lifecycle, highlighting the pivotal roles of sequencers, provers, and nodes within the network. This simplified explanation is tailored to the needs of developers and users, both experienced and newcomers. For a deep dive into the architecture, please refer to the \"Starknet Architecture\" chapter. Starknet's system is like a well-oiled machine where sequencers, provers, and nodes each play distinct but interrelated roles. While Starknet is yet to achieve complete decentralization, it is making strides, particularly in development, towards this overarching goal. Understanding the roles and interactions of these actors will help you comprehend the Starknet ecosystem better. == Sequencers Sequencers are a crucial part of the Starknet network and have a central role in its operation, similar to validators in Ethereum. They serve as the point of entry for transactions into the Starknet system. The greatest asset of ZK rollups is their ability to delegate some of the network's tasks \u2013 specifically, the aggregation and processing of transactions \u2013 to specialized entities. This process is similar to how Ethereum and Bitcoin outsource their security to miners and then validate their work. Just as mining isn't a small business, sequencing requires significant resources due to its high-capacity and liveness requirements. For networks like Starknet and other platforms utilizing ZK rollups, a similar parallel is drawn. These networks outsource transaction processing to specialized entities and then verify their work. These specialized entities in the context of ZK rollups are known as \"sequencers.\" Instead of providing security, as miners do, sequencers provide transaction capacity. They aggregate multiple transactions into a single batch, process them, and produce a block that will later be proved by the Prover and submited to the Layer 1 network as a single, compact proof, known as a \"rollup.\" In other words, just as validators in Ethereum and miners in Bitcoin are specialized actors securing the network, sequencers in ZK rollup-based networks are specialized actors that provide transaction capacity. This mechanism allows Validity (or ZK) rollups to handle a higher volume of transactions while maintaining the security of the underlying Ethereum network. It enhances scalability without compromising on security. Sequencers follow a systematic method for transaction processing: 1. Aggregation: They collect transactions from users. 2. Processing: Sequencers then process these transactions according to the rules defined by the network. 3. Batching: Transactions are grouped together in batches or blocks for efficiency. 4. Block Production: Sequencers produce blocks that contain batches of processed transactions. Sequencers must be reliable and highly available, as their role is critical to the network's smooth functioning. They need powerful and well-connected machines to perform their role effectively, as they must process transactions rapidly and continuously. The current roadmap for Starknet includes decentralizing the sequencer role. This shift towards decentralization will allow more participants to become sequencers, contributing to the robustness and security of the network. == Provers Provers serve as the second line of verification in the Starknet network. Their main task is to validate the work of the sequencers (when they receive the block produced by the Sequencer) and to generate proofs that these processes were correctly performed. The duties of a prover include: 1. Receiving Blocks: Provers obtain blocks of processed transactions from sequencers. 2. Processing: Provers process these blocks a second time, ensuring that all transactions within the block have been correctly handled. 3. Proof Generation: After processing, provers generate a proof of correct transaction processing. 4. Sending Proof to Ethereum: Finally, the proof is sent to the Ethereum network for validation. If the proof is correct, the Ethereum network accepts the block of transactions. Provers need even more computational power than sequencers because they have to calculate and generate proofs, a process that is computationally heavy. However, the work of provers can be split into multiple parts, allowing for parallelism and efficient proof generation. The proof generation process is asynchronous, meaning it doesn't have to occur immediately or in real-time. This flexibility allows for the workload to be distributed among multiple provers. Each prover can work on a different block, allowing for parallelism and efficient proof generation. The design of Starknet relies on these two types of actors \u2014 sequencers and provers \u2014 working in tandem to ensure efficient processing and secure verification of transactions. == Nodes When it comes to defining what nodes do in Bitcoin or Ethereum, people often misinterpret their role as keeping track of every transaction within the network. This, however, is not entirely accurate. Nodes serve as auditors of the network, maintaining the state of the network, such as how much Bitcoin each participant owns or the current state of a specific smart contract. They accomplish this by processing transactions and preserving a record of all transactions, but that's a means to an end, not the end itself. In ZK rollups and specifically within Starknet, this concept is somewhat reversed. Nodes don't necessarily have to process transactions to get the state. In contrast to Ethereum or Bitcoin, Starknet nodes aren't required to process all transactions to maintain the state of the network. [NOTE] ==== There are two main ways to access network state data: via an API gateway or using the RPC protocol to communicate with a node. Operating your own node is typically faster than using a shared architecture, like the gateway. Over time, Starknet plans to deprecate APIs and replace them with a JSON RPC standard, making it even more beneficial to operate your own node. It's worth noting that encouraging more people to run nodes increases the resilience of the network and prevents server flooding, which has been an issue in networks in other L2s. ==== Currently, there are primarily three methods for a node to keep track of the network's state: 1. *Replaying Old Transactions*: Like Ethereum or Bitcoin, a node can take all the transactions and re-execute them. Although this approach is accurate, it isn't scalable unless you have a powerful machine that's capable of handling the load. If you can replay all transactions, you can become a Sequencer. 2. *Relying on L2 Consensus*: Nodes can trust the Sequencer(s) to execute the network correctly. When the sequencer updates the state and adds a new block, nodes accept the update as accurate. 3. *Checking Proof Validation on L1*: Nodes can monitor the state of the network by observing L1 and ensuring that every time a proof is sent, they receive the updated state. This way, they don't have to trust anyone and only need to keep track of the latest valid transaction for Starknet. Each type of node setup comes with its own set of hardware requirements and trust assumptions. === Nodes That Replay Transactions Nodes that replay transactions require powerful machines to track and execute all transactions. These nodes don't have trust assumptions; they rely solely on the transactions they execute, guaranteeing that the state at any given point is valid. === Nodes That Rely on L2 Consensus Nodes relying on L2 consensus require less computational power. They need sufficient storage to keep the state but don't need to process a lot of transactions. The trade-off here is a trust assumption. Currently, Starknet revolves around one sequencer, so these nodes are trusting Starkware not to disrupt the network. However, once a consensus mechanism and leader election amongst sequencers are in place, these nodes will only need to trust that a sequencer who staked their stake to produce a block is not willing to lose it. === Nodes That Check Proof Validation on L1 Nodes that only update their state based on proof validation on L1 require the least hardware. They have the same requirements as an Ethereum node, and once Ethereum light nodes become a reality, maintaining such a node could be as simple as using a smartphone. The only trade-off is latency. Proofs are not sent to Ethereum every block but intermittently, resulting in delayed state updates. Plans are in place to produce proofs more frequently, even if they are not sent to Ethereum immediately, allowing these nodes to reduce their latency. However, this development is still a way off in the Starknet roadmap. == Conclusion Through this chapter, we delve into Starknet's structure, uncovering the importance of sequencers, provers, and nodes. Each plays a unique role, but together, they create a highly scalable, efficient, and secure network that marks a significant step forward in Layer 2 solutions. As Starknet evolves towards decentralization, understanding these roles will provide valuable insight into the inner workings of this network. As we venture further into the Starknet universe, our next stop will be an exploration of the transaction lifecycle before we dive into the heart of coding with Cairo. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "transactions.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "= Behind The Scenes: Starknet Transaction Lifecycle Whether you're a developer wanting to dive deeper into Starknet or a crypto enthusiast eager to understand the intricacies of Layer-2 solutions, this chapter on the transaction lifecycle in Starknet will provide valuable insights. However, if you want to get straight into coding with Cairo, feel free to skip to the next chapter. A transaction's journey in Starknet, from its inception to finality, comprises a series of carefully orchestrated steps. Each stage plays a crucial role in ensuring data is accurately transmitted, processed, and stored within the network. In this chapter, we explore the lifecycle of a Starknet transaction. == Preparing the Groundwork: Transaction Creation Every transaction's journey commences with its preparation. The sender queries the nonce of their account, serving as a unique identifier for each transaction, signs the transaction, and dispatches it to their node. It's critical to understand the sender must be online during this process to access real-time data. [source] ---- Preparing Transactions 1. Query the nonce of your account 2. Sign your transaction 3. Send your transaction to your node ---- The node, analogous to a post office, receives the transaction and broadcasts it on the Starknet network, primarily to the sequencer. As the network evolves, the transaction will be broadcasted to multiple sequencers. == Reception and Processing: The Sequencer's Role On receiving the transaction, the sequencer acknowledges its receipt but hasn't processed it yet\u2014similar to Ethereum's mempool state. [source] ---- Sequencer's Process 1. Receive the transaction 2. Validate the transaction 3. Execute the transaction 4. Update the state ---- It's crucial to remember the sequentiality of transaction processing in Starknet: the nonce won't update until the sequencer processes your transaction. This aspect could become a hurdle when building backend applications, as sending multiple transactions consecutively may result in confusion or errors. == Acceptance on Layer-2 (L2) When the sequencer validates and executes a transaction, it immediately updates the state without waiting for the block emission. The transaction status changes from 'received' to 'pending' at this stage. Following the state update, the transaction is included in a block. However, the block isn't emitted immediately. The sequencer decides the opportune moment to emit the block, either when there are enough transactions to form a block or after a certain time has passed. When the block is emitted, the transaction's status changes to 'accepted on L2', and the block becomes available for other nodes to query. [source] ---- Transaction Status Transition 1. Received -> Pending 2. Pending -> Accepted on L2 ---- It's essential to remember that at this stage, no proof has been generated, and the transaction relies on L2 consensus for security. There remains a slim possibility of transaction reversal if all sequencers collude. Therefore, these stages should be seen as different layers of transaction finality. To improve user experience, the 'pending' status will be removed in future versions, and all transactions waiting to be in a block will be marked as 'accepted on L2'. == Acceptance on Layer-1 (L1) The final step in the transaction's lifecycle is its acceptance on Layer-1 (L1). A 'prover' receives the block containing the transaction, re-executes the block, generates a proof, and sends it to Ethereum. Specifically, the proof is sent to a smart contract on Ethereum called the Verifier smart contract, which checks the proof's validity. If valid, the transaction's status changes to 'accepted on L1', signifying the transaction's security by Ethereum consensus. [source] ---- Transaction Status Transition 1. Accepted on L2 -> Accepted on L1 ---- == [Optional] Transaction Finality in Starknet Transaction finality refers to the point at which a transaction is considered irreversible and is no longer susceptible to being reversed or undone. It's the assurance that once a transaction is committed, it can't be altered or rolled back, hence securing the integrity of the transaction and the system as a whole. Let's dive into the transaction finality in both Starknet and Ethereum, and how they compare. === Ethereum Transaction Finality Ethereum operates on a Proof of Stake (PoS) consensus mechanism. A transaction has the finality status when it is part of a block that can't change without a significant amount of ETH getting burned. The number of blocks required to ensure that a transaction won't be rolled back is called 'blocks to finality', and the time to create those blocks is called 'time to finality'. It is considered to be an average of 6 blocks to reach the finality status; given that a new block is validated each 12 seconds, the average time to finality for a transaction is 75 seconds. === Starknet Transaction Finality Starknet, a Layer-2 (L2) solution on Ethereum, has a two-step transaction finality process. The first step is when the transaction gets accepted on Layer-2 (Starknet), and the second step is when the transaction gets accepted on Layer-1 (Ethereum). * Accepted on L2: When a transaction is processed by the sequencer and included in a block on Starknet, it reaches L2 finality. However, this finality relies on the L2 consensus and comes with a slight risk of collusion among sequencers leading to transaction reversal. * Accepted on L1: The absolute finality comes when the block containing the transaction gets a proof generated, the proof is validated by the Verifier contract on Ethereum, and the state is updated on Ethereum. At this point, the transaction is as secure as the Ethereum's PoW consensus can provide, meaning it becomes computationally infeasible to alter or reverse. === Comparison == The main difference between Ethereum and Starknet's transaction finality lies in the stages of finality and their reliance on consensus mechanisms. * Ethereum's transaction finality becomes increasingly unlikely to be reversed as more blocks are added. * Starknet's finality process is two-fold. The initial finality (L2) is quicker but relies on L2 consensus and carries a small risk of collusion. The ultimate finality (L1) is slower, as it involves generation and validation of proofs and updates on Ethereum. However, once reached, it provides the same level of security as an Ethereum transaction. == Handling of Rejected Transactions == A transaction can be rejected at any stage if it's found to be invalid or erroneous. In the upcoming version 0.12.1, Starknet will start charging for failed transactions, which will mitigate the potential for Denial of Service (DoS) attacks. However, this change adds a trust assumption for the sequencer to be honest and non-censoring. In later versions, there will be an OS change that will enable the sequencer to prove that a transaction failed and charge the correct amount of gas for it, thus making it censorship-resistant with provably failed transactions. [source] ---- Transaction Status Transition 1. Any Stage -> Rejected (if invalid or erroneous) ---- == Transaction Lifecycle Summary == The following outlines the various steps in a transaction's lifecycle: image::transactions.png[transactions] A transaction can be rejected at any stage if it's found to be invalid or erroneous. This comprehensive lifecycle ensures that transactions on Starknet are processed efficiently, securely, and transparently. == Conclusion The lifecycle of a Starknet transaction is a carefully curated journey, ensuring efficient, secure, and transparent transaction processing. It incorporates everything from transaction creation, sequencer processing, Layer-2 acceptance, to finality on Layer-1. With the completion of our exploration of Starknet's transaction lifecycle, it's time to dive into the world of Cairo programming. In the coming chapters, we'll unwrap the complexities and potentials of this language, setting you on course to become a proficient Starknet developer. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "aa_coding.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"aa_coding\"] = More Examples of Account Contracts Here, we will explore numerous examples, elucidating the principles and techniques to effectively design and implement Account contracts. Before delving into the examples, we would like to issue a disclaimer: the contracts discussed in this chapter are for illustrative and educational purposes, and they have not undergone formal auditing. This signifies that, while we strive to provide accurate and informative content, the implementation of these contracts in a live environment should be approached with due diligence. We encourage users to thoroughly test and validate these contracts before their deployment on the mainnet. The goal of this chapter is not only to furnish a library of contract examples but also to foster collaboration and knowledge sharing among the Starknet community. We believe that the exchange of ideas and constructive feedback are instrumental in advancing our collective understanding and expertise. If you've developed or come across an innovative contract that could serve as a valuable learning resource for others, we invite you to contribute. Here are a few guidelines for your contribution: . *Open a PR:* To submit a contract example or suggest changes to existing ones, simply open a Pull Request. Ensure that your PR contains a thorough explanation of the contract, its use cases, and its functionality. . *Code Standards:* Please ensure that the submitted code is well-documented and adheres to the standard code conventions of Starknet. This will facilitate the review process and enhance the readability and comprehensibility of the contract. . *Detailed Explanation:* Accompany your code with a detailed explanation of the contract logic. Wherever possible, use diagrams, flowcharts, or pseudocode to illustrate complex mechanisms or workflows. As we expand this repertoire of contract examples, we hope to equip the Starknet community with a robust toolset and inspire further exploration and innovation in the realm of custom account contracts. == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "aa_roadmap.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"aa_roadmap\"] = Roadmap == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "aa_security.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"aa_security\"] = Security Considerations == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "autopayment.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"autopayment\"] = Auto-Payments Accounts == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "deploy_aa.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"deploy_aa\"] = Deploying and Interacting with Account Contracts == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "hello_account.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "= Hello World Account Contract In this chapter, we will explore the fundamentals of account contracts in Starknet using an example \"Hello World\" account contract written in Cairo language. You can find it in the contracts directory of this chapter in the Book's repository (TODO: add link). [,Rust] ---- // Import necessary modules #[account_contract] mod HelloAccount { use starknet::ContractAddress; use core::felt252; use array::ArrayTrait; use array::SpanTrait; // Validate deployment of the contract. // Returns starknet::VALIDATED to confirm successful validation. #[external] fn __validate_deploy__( class_hash: felt252, contract_address_salt: felt252, public_key_: felt252 ) -> felt252 { starknet::VALIDATED } // Validate declaration of transactions using this Account. // This function enforces that transactions now require accounts to pay fees. // Returns starknet::VALIDATED to confirm successful validation. #[external] fn __validate_declare__(class_hash: felt252) -> felt252 { starknet::VALIDATED } // Validate transaction before execution. // This function is called by the account contract upon receiving a transaction. // If the validation is successful, it returns starknet::VALIDATED. #[external] fn __validate__( contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array:: ) -> felt252 { starknet::VALIDATED } // Execute transaction. // If the '__validate__' function is successful, this '__execute__' function will be called. // It forwards the call to the target contract using starknet::call_contract_syscall. #[external] #[raw_output] fn __execute__( contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array:: ) -> Span:: { starknet::call_contract_syscall( address: contract_address, entry_point_selector: entry_point_selector, calldata: calldata.span() ).unwrap_syscall() } } ---- == External Functions The account contract includes several external functions to handle the validation and execution of transactions. These functions are: 1. `__validate_deploy__`: Validates the deployment of the contract. 2. `__validate_declare__`: Validates the declaration of transactions using the account. 3. `__validate__`: Validates a transaction before execution. 4. `__execute__`: Executes a transaction after successful validation. === __validate_deploy__ This function is responsible for validating the deployment of the account contract. It returns `starknet::VALIDATED` to confirm successful validation. [source,cairo] ---- #[external] fn __validate_deploy__( class_hash: felt252, contract_address_salt: felt252, public_key_: felt252 ) -> felt252 { starknet::VALIDATED } ---- === __validate_declare__ This function enforces that transactions now require accounts to pay fees. It returns `starknet::VALIDATED` to confirm successful validation. [source,cairo] ---- #[external] fn __validate_declare__(class_hash: felt252) -> felt252 { starknet::VALIDATED } ---- === __validate__ This function is called by the account contract upon receiving a transaction. If the validation is successful, it returns `starknet::VALIDATED`. [source,cairo] ---- #[external] fn __validate__( contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array:: ) -> felt252 { starknet::VALIDATED } ---- === __execute__ If the `__validate__` function is successful, this `__execute__` function will be called. It forwards the call to the target contract using `starknet::call_contract_syscall`. [source,cairo] ---- #[external] #[raw_output] fn __execute__( contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array:: ) -> Span:: { starknet::call_contract_syscall( address: contract_address, entry_point_selector: entry_point_selector, calldata: calldata.span() ).unwrap_syscall() } ---- == Declaring and Deploying the Hello World Account Contract The declaring and deploying process is the same as with other contracts. Before declaring and deploying the Hello World account contract, you must first have an account contract set up to manage the deployment process. To learn more about deploying an account contract, refer to the subchapter on deploying in Chapter 2 of the Book. Remember to compile using `scarb build` (refer to the Scarb subchapter in Chapter 2 of the Book). Then follow the steps below to declare and deploy the Hello World account contract: * Export the required environment variables: [source,bash] ---- export STARKNET_NETWORK=alpha-goerli export STARKNET_WALLET=starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount ---- * Declare the contract (since the contract is already declared, you can skip this step. If you want to declare it anyway, run the following command but you will receive an error): [source,bash] ---- starknet declare --contract target/release/starknetbook_chapter_7_HelloAccount.json --account my_account --max_fee 100000000000000000 ---- The class hash is: 0x07e813097812d58afbb4fb015e683f2b84e4f008cbecc60fa6dece7734a2cdfe * Deploy the contract: [source,bash] ---- starknet deploy --class_hash 0x07e813097812d58afbb4fb015e683f2b84e4f008cbecc60fa6dece7734a2cdfe --account my_account --max_fee 100000000000000000 ---- After completing these steps, you will have successfully declared and deployed the Hello World account contract on Starknet. is a deployed version]. == Summary In this subchapter, we delved into the details of a basic account contract in Starknet using a \"Hello World\" example. We also outlined the steps to declare and deploy the Hello World account contract on the Starknet network. The deployment process involves exporting the required environment variables, declaring the contract, and deploying it using the class hash. As we progress in our exploration of Starknet account contracts, the next subchapter will introduce a standard account contract, drawing parallels with the standard account contract defined by Open Zeppelin and Starkware. This will further strengthen our understanding of how account contracts operate within the Starknet ecosystem. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "index.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"IntroToAA\"] = Account Abstraction == What is Account Abstraction? Account Abstraction (AA) is a paradigm shift in how accounts and transactions are managed in blockchain networks. To break it down, AA refers to two intertwined notions: 1. Transaction Flexibility: This gives the power to each smart contract to validate its transactions, rather than enforcing a one-size-fits-all validation process. This can lead to a variety of potential benefits such as enabling smart contracts to pay for gas fees, allowing multiple signers for a single account, and even introducing advanced cryptographic signatures. 2. User Experience Optimization: AA provides a more intuitive experience for end-users. It allows developers to create a more flexible security model, for instance, allowing different keys for everyday use and high-value transactions. Additionally, it eliminates, if wished, the need for seed phrases, instead opting for easier recovery methods. At a technical level, AA replaces Externally Owned Accounts (EOA) with a generalized concept of accounts. Under this model, accounts can be represented by a smart contract that dictates their specific rules and behaviors. This means the user or contract account could dictate rules about transaction ordering, signatures, access controls, and more, providing a high level of customization. Here are two commonly cited definitions of AA: ____ Definition 1: Account Abstraction (AA) is when a *smart contract can pay for its own transactions* (Martin Triay, Devcon 6)[1]. In other words, abstract contracts (or account smart contracts) can pay for transactions. This is a departure from the traditional Externally Owned Accounts or Smart Wallets. ____ ____ Definition 2: AA is *validation abstraction*. Instead of relying on a single method of transaction validation, as with Ethereum's Layer 1, AA enables an abstraction of the validation process. This implies the possibility of using different types of signatures, cryptographic primitives, execution processes, etc. (lightclient, Devcon 6)[3]. ____ AA is positioned as the cornerstone of the next generation blockchain technologies, with significant improvements in scalability, user experience, and security. It is currently being pioneered by Layer 2 solutions, including Starknet, as they aim to revolutionize the way we approach security, user experience, and self-custody in the crypto space. == Applications of Account Abstraction Having defined Account Abstraction, let's delve into its practical applications. Account Abstraction aims to improve both the accessibility and security of self-custody. Here are a few of the key features that AA enables: 1. *Hardware Signer:* With AA, you could sign transactions using a key generated and safeguarded by your smartphone's secure enclave. This use of biometric identity makes the process more secure and user-friendly (Starkware)[4], (Braavos)[7]. 2. *Social recovery:* With the integration of AA, if you lose or compromise your key, you could securely replace it, thus eliminating the need for seed phrases. This change not only enhances security but also simplifies the user experience (Julien Niset, 2022)[5]. 3. *Key rotation:* If a key controlling your account is compromised, you can easily replace it, negating the need to transfer your assets. 4. *Session keys:* AA can enhance the usability of web3 applications by allowing a 'sign in once' feature. This would enable websites to execute transactions on your behalf, reducing the need for continuous approvals. 5. *Custom transaction validation schemes:* AA enables the use of various signature schemes, multisignatures, and other security rules. This flexibility allows for customizable security measures to meet individual user's needs (Martin Triay, Devcon 6)[1], (Julien Niset, 2022)[5], (Motty Lavie)[7]. Moreover, AA provides enhanced security in several ways: 1. *Improved key management:* With AA, you can associate multiple devices with your wallet, so if one device is lost, you still have access to your account. 2. *Various signature and validation schemes:* AA supports additional security measures, like two-factor authentication for large transactions, providing a more secure environment that adapts to individual user's needs. 3. *Custom security policies:* Tailor security schemes to suit different types of users or devices and adapt good practices from the banking and web2 sectors. AA opens up new possibilities for both developers and users in the Ethereum ecosystem. It offers a promising pathway for a more secure, user-friendly experience and lays the groundwork for widespread adoption. == Ethereum's Current Account System: A Closer Look To fully understand the benefits of Account Abstraction (AA), let's delve into Ethereum's current account system. The system is split into two types of accounts: * *Externally Owned Accounts* (EOAs) + * *Contract Accounts* (CAs). EOAs are the accounts used by individuals, wallets, or any entity external to the Ethereum network. These accounts are identified by their address, which is derived from the public key of an associated cryptographic object called a signer. This signer, or keypair, consists of a private key and a public key. The private key, also known as the secret key, is used to digitally sign transactions or messages, establishing proof of ownership. The corresponding public key is used to verify this signature, ensuring it was indeed signed by the respective private key. This means, in order to modify the state of an account, a transaction must be initiated and signed by the corresponding private key of the account's EOA. This design choice ensures security by associating each account with a unique cryptographic identity. On the other hand, CAs are smart contracts living on the Ethereum blockchain. Unlike EOAs, they do not have a private key. They are triggered through transactions or messages initiated by EOAs, and their behavior is determined by their associated code. However, the current account model presents some challenges: 1. *Key Management:* The loss of a private key is catastrophic. Given that the private key represents the ownership of the account, if it is lost, all the assets within the account are lost too. Similarly, if it gets stolen, the perpetrator gains full control over the account and its assets. 2. *User Experience:* Currently, the Ethereum account model lacks user-friendly methods for key recovery or account recovery, which can discourage non-technical users. Additionally, user interfaces, such as crypto wallets, can be overwhelming and difficult to use, presenting barriers for wider adoption. 3. *Lack of Flexibility:* The traditional model doesn't allow for custom transaction validation schemes, limiting the possible security and access control improvements. Account Abstraction proposes to improve upon these limitations, offering new possibilities in terms of security, scalability, and user experience. == The Need for Account Abstraction As the crypto ecosystem matures and attracts a broader user base, it faces pivotal challenges that demand innovative solutions. Among these, the question of Account Abstraction (AA) has taken center stage. Ethereum, one of the leading platforms for smart contracts and Decentralized Applications (dApps), is in a precarious position: it must embrace Account Abstraction or risk its position in the crypto world. Without AA, Ethereum's ability to provide a seamless, empowering, and secure experience for its users is hampered. This could lead to users abandoning the platform for centralized exchanges and wallets, a trend that would undermine the very ethos of decentralization that cryptocurrency and blockchain technology espouse. There are several compelling reasons why Ethereum, and the larger crypto ecosystem, needs Account Abstraction: * *Risk of Centralization:* The inefficiencies and limitations of the current account model may push users towards centralized exchanges and wallets. These entities defy the principles of decentralization, presenting familiar risks such as censorship, discrimination, and potential abuse of power. Account Abstraction, by enabling easier and more secure account management, can help uphold the principles of decentralization. * *Quantum Threat:* Quantum computing poses a potential threat to cryptographic systems, with its ability to break traditional security measures. Account Abstraction can address this by enabling the use of different signature schemes, including quantum-resistant ones, enhancing the security of assets on the blockchain. * *Scaling Self-Custody:* As the next billion users approach the crypto ecosystem, the importance of scaling self-custody becomes paramount. AA can improve the scalability of self-custody, which is essential for onboarding these new users. * *User Experience:* Simplifying the onboarding process and user experience is essential for widespread adoption. The complexity associated with current wallets and key management systems can be daunting for newcomers. Account Abstraction promises to simplify these aspects, paving the way for a more intuitive user experience. Starknet is currently leading the efforts to implement Account Abstraction at the protocol level. Many consider it to be the \"proving ground\" for the future of AA. With numerous experts from different organizations collaborating, Starknet aims to redefine the approach to security, user experience, and self-custody in the crypto space. The stakes are high. The future of Ethereum, and by extension, the crypto ecosystem, is deeply intertwined with the success of Account Abstraction. If Ethereum cannot adapt, it risks losing its prominence to other, more adaptable platforms. == Why Isn't Account Abstraction Implemented in Ethereum's Layer 1 Yet? Ethereum's Layer 1 (L1) doesn't yet support Account Abstraction (AA) at a protocol level, not due to lack of desire or understanding of its importance, but rather due to the complexity of its implementation. The most prominent roadblock in integrating AA is the entrenched nature of Externally Owned Accounts (EOAs) in Ethereum's architecture. These accounts, as fundamental elements of the Ethereum core protocol, would need significant alteration to support AA, an undertaking that becomes more daunting as the value secured by Ethereum continues to rise. One key aspect that complicates the integration of AA into Ethereum's L1 is the Ethereum Virtual Machine (EVM). The EVM, as the runtime environment for smart contracts in Ethereum, has limitations that hinder the implementation of AA. While there have been several proposals for AA since Ethereum's inception, they have been consistently delayed due to other pressing updates and improvements to the Ethereum network. However, the emergence of Layer 2 (L2) solutions provides a new pathway for the implementation of AA. With their focus on scalability and performance enhancements, these new virtual machines can better accommodate AA. Starknet and ZKSync are examples of platforms that have native AA inspired by EIP4337 \u2013 a proposal deemed superior by industry experts like Argent's Julien Niset. The repeated postponements and challenges in implementing AA on Ethereum's L1 have led many proponents, including Niset, to shift their focus. Instead of hoping for EOAs to be phased out and AA integrated at Ethereum's core, they are now advocating for the broad adoption of AA through L2 solutions like Starknet. This strategy could bring the benefits of AA to users sooner and help the Ethereum network remain competitive in the rapidly evolving crypto landscape. == Conclusion To bring it all home, imagine the Ethereum account system as a kind of multifunctional Swiss Army knife, currently under renovation. What we're doing with Account Abstraction is swapping out a few tools - while it was once a knife and a corkscrew, we're making it into a magnifying glass and a set of tweezers. Why the change? The original tools served us well, but they didn't fit every task we found ourselves up against. Some jobs required precision; others needed a broader lens. That's where Account Abstraction shines. It expands Ethereum's capabilities, adjusting and adapting to our ever-evolving requirements. Remember the complications of Ethereum's current account system? Account Abstraction seeks to transform those by offering more flexible, personalized, and safer solutions. It's like tailoring the tools of your Swiss Army knife to your unique needs. However, it's not yet implemented into Ethereum's Layer 1. And why? The kitchen is bustling, and the chefs are wary of spilling the soup. The implementation process has its challenges, it's true. But the cook who never dropped a pan never learned to make an omelette. That's why research and development continue relentlessly. Through the lens of Account Abstraction, we see Ethereum's future\u2014secure, accessible, flexible. It's an exciting, transformative prospect that's redefining what we thought possible. And though the path may be fraught with complexities and risks, it's a journey well worth taking. After all, the Swiss Army knife was once just a knife. Imagine what it could become next. == References: * [1] Martin Triay, Devcon 6: * [2] Julien Niset: * [3] lightclient, Devcon 6: * [4] Starkware: * [5] Julien Niset, 2022: * [6] Yoav, Devcon 6: * [7] Motty Lavie, 2023: [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ===="}
{"title": "multicall.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"multicall\"] = Multicalls ==== CONTRIBUTE: This subchapter is missing an example of declaration, deployment and interaction with the contract. We would love to see your contribution! Please submit a PR. ==== is a powerful technique that allows multiple constant smart contract function calls to be aggregated into a single call, resulting in a consolidated output. With Starknet's account abstraction feature, multicalls can be seamlessly integrated into account contracts. == Why Multicalls? Multicalls come handy in several scenarios. Here are some examples: 1. *Token Swapping on Decentralized Exchanges*: In a typical token swap operation on a decentralized exchange (DEX), you first need to approve the spending of the tokens and then initiate the swap. Executing these operations separately could be cumbersome from a user experience perspective. With multicall, these calls can be combined into a single transaction, simplifying the user's task. 2. *Fetching Blockchain Data*: When you want to query the prices of two different tokens from the blockchain, it's beneficial to have them both come from the same block for consistency. Multicall returns the latest block number along with the aggregated results, providing this consistency. The benefits of multicall transactions can be realized more in the context of account abstraction. == Multicall Functionality in Account Contracts To facilitate multicalls, we can introduce specific functions in the account contract. Here are two core functions: === `_execute_calls` Function The `_execute_calls` function is responsible for executing the multicalls. It iterates over an array of calls, executes them, and aggregates the results. [Source,Rust] ---- fn _execute_calls(mut calls: Array, mut res:Array::>) -> Array::> { match calls.pop_front() { Option::Some(call) => { let _res = _call_contract(call); res.append(_res); return _execute_calls(calls, res); }, Option::None(_) => { return res; }, } } ---- Apart from the traditional *\"_ _execute_ _\"* function, adding the *\"_execute_calls\"* function to your account contract can ensure that you can make a multicall using your smart contract account. The above code is a simple example snippet where the *\"return _execute_calls(calls, res);\"* statement makes recursive calls to the *\"_execute_calls_\"* function thereby bundling the calls together. The final result will be aggregated and returned in the *_res_* variable. === `_call_contract` Function The `_call_contract` function is a helper function used to make individual contract calls. [,Rust] ---- fn _call_contract(call: AccountCall) -> Array:: { starknet::call_contract_syscall( call.to, call.selector, call.calldata ).unwrap_syscall() } ---- == Considerations While multicall provides significant benefits in terms of UX and data consistency, it's important to note that it may not significantly reduce gas fees compared to individual calls. However, the primary advantage of using multicall is that it ensures results are derived from the same block, providing a much-improved user experience. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "multisig.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"multisig\"] = Multisig Accounts ==== CONTRIBUTE: This subchapter is missing an example of declaration, deployment and interaction with the contract. We would love to see your contribution! Please submit a PR. ==== Multisignature (multisig) technology is an integral part of the modern blockchain landscape. It enhances security by requiring multiple signatures to confirm a transaction, hence reducing the risk of fraudulent transactions and increasing control over asset management. In Starknet, the concept of multisig accounts is abstracted at the protocol level, allowing developers to implement custom account contracts that embody this concept. In this chapter, we'll delve into the workings of a multisig account and see how it's created in Starknet using an account contract. == What is a Multisig Account? A multisig account is an account that requires more than one signature to authorize transactions. This significantly enhances security, requiring multiple entities' consent to transact funds or perform critical actions. Key specifications of a multisig account include: * Public keys that form the account * Threshold number of signatures required A transaction signed by a multisig account must be individually signed by the different keys specified for the account. If fewer than the threshold number of signatures needed are present, the resultant multisignature is considered invalid. In Starknet, accounts are abstractions provided at the protocol level. Therefore, to create a multisig account, one needs to code the logic into an account contract and deploy it. The contract below serves as an example of a multisig account contract. When deployed, it can create a native multisig account using the concept of account abstraction. Please note that this is a simplified example and lacks comprehensive checks and validations found in a production-grade multisig contract. == Multisig Account Contract [,Rust] ---- #[account_contract] mod MultisigAccount { use ecdsa::check_ecdsa_signature; use starknet::ContractAddress; use zeroable::Zeroable; use array::ArrayTrait; use starknet::get_caller_address; use box::BoxTrait; use array::SpanTrait; struct Storage { index_to_owner: LegacyMap::, owner_to_index: LegacyMap::, num_owners: usize, threshold: usize, curr_tx_index: felt252, //Mapping between tx_index and num of confirmations tx_confirms: LegacyMap, //Mapping between tx_index and it's execution state tx_is_executed: LegacyMap, //Mapping between a transaction index and its hash transactions: LegacyMap, has_confirmed: LegacyMap::, } #[constructor] fn constructor(public_keys: Array::, _threshold: usize) { assert(public_keys.len() usize { tx_confirms::read(tx_index) } //Get the number of owners of this account #[view] fn get_num_owners() -> usize { num_owners::read() } //Get the public key of the owners //TODO - Recursively add the owners into an array and return, maybe wait for loops to be enabled //EXTERNAL FUNCTIONS #[external] fn submit_tx(public_key: felt252) { //Need to check if caller is one of the owners. let tx_info = starknet::get_tx_info().unbox(); let signature: Span = tx_info.signature; let caller = get_caller_address(); assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); //Updating the transaction index let tx_index = curr_tx_index::read(); //`true` if a signature is valid and `false` otherwise. assert( check_ecdsa_signature( message_hash: tx_info.transaction_hash, public_key: public_key, signature_r: *signature.at(0_u32), signature_s: *signature.at(1_u32), ), 'INVALID_SIGNATURE', ); transactions::write(tx_index, tx_info.transaction_hash); curr_tx_index::write(tx_index + 1); } #[external] fn confirm_tx(tx_index: felt252, public_key: felt252) { let transaction_hash = transactions::read(tx_index); //TBD: Assert that tx_hash is not null let num_confirmations = tx_confirms::read(tx_index); let executed = tx_is_executed::read(tx_index); assert(executed == false, 'TX_ALREADY_EXECUTED'); let caller = get_caller_address(); let tx_info = starknet::get_tx_info().unbox(); let signature: Span = tx_info.signature; assert( check_ecdsa_signature( message_hash: tx_info.transaction_hash, public_key: public_key, signature_r: *signature.at(0_u32), signature_s: *signature.at(1_u32), ), 'INVALID_SIGNATURE', ); let confirmed = has_confirmed::read((caller, tx_index)); assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED'); tx_confirms::write(tx_index, num_confirmations+1_usize); has_confirmed::write((caller, tx_index), true); } //An example function to validate that there are at least two signatures fn validate_transaction(public_key: felt252) -> felt252 { let tx_info = starknet::get_tx_info().unbox(); let signature: Span = tx_info.signature; let caller = get_caller_address(); assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); //`true` if a signature is valid and `false` otherwise. assert( check_ecdsa_signature( message_hash: tx_info.transaction_hash, public_key: public_key, signature_r: *signature.at(0_u32), signature_s: *signature.at(1_u32), ), 'INVALID_SIGNATURE', ); starknet::VALIDATED } //INTERNAL FUNCTION //Function to add the public keys of the multi sig in permanent storage fn _set_owners(owners_len: usize, public_keys: Array::) { if owners_len == 0_usize { } index_to_owner::write(owners_len, *public_keys.at(owners_len - 1_usize)); owner_to_index::write(*public_keys.at(owners_len - 1_usize), owners_len); _set_owners(owners_len - 1_u32, public_keys); } #[external] fn __validate_deploy__( class_hash: felt252, contract_address_salt: felt252, public_key_: felt252 ) -> felt252 { validate_transaction(public_key_) } #[external] fn __validate_declare__(class_hash: felt252, public_key_: felt252) -> felt252 { validate_transaction(public_key_) } #[external] fn __validate__( contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::, public_key_: felt252 ) -> felt252 { validate_transaction(public_key_) } #[external] #[raw_output] fn __execute__( contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::, tx_index: felt252 ) -> Span:: { // Validate caller. assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER'); // Check the tx version here, since version 0 transaction skip the __validate__ function. let tx_info = starknet::get_tx_info().unbox(); assert(tx_info.version != 0, 'INVALID_TX_VERSION'); //Multisig check here let num_confirmations = tx_confirms::read(tx_index); let owners_len = num_owners::read(); //Subtracting one for the submitter let required_confirmations = threshold::read() - 1_usize; assert(num_confirmations >= required_confirmations, 'MINIMUM_50%_CONFIRMATIONS'); tx_is_executed::write(tx_index, true); starknet::call_contract_syscall( contract_address, entry_point_selector, calldata.span() ).unwrap_syscall() } } ---- == Multisig Transaction Flow The flow of a multisig transaction includes the following steps: 1. Submitting a transaction: Any of the owners can submit a transaction from the account. 2. Confirming the transaction: The owner who hasn't submitted a transaction can confirm the transaction. The transaction will be successfully executed if the number of confirmations (including the submitter's signature) is greater than or equal to the threshold number of signatures, else it fails. This mechanism of confirmation ensures that no single party can unilaterally perform critical actions, thereby enhancing the security of the account. == Exploring Multisig Functions Let's take a closer look at the various functions associated with multisig functionality in the provided contract. === _set_owners Function This is an internal function designed to add the public keys of the account owners to a permanent storage. Ideally, a multisig account structure should permit adding and deleting owners as per the agreement of the account owners. However, each change should be a transaction requiring the threshold number of signatures. [,Rust] ---- //INTERNAL FUNCTION //Function to add the public keys of the multi sig in permanent storage fn _set_owners(owners_len: usize, public_keys: Array::) { if owners_len == 0_usize { } index_to_owner::write(owners_len, *public_keys.at(owners_len - 1_usize)); owner_to_index::write(*public_keys.at(owners_len - 1_usize), owners_len); _set_owners(owners_len - 1_u32, public_keys); } ---- === submit_tx Function This external function allows the owners of the account to submit transactions. Upon submission, the function checks the validity of the transaction, ensures the caller is one of the account owners, and adds the transaction to the transactions map. It also increments the current transaction index. [,Rust] ---- #[external] fn submit_tx(public_key: felt252) { //Need to check if caller is one of the owners. let tx_info = starknet::get_tx_info().unbox(); let signature: Span = tx_info.signature; let caller = get_caller_address(); assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); //Updating the transaction index let tx_index = curr_tx_index::read(); //`true` if a signature is valid and `false` otherwise. assert( check_ecdsa_signature( message_hash: tx_info.transaction_hash, public_key: public_key, signature_r: *signature.at(0_u32), signature_s: *signature.at(1_u32), ), 'INVALID_SIGNATURE', ); transactions::write(tx_index, tx_info.transaction_hash); curr_tx_index::write(tx_index + 1); } ---- === confirm_tx Function Similarly, the *_confirm_tx_* function provides a way to record confirmations for each transaction. An account owner, who did not submit the transaction, can confirm it, increasing its confirmation count. [Source, Rust] ---- #[external] fn confirm_tx(tx_index: felt252, public_key: felt252) { let transaction_hash = transactions::read(tx_index); //TBD: Assert that tx_hash is not null let num_confirmations = tx_confirms::read(tx_index); let executed = tx_is_executed::read(tx_index); assert(executed == false, 'TX_ALREADY_EXECUTED'); let caller = get_caller_address(); let tx_info = starknet::get_tx_info().unbox(); let signature: Span = tx_info.signature; assert( check_ecdsa_signature( message_hash: tx_info.transaction_hash, public_key: public_key, signature_r: *signature.at(0_u32), signature_s: *signature.at(1_u32), ), 'INVALID_SIGNATURE', ); let confirmed = has_confirmed::read((caller, tx_index)); assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED'); tx_confirms::write(tx_index, num_confirmations+1_usize); has_confirmed::write((caller, tx_index), true); } ---- === __execute__ Function The __execute__ function serves as the final step in the transaction process. It checks the validity of the transaction, whether it has been previously executed, and if the threshold number of signatures has been reached. The transaction is executed if all the checks pass. [,Rust] ---- #[external] #[raw_output] fn __execute__( contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::, tx_index: felt252 ) -> Span:: { // Validate caller. assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER'); // Check the tx version here, since version 0 transaction skip the __validate__ function. let tx_info = starknet::get_tx_info().unbox(); assert(tx_info.version != 0, 'INVALID_TX_VERSION'); //Multisig check here let num_confirmations = tx_confirms::read(tx_index); let owners_len = num_owners::read(); //Subtracting one for the submitter let required_confirmations = threshold::read() - 1_usize; assert(num_confirmations >= required_confirmations, 'MINIMUM_50%_CONFIRMATIONS'); tx_is_executed::write(tx_index, true); starknet::call_contract_syscall( contract_address, entry_point_selector, calldata.span() ).unwrap_syscall() } ---- == Closing Thoughts This chapter has introduced you to the concept of multisig accounts in Starknet and illustrated how they can be implemented using an account contract. However, it's important to note that this is a simplified example, and a production-grade multisig contract should contain additional checks and validations for robustness and security. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "signatures.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"signatures\"] = Alternative Signature Schemes == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "standard_account.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "= Signing and a Standard Account Contract In this chapter, we build upon our exploration of account contracts in Starknet by introducing a more complex account contract. This Standard Account Contract includes additional features such as signature validation, providing a more robust example of an account contract in Cairo language. You can find the full code for this contract in the Book repository (todo: add link). You can interact and compile the contract using Scarb (review the Scarb subchapter in Chapter 2 of the Book for more information). [,Rust] ---- // Import necessary modules and traits use serde::Serde; use starknet::ContractAddress; use array::ArrayTrait; use array::SpanTrait; use option::OptionTrait; // Define the Account contract #[account_contract] mod Account { use array::ArrayTrait; use array::SpanTrait; use box::BoxTrait; use ecdsa::check_ecdsa_signature; use option::OptionTrait; use super::Call; use starknet::ContractAddress; use zeroable::Zeroable; use serde::ArraySerde; // Define the contract's storage variables struct Storage { public_key: felt252 } // Constructor function for initializing the contract #[constructor] fn constructor(public_key_: felt252) { public_key::write(public_key_); } // Internal function to validate the transaction signature fn validate_transaction() -> felt252 { let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info let signature = tx_info.signature; // Extract signature assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // Check signature length // Verify ECDSA signature assert( check_ecdsa_signature( message_hash: tx_info.transaction_hash, public_key: public_key::read(), signature_r: *signature[0_u32], signature_s: *signature[1_u32], ), 'INVALID_SIGNATURE', ); starknet::VALIDATED // Return validation status } // Validate contract deployment #[external] fn __validate_deploy__( class_hash: felt252, contract_address_salt: felt252, public_key_: felt252 ) -> felt252 { validate_transaction() } // Validate contract declaration #[external] fn __validate_declare__(class_hash: felt252) -> felt252 { validate_transaction() } // Validate contract execution #[external] fn __validate__( contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array ) -> felt252 { validate_transaction() } // Execute a contract call #[external] #[raw_output] fn __execute__(mut calls: Array) -> Span { // Validate caller assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER'); let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info assert(tx_info.version != 0, 'INVALID_TX_VERSION'); assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only single calls are supported let Call{to, selector, calldata } = calls.pop_front().unwrap(); // Call the target contract starknet::call_contract_syscall( address: to, entry_point_selector: selector, calldata: calldata.span() ).unwrap_syscall() } } // Define the Call struct #[derive(Drop, Serde)] struct Call { to: ContractAddress, selector: felt252, calldata: Array } ---- == Grasping ECDSA Signature Elliptic Curve Digital Signature Algorithm (ECDSA) is a cryptographic protocol extensively utilized across various blockchains to ensure data integrity and verify the sender's authenticity. As a variant of the Digital Signature Algorithm (DSA), ECDSA leverages elliptic curve cryptography, offering superior security with shorter keys than the traditional DSA. An ECDSA signature comprises two components, commonly referred to as 'r' and 's'. These two values, generated using the signer's private key and the hash of the message (or transaction) being signed, collectively form the signature for a given input. === Deciphering signature_r and signature_s Within the context of the Standard Account Contract, 'signature_r' and 'signature_s' represent the two constituents of the ECDSA signature. These are utilized in the 'check_ecdsa_signature' function to authenticate the transaction's legitimacy. * `signature_r (r)`: A random number generated during the signing process, unique for each signature. Reusing 'r' across different messages may lead to private key exposure. * `signature_s (s)`: This is computed using 'r', the private key, and the hash of the message. Like 'r', 's' is also unique for each signature. The function 'check_ecdsa_signature' takes these two values, the public key of the signer, and the hash of the message to authenticate the signature. A valid signature indicates that the message was indeed signed by the private key owner and remains unaltered. [source,rust] ---- assert( check_ecdsa_signature( message_hash: tx_info.transaction_hash, public_key: public_key::read(), signature_r: *signature[0_u32], signature_s: *signature[1_u32], ), 'INVALID_SIGNATURE', ); ---- The above code snippet employs 'check_ecdsa_signature' function to assert the legitimacy of the transaction signature. If the signature is not valid, the assertion fails, returning 'INVALID_SIGNATURE'. == Contract Anatomy === Storage In the standard account contract, we declare a single storage variable: 'public_key'. This assists in transaction signature validation. The public key, stored as a 'felt252' (a 252-bit unsigned integer), is written to the storage in the constructor function and is accessed from the storage in the 'validate_transaction' function. [source,rust] ---- struct Storage { public_key: felt252 } ---- === Constructor The constructor function serves to initialize the contract, storing the supplied public key in the contract's storage. [source,rust] ---- #[constructor] fn constructor(public_key_: felt252) { public_key::write(public_key_); } ---- === validate_transaction This internal function validates the transaction signature. It retrieves the signature from the transaction info, checks its length, and verifies the ECDSA signature. If the signature is legitimate, it returns starknet::VALIDATED, otherwise an error. This function is invoked by '__validate_deploy__', '__validate_declare__', and '__validate__' functions. The inclusion of this function is optional. If transaction signature validation is not required, it can be omitted. However, its inclusion in your account contract is advised to ensure transaction validity and to facilitate its reuse in all three validation functions. [source,rust] ---- fn validate_transaction() -> felt252 { let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info let signature = tx_info.signature; // Extract signature assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // Check signature length // Verify ECDSA signature assert( check_ecdsa_signature( message_hash: tx_info.transaction_hash, public_key: public_key::read(), signature_r: *signature[0_u32], signature_s: *signature[1_u32], ), 'INVALID_SIGNATURE', ); starknet::VALIDATED // Return validation status } ---- === Call Struct The Call struct outlines the parameters required for a contract call. These parameters comprise the target contract address (to), the function to be called (selector), and the function's arguments (calldata). The Call struct is utilized in the __execute__ function. [source,rust] ---- #[derive(Drop, Serde)] struct Call { to: ContractAddress, selector: felt252, calldata: Array } ---- === execute This external function triggers a transaction post successful validation. It ensures the caller's validity, checks for a non-zero transaction version, and supports only single calls. Post validation, it forwards the call to the target contract. The contract creator can incorporate multiple calls to different contracts or the same contract (multicall) within this function. The function returns the output from the target contract. [source,rust] ---- #[external] #[raw_output] fn __execute__(mut calls: Array) -> Span { // Validate caller assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER'); let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info assert(tx_info.version != 0, 'INVALID_TX_VERSION'); assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only single calls are supported let Call{to, selector, calldata } = calls.pop_front().unwrap(); // Call the target contract starknet::call_contract_syscall( address: to, entry_point_selector: selector, calldata: calldata.span() ).unwrap_syscall() } ---- == Improvements to the Standard Account Contract The implementation of the Standard Account Contract has a few limitations: * It currently supports only single calls. We could support multicalls to improve the flexibility and utility of the contract. * The ECDSA signature algorithm, while secure, can be computationally intensive. Future versions could explore using more efficient signature algorithms, such as Schnorr or BLS. Or quantum-resistant signature algorithms, such as the STARKs. Despite these limitations, the Standard Account Contract provides a robust and secure foundation for creating and interacting with smart contracts on Starknet. == Declaring and Deploying the Hello World Account Contract This time we have a constructor function that takes the public key as an argument. We need to generate a private key with the corresponding public key. TODO: add section on how to generate a private key and public key. * Export the required environment variables: [source,bash] ---- export STARKNET_NETWORK=alpha-goerli export STARKNET_WALLET=starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount ---- * Declare the contract (since the contract is already declared, you can skip this step. If you want to declare it anyway, run the following command but you will receive an error): [source,bash] ---- starknet declare --contract target/release/starknetbook_chapter_7_Account.json --account vote_admin --max_fee 100000000000000000 ---- The class hash is: 0x05501f7806d3d11cab101e19001e409dd4760200c2da2fe03761750f66e4a5e1 * Deploy the contract: TODO: add section on how to deploy the contract. [NOTE] ==== Elliptic Curve Digital Signature Algorithm (ECDSA) is a popular choice for ensuring data integrity and sender authenticity in blockchain networks, but it's not the only option. Other alternatives include: * EdDSA (Edwards-curve Digital Signature Algorithm): EdDSA is another form of elliptic curve cryptography that is designed to be faster and more secure than ECDSA. EdDSA uses twisted Edwards curves, which have strong security properties and allow for more efficient computations. An example of EdDSA in use is Monero. * Schnorr Signatures: Schnorr signatures offer a level of security similar to ECDSA but with shorter signatures. They have the additional property of being linear, which allows for signature aggregation and multi-signatures. This can lead to increased efficiency and privacy. Bitcoin developers have proposed adding Schnorr signatures to the Bitcoin protocol with the Taproot upgrade. * RSA (Rivest\u2013Shamir\u2013Adleman): RSA is an older cryptographic algorithm that is widely used for secure data transmission. However, RSA requires larger key sizes for equivalent security levels, making it less efficient than elliptic curve techniques. RSA is not commonly used in modern blockchain systems, but it is still used in many traditional secure communication protocols. * BLS (Boneh-Lynn-Shacham) Signatures: BLS signatures, like Schnorr, allow for signature aggregation, making them useful in systems that require a large number of signatures. This property makes BLS signatures particularly useful for consensus algorithms in distributed systems and blockchains, such as Ethereum 2.0. * Post-Quantum Cryptography: With the advent of quantum computing, researchers are developing new cryptographic algorithms that are resistant to quantum attacks. One example are the STARKs used in Starknet. Each of these alternatives has its strengths and weaknesses in terms of security, efficiency, complexity, and mathematical properties. ==== == Summary In this chapter, we expanded on our understanding of account contracts in Starknet by examining a more complex \"Standard Account Contract\". We dove into the various components of the contract and learned how they work together to validate and execute transactions. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "starknet_aa.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"starknet_aa\"] = Account Abstraction model in Starknet Now that we know better the concept of AA, let's actually code it in Starknet. == Account Contract Interface Although account contracts are nothing more than smart contracts, they have methods that set them apart from other smart contracts. The following interface to an account contract implements the AA protocol. It has a public key associated with it and can validate and execute transactions. Here's what it does: * `constructor`: This optional method initializes the account contract. While an account contract can exist without a constructor, it is common practice to establish the associated public key within the constructor. * `validate_transaction`: An optional helper method, `validate_transaction`, checks the validity of a transaction. This could involve comparing a signature against an associated public key, or any other validation process as defined by the contract creator. * `__validate_deploy__`: This method is invoked during the deployment process and serves to validate the deployment of a new contract. * `__validate_declare__`: This method validates the declaration of a new contract. It confirms the syntax and semantics of the contract declaration are correct. * `__validate__`: This method validates transactions before they are executed. It ensures that the transaction adheres to the rules defined in the contract. * `__execute__`: After the transactions have been validated, `__execute__` is the method that executes a series of contract calls. Account contracts play a vital role in ensuring the security of the Starknet network by allowing only transactions with valid signatures to be executed. Here is a generic implementation of an account contract: [,Rust] ---- #[account_contract] mod Account { use starknet::ContractAddress; #[constructor] fn constructor(public_key_: felt252); fn isValidSignature() -> felt252; #[external] fn __validate_deploy__( class_hash: felt252, contract_address_salt: felt252, public_key_: felt252 ) -> felt252; #[external] fn __validate_declare__(class_hash: felt252) -> felt252; #[external] fn __validate__( contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array ) -> felt252; #[external] #[raw_output] fn __execute__(mut calls: Array) -> Span; } ---- The entry points of an account contract are its callable functions. Let's explore these in detail: * `constructor`: This function is not mandatory, but it's useful for setting up an account contract. It accepts a `public_key` parameter that represents the public key associated with the account. In the future, there may be a `setPublicKey()` method to facilitate account transfers. * `isValidSignature`: Inspired by EIP-1271, this function returns true if a given signature is valid; otherwise, it reverts. * `__validate__`: Allows you to define an arbitrary logic to determine if a transaction is valid or not. They can not read This function allows you to define custom logic for determining the validity of a transaction. It cannot read other contracts' storage, which helps prevent spam. The account contract calls `__validate__` when it receives a transaction. The function takes the following arguments (calldata): ** `contract_address: ContractAddress`: The target contract address. ** `entry_point_selector: felt252`: The function to be called on the target contract. ** `calldata: Array`: An array representing the function parameters.. Remember calldata are the parameters used to call a function. * `__validate_declare__`: This function validates the signature before declaring a new contract. It takes a single argument, `class_hash`, which represents the class hash of the contract to be declared. * `__execute__`: This function serves as the state-changing entry point for all user interactions with any contract, including managing the account contract itself. It is called after successful validation by `__validate__`. The function takes an argument `mut calls`, which is an array of `Call` structs. == The Call Struct The `Call` struct represents a single call to a contract: [,Rust] ---- struct Call { to: ContractAddress, selector: felt252, calldata: Array } ---- It contains the following fields: * `to`: The target contract address. * `selector`: The selector of the function to be called on the target contract. * `calldata`: An array representing the function parameters. == Summary In this chapter, we explored the Account Abstraction model in Starknet, focusing on account contracts and their methods. To summarize: * Account contracts are smart contracts implementing the Account Abstraction protocol. * They provide methods for validating and executing transactions and contract deployments. * They offer flexibility to users by allowing them to define custom validation logic. In the next subchapter, we will implement a simple account contract and learn how to deploy it on Starknet. This will provide a practical understanding of how account contracts work and how to interact with them. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ===="}
{"title": "artificial_intelligence.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"artificial_intelligence\"] = On-Chain Artificial Intelligence The advent of higher transactions per second (TPS) on Starknet has sparked a transformation in the realm of artificial intelligence (AI). It is becoming increasingly conceivable to integrate AI into our digital existence on-chain, an endeavor that could have multiple advantages, such as verifiable inference and training, and on-chain model ensembles. All of these are predicated on the availability of cheap computation. Teams like Giza and Modulus Labs are engaged in pioneering research to bring AI on-chain using Zero-Knowledge (ZK) proofs. One of the exciting outcomes of this work is Orion, a Cairo library for Validity ML. == Validity ML and Orion: Building Trust in AI Validity ML uses validity proofs like STARKs, allowing the verification of computational process correctness. By incorporating these proof systems into ML applications, it's possible to authenticate private data with public models and vice versa. Thus, a trustless and transparent ML ecosystem is emerging, in which we can trustlessly prove and verify sources and traces of inference. Orion, an exciting outcome of this research, offers a new ONNX runtime built in Cairo. Leveraging Cairo and ONNX's capabilities, Orion provides a transparent, verifiable, and wholly open-source inference framework, accessible for community contribution and use. Its goal is to provide a runtime implementation for verifiable ML model inferences using STARKs, ensuring reliable inferences with Cairo. ==== A Call to Developers: The frontier of on-chain AI is expansive and inviting. As we traverse this exciting landscape, we welcome more developers to explore and contribute to this pioneering space. Whether with Orion or other tools, your expertise and innovative ideas are valuable in creating a transparent, verifiable, and community-driven AI ecosystem. This is an open invitation to help shape the future of AI, making it more accessible, reliable, and beneficial for all. ==== == Orion's Capabilities Orion offers three distinct APIs: Operators, Numbers, and Performance, each contributing to create a well-rounded, effective environment for developing machine learning models on-chain. *Operators API* provides a comprehensive set of standard mathematical functions and operations specifically designed for computing neural network models and compatible with ONNX standard. *Numbers API* extends Cairo's built-in number capabilities by introducing Signed-Integer and Fixed-Point implementations. By incorporating these features, developers can work with a wider range of numeric data types, allowing for more accurate calculations in their applications. *Performance API* contains a set of functions to optimize the performance of your model. The initial release supports 8-bit quantization, which reduces the memory footprint and accelerates the computation time of your models, allowing you to build more efficient and faster ML applications without sacrificing accuracy. == Exploring Orion Further To delve into Orion's capabilities and learn how to use it for creating AI on-chain, you can access a wealth of resources available in the official documentation at The tutorials guide you through the process of leveraging Orion's APIs and functionalities, helping you to develop, deploy, and verify ML models on-chain. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "index.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"pioneering_applications\"] = Pioneering Applications: Expanding Starknet's Horizons Developers working in the Starknet ecosystem seek to push the boundaries, developing innovative applications and use-cases. This chapter illuminates two pioneering areas of exploration in the Starknet ecosystem (more soon): On-Chain Artificial Intelligence and Storage Proofs. * *On-Chain Artificial Intelligence*: Starknet's increased transactions per second (TPS) and affordable computation costs have made it feasible to host AI models on-chain, marking a paradigm shift towards decentralized and transparent AI applications. * *Storage Proofs*: As a cryptographic tool, storage proofs facilitate trustless cross-chain information access. They provide a robust method for verifying data's integrity across different chains, reinforcing security and efficiency in the decentralized ecosystem. Each of these applications harnesses Starknet's capabilities, coupled with cutting-edge cryptographic techniques, to offer revolutionary solutions that contribute to a more transparent, efficient, and secure decentralized environment. This chapter delves deep into these topics, beginning with an examination of on-chain AI and the technological advancements in Starknet that have made this possibility a reality. We then explore the realm of storage proofs, understanding their role and the significant impact they have on cross-chain information access."}
{"title": "storage_proofs.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"storage_proofs\"] = Storage Proofs: Trustless Cross-Chain Information Access on Starknet In the world of decentralized systems and blockchain technology, ensuring the accuracy and authenticity of data is of paramount importance. As the ecosystem evolves, it becomes increasingly necessary to share information across different chains, leading to the development of innovative solutions to verify the integrity of the data without sacrificing security or efficiency. One such solution is the use of storage proofs. Storage proofs offer a cryptographic method for tracking and sharing blockchain information across chains, similar to oracles. However, the key difference lies in the trust model; storage proofs inherently provide proof of authenticity without relying on third-party trust. In some situations, they can even replace or complement oracles, paving the way for new use cases and applications in the blockchain ecosystem. In this chapter, we'll explore the world of storage proofs in depth, covering their fundamentals, how they work, their potential use cases, and how they can enhance or even replace traditional oracles in certain scenarios. By the end of this chapter, you'll have a thorough understanding of storage proofs and their significance in the ever-evolving landscape of decentralized systems. Storage proofs have been an essential part of the cryptographic landscape since the invention of Merkle trees in 1979. The innovation lies in combining storage proofs with provable computation to create succinct proofs that can be verified on-chain. [NOTE] ==== This chapter was inspired by and based on the blog post] on the same topic. Any errors or inaccuracies found in this chapter are the responsibility of the Starknet Book editor and should not be attributed to the authors of the original blog post. ==== image::storage5.png[storage5] == What are storage proofs? Storage proofs are a way to prove that certain information exists on a blockchain and is true, without having to trust a third party. To better understand storage proofs, let's break down the concept using a simple analogy: Imagine you have a giant book filled with information, and you want to prove that a specific piece of information is in that book. Instead of requiring someone to go through the entire book to find the information, you use a clever system (in our case, cryptography) to create a small \"proof\" that can easily demonstrate the information's presence in the book. This \"proof\" is what we call a storage proof. In the context of blockchains, these giant books are the databases that store all the transactions and data on the network. Storage proofs allow you to create a small and verifiable proof that certain data exists within the blockchain's state at a particular point in time. This is done using cryptographic techniques that are built into the storage itself. Blockchains use various data structures, like Merkle trees, Merkle Patricia trees, and Verkle trees, to cryptographically commit to their data. Using these data structures, storage proofs can be generated to demonstrate that specific information is part of a given state. However, when used alone, these proofs can become quite large, making them impractical for on-chain verification. To overcome this, storage proofs are often combined with advanced cryptographic techniques, such as STARKs or SNARKs, to create smaller and more efficient proofs that can be verified on any domain without trusting a third party. Instead, the security and trust come from the underlying blockchain itself. == How do storage proofs work? Now that we have a basic understanding of what storage proofs are, let's dive into how they work. === Cryptographic Commitments and Data Structures Storage proofs rely on cryptographic commitments and specific data structures to verify the authenticity of data without revealing the entire dataset. These data structures, such as Merkle trees, Merkle Patricia trees, or Verkle trees, enable efficient storage and retrieval of data while maintaining the cryptographic security of the entire dataset. When a piece of data is added to the blockchain, it's hashed and stored in a specific location within the tree. This data, along with other data in the tree, is combined using a hashing algorithm to create parent nodes. This process continues until a single root hash, known as the Merkle root or Verkle root, is obtained. This root hash represents the entire dataset and serves as a commitment to the data. === Generating and Verifying Storage Proofs To generate a storage proof, one must provide a specific piece of data and its associated Merkle or Verkle path within the tree. The path consists of the sibling hashes required to reconstruct the root hash using the same hashing algorithm. The storage proof is essentially the combination of the data and its Merkle or Verkle path. When verifying a storage proof, a recipient can use the provided data and Merkle or Verkle path to recompute the root hash. If the recomputed root hash matches the known root hash, the recipient can be confident that the data is authentic and part of the committed dataset. === Optimizing Storage Proofs with STARKs or SNARKs While storage proofs provide a secure and efficient way to prove the existence of data in a blockchain, their size and computational requirements can be further optimized using zero-knowledge proofs, such as STARKs (Scalable Transparent ARguments of Knowledge) or SNARKs (Succinct Non-interactive ARguments of Knowledge). These advanced cryptographic techniques allow for the creation of smaller, more efficient proofs that can be verified quickly, even on-chain. By combining storage proofs with STARKs or SNARKs, we can achieve trustless and efficient cross-chain data sharing without relying on third parties. == Storage Proofs Use Cases Storage proofs offer an efficient means of compressing blockchain data and transmitting it to other chains, opening up a wide array of applications. Their affordable verification costs allow destination chains to validate the proof, reducing the need for complex cross-chain messaging systems. Some potential use cases for storage proofs include: * *General information access*: Storage proofs enable one chain to access information about the state and transactions of another chain, facilitating seamless cross-chain communication. * *Simplified cross-chain voting systems*: Storage proofs can streamline cross-chain voting processes where users hold assets on a secure but slower chain (Chain A) while voting takes place on a faster, more cost-effective chain (Chain B). Instead of incurring high transaction fees to transfer assets between chains, storage proofs allow users to prove their token balance on Chain A and seamlessly cast their vote on Chain B. * *Trustless cross-chain bridges*: Current cross-chain bridges often involve third-party intermediaries, such as custodians or decentralized autonomous organizations (DAOs), which require a certain level of trust. Storage proofs can facilitate trustless bridges, with smart contracts on the destination chain validating transactions and minting bridged assets based on the proof. In some cases, storage proofs may even eliminate the need for transferring assets between chains by simply proving ownership on the original chain. image::storage1.png[storage1] * *Improved user experience for Account Abstraction (AA) use cases*: AA, a key innovation in blockchain technology, has been implemented across various chains to enhance user onboarding. Storage proofs can further augment AA, allowing wallets to restore access based on specific conditions, such as inactivity, or enforce additional checks that require data from other chains. * *Accessing historical data without running an archival node*: Storage proofs are not just used for cross-chain use cases, they can also be used to get data about the past in the same blockchain without the need of running an archival node. This allows users to access historical data more efficiently, reducing storage requirements and lowering the barrier to entry for participating in the network. By harnessing the power of storage proofs, these use cases demonstrate the potential for more efficient, secure, and seamless interactions within the blockchain ecosystem. == An example of a storage proof Generating storage proofs on EVM-compatible chains is straightforward. For example, the Web3.js library has the `getProof` function that can generate proof of a contract's state on Ethereum (and other EVM-compatible chains such as Polygon or BSC). A contract address and the storage slot for the contract must be passed to the function. In Ethereum, smart contracts use a key-value store to store data in their storage. Each piece of data is stored in a specific location known as a \"storage slot.\" Storage slots are memory locations within the contract's storage and are identified by a unique index. Let's look at a sample smart contract with the following code deployed on Ethereum mainnet at `0xcc...da8b`. image::storage2.png[storage2] The `owner` variable would be stored at slot 0. Now, to generate the proof that the `owner` of this contract was an address A, we can use the `getProof` function as follows: image::storage3.png[storage3] The output of the code above looks something like this: image::storage4.png[storage4] The \"storageProof\" returned contains the storage proof for the \"owner\" variable. Since Ethereum uses Merkle Patricia Trees to commit to its state, the state of accounts and their storage, the storage generated can be used to prove a storage slot (or account state). However, as previously stated, these proofs are not scalable enough to discuss cross-chain message transfers. Using complex ZK mathematics on top of this can decrease the computation required to verify the proof. == Comparing and Contrasting Storage Proofs and Oracles Blockchains are designed to be trustless, which means they cannot inherently access off-chain data. This limitation affects smart contracts' ability to make decisions based on real-world events or historical blockchain information. As a solution, oracles were introduced to provide off-chain data or results from resource-intensive off-chain computations to smart contracts. Oracles typically require a third party, such as an institution or a decentralized network of node operators, to submit data on-chain. While this introduces a level of trust, various teams, like Pragma, are working to minimize this trust requirement. Chainlink is a well-known blockchain oracle, providing real-world data, off-chain computation services, and cross-chain services. As smart contracts currently rely on oracles for real-world data, oracles have become a crucial part of the blockchain ecosystem. == The State of Oracles on Starknet On the Starknet testnet, Chainlink provides price data feeds for seven cryptocurrency pairs and has partnered with Starkware to accelerate app development and growth within the Starknet ecosystem. Chainlink minimizes trust assumptions through a decentralized network of nodes, but data aggregation occurs off-chain. Pragma and Stork Network are two significant oracle providers on Starknet, operating on both mainnet and testnet. They offer price tickers for multiple cryptocurrency pairs, and Pragma is working on implementing a verifiable randomness feed on the mainnet for secure, on-chain randomness. Pragma's price feeds are based on submissions from large institutions and market makers, leveraging efficient ZK technology for on-chain price aggregation. In summary, both storage proofs and oracles are crucial for facilitating cross-chain communication and access to off-chain data. While oracles are indispensable for real-world data, storage proofs offer a trustless, efficient way to transfer and verify blockchain information across chains. Together, they help create a more robust, interconnected blockchain ecosystem. == Can Oracles Be Replaced or Improved by Storage Proofs? In certain cases, storage proofs can replace oracles. Some data provided by oracles is already available on-chain, and a storage proof can eliminate the need for trust in a third party, allowing smart contracts to rely entirely on the security of cryptographic commitments. However, in other cases where storage proofs cannot fully replace oracles, they can still enhance them with additional functionality: * Storage proofs enable computations on data from different sources and export the results to other chains, making it possible for oracles to transmit information across multiple chains. * Storage proofs can facilitate cost-effective validation on destination chains, as the preferred source chain typically has cheap computation. * Research leaders, such as Herodotus, enable cross-domain data access across Ethereum chains using storage proofs and ZK mathematics. Pragma plans to partner with Herodotus to support cross-chain oracles in the near future. * Storage proofs can unify the state of multiple rollups and even allow synchronous reads between Ethereum layers. * Trustless retrieval of historical on-chain data is another enhancement made possible by storage proofs. Stateful blockchains like Ethereum and Starknet cryptographically preserve their state through specialized data structures, enabling proof of data inclusion. This allows smart contracts to access information dating back to the genesis block. Pragma is exploring the development of an L3 oracle on Starknet, which could enable other chains to \"pull\" and verify data using storage proofs. Benefits of having an L3 oracle on a computationally cheap network like Starknet include: * Faster consensus on blocks due to the highly customizable L3 chain, significantly reducing data latency for the oracle. * Asynchronous transfer of low-latency data to other chains upon reaching consensus on the source chain, in combination with storage proofs. * Enhanced trust in data through an inbuilt system to penalize dishonest data providers. Data providers on the L3 could stake their assets as a guarantee of accurate data. As the entire L3 network must reach consensus before other chains can use the data, the oracle's data can be considered secured by the validators' stake on L3. == Conclusion The growing adoption of Ethereum L2 solutions, such as Starknet, Optimism, and Arbitrum, has offered insights into the future of the industry. However, a key challenge hindering further growth is the implementation of a decentralized cross-chain messaging system. Though still in the early stages, storage proofs hold immense potential to address this issue. In some instances, storage proofs can replace or enhance oracles, facilitating more efficient cross-chain communication and access to historical data. By reducing the reliance on trust in third parties, storage proofs can significantly bolster the security and efficiency of blockchain applications. As the blockchain landscape continues to evolve, we can anticipate further developments and innovations in storage proofs, oracles, and cross-chain communication. By leveraging these technologies, the blockchain ecosystem can sustain its growth and deliver increased value to both users and developers. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "allocation.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"allocation\"] = Allocation == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "builtin.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"builtin\"] = Deep into Builtins The Algebraic RISC can simulate any Turing Machine and hence is Turing-complete (supports any feasible computation). However, implementing some basic operations, such as the comparison of elements, using only Cairo instructions would result in a lot of steps which damages the goal of minimizing the number of trace cells used. Consider that adding a new instruction to the Instruction Set has a cost even if this instruction is not used. To mitigate this without increasing the number of trace cells per instruction, Cairo introduces the notion of builtins. ____ Builtins are predefined optimized low-level execution units which are added to the Cairo CPU board to perform predefined computations which are expensive to perform in vanilla Cairo (e.g., range-checks, Pedersen hash, ECDSA, ...). ____ The communication between the CPU and the builtins is done through memory: each builtin is assigned a continuous area in the memory and applies some constraints (depending on the builtin definition) on the memory cells in that area. In terms of building the AIR, it means that adding builtins does not affect the CPU constraints. It just means that the same memory is shared between the CPU and the builtins. To \"`invoke`\" a builtin, the Cairo program \"`communicates`\" with certain memory cells, and the builtin enforces some constraints on those memory cells. For example, the `range-check` builtin enforces that all the values for the memory cells in some fixed address range are within the range $[0, 2{caret}\\{128})$. The memory cells constrained by the `range-check` builtin are called \"range-checked\" cells. In practical terms, a builtin is utilized by writing (and reading) the inputs to a dedicated memory segment accessed via the \"builtin pointer\": each builtin has its pointer to access the builtin's memory segment. Builtin pointers follow the name convention `_ptr`; e.g., `range_check_ptr`. In the Cairo case, the builtin directive adds the builtin pointers as parameters to main which can then be passed to any function making use of them. Builtin declarations appear at the top of the Cairo code file. They are declared with the `%builtins` directive, followed by the name of the builtins; e.g., `%builtin range_check`. In Starknet contracts, it is not necessary to add them. Builtin pointers can be of different types. The following table summarizes the available builtins, what they are for, their pointer names, and their pointer types. [cols=\"^,,^,^\"] |=== | *Builtin* | For... | *Pointer name* | *Pointer type* | output | Writing program output which appears explicitly in an execution proof | output_ptr | felt* | pedersen | Computing the Pedersen hash function | pedersen_ptr | HashBuiltin* | range_check | Checking that a field element is within a range $[0,2{caret}\\{128})$, and for doing various comparisons | range_check_ptr | felt (not a pointer) | ecdsa | Verifying ECDSA signatures | ecdsa_ptr | SignatureBuiltin* | bitwise | Performing bitwise operations on felts | bitwise_ptr | BitwiseBuiltin* |=== The details of each type are in the library]. Each type, that is not directly a `felt*`, is nothing more than a struct. For example, the [,Rust] ---- struct HashBuiltin { x: felt, y: felt, result: felt, } ---- Note the following implementation of the function] to compute the hash of two given field elements: [,Rust] ---- from starkware.cairo.common.cairo_builtins import HashBuiltin func hash2(hash_ptr: HashBuiltin*, x, y) -> ( hash_ptr: HashBuiltin*, z: felt ) { let hash = hash_ptr; // Invoke the hash function. hash.x = x; hash.y = y; // Return the updated pointer (increased by 3 memory cells) // and the result of the hash. return (hash_ptr=hash_ptr + HashBuiltin.SIZE, z=hash.result); } ---- `hash_ptr` was added as an explicit argument and explicitly returned updated (`hash_ptr + HashBuiltin.SIZE`). We have to keep track of a pointer to the next unused builtin memory cell. The convention is that functions that use the builtin should get that pointer as an argument and return an updated pointer to the next unused builtin memory cell. It is easier to use implicit arguments: a Cairo syntactic sugar that automatically returns the implicit argument. The common library implementation of the function] is: [,Rust] ---- %builtins pedersen from starkware.cairo.common.cairo_builtins import HashBuiltin func hash2{hash_ptr: HashBuiltin*}(x, y) -> (result: felt) { // Invoke the hash function hash_ptr.x = x; hash_ptr.y = y; let result = hash_ptr.result; // Update hash_ptr (increased by 3 memory cells) let hash_ptr = hash_ptr + HashBuiltin.SIZE; return (result=result); } ---- `hash_ptr` is updated but this time it was returned implicitly. As another example, this is the implementation of the function] which will output a felt into your terminal: [,Rust] ---- func serialize_word{output_ptr: felt*}(word) { // Invoke the output function assert [output_ptr] = word; // Update output_ptr (increased by 1 memory cell) let output_ptr = output_ptr + 1; return (); } ---- Refer to the implementation in for an example using the `output`, `pedersen`, and `range_check` builtins. At what moment did the `hash2` and `serialize_word` functions invoked the properties of their builtins? . When we called `%builtins output pedersen` at the start of the Cairo program, the Cairo VM prepares to use the `output_ptr` and `pedersen_ptr` pointers, and their respective memory segments: usually 2 and 3 (segment 1 is commonly the execution segment, more on the next section). . Second, the Cairo code reads or writes to the memory cells in the segments assigned to the `output` and `pedersen`. . Finally, when a value is written in a memory cell inside a builtin segment, the builtin properties are invoked. For example, when a `struct HashBuiltin` is defined (you have to indicate `x` and `y`, see the structure of then the Pedersen builtin enforces that $result == hash(x, y)$. We can then retrieve the value of `result` with `let result = hash_ptr.result;` as in the `hash2` function. Whenever the program wishes to communicate information to the verifier, it can do so by writing it to a designated memory segment which can be accessed by using the `output` builtin (see more in docs])."}
{"title": "cairo.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"cairo\"] = C(pu)AIR(o) The STARK Proof system is based on `AIR` or Algebraic Intermediate Representation of computation. The AIR is a list of polynomial constraints operating on a trace of finite field elements and the STARK Proof verifies there exists a trace that satisfies those constraints. Cairo stands for CPU AIR and consists of a single set of polynomial constraints such that the execution of a program on this architecture is valid. Cairo is a programming language for writing provable programs. == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "cairovm.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"cairovm\"] = Cairo VM == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "casm.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"casm\"] = CASM == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "dynamic.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"dynamic\"] = Builtins and Dynamic Layouts == A Pathway to More Efficient Proving Jobs Builtins optimize the proving process. However, each proof is computed with respect to a layout, and layouts which are inefficient for a particular proving job diminish the benefit of builtins. Currently, there is a small static list of layouts, and each proof is computed with respect to the most suitable layout from that list. The static approach has two main drawbacks. First, the limited variety of layouts is inefficient for most proving jobs, incurring unnecessary costs on users through a convoluted fee mechanism. Second, manual maintenance of the list to accommodate new builtins becomes wildly more difficult for a large set of builtins, practically impeding the proving process from supporting many builtins with any semblance of efficiency. To resolve these issues, we are working on a Dynamic Layout system in which a layout is tailored to each proving job. The Cairo stack facilitates provable general computation by compiling Cairo code into instructions for a STARK-friendly CPU architecture: the Cairo VM (henceforth CVM). The many advantages of a general purpose CPU come at an inherent cost: the CVM is not optimized for many frequently used operations. Prominent examples of such operations are hash functions e.g Keccak, Pedersen, and Poseidon, with other examples including elliptic curve operations and range checks (i.e checking if a particular number lies in a particular range of values). To resolve the relative inefficiency of the CVM, the Cairo stack introduced the concept of builtins for key operations: plugins that optimize those operations\u2019 proving complexity. Builtins are analogous to ASICs: ASICs are application-specific integrated circuits while builtins are application-specific algebraic constraints (AIRs). If you don\u2019t know or remember what AIRs are, we\u2019ll briefly touch on them later on; more details appear in link: introductory medium post.] In a nutshell, proof complexity is correlated (roughly linearly) to a resource called trace cells, and builtins streamline proofs of particular operations by using far fewer trace cells than the Cairo VM. Having explained the benefit from builtins, it seems natural to develop them for many frequently used operations. This is easier said than done. The current process of introducing new builtins into Starknet involves several steps: 1. Write the AIR 2. Integrate into the prover by creating new layouts (explained below) 3. Integrate into Starknet, i.e modify its codebase and developer tooling to use the new builtin Beyond the challenge of writing an AIR there is much room for improvement in the remaining two stages. This high-level post will go into more detail about builtins as application-specific AIRs, the above issues, and our plans for the upcoming future. == Builtins: Application-Specific AIRs AIR is an acronym for Algebraic Intermediate Representation. In our context, it is a system of polynomials which represents a virtual machine. For instance, Cairo derives its name from CPU AIR: a system of polynomials which represents a particular CPU architecture. A solution of this polynomial system represents a valid state transition, and is called a valid algebraic execution trace (AET). STARKs prove the correct operation of a virtual machine by proving that the associated execution trace is valid with respect to the given AIR. Roughly speaking, execution traces are organized as tables of numbers, and the STARK protocol proves these numbers jointly solve a polynomial system. There are many ways to compute the same thing, with some computations more efficient than others. In our context, proof complexity is essentially determined by the trace size, i.e the number of trace cells in the table. Since traces are generated with respect to an AIR, an application-specific AIR can greatly reduce the execution trace of a particular computation. Builtins are application-specific AIRs aiming for precisely this optimization. Here\u2019s a table that conveys the efficiency improvements of particular builtins (all in production). image::builtin.png[builtin] == Trace layouts: present and future Recall an algebraic execution trace (AET) is (roughly speaking) a table of numbers that encodes a sequence of VM steps (i.e an execution of a program). To compute a proof, the prover executes the STARK protocol on an execution trace with respect to an AIR. Above, we introduced builtins as application-specific AIRs that aim to minimize proof complexity by reducing the number of trace cells required to encode a computation. However, careless integration of builtins into Starknet can waste many trace cells, diminishing the intended benefits. Let\u2019s elaborate. In a nutshell, a trace layout is an allocation of trace cells to different \u201ccomponents\u201d. In our context, these components are the CVM and the builtins. More specifically, a layout specifies the relative amount of trace cells allocated to each component. (Layouts are always structured to streamline proof verification. For more information, see the \u201csuccinctness\u201d link: in this medium article].) Here\u2019s the crucial point: proof complexity depends on the total number of trace cells allocated by the layout, which may be larger than necessary. For example, to prove a sequence of CVM steps, it is roughly doubly efficient to use a layout that only allocates trace cells to the CVM component compared to a layout that allocates half the trace cells to e.g the Poseidon builtin. In summary, the complexity of proving a particular computation can be greatly reduced with a suitable layout. Currently, there is a manually maintained list of layouts, which gradually grows for two main reasons: 1. Builtins can only be used in layouts which allocate them trace cells. Hence the addition of a builtin requires at least one new layout. 2. Tailoring a layout to an execution of Cairo code can improve cell allocation. Hence optimizations of cell utilization often require new layouts. The code for both prover and verifier (the Solidity and Cairo verifiers) is configured according to the list of layouts. With the addition of the Keccak and Poseidon builtins, we found it increasingly difficult to generate a small list of layouts which include many builtins while remaining efficient for the execution of most Starknet blocks. Furthermore, this efficiency is expected to drop wildly with the introduction of additional builtins, since layouts would have to account for the many possible combinations and ratios amongst them. We are currently working to improve our system and forgo a prespecified list of layouts in favor of \u201cDynamic Layouts\u201d: tailored on-the-fly to every execution of Cairo code. Dynamic Layouts will always be optimally proportioned for the proving job at hand. From an engineering perspective, this requires a considerable change in the codebase to support dynamic inputs. However, we expect Dynamic Layouts to streamline Starknet\u2019s proving layer by improving trace cell utilization and consequently making better use of the prover machine. Dynamic Layouts will dismiss the challenges of manually maintaining efficient layouts for many builtins, consequently streamlining the process of integrating more builtins into Starknet. == Dynamic Layouts and fees One of the goals of transaction fees is to charge users for the marginal costs incurred on the protocol from their transactions. Since the units of transaction fees are currency, the fee mechanism involves conversion from resources (e.g VM steps, builtins, calldata, Ethereum gas) to tokens (e.g STRK, ETH). Currently, the wasteful resource utilization of the prover comes at the expense of the users since they are charged fees according to the total trace, and not its utilized portion. Dynamic Layouts will improve cell utilization and consequently reduce the \u201cunnecessary\u201d part of the transaction fee (the part covering resource consumption not directly incurred by the user\u2019s transaction). == Starknet builtin integration Currently, the final step in builtin integration involves modifying the Starknet codebase to actually employ them. These modifications are orthogonal to layouts: they are required to ensure the Starknet operating system invokes builtins when possible. For instance, we want the Starknet operating system to invoke the Poseidon builtin during execution of Cairo code that invokes the Poseidon hash function. Starknet builtin support is supported manually now, similarly to layouts. However, unlike the case of layouts, this manual support will remain tame and straightforward even for many builtins. In other words, Starknet builtin support is not a blocker to integration, and Dynamic Layouts will truly pave the way for creation and integration of additional builtins. == Summary The focus is on developing Dynamic Layouts to improve the efficiency of the proving process and facilitate the integration of new builtins. This approach will optimize"}
{"title": "felts.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"felts\"] = Deep into Felts In most of your code (unless you intend to write very algebraic code), you won't have to deal with the fact that the values in Cairo are felts and you can treat them as if they were normal integers ( documentation]). The field element (felt) is the only data type that exists in Cairo, you can even omit its explicit declaration; when the type of a variable or argument is not specified, it is automatically assigned the type felt. Addresses are also stored as felts. A felt can be negative or zero, and can be a large integer: specifically, it can be in the range $-X < felt < X$, where $X = 2{caret}\\{251} + 17* 2{caret}\\{192} + 1$ . Any value that is not within its range will cause an \"`overflow`\": an error that occurs when a program, Cairo, receives a number or value outside the scope of its ability to handle. Thus, when we add, subtract or multiply and the result is outside the felt's range, there is an overflow. Compile and run link:./felts/cairo/felt.cairo[felt.cairo] with: [,bash] ---- cairo-compile felts/cairo/felt.cairo --output felt_compiled.json cairo-run --program felt_compiled.json --print_output --layout=small ---- You will get: [,bash] ---- Program output: 0 -1 1 2 1206167596222043737899107594365023368541035738443865566657697352045290673496 7 ---- `+FELT_SIZE = 2**251 + 17 * 2**192 + 1+` is just outside the range of values a felt can take, then it will overflow to `0` as evidenced when running `serialize_word(FELT_SIZE)`. The most important difference between integers and field elements is division: Division of felts is not the integer division in many programming languages; the integral part of the quotient is returned (so you get $(7 / 3 = 2)$. As long as the numerator is a multiple of the denominator, it will behave as you expect $(6 / 3 = 2)$. If this is not the case, for example when we divide $7/3$, it will result in a felt $x$ that satisfies $(3 * x = 7)$; specifically, $x=1206167596222043737899107594365023368541035738443865566657697352045290673496$. It won't be $2.3333$ because $x$ has to be an integer and since $3 * x$ is larger than $2{caret}\\{251} + 17 * 2{caret}\\{192} + 1$ it will overflow to exactly $7$. In other words, when we are using modular arithmetic, unless the denominator is zero, there will always be an integer $x$ satisfying $denominator * x = numerator$. == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "hints.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"hints\"] = Deep into Hints Python code can be invoked with the %{ %} block called a hint, which is executed right before the next Cairo instruction. The hint can interact with the program's variables/memory as shown in the following code sample. Note that the hint is not actually part of the Cairo program, and can thus be replaced by a malicious prover. We can run a Cairo program with the --program_input flag, which allows providing a json input file that can be referenced inside a hint. [,Rust] ---- alloc_locals; %{ memory[ap] = 100 %} // Assign to memory. [ap] = [ap], ap++; // Increment `ap` after using it in the hint. assert [ap - 1] = 100; // Assert the value has some property. local a; let b = 7; %{ # Assigns the value '9' to the local variable 'a'. ids.a = 3 ** 2 c = ids.b * 2 # Read a reference inside a hint. %} ---- Note that you can access the address of a pointer to a struct using ids.struct_ptr.address_ and you can use memory[addr] for the value of the memory cell at address addr. == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "index.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"index\"] = Deep into Cairo == CLI Cheatsheet++++++ [,bash] ---- # compile cairo program cairo-compile example.cairo --output example_compiled.json # run cairo program and output results cairo-run --program=example_compiled.json --print_output --layout=small # output the KECCAK Fact of the cairo program cairo-hash-program --program=example_compiled.json # format/lint your cairo program cairo-format -i example.cairo # compile cairo program and submit the fact to the SHARP cairo-sharp submit --source example.cairo --program_input input.json ---- == Sources [ , , , , , == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "integrity.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"integrity\"] = Statement of Computational Integrity == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "memory.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"memory\"] = Memory Model == Continous Memory addresses accessed by a program must be continuous. For example, if addresses 7 and 9 are accessed, then 8 must also be accessed before the end of the program. The prover will automatically fill the empty memory cells with arbitrary values. Having such gaps is inefficient, as it means memory is being consumed without being used. Introducing too many holes could make the generation of a proof too expensive. However, this still does not violate the soundness guarantee -- a false proof cannot be generated regardless. In practice we can store values in memory cells while skipping memory cells (see the prover will fill the empty cells to keep the memory continous. == Write-once, read-only We can think of the memory of Cairo as a write-once memory (it can only be written once). If we assign that `assert [d] = 7;` then the address `d` in memory will always contain the value `7` until the execution of our program is finished. We won't be able to change what address `d` stores at run time, we could only write it once and then read it. == Relative addresses The absolute address of each memory cell can only be determined at the end of the execution of the Cairo program. That is, we are dealing with addresses relative to other addresses. I cannot say that I want the felt equivalent to `\u201cI rule here\u201d` to be found in memory cell number 32. I can say, for example, I want the felt equivalent to `Cairo rule\u201d` to be found in the next empty cell or in three cells from the current one being used. Do you notice how we are not talking about absolute addresses but relative addresses? We will review registers, which are very useful for this, in a the next section."}
{"title": "polynomial.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"polynomial\"] = Polynomial Equations == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "registers.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"registers\"] = Registers We know that the Algebraic RISC operates on memory cells (there are no general purpose registers). One Cairo instruction may deal with up to 3 values from the memory: it can perform one arithmetic operation (either addition or multiplication) on two of them, and store the result in the third. In total, each instruction uses 4 memory accesses since it first uses one for fetching the instruction ( Whitepaper]). The Cairo CPU operates on 3 registers (`pc`, `ap`, and `fp`) that are used for specifying which memory cells the instruction operates on. For each of the 3 values in an instruction, you can choose either an address of the form $ap + off$ or $fp + off$ where $off$ is a constant offset in the range $[\u2212215, 215)$. Thus, an instruction may involve any 3 memory cells out of $2 \u00b7 216 = 131072$. In many aspects, this is similar to having this many registers (implemented in a much cheaper way). An offset is an addition or substraction to a cell in the memory, e.g., $[fp - 1] = [ap - 2] + [fp + 4]$ where $-1$, $-2$ and $+4$ are offsets. Offsets allow us to have relative memory positions. * The \"allocation pointer\" (ap) points to the first memory cell that has not been used by the program so far. Many instructions may increase the value `ap` by one to indicate that another memory cell has been used by the instruction; similar to what `serialize_word` does when it uses the output builtin memory at `output_ptr` and then updates its value. * When a function starts the \"frame pointer\" register (fp) is initialized to the current value of ap. During the entire scope of the function (excluding inner function calls) the value of `fp` remains constant. In particular, when a function, foo, calls an inner function, bar, the value of `fp` changes when bar starts but is restored when bar ends. The idea is that `ap` may change in an unknown way when an inner function is called, so it cannot reliably be used to access the original function's local variables and arguments anymore after that. Thus, `fp` serves as an anchor to access these values. * The \"`program counter`\" (pc) register points to the address in memory of the current Cairo instruction to be executed. The `pc` starts at the beginning of the program segment; segment 0. The CPU (1) fetches the value of that memory cell, (2) performs the instruction expressed by that value (which may affect memory cells or change the flow of the program by assigning a different value to PC), (3) moves `pc` to the next instruction and (4) repeats this process. In other words, The program counter (pc) keeps the address of the current instruction. Usually it advances by 1 or 2 per instruction according to the size of the instruction (when the current instruction occupies two field elements, the program counter advances by 2 for the next instruction). Compile and the run link:registers/cairo/ap_fp_example.cairo[registers/cairo/ap_fp_example.cairo]. The example will print: [,Bash] ---- 1. ap address: 1:3; fp address: 1:3 2. ap address: 1:4; fp address: 1:3; value at address [AP - 1] is 100. 3. ap address: 1:5; fp address: 1:3; value at address [AP - 1] is 200. 4. ap address: 1:6; fp address: 1:3; value at address [AP - 1] is 2:0 (WITH OUTPUT_PTR). 5. ap address: 1:9; fp address: 1:8; value at address [AP - 1] is 300 (FOO() FUNCTION). 6. ap address: 1:9; fp address: 1:8; value at address [AP + 2] is 500; we can not get the value at [AP + 1] since it is unknown. 7. ap address: 1:10; fp address: 1:3; value at address [AP - 1] is 600. ---- Note: . `fp` is initialized to the same value that `ap` takes at the start of a function's scope: during scope of `main` it is `1:3`, during scope of `foo` it is `1:8`. When the scope of `foo` ends and the program returns to the `main`, `fp` is `1:3` again. . You can skip memory cells. During instruction 6. we set the value in `[ap+2]` without defining `[ap+1]`. . `[ap]` can store felts but also relocatable addresses as in instruction 4. where we store the value of `output_ptr`. . `ap` advances one by one except when a function is called and at the beginning. Our `ap` starts pointing at 1:3, because the first three memory cells of the execution segment (1:0, 1:1, 1:2) indicate the other segments that will be used, in this case segments 2, 3 and 4. Segment 2 is used for the output builtin, and segments 3 and 4 are empty segments used for the return values of `fp` an pc. Run link:registers/cairo/ap_fp_example.cairo[registers/cairo/ap_fp_example.cairo] with the flags `--print_info` and `--print_segments`. Note: . Thanks to `--print_info` we can see the register values after execution. [,Bash] ---- Register values after execution: pc = 4:0 ap = 1:11 fp = 3:0 ---- The final values of the registers are also relocatable. `ap` remains in the execution segment (1), while the return values of `fp` and `pc` are given their own segments for technical reasons. . Thanks to `--print_segments` we can see the segment relocation table; [,Bash] ---- Segment relocation table: 0 1 1 29 2 339 3 340 4 340 ---- The table shows the actual (not relative) addresses of the memory cells used by each segment after relocation. Segments 3-4 are empty segments used to return values \u200b\u200bfrom `fp` and `pc`. As you can see, the memory ends up being continuous: for example segment 1 starts at cell 29, when segment 0 ends and continues to cell 338, remember we set the value to `[ap+300]` so that the cells 40-337 were automatically filled by the prover. Then segment 2 starts at the next address, 339."}
{"title": "risc.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"risc\"] = The Cairo Intruction Set (Algebraic RISC) Here is a nice mental model by to think about Cairo: * AIR = Assembly for STARK's * Cairo Language = Java for STARK's Java code turns into JVM bytecode which is interpreted into assembly; similarly, Cairo (the language) code is interpreted into CairoVM bytecode which is interpreted into AIR. The JVM executes on an x86 processor (e.g. java.exe), and the CairoVM executes on a STARK prover. STARK provers will eventually be embedded in hardware, just like other cryptographic coprocessors (TPM's, enclaves). Unlike ordinary Instruction Sets, which are executed on a physical chip built of transistors, Cairo is executed in an AIR (the execution trace is verified using an AIR). Roughly speaking, the most important constraint when designing an AIR (and, therefore, when designing an Instruction Set that will be executed by an AIR) is to minimize the number of trace cells used. The Instruction Set is the set of operations the Cairo CPU can perform in a single step. Cairo uses a small and simple, yet relatively expressive, Instruction Set; it was chosen so that the corresponding AIR will be as efficient as possible. It is a balance between: . A minimal set of simple instructions that require a very small number of trace cells; and . Powerful enough instructions that will reduce the number of required steps. Particularly: . Addition and multiplication are supported. . Checking whether two values are equal is supported, but there is no instruction for checking whether a certain value is less than another value (such an instruction would have required many more trace cells since a finite field does not support an algebraic-friendly linear ordering of its elements). This minimalistic set of instructions is called an Algebraic RISC (Reduced Instruction Set Computer); \"`Algebraic`\" refers to the fact that the supported operations are field operations. Using an Algebraic RISC allows us to construct an AIR for Cairo with only 51 trace cells per step."}
{"title": "segments.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"segments\"] = Segments When accessing memory in Cairo we use segments. The segments are memory areas. These segments will then be concatenated to create a list of segments: our memory. As we mentioned before, addresses in Cairo are relative: they are not inly relative to each other but also to the segment to which they belong. Therefore, an address in Cairo is represented like this: `:`. Where `` is the segment number (we don't know it when writing the program, it is assigned when running our program); and `` is the position of the address relative to the segment. This way of representing addresses is called \"relocatable\": in the end, when we run our program, these memory cells will be relocated so that the memory ends up being continuous. The two segments that any Cairo program require are: * *Segment 0* - Program segment. Cairo programs are themselves kept in the program segment. This segment is of fixed length and contains the numeric representation of the Cairo program. The register `pc` starts here. * *Segment 1* - Execution segment. This is where the registers `ap` and `fp` start, and where data generated during the run of a Cairo program (variables, return addresses for function calls, etc.) is stored. The length of the execution segment is variable, as it depends, for example, on the program input. As we saw before, we can use builtins which would have their own memory segment. Compile (`cairo-compile builtins/cairo/hash.cairo --output hash_compiled.json`) and run it with the `--print-memory` flag (`cairo-run --program hash_compiled.json --print_output --layout=small --print_memory`). Notice we have values in the Program (0), Execution (1), Output (2), Pedersen (3), and Range Check (4) segments."}
{"title": "sierra.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"sierra\"] = Sierra == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "silicon.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"silicon\"] = Cairo vs Silicon CPU == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "turing.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"turing\"] = A practically-efficient Turing-complete STARK-Friendly CPU Architecture While this section is being built we recommend reading the video session for this chapter and the docs]. `Practical`: Cairo supports conditional branches, memory, function calls, and recursion `Efficient`: Instruction Set chosen so the corresponding AIR is efficient and optimized with `builtins` `Turing Complete`: Can simulate any Turing machine, as such supports any feasible computation == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "arithmetization.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"arithmetization\"] = Arithmetization The goal of the STARK protocol is to verify computations succinctly and transparently. It follows three steps: . The first step in a STARK is called _arithmetization_, and it is the translation (often referred to as '`reduction`') of the problem of verifying a computation to the problem of checking that a certain polynomial, which can be evaluated efficiently on the verifier's side (this is the '`succinctly`' part), is of low degree. Arithmetization is useful since it enables the use of tools from the realm of Error Correction Codes that efficiently test low degree-ness. . However, arithmetization itself only translates a Computational Integrity statement into a polynomial, setting the scene for the next phase in STARK, which is another interactive protocol that involves a prover that attempts to convince a verifier that the polynomial is indeed of low degree. The verifier is convinced that the polynomial is of low degree if and only if the original computation is correct (except for an infinitesimally small probability). . In the last step of STARK, the interactive protocol is transformed into a single non-interactive proof, that can be posted to a blockchain and publicly verified by anyone. Arithmetization itself is composed of two steps. The first is generating an execution trace and polynomial constraints, the second is transforming these two objects into a single low-degree polynomial. In terms of prover-verifier interaction, what really goes on is that the prover and the verifier agree on what the polynomial constraints are in advance. The prover then generates an execution trace, and in the subsequent interaction, the prover tries to convince the verifier that the polynomial constraints are satisfied over this execution trace, unseen by the verifier. Let's review each step. == Step 1: Generating an execution trace and a set of polynomial constraints The first step takes some CI statement (such as \"`the fifth transaction in block 7218290 is correct`\"), and translate it into formal algebraic language. This serves two purposes: 1) it defines the claim succinctly in an unambiguous way, and 2) it embeds the claim in an algebraic domain. This embedding is what allows the second step of arithmetization, which reduces the CI statement to a claim about the degree of a specific polynomial. The algebraic representation that we use has two main components: 1) an execution trace, and 2) a set of polynomial constraints. The execution trace is a table that represents the steps of the underlying computation, where each row represents a single step. The set of polynomial constraints is constructed such that all of them are satisfied if and only if the trace represents a valid computation. While the execution trace may be very long, we will work with a succinct set of polynomial constraints. The type of execution trace that we're looking to generate must have the special trait of being succinctly testable -- each row can be verified relying only on rows that are close to it in the trace, and the same verification procedure is applied to each pair of rows. This trait directly affects the size of the proof. To exemplify what we mean by being succinctly testable, let's go back to the supermarket receipt, and add another column for the running total: image::receipt2.png[receipt2] This simple addition allows us to verify each row individually, given its previous row. We can, for example, examine these two rows: image::receipt3.png[receipt3] We would be convinced that this particular step of the computation (i.e. the number 16.41) is correct since 12.96+3.45=16.41. Notice that the same constraint is applied to each pair of rows. This is what we mean by succinct constraints. Let's proceed with the polynomial constraints. We rewrite the supermarket receipt (with the running total) in the form of a table: image::receipt4.png[receipt4] Denote the value of the cell in the $i$-th row and $j$-th column by $A_{i,j}$. We can now rephrase the correctness conditions as this set of polynomial constraints: image::constraints.png[constraints] These are linear polynomial constraints in Ai,j. If the set of polynomial constraints we use are of high degree, this has an adverse effect on the proof length and the time it takes to generate it. Consequently, linear constraints are the best we can hope for. Notice that (2) is really a single constraint applied multiple times, and the whole size of the set is independent of the length of the receipt. In sum, we took a CI problem of verifying a supermarket receipt, and transformed it into a succinctly testable execution trace, and a corresponding set of polynomial constraints that hold if and only if the total sum in the original receipt is correct. Let's see a more complex example: the Collatz Conjecture. In 1937, a German mathematician named Lothar Collatz presented a conjecture in the field of number theory. At first glance this conjecture might seem merely a cute math puzzle, but in fact it is a hard open problem in number theory. It caught the attention of many mathematicians over the years, and acquired a lot of synonyms (e.g., the $3n + 1$ conjecture, the Ulam conjecture, Kakutani's problem and many more). Paul Erd\u0151s once said about this conjecture: \"`Mathematics may not be ready for such problems`\". A Collatz sequence starts with any positive integer, where each subsequent element in the sequence is obtained from the previous one as follows: If the previous element is even: divide it by 2. If the previous element is odd and greater than 1: multiply it by 3 and add 1. If the previous element is 1, stop. Let's consider a simple example where the initial term is 52: $52 \\-> 26 \\-> 13 \\-> 40 \\-> 20 \\-> 10 \\-> 5 \\-> 16 \\-> 8 \\-> 4 \\-> 2 \\-> 1$. *Collatz Conjecture*: for any positive integer we start with, the sequence always reaches 1. Unfortunately, resolving the Collatz Conjecture is beyond the scope of this tutorial. Instead, we will consider the problem of verifying a computation that checks the conjecture for a particular starting integer. The Collatz Sequence Execution Trace The CI statement is: \"`A Collatz sequence that starts with 52, ends with 1 after 11 iterations`\". Let A be the execution trace of the sequence's computation. The i-th row, denoted by Ai, represents the i-th number in the sequence. All numbers are represented as binary strings, to make it easier to express the odd/even condition with polynomials. Ai,j equals to the j-th least significant bit of the i-th number of the sequence. For example, A0=001011: the first term is 52, its binary representation is 110100 and then we reverse the bits`' order (bit reversal order simplifies indexing in the polynomial constraints notation). Here is the execution trace of the above Collatz sequence that starts with 52: image::collatz.png[collatz] Note that here the trace has 6 columns because 6 bits are enough to represent even the largest number in the sequence. Had we started the sequence with 51, the next number would have been 154, so the trace of such a sequence would have required at least 8 columns. Recall that the polynomial constraints we are looking for are such that all of them are satisfied if and only if the trace A describes the given Collatz sequence (starting with 52, ending with 1, and the transition from any two consecutive rows is done correctly). In our example, the trace A is of size 6x12, i.e., it represents a Collatz sequence of 12 6-bit numbers. The set of polynomial constraints are the following ($n=12$, $m=6$): image::collatz2.png[collatz2] Let's go over each of the constraints. The first three are straightforward: . holds if and only if the first row is a binary representation of 52. . holds if and only if the last row is a binary representation of 1. . holds if and only if the trace contains only bits (a number is equal to its square if and only if it is either 0 or 1). The fourth set of constraints defines the heart of the succinct computation of the sequence, i.e., the connection between every two consecutive rows. The ability to express computational constraints as a recurring pattern of local constraints (i.e. succinctness), is fundamental to the verifier being exponentially faster than a naive replay of the computation. Let's examine the constraints themselves carefully. For any $i<n-1$, denote: image::collatz3.png[collatz3] Hence, for each $i<n-1$, we get the following constraint: image::collatz4.png[collatz4] $A_{i,0}$ is the least significant bit of the $i$-th number, which determines its parity as an integer, so this constraint describes the Collatz sequence rule. To sum up, all constraints are satisfied if and only if the trace represents a valid computation of a Collatz sequence. Note that any Collatz sequence of length n, can be represented using a trace of size n*m where m is the maximum number of bits in the representation of a number in the sequence, and the corresponding polynomial constraints are modified accordingly. Note that the polynomial constraints do not grow with n and m, but remain simple and concise. Given a specific first term for a Collatz sequence, a simple computer program can output the execution trace and the polynomial constraints. We have seen how a CI statement about a Collatz sequence can be transformed into an execution trace and a succinctly-described set of polynomial constraints. Similar methods can be used to transform any computation, and in general, any CI statement can be translated into this form. The details, however, matter a great deal. While there are many ways in which an execution trace (and a set of polynomial constraints) may describe a specific computation, only a handful of them result in a small STARK proof which can be constructed efficiently. Much of the effort in Starkware is devoted to designing reductions that lead to good polynomial constraints, which we call AIR (Algebraic Intermediate Representation), as much of the performance of our systems depends on it. == Step 2: Transform the execution trace and the set of polynomial constraints into a single low-degree polynomial Using a Fibonacci sequence, we will show how the prover can combine the execution trace and the polynomial constraints to obtain a polynomial that is guaranteed to be of low degree if and only if the execution trace satisfies the polynomial constraints that we started with. Moreover, we will show how the domain over which the polynomial is considered allows the verifier to evaluate it succinctly. We also briefly discuss how error correction codes play a role in STARKs. [XXX Should we add fine fields here? We will assume familiarity with finite groups, polynomials over finite fields, and the previous posts in this series.] Recall that our goal is to make it possible for a verifier to ask a prover a very small number of questions, and decide whether to accept or reject the proof with a guaranteed high level of accuracy. Ideally, the verifier would like to ask the prover to provide the values in a few (random) places in the execution trace, and check that the polynomial constraints hold for these places. A correct execution trace will naturally pass this test. However, it is not hard to construct a completely wrong execution trace, that violates the constraints only at a single place, and, doing so, reach a completely far and different outcome. Identifying this fault via a small number of random queries is highly improbable. Common techniques that address similar problems are Correction Codes*]. Error Correction Codes transform a set of strings, some of which may be very similar to one another, into a set of strings that are pairwise very different, by replacing the original strings with longer strings. Interestingly, polynomials can be used to construct good error correction codes, since two polynomials of degree d, evaluated on a domain that is considerably larger than $d$, are different almost everywhere (to see this, notice that the difference between distinct degree-$d$ polynomials is a non-zero polynomial of degree $d$, hence has at most $d$ zeros). Such codes are called *Reed-Solomon* codes. Observing that, we can extend the execution trace by thinking of it as an evaluation of a polynomial on some domain, and evaluating this same polynomial on a much larger domain. Extending in a similar fashion an incorrect execution trace, results in a vastly different string, which in turn makes it possible for the verifier to distinguish between these cases using a small number of queries. Our plan is therefore to 1) rephrase the execution trace as a polynomial, 2) extend it to a large domain, and 3) transform that, using the polynomial constraints, into yet another polynomial that is guaranteed to be of low degree if and only if the execution trace is valid. *Toy Example: Boolean Execution Trace* Suppose that the CI statement in question is \"`The prover has a sequence of 512 numbers, all of which are either 0 or 1`\", which we would like to verify by reading substantially less than 512 numbers. Let's see what kind of execution trace and polynomial constraints express this toy example: . The execution trace has $512$ rows, each row containing a single cell with either zero or one in it. . The polynomial constraint we use here is simply $A_\\{\u1d62}\u22c5A_\\{\u1d62}-A_\\{\u1d62}=0$, where $A_\\{\u1d62}$ denotes the $i$-th cell in this single-column execution trace (a number is equal to its square if and only if it is either 0 or 1). [cols=3*] |=== | In order to rephrase this execution trace in terms of polynomials, we specify the field we will be working in -- we go with $Z_{\u2089\u2086\u2087\u2086\u2089}$, obtained from the set of integers ${0,1,...,96768}$ with addition and multiplication modulo $96769$. Next we pick a subgroup $G$ of $Z_{\u2089\u2086\u2087\u2086\u2089}{caret}{_}$ (we use $F_$ to denote the multiplicative group of $F$; the multiplicative group is obtained by omitting the zero element from the field) such that $ | G | =512$, and some generator $g$ of $G$. The existence of such a subgroup is guaranteed since $512$ divides the size of this group (which is $96768$). |=== We now think of the elements in the execution trace as evaluations of some polynomial f(x) of degree less than 512 in the following way: the i-th cell contains the evaluation of f on the generator's i-th power. Formally: image::generator.png[generator] Such a polynomial of degree at most 512 can be computed by interpolation, and we then proceed to evaluate it on a much larger domain (choosing this domain's size directly translates into the soundness error, the bigger it is -- the smaller the soundness error), forming a special case of Reed-Solomon codeword. Lastly, we use this polynomial to create another one, whose low degreeness depends on the constraint being satisfied over the execution trace. To do so, we must go on a tangent and discuss roots of polynomials. A basic fact about polynomials and their roots is that if $p(x)$ is a polynomial, then $p(a)=0$ for some specific value $a$, if and only if there exists a polynomial $q(x)$ such that $(x-a)q(x)=p(x)$, and $deg(p)=deg(q)+1$. Moreover, for all $x\u2260a$, we can evaluate $q(x)$ by computing: image::root.png[root] By induction, a similar fact is true for $k$ roots. Namely, if $a_\\{\u1d62}$ is a root of p for all $i=0..k-1$, then there exists a polynomial $q$ of degree $deg(p)-k$, and in all but these $k$ values, it is exactly equal to: image::kroots.png[kroots] Rephrasing the polynomial constraint in terms of f yields the following polynomial: image::polConstraint.png[polConstraint] We have defined $f$ such that the roots of this expression are $1$, $g$, $g\u00b2$, $...$, $g\u2075\u00b9\u00b9$ if and only if the cells in the execution trace are $0$ or $1$. We can define: image::polConstraint2.png[polConstraint2] And we know from the previous paragraph that there exists a polynomial of degree at most $2\u00b7deg(f)-512$ that agrees with $p$ on all $x \u2209{1, g, g{caret}\\{2}, ..., g{caret}\\{511}}$ if and only if the execution trace is indeed a list of 512 bits (i.e., 0 or 1). Note that earlier on, the prover has extended the execution trace to a larger domain, so querying for the polynomial values in that domain is well defined. If there exists a protocol by which the prover can convince (such that the verifier is convinced if and only if the prover is not cheating) the verifier that this polynomial is of low degree, such that in it the verifier only asks for values outside the execution trace, then indeed the verifier will be convinced about the truthfulness of the CI statement only when it is true. In fact, in the next post, we will show a protocol that does exactly that, with some very small probability of error. For the time being -- let's take a look at another example, that is still simple, but not completely trivial, and see how the reduction works in that case. *Not so trivial example: Fibonacci* The example that we use next is that of correctly computing a Fibonacci sequence in $Z_{\u2089\u2086\u2087\u2086\u2089}$ to the $512$-th place. The sequence is defined formally by: image::fibonacci1.png[fibonacci1] And our claim (i.e., the CI statement) is that $a_{\u2085\u2081\u2081}=62215$. We can create an execution trace for this CI statement by simply writing down all 512 numbers: image::fibonacci2.png[fibonacci2] The polynomial constraints that we use are image::fibonacci3.png[fibonacci3] Now we translate into Polynomials. Here, too, we define a polynomial $f(x)$ of degree at most $512$, such that the elements in the execution trace are evaluations of $f$ in powers of some generator $g$. Formally: image::fibonacci4.png[fibonacci4] Expressing the polynomial constraints in terms of $f$ instead of $A$, we get: image::fibonacci5.png[fibonacci5] Since a composition of polynomials is still a polynomial -- substituting the $A\u1d62$ in the constraints with $f(g\u2071)$ still means these are polynomial constraints. Note that 1, 2, and 4 are constraints that refer to a single value of $f$, we refer to them as boundary constraints. The Fibonacci recurrence relation, in contrast, embodies a set of constraints over the entire execution trace, and it may be alternatively rephrased as: image::fibonacci6.png[fibonacci6] The use of a generator to index the rows of the execution trace allows us to encode the notion of \"`next row`\" as a simple algebraic relation. If x is some row in the execution trace, then $gx$ is the next row, $g\u00b2x$ is the row after that, $g\u207b\u00b9x$ is the previous row and so on. The recurrence relation polynomial: $f(g\u00b2x)-f(gx)-f(x)$ is zero for every $x$ that indexes a row in the execution trace, except for the last two. It means that 1, $g$, $g\u00b2$, $...$, $g\u2075\u2070\u2079$ are all roots of this recurrence relation polynomial (and it is of degree at most 510), so we can construct $q(x)$ as follows: image::fibonacci7.png[fibonacci7] In STARK lore, this is often referred to as the composition polynomial. Indeed, when the original execution trace obeys the Fibonacci recurrence relation, this expression agrees with some polynomial whose degree is at most 2 (recall that the degree of f is at most 512) on all but these 510 values: 1, $g$, $g\u00b2$, $...$, $g\u2075\u2070\u2079$. However, the term composition polynomial is somewhat misleading, as when the execution trace does not satisfy the polynomial constraint -- the evaluations of this expression differ from any low degree polynomial in many places. In other words -- it is close to a low-degree polynomial if and only if the original CI is correct, which indeed was our goal. This concludes the promised reduction, that translates the problem of checking whether certain polynomial constraints are satisfied over some execution trace, to the problem of checking whether some polynomial (known to the prover) is of low degree. Succinctness Having a very efficient verification technique is key to STARKs, and it can be seen as comprised of two parts -- using a small number of queries, and having the verifier perform a small computation on each query. The former is achieved by error correction codes, which allow querying in very few places, and the latter we have sort of sweeped under the rug throughout this post, until now. The verifier's work can be summed up as 1) querying the composition polynomial in random places, and 2) checking low-degreeness based on these queries. Low degreeness succinct checking will be handled in the next post, but what exactly do we mean by \"`querying the composition polynomial`\"? The avid reader may have been suspicious of this expression, and rightfully so. The prover, after all, may be malicious. When the verifier asks for the evaluation of the composition polynomial at some x, the prover may reply with the evaluation of some truly low-degree polynomial, that will pass any low-degree testing, but is not the composition polynomial. To prevent this, the verifier explicitly queries the Fibonacci execution trace at some row w by asking for the values of $f$ in three places: $f(w)$, $f(gw)$, $f(g\u00b2w)$. The verifier can now compute the value of the composition polynomial at w by: image::succinctness.png[succintness] Where the numerator can be computed using the values obtained from the prover, and the denominator... well, there's the rub (that was sweeped under the rug). On the one hand the denominator is completely independent of the execution trace, so the verifier can compute it before ever communicating with the prover. On the other hand, in practicality -- the trace may be comprised of hundreds of thousands of rows, and computing the denominator would cost the verifier dearly in running time. Here's where the arithmetization is crucial to succinctness -- since calculating this expression for the special case where the powers of g form a subgroup can be done very efficiently if one notices that: image::succinctness2.png[succinctness2] [cols=3*] |=== | This equality is true because both sides are polynomials of degree $ | G | $ whose roots are exactly the elements of $G$. |=== [cols=5*] |=== | Computing the right hand side of this equation seems to require a number of operations that is linear in $ | G | $. However, if we resort to by squaring], the left hand side of this equation can be computed in running time that is logarithmic in $ | G | $. |=== And the actual denominator of the Fibonacci composition polynomial in question can be obtained by rewriting it as: image::succinctness3.png[succinctness3] This seeming technicality stands at the core of the verifier being able to run in polylogarithmic time, and it is enabled only because we view the execution trace as evaluations of a polynomial over some subgroup of the field, and that the polynomial constraints in question hold over a subgroup. Similar tricks can be applied for more sophisticated execution traces, but it is crucial that the repeating pattern of the constraint coincides with some subgroup of the field. More Constraints, More Columns! The examples in this post were deliberately simple, to highlight key aspects of arithmetization. A natural question that arises will be: how is the case of multiple columns and multiple constraints handled. The answer is straightforward: multiple columns simply mean that there's more than one polynomial to work with, and multiple composition polynomials -- resulting from the multiple constraints -- are combined into a single polynomial, a random linear combination of all of them, for the sake of the last phase in STARK, which is a low degree test. With high probability, the linear combination is of low degree if and only if so are all of its components. We have shown how, given an execution trace and constraint polynomials, the prover can construct a polynomial which is of low degree if and only if the original CI statement holds. Furthermore, we have shown how the verifier can query the values of this polynomial efficiently, making sure that the prover did not replace the true polynomial with some false low-degree one. Next we will go into the details of low-degree testing, showing how this magic, of querying a small number of values and determining whether some polynomial is of low degree, is done. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "cryptography.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "{plus}{plus} [id=\"cryptography\"] = Cryptography == Cryptographic Hash Functions _Hashing_ is a process that uses an algorithm to take data and convert it to a fixed length known as a hash value, which varies widely even with small variations in the input. Here are two examples using the `SHA-256 hash function` (one of the most broadly used hash functions in use today): * If the input is `\"Starknet\"`, this would be the output: `a22979efeb74ca6aa02eaf2be8899e65b43dca9788a45ea687a96d970c32d96b` * And if the input is `\"Starknet.\"` then the output is: `78874a2e5dc07ce99d6fb8d71016e7edcb4fda2e64c0642762999baa6b5a0568` As you can see, the *difference between the two inputs is only one point* and the two outputs differ greatly from each other. Hash functions are designed to protect data integrity and this will be very important in the *STARK protocol*. With several data, in collaboration with hashing, we can build Trees] that will allow us to generate commitments and decommitments in the protocol, guaranteeing that a determined computation was performed correctly. == Asymmetric Encryption == Digital Signatures == Zero-Knowledge Proofs A party (P) executing a computation (C) on a dataset (D) may have incentive to misreport the correct output (C(D)), raising the problem of computational integrity (CI) (also known as delegation of computation, certified computation, and verifiable computation). That is, ensuring that P indeed reports C(D) rather than an output more favorable to P. When the dataset D is public, any party (V) interested in verifying CI can re-execute C on D and compare its output to that reported by P, as a customer might inspect a restaurant bill, or as a new Ethereum node will verify its blockchain. This solution does not scale because the time spent by the verifier (TV) is as large as the time required to execute the program (TC) and V must read the full dataset D. Thus, the computational integrity solution we seek should have scalable verification. Additionally, when the dataset D contains confidential data, the previous solution can no longer be implemented and the party P in charge of D may conceal violations of computational integrity under the veil of secrecy. Zero knowledge (ZK) proof and argument systems are automated protocols that guarantee computational integrity over confidential data for any efficient computation, eliminating corruptibility (possibly of auditors) and reducing costs. A ZK system S for a computation C is a pair of randomized algorithms, S = (P, V); the prover P is the algorithm used to prove computational integrity and the verifier V checks such proofs. Ideally we want the proof to be succint: the proof should be quicker to verify than than computing it. The completeness and soundness of S imply that P can efficiently prove all truisms but will fail to convince V of any falsities (with all but negligible probability). === Terminology Zero Knowledge Proof Systems are proof systems in which there is secret information known to the `prover` that is not known to the `verifier`, and the verifier is still convinced of the computational claim. A `non-interactive` proof system is an abstract machine that models computation between the two parties(prover and verifier). Messages are sent in direction] until the verifier is convinced of the computational claim. A `succinct` proof system is one in which the verifier can run an order of magnitute faster than a naive re-execution of the program `SNARKS`: Succint Non-Interactive Arguments of Knowledge `STARKs`: Scalable Transparent Arguments of Knowledge === SNARKs SNARK means Succinct Non-interactive Argument of Knowledge. They were pushed by a 2012 paper from Chiesa et. al.]. Alessandro is Co-Founder and Scientific Advisor at Starkware. SNARKs use elliptic curves to secure the randomness required for a proof. Elliptic curves are collision resistant, which means that it is very hard to find two separate inputs that produce the same output ( 2022]). The main limitations of SNARKs are: . No post-quantum resistance. . Initial trust requirements. [#starks] == STARKS: The newer and shinier cousin of SNARKs ____ (2017)] - \"What you might not know is that ZK-SNARKs have a newer, shinier cousin: ZK-STARKs.\" ____ STARKs were introduced in 2018 in a by Eli Ben-Sasson et. al.]. Eli is Co-Founder of Starkware. That is right, Starkware was founded by the some of the creators of both SNARKs and STARKs. The main difference between SNARKs and STARKs is that a STARK uses collision resistant hash functions instead of elliptic curves. These are much simpler cryptographic assumptions. STARKs rely purely on hashes and information theory; meaning that they are secure against attackers with quantum computers ( 2017]). What is the downside? Mainly that proof sizes go uo from 288 bytes, in SNARKs case, to a few hundred kilobytes. The tradeoff could be worth it or not. Authors suggest it could be worth it because it This tradeoff is worth STARKs allow us to have a much higher effective TPS and throughput than a SNARK ( 2022]), and if elliptic curves break or when quantum computers come around ( 2017]). \"With the T standing for \"transparent\", ZK-STARKs resolve one of the primary weaknesses of ZK-SNARKs, its reliance on a 'trusted setup\u00b4.\" 2017)]. == Commitment Schemes == Secure Multi-Party Computation (MPC) [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "efficient_starks.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"efficient_starks\"] = Efficient STARKs == Micali Construction == Interactive Oracle Proofs (IOPs) == BCS Construction == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "fri.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"fri\"] = The FRI Protocol We now combine the two above ideas (testing two polynomials with half the queries, and splitting a polynomial into two smaller ones) into a protocol that only uses O(log d) queries to test that a function f has (more precisely, is close to a function of) degree less than d. This protocol is known as FRI (which stands for Fast Reed -- Solomon Interactive Oracle Proof of Proximity), and the interested reader can read more about it For simplicity, below we assume that d is a power of 2. The protocol consists of two phases: a commit phase and a query phase. == Commit phase The prover splits the original polynomial f\u2080(x)=f(x) into two polynomials of degree less than d/2, g\u2080(x) and h\u2080(x), satisfying f\u2080(x)=g\u2080(x\u00b2)+xh\u2080(x\u00b2). The verifier samples a random value \ud835\udefc\u2080, sends it to the prover, and asks the prover to commit to the polynomial f\u2081(x)=g\u2080(x) + \ud835\udefc\u2080h\u2080(x). Note that f\u2081(x) is of degree less than d/2. We can continue recursively by splitting f\u2081(x) into g\u2081(x) and h\u2081(x), then choosing a value \ud835\udefc\u2081, constructing f\u2082(x) and so on. Each time, the degree of the polynomial is halved. Hence, after log(d) steps we are left with a constant polynomial, and the prover can simply send the constant value to the verifier. A note about the domains: for the above protocol to work, we need the property that for every z in the domain L, it holds that -z is also in L. Moreover, the commitment on f\u2081(x) will not be over L but over L\u00b2={x\u00b2: x \u220a L}. Since we iteratively apply the FRI step, L\u00b2 will also have to satisfy the {z, -z} property, and so on. These natural algebraic requirements are easily satisfied via natural choices of domains L (say, a multiplicative subgroup whose size is a power of 2), and in fact coincide with those that we anyways need in order to benefit from efficient FFT algorithms (which are used elsewhere in STARK, e.g., to encode execution traces). == Query phase We now have to check that the prover did not cheat. The verifier samples a random z in L and queries f\u2080(z) and f\u2080(-z). These two values suffice to determine the values of g\u2080(z\u00b2) and h\u2080(z\u00b2), as can be seen by the following two linear equations in the two \"`variables`\" g\u2080(z\u00b2) and h\u2080(z\u00b2): image::query1.png[query1] The verifier can solve this system of equations and deduce the values of g\u2080(z\u00b2) and h\u2080(z\u00b2). It follows that it can compute the value of f\u2081(z\u00b2) which is a linear combination of the two. Now the verifier queries f\u2081(z\u00b2) and makes sure that it is equal to the value computed above. This serves as an indication that the commitment to f\u2081(x), which was sent by the prover in the commit phase, is indeed the correct one. The verifier may continue, by querying f\u2081(-z\u00b2) (recall that (-z\u00b2)\u220a L\u00b2 and that the commitment on f\u2081(x) was given on L\u00b2) and deduce from it f\u2082(z\u2074). The verifier continues in this way until it uses all these queries to finally deduce the value of f_{log d}(z) (denoting f with a subscript log d, that we can't write due to Medium's lack of support for fully fledged mathematical notation). But, recall that f_{log d}(z) is a constant polynomial whose constant value was sent by the prover in the commit phase, prior to choosing z. The verifier should check that the value sent by the prover is indeed equal to the value that the verifier computed from the queries to the previous functions. Overall, the number of queries is only logarithmic in the degree bound d. Optional: To get a feeling why the prover cannot cheat, consider the toy problem where f\u2080 is zero on 90% of the pairs of the form {z,-z}, i.e., f\u2080(z) = f\u2080(-z) = 0 (call these the \"`good`\" pairs), and non-zero on the remaining 10% (the \"`bad`\" pairs). With probability 10% the randomly selected z falls in a bad pair. Note that only one \ud835\udefc will lead to f\u2081(z\u00b2)=0, and the rest will lead to f\u2081(z\u00b2)\u22600. If the prover cheats on the value of f\u2081(z\u00b2), it will be caught, so we assume otherwise. Thus, with a high probability (f\u2081(z\u00b2), f\u2081(-z\u00b2)) will also be a bad pair in the next layer (the value of f\u2081(-z\u00b2) is not important as f\u2081(z\u00b2)\u22600). This continues until the last layer where the value will be non-zero with high probability. On the other hand, since we started with a function with 90% zeros, it is unlikely that the prover will be able to get close to a low degree polynomial other than the zero polynomial (we will not prove this fact here). In particular, this implies that the prover must send 0 as the value of the last layer. But then, the verifier has a probability of roughly 10% to catch the prover. This was only an informal argument, the interested reader may find a rigorous proof In the test described so far (and the above analysis) the probability that the verifier catches a malicious prover is only 10%. In other words the error probability is 90%. This can be exponentially improved by repeating the above query phase for a few independently sampled z's. For example, by choosing 850 z's, we get an error probability of 2{caret}{-128} which is practically zero. In summary, the direct solution (test) requires too many queries to achieve the succinctness required by STARK. To attain logarithmic query complexity, we use an interactive protocol called FRI, in which the prover adds more information in order to convince the verifier that the function is indeed of low degree. Crucially, FRI enables the verifier to solve the low-degree testing problem with a number of queries (and rounds of interaction) that is logarithmic in the prescribed degree. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "geometry.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"geometry\"] = Algebraic Geometry == Polynomials `Polynomials` have properties that are very useful in proofs]. A polynomial is an expression of more than two algebraic terms. The degree of a polynomial is the highest degree of any specific term. For an example of how Polynomials can be built and expressed in code. Run: == [,bash] python3 finite_fields/python/polynomial.py --- Polynomial arithmetic deals with the addition, subtraction, multiplication, and division of polynomials. We can represent a bit pattern by a polynomial in, say, the variable $x$. Each power of $x$ in the polynomial can stand for a bit position in a bit pattern. For example, we can represent: * the bit pattern $111$ by the polynomial $x{caret}\\{2} + x + 1$; * the bit pattern $101$ by the polynomial $x{caret}\\{2} + 1$; and * the pattern $011$ by the polynomial $x + 1$. Since all the bits in $111$ are set, we have all powers of $x$ up to 2 in the corresponding polynomial. On the other hand, in the bit pattern $101$, the second bit is not set, so the coefficient of $x$ in the polynomial is zero, which results in the polynomial $x{caret}\\{2} + 1$. Finally, in the bit pattern $011$, since only the two least significant bits are set, the polynomial becomes $x + 1$. Representing bit patterns with polynomials will allow us to create a finite field with bit patterns. In general, a polynomial is an expression of the form: image::poly1.png[poly1] for some non-negative integer $n$ and where the coefficients $a_\\{0}$, $a_\\{1}$, $...$, $a_\\{n}$ are drawn from some designated set $S$. $S$ is called the coefficient set. $n$ marks de degree of the polynomial. A $0$-degree polynomial is called a constant polynomial. In reality, we do not have intentions of evaluating the value of a polynomial for a certain value of $x$. We will be dealing with finding the point at which these polynomials equal 0. Polynomial arithmetic is quite simple. The more complex operation is the division which is not in the scope of this tutorial for now. image::poly2.png[poly2] We can define several polynomials belonging to the same field. For example, for the $F_2$ field, which only contains $0$ and $1$ as members, we can generate an infinite number of polynomials without caring for the their degree. That is, the members of the field only populate the coefficients of the polynomial without caring for the exponents. image::poly6.png[poly6] We can follow the same logic for polynomial arithmetic operations when the coefficients belong to finite field. We just need to remember the modular nature of finite fields. As an example, let's operate with polynomals whose coefficients belong to the $F_7$ field. You will notice that we are simply using field arithmetic within the coefficients. Addition: image::poly3.png[poly3] Substraction: image::poly4.png[poly4] Multiplication: image::poly5.png[poly5] Again the division case is out of the scope of this tutorial for now. A polynomial $f(x)$ over a field $F$ is called prime or irreducible if $f(x)$ cannot be expressed as a product of two polynomials. Both polynomials have to be part of $F$ and of a lower degree than $f(x)$. That is, an irreducible polynomial as a polynomial that cannot be factorized into lower-degree polynomials. The concept of generator, $g$, frequently appears in cryptography. A generator is an element in the subgroup whose powers span the entire subgroup. In easier words, it is a number that is capable of of generating the entire set or the entire field by exponentiating the generator. For example, for the field $Z_\\{13}$, a generator $g$ is $g=2$. Why? Because if we exponentiate $2$ we can get all the 13 elements in the field $Z_\\{13} = {0,1,...,12}$ (except for the 0). Notice $2{caret}\\{0}\\bmod13 = 1$, $2{caret}\\{1}\\bmod13 = 2$, $2{caret}\\{2}\\bmod13 = 4$, $2{caret}\\{3}\\bmod13 = 8$, $2{caret}\\{4}\\bmod13 = 3$, $2{caret}\\{5}\\bmod13 = 6$, and so on. Not all elements in a set can be generators, make the exercise and you will notice 3 is not a generator of the field $Z_\\{13}$. More generally, note that if $g$ is the generator of a field $Z_\\{n}$, then $Z_\\{n} = {0, g{caret}\\{0}, g{caret}\\{1}, ..., g{caret}\\{n-2}}$ (because by exponentiating generator $g$ we can get each element in the field). == Points, Lines, and Curves == Algebraic Varieties == Divisors == Algebraic Morphisms == Sheaves [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "index.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"index\"] = STARKs Math == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "introduction_starks.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"introduction_starks\"] = Introduction to the STARKs By now there are quite a few theoretical constructions of proof systems, along with implementations. Some are deployed in cryptocurrencies, like the used by and (BP) deployed in (For general information on proof systems go What distinguishes is the combination of the following three properties: scalability (the S in STARK), transparency (the T in STARK), and lean cryptography. == Scalability: Exponential Speedup of Verification** Scalability means that two efficiency properties hold simultaneously: * *Scalable Prover*: The prover's running time is \"`nearly-linear`\" in the time it would take a trusted computer to check CI by just re-executing the computation themselves and checking that the result matches what someone is claiming. The ratio of \"`overhead`\" (time needed to generate a proof / time needed to just run the computation) remains reasonably low. * *Scalable Verifier*: The verifier's running time is polynomial in the logarithm of naive replay time. In other words, the verifier's runtime is exponentially smaller than simply replaying the computation (recall that '`replay`' is the current blockchain method to achieve Inclusive Accountability). image::scalable.png[scalable] Apply this notion of scalability to a blockchain. Instead of the current mode of verification by naive replay, imagine how things will look when a blockchain moves to verification by using proof systems. Instead of simply sending the transactions to be added to the blockchain, a prover node will need to generate a proof but thanks to the Scalable Prover its running time is nearly-linear in the running time of the naive replay solution. And the Scalable Verifier will benefit from an exponential decrease in its verification time. Furthermore, as blockchain throughput scales up, most of the effect will be shouldered by the prover nodes (which could run on dedicated hardware, like miners), whereas the verifiers, which would constitute most of the nodes in the network, would hardly be affected. Let's consider a concrete hypothetical example, assuming verifier time (in milliseconds) scales like the square of the logarithm of the number of transactions (tx). Suppose we start with 10,000 tx/block. Then the verifier's running time is $VTime = (log\u2082 10,000)\u00b2 ~ (13.2)\u00b2 ~ 177 ms$. Now increase the blocksize a hundredfold (to 1,000,000 tx/block). The new running time of the verifier is $VTime = (log\u2082 1,000,000)\u00b2 ~ 20\u00b2 ~ 400 ms$. In words, a 100x increase in transaction throughput led only to a 2.25x increase in the verifier's running time! In some cases, the verifier will still need to download and verify _availability of data_, which is a linear-time process, but downloading data is generally much cheaper and faster than checking its validity. == Transparency: With Trust Toward None, with Integrity for All Transparency means there is no trusted setup (formally, a transparent proof system is one in which all verifier messages are public random strings. Such systems are also known as protocols]) -- there is no use of secrets in the setting up of the system. Transparency offers many benefits. It eliminates the parameter setup generation procedure which constitutes a single point of failure. The lack of a trusted setup allows even powerful entities -- big corporations, monopolies and governments, which control the \"`old world`\" financial system -- to prove CI and gain public acceptance of their claims because there's no known way to forge STARK proofs of falsities, even by the most powerful of entities. On a more tactical level, it makes it much easier to deploy new tools and infrastructure and change existing ones without a need for elaborate parameter-generation ceremonies. Most importantly, transparency aligns well with the \"`new world`\" that demands Inclusive Accountability under no trust assumptions. paraphrase Abraham Lincoln], transparent systems allow to operate with trust toward none, with integrity for all. == Lean Cryptography: Secure & Fast STARK has minimal cryptographic assumptions underlying its security: the existence of secure cryptographic and hash functions] (this minimality of cryptographic assumptions holds for interactive STARKs (iSTARKs). Noninteractive STARKs (nSTARKs) require the Fiat-Shamir heuristic which is a different beast). Many of these primitives exist today as hardware instructions, and the lean cryptography leads to two more benefits: * *Post-Quantum Security*: STARKs are plausibly secure against efficient quantum computers. * *Concrete Efficiency*: For a given computation, the STARK prover is at least 10x faster than both the SNARK and Bulletproofs prover. The STARK verifier is at least 2x faster than the SNARK verifier and more than 10x faster than the Bulletproof verifier. As Starkware continues to optimize STARKs these ratios will likely improve. However, a STARK proof length is ~100x larger than the corresponding SNARK and ~20x larger than BulletProofs. To understand how STARKs are computed, we need to delve into the arithmetic of modular operations, finite fields, and polynomials. For this we will need to touch mathematical concepts that at first glance might seem complicated, however, you will see that it is easier than you thought. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "low_testing.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"low_testing\"] = Low Degree Testing: The Secret Sauce of Succinctness The process of Arithmetization enabled us to reduce the CI problem to a low degree testing problem. Low degree testing refers to the problem of deciding whether a given function is a polynomial of some bounded degree, by making only a small number of queries to the function. Low degree testing has been studied for more than two decades, and is a central tool in the theory of probabilistic proofs. The goal of this blog post is to explain low degree testing in more detail, and to describe FRI, the protocol that we use for low degree testing in STARK. This post assumes familiarity with polynomials over finite fields. Before we discuss low-degree testing, we first present a slightly simpler problem as a warm-up: We are given a function and are asked to decide whether this function is equal to some polynomial of degree less than some constant d, by querying the function at a \"`small`\" number of locations. Formally, given a subset L of a field F and a degree bound d, we wish to determine if $f:L\u279dF$ is equal to a polynomial of degree less than $d$, namely, if there exists a polynomial image::low1.png[low1] over $F$ for which $p(a) = f(a)$ for every $a$ in $L$. For concrete values, you may think of a field of size which is very large, say $2\u00b9\u00b2\u2078$, and $L$ which is of size approximately 10,000,000. Solving this problem requires querying $f$ at the entire domain $L$, as f might agree with a polynomial everywhere in $L$ except for a single location. Even if we allow a constant probability of error, the number of queries will still be linear in the size of $L$. [cols=3*] |=== | For this reason, the problem of low degree testing actually refers to an approximate relaxation of the above problem, which suffices for constructing probabilistic proofs and also can be solved with a number of queries which is logarithmic in $ | L | $ (note that if $L\u224810,000,000$, then $log\u2082(L)\u224823)$. In more detail, we wish to distinguish between the following two cases. |=== * *The function $f$ is equal to a low degree polynomial*. Namely, there exists a polynomial $p(x)$ over $F$, of degree less than $d$, that agrees with $f$ everywhere on $L$. * *The function $f$ is far from ALL low degree polynomials*. For example, we need to modify at least 10% of the values of $f$ before we obtain a function that agrees with a polynomial of degree less than $d$. Note that there is another possibility -- the function $f$ may be mildly close to a low degree polynomial, yet not equal to one. For example, a function in which $5%$ of the values differ from a low-degree polynomial does not fall in either of the two cases described above. However, the prior arithmetization step (discussed in our previous posts) ensures the third case never arises. In more detail, arithmetization shows that an honest prover dealing with a true statement will land in the first case, whereas a (possibly malicious) prover attempting to \"`prove`\" a false claim will land, with high probability, in the second case. In order to distinguish the two cases, we will use a probabilistic polynomial-time test that queries f at a small number of locations (we discuss what \"`small`\" means later). [cols=3*] |=== | This paragraph is optional for understanding the big picture. If $f$ is indeed low degree, then the test should accept with probability 1. If instead f is far from low degree, then the test should reject with high probability. More generally, we seek the guarantee that if f is $\u03b4-far$ from any function of degree less than d (i.e., one must modify at least $\u03b4 | L | $ locations to obtain a polynomial of degree less than d), then the test rejects with probability at least $\u03a9(\u03b4)$ (or some other \"`nice`\" function of $\u03b4$). Intuitively, the closer $\u03b4$ is to zero, the more difficult it is to distinguish between the two cases. |=== In the next few sections we describe a simple test, then explain why it does not suffice in our setting, and finally we describe a more complex test that is exponentially more efficient. This latter test is the one that we use in STARK. == The Direct Test [cols=3*] |=== | The first test we consider is a simple one: it tests whether a function is (close to) a polynomial of degree less than $d$, using $d+1$ queries. The test relies on a basic fact about polynomials: any polynomial of degree less than d is fully determined by its values at any d distinct locations of $F$. This fact is a direct consequence of the fact that a polynomial of degree $k$ can have at most $k$ roots in $F$. Importantly, the number of queries, which is $d+1$, can be significantly less than the size of the domain of $f$, which is $ | L | $. |=== We first discuss two simple special cases, to build intuition for how the test will work in the general case. * *The case of a constant function $(d=1)$.* This corresponds to the problem of distinguishing between the case where $f$ is a constant function ($f(x)=c$ for some $c$ in $F$), and the case where $f$ is far from any constant function. In this special case there is a natural 2-query test that might work: query $f$ at a fixed location $z1$ and also at a random location $w$, and then check that $f(z1)=f(w)$. Intuitively, $f(z1)$ determines the (alleged) constant value of $f$, and $f(w)$ tests whether all of $f$ is close to this constant value or not. * *The case of a linear function $(d=2)$.* This corresponds to the problem of distinguishing between the case where $f$ is a linear function ($f(x)=ax+b$ for some $a$,$b$ in $F$), and the case where $f$ is far from any linear function. In this special case there is a natural 3-query test that might work: query f at two fixed locations z1,z2 and also at a random location $w$, and then check that ($z1$,$f(z1)$), ($z2$,$f(z2)$), ($w$,$f(w)$) are collinear, namely, we can draw a line through these points. Intuitively, the values of $f(z1)$ and $f(z2)$ determine the (alleged) line, and $f(w)$ tests whether all of $f$ is close to this line or not. The above special cases suggest a test for the general case of a degree bound $d$. Query $f$ at $d$ fixed locations $z1$,$z2$,$...$,$zd$ and also at a random location $w$. The values of $f$ at $z0$,$z1$,$...$,$zd$ define a unique polynomial $h(x)$ of degree less than $d$ over $F$ that agrees with $f$ at these points. The test then checks that $h(w)=f(w)$. We call this the direct test. By definition, if $f(x)$ is equal to a polynomial $p(x)$ of degree less than $d$, then $h(x)$ will be identical to $p(x)$ and thus the direct test passes with probability 1. This property is called \"`perfect completeness`\", and it means that this test has only 1-sided error. We are left to argue what happens if $f$ is $\u03b4$-far from any function of degree less than $d$. (For example, think of $\u03b4=10%$.) We now argue that, in this case, the direct test rejects with probability at least \u03b4. Indeed, let \ud835\udfb5 be the probability, over a random choice of w, that $h(w)\u2260f(w)$. Observe that $\ud835\udfb5$ must be at least \u03b4. Optional: This is because if we assume towards contradiction that \ud835\udfb5 is smaller than \u03b4, then we deduce that f is \u03b4-close to h, which contradicts our assumption that f is \u03b4-far from any function of degree less than d. == The Direct Test Does Not Suffice For Us In our setting we are interested in testing functions f:L\u279dF that encode computation traces, and hence whose degree d (and domain L) are quite large. Merely running the direct test, which makes d+1 queries, would be too expensive. In order to gain the exponential savings of STARK (in verification time compared to the size of the computation trace), we need to solve this problem with only O(log d) queries, which is exponentially less than the degree bound d. This, unfortunately, is impossible because if we query f at less than d+1 locations then we cannot conclude anything. Optional: One way to see this is to consider two different distributions of functions f:L\u279dF. In one distribution we uniformly pick a polynomial of degree exactly d and evaluate it on L. In the other distribution we uniformly pick a polynomial of degree less than d and evaluate it on L. In both cases, for any d locations z1,z2,...,zd, the values f(z1),f(z2),...,f(zd) are uniformly and independently distributed. (We leave this fact as an exercise for the reader.) This implies that information-theoretically we cannot tell these two cases apart, even though a test would be required to (since polynomials from the first distribution should be accepted by the test while those of degree exactly d are very far from all polynomials of degree less than d, and thus should be rejected). We seem to have a difficult challenge to overcome. == A Prover Comes to the Rescue We have seen that we need d+1 queries to test that a function f:L\u279dF is close to a polynomial of degree less than d, but we cannot afford this many queries. We avoid this limitation by considering a slightly different setting, which suffices for us. Namely, we consider the problem of low degree testing when a prover is available to supply useful auxiliary information about the function f. We will see that in this \"`prover-aided`\" setting of low-degree testing we can achieve an exponential improvement in the number of queries, to O(log d). In more detail, we consider a protocol conducted between a prover and a verifier, wherein the (untrusted) prover tries to convince the verifier that the function is of low degree. On the one hand, the prover knows the entire function f being tested. On the other hand, the verifier can query the function f at a small number of locations, and is willing to receive help from the prover, but does NOT trust the prover to be honest. This means that the prover may cheat and not follow the protocol. However, if the prover does cheat, the verifier has the liberty to \"`reject`\", regardless of whether the function f is of low degree or not. The important point here is that the verifier will not be convinced that f is of low degree unless this is true. Note that the direct test described above is simply the special case of a protocol in which the prover does nothing, and the verifier tests the function unassisted. To do better than the direct test we will need to leverage the help of the prover in some meaningful way. Throughout the protocol the prover will want to enable the verifier to query auxiliary functions on locations of the verifier's choice. This can be achieved via commitments, a mechanism that we will discuss in a future blog post. For now it suffices to say that the prover can commit to a function of its choice via a Merkle tree, and subsequently the verifier can request the prover to reveal any set of locations of the committed function. The main property of this commitment mechanism is that once the prover commits to a function, it must reveal the correct values and cannot cheat (for example, it cannot decide what the values of the function are after seeing the requests from the verifier). == Halving the number of queries for the case of two polynomials Let's start with a simple example that illustrates how a prover can help to reduce the number of queries by a factor of 2. We will later build on this example. Suppose that we have two polynomials f and g and we want to test that they are both of degree less than d. If we simply run the direct test individually on f and g then we would need to make 2 * (d + 1) queries. Below we describe how with the help of a prover we can reduce the number of queries to (d + 1) plus a smaller-order term. First, the verifier samples a random value \ud835\udefc from the field and sends it to the prover. Next, the prover replies by committing to the evaluation on the domain L (recall that L is the domain of the function f) of the polynomial h(x) = f(x) + \ud835\udefc g(x) (in other words, the prover will compute and send the root of a Merkle tree whose leaves are the values of h on L). The verifier now tests that h has degree less than d, via the direct test, which requires d+1 queries. [cols=5*] |=== | Intuitively, if f or g has degree at least d, then with high probability so does h. For example, consider the case where the coefficient of x\u207f in f is not zero for some n\u2265d. Then, there is at most one choice of \ud835\udefc (sent by the verifier) for which the coefficient of x\u207f in h is zero, which means that the probability that h has degree less than d is roughly 1/ | F | . If the field is large enough (say, | F | >2\u00b9\u00b2\u2078), the probability of error is negligible. |=== The situation, however, is not this simple. The reason is that, as we explained, we cannot literally check that h is a polynomial of degree less than d. Instead we only can check that h is close to such a polynomial. This means that the analysis above is not accurate. Is it possible that f will be far from a low degree polynomial and the linear combination h will be close to one with a non-negligible probability over \ud835\udefc? Under mild conditions the answer is no (which is what we want), but it is outside the scope for this post; we refer the interested reader to paper] and paper]. Moreover, how does the verifier know that the polynomial h sent by the prover has the form f(x)+\ud835\udefc g(x)? A malicious prover may cheat by sending a polynomial which is indeed of low degree, but is different from the linear combination that the verifier asked for. If we already know that h is close to a low degree polynomial, then testing that this low degree polynomial has the correct form is straightforward: the verifier samples a location z in L at random, queries f, g, h at z, and checks that the equation h(z)=f(z)+\ud835\udefc g(z) holds. This test should be repeated multiple times to increase accuracy of the test, but the error shrinks exponentially with the number of samples we make. Hence this step increases the number of queries (which so far was d+1) only by a smaller-order term. == Splitting a polynomial into two smaller-degree polynomials We saw that, with the prover's help, we can test that two polynomials are of degree less than d with less than 2*(d+1) queries. We now describe how we can turn one polynomial of degree less than d into two polynomials of degree less than d/2. Let f(x) be a polynomial of degree less than d and assume that d is even (in our setting this comes without loss of generality). We can write f(x)=g(x\u00b2)+xh(x\u00b2) for two polynomials g(x) and h(x) of degree less than d/2. Indeed, we can let g(x) be the polynomial obtained from the even coefficients of f(x), and h(x) be the polynomial obtained from the odd coefficients of f(x). For example, if d=6 we can write image::smallerPol1.png[smallerPol1] which means that image::smallerPol2.png[smallerPol2] and image::smallerPol3.png[smallerPol3] which is an n*log(n) algorithm for polynomial evaluation (improving over the naive n2 algorithm). [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "number_theory.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"number_theory\"] = Algebraic Number Theory == Euler's Theorem In theory], *Euler\u2019s theorem* (also known as the *Fermat\u2013Euler theorem* or *Euler\u2019s totient theorem*) states that, if _n_ and _a_ are positive integers, and _\u03c6(n)_ is totient function], then _a_ raised to the power _\u03c6(n)_ is congruent to 1 _n_; that is latexmath:[a^{\u03c6(n)} \u2261 1 (mod\u200e n)] == Modular Arithmetic A system of arithmetic for integers where numbers \"wrap around\" when reaching a certain value (aka 'modulus') image:modular.png[modular] A real-world example of modular arithmetic is time-keeping via a clock. When the hour of the day exceed the modulus(12) we \"wrap\" around and begin at zero. Example: [,bash] ---- python3 finite_fields/python/modular_arithmetic.py ---- In other words, of an division we sometimes are more interested in the *remainder*. Here is where we use the operator named as *modulo operator* or simply *mod*. For example, $13\\bmod5 = 3$ because $\\frac\\{13}\\{5}=2$ remainder $3$. Let's go trough a couple examples: * $-29\\bmod3 = 1$ If we divide $-29$ by $3$ we get a quotient of $9$ with a remainder of $-2$; we substract $-2$ from $3$ (our modulus) to get $1$. * $-9\\bmod6 = 3$ Divide $-9$ by $6$ to get $-1$ as quotient with a remainder of $-3$. We then substract $-3$ from $6$ to get $3$ as our result. * $7\\bmod6 = 1$ Divide $7$ by $6$ to get a quotient of $1$ with a remainder of $1$, our result. Note that the mod operator only gives positive numbers. Modular arithmetic is the stepping stone for Fine Field Arithmetic which will take us to understand elliptic curve cryptography, which in turn, gives us the signing and verification algorithms in Ethereum. Signing and verification are key for transactions in a blockchain. == Finite Fields Much of today's practical cryptography is based on finite fields: a finite set of numbers with two operations (addition and multiplication from which we can define subtraction and division too). The order or size of the field is usually called $p$ and is a prime number. This is a finite field of order $p$: $F_p = {0, 1, 2, ..., p--1 }$. A finite field of order 3 would be: $F_3 = {0, 1, 2}$. A finite field cannot contain sub-fields since their order is prime. Therefore, the fine field implements the principles of modular arithmetic over a large, irreducible prime number. Example: [,bash] ---- python3 finite_fields/python/finite_field_arithmetic.py ---- A key property of the finite field is that if `a` and `b` are in the set, `a + b` and `a \u22c5 b` should be in the set too. This is the *closed* property. Thus, if we have $F_3$ then the sum $1 + 2 = 3$ violates the closed property because $3$ is not in the set $F_3$. Something similar happens with the multiplication. We need to make our finite field closed under arithmetic operations as addition, substraction, multiplication and division. Here is where modular arithmetic comes in handy. Most operations with finite fields will be using modular arithmetic. We represent a finite field addition as $+_f$ to distinguish it from a simple addition. We will do the same for the symbols of other arithmetic operators. Now, for our finite field $F_3$, $1$ $+_f$ $2$ $=$ $(1+2) \\bmod 3$ $=$ $0$. Also $2$ $\u22c5_f$ $2$ $=$ $(2\u22c52) \\bmod 3$ $=$ $1$. Now we have close operations for our finite field. What about substraction? It is the same. For a finite field $F_3$, $1$ $-_f$ $2$ $=$ $(1-2) \\bmod 3$ $=$ $2$. We are basically performing modular arithmetic where the the modulo is the finite field's order. For multiplication the case is similar. Addition, Multiplication, Exponentiation, and Substraction of fields are intuitive. However, Division of fields can be a bit challenging at the beginning. Let's begin with easy operations: * For the finite field $F_3$, $2$ $/_f$ $2$ $=$ $(2/2) \\bmod 3$ $=$ $1$. It makes sense since $2/2=1$. * For the finite field $F_3$, $6$ $/_f$ $2$ $=$ $(0/2) \\bmod 3$ $=$ $0$. It makes sense since $0/2=0$. * For the finite field $F_3$, the operation $1$ $/_f$ $0$ $=$ $(1/0) \\bmod 3$ can not be performed since we can not divide by 0. * For the finite field $F_3$, $8$ $/_f$ $5$ $=$ $(2/2) \\bmod 3$ $=$ $1$. It makes sense since $2/2=1$. Until now eveything seems ok. However, what happens when, for the finite field $F_5$, we divide $8$ $/_f$ $4$ $=$ $(3/4) \\bmod 5$? The result is not trivial. == Congruences [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "part1_trace_and_low_degree_extension.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "_ License, Version 2.0 (the \"License\"). You may not use this file except in compliance with the License. You may obtain a copy of the License at Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License._ == Part 1: Trace and Low-Degree Extension * Lecture (youtube)] * (PDF)] Today we will develop a STARK prover for the FibonacciSq sequence over a finite field. The FibonacciSq sequence is defined by the recurrence relation latexmath:[a_{n+2} = a_{n+1} ^2 + a_n ^2]. By the end of the day, your code will produce a _STARK_ proof attesting to the following statement: *I know a field element latexmath:[X\\in \\mathbb{F}] such that the 1023rd element of the FibonacciSq sequence starting with latexmath:[1, X] is latexmath:[2338775057]*. === The Basics ==== FieldElement class We use our `+FieldElement+` class to represent field elements. You can construct instances of `+FieldElement+` from integers, and then add, multiply, divide, get inverse, and so on. The underlying field of this class is latexmath:[\\mathbb{F}_{3221225473}] (latexmath:[3221225473 = 3 \\cdot 2^{30} + 1]), so all operations are done modulo 3221225473. Try it by running the following cell (shift + enter): [source,python] ---- from field import FieldElement FieldElement(3221225472) + FieldElement(10) ---- == FibonacciSq Trace To start, let's construct a list `+a+` of length 1023, whose first two elements will be FieldElement objects representing 1 and 3141592, respectively. The next 1021 elements will be the FibonacciSq sequence induced by these two elements. `+a+` is called the trace of FibonacciSq, or, when the context is clear, the trace. We can calculate `+a+` as follows: [source,python] ---- a = [FieldElement(1), FieldElement(3141592)] while len(a) 1024') ---- == Polynomial class We provide you with a class called `+Polynomial+`. The simplest way to construct a `+Polynomial+` is by using the variable `+X+` (note that it's a capital `+X+`) which represents the formal variable latexmath:[x]: [source,python] ---- from polynomial import X # The polynomial 2x^2 + 1. p = 2*X**2 + 1 # Evaluate p at 2: print(p(2)) ---- == Interpolating a Polynomial Our `+polynomial+` module provides a Lagrange interpolation function, whose arguments are: * x_values: x-values of G that the polynomial's values for them is known. [List] * y_values: the corresponding y-values. [List] It returns the unique `+Polynomial+` of degree < `+len(x_values)+` instance that evaluates to `+y_values[i]+` on `+x_values[i]+` for all i. Run the following cell to get help on the function `+interpolate_poly+`. [source,python] ---- from polynomial import interpolate_poly interpolate_poly? ---- Suppose that `+a+` contains the values of some polynomial over `+G+` (except for `+G[-1]+`, since `+a+` is one element shorter). Use `+interpolate_poly()+` to get `+f+` and get its value at `+FieldElement(2)+`. Solution: [source,python] ---- f = interpolate_poly(G[:-1], a) v = f(2) ---- Run test: [source,python] ---- assert v == FieldElement(1302089273) print('Success!') ---- == Evaluating on a Larger Domain The trace, viewed as evaluations of a polynomial latexmath:[f] on latexmath:[G], can now be extended by evaluating latexmath:[f] over a larger domain, thereby creating a Reed-Solomon error correction code. === Cosets To that end, we must decide on a larger domain on which latexmath:[f] will be evaluated. We will work with a domain that is 8 times larger than latexmath:[G]. A natural choice for such a domain is to take some group latexmath:[H] of size 8192 (which exists because 8192 divides latexmath:[|\\mathbb{F}^\\times|]), and shift it by the generator of latexmath:[\\mathbb{F}^\\times], thereby obtaining a of latexmath:[H]. Create a list called `+H+` of the elements of latexmath:[H], and multiply each of them by the generator of latexmath:[\\mathbb{F}^\\times] to obtain a list called `+eval_domain+`. In other words, eval_domain = latexmath:[\\{w\\cdot h^i | 0 \\leq i <8192 \\}] for latexmath:[h] the generator of latexmath:[H] and latexmath:[w] the generator of latexmath:[\\mathbb{F}^\\times]. Hint: You already know how to obtain latexmath:[H] - similarly to the way we got latexmath:[G] a few minutes ago. Solution: [source,python] ---- w = FieldElement.generator() h = w ** ((2 ** 30 * 3) // 8192) H = [h ** i for i in range(8192)] eval_domain = [w * x for x in H] ---- Run test: [source,python] ---- from hashlib import sha256 assert len(set(eval_domain)) == len(eval_domain) w = FieldElement.generator() w_inv = w.inverse() assert '55fe9505f35b6d77660537f6541d441ec1bd919d03901210384c6aa1da2682ce' == sha256(str(H[1]).encode()).hexdigest(),\\ 'H list is incorrect. H[1] should be h (i.e., the generator of H).' for i in range(8192): assert ((w_inv * eval_domain[1]) ** i) * w == eval_domain[i] print('Success!') ---- == Evaluate on a Coset Time to use `+interpolate_poly+` and `+Polynomial.poly+` to evaluate over the coset. Note that it is implemented fairely naively in our Python module, so interpolation may take up to a minute. Indeed - interpolating and evaluating the trace polynomial is one of the most computationally-intensive steps in the STARK protocol, even when using more efficient methods (e.g. FFT). Solution: [source,python] ---- f = interpolate_poly(G[:-1], a) f_eval = [f(d) for d in eval_domain] ---- Run test: [source,python] ---- # Test against a precomputed hash. from hashlib import sha256 from channel import serialize assert '1d357f674c27194715d1440f6a166e30855550cb8cb8efeb72827f6a1bf9b5bb' == sha256(serialize(f_eval).encode()).hexdigest() print('Success!') ---- == Commitments We will use Trees] as our commitment scheme. A simple implementation of it is available to you in the `+MerkleTree+` class. Run the next cell (for the sake of this tutorial, this also serves as a test for correctness of the entire computation so far): [source,python] ---- from merkle import MerkleTree f_merkle = MerkleTree(f_eval) assert f_merkle.root == '6c266a104eeaceae93c14ad799ce595ec8c2764359d7ad1b4b7c57a4da52be04' print('Success!') ---- == Channel Theoretically, a STARK proof system is a protocol for interaction between two parties - a prover and a verifier. In practice, we convert this interactive protocol into a non-interactive proof using the Heuristic]. In this tutorial you will use the `+Channel+` class, which implements this transformation. This channel replaces the verifier in the sense that the prover (which you are writing) will send data, and receive random numbers or random `+FieldElement+` instances. This simple piece of code instantiates a channel object, sends the root of your Merkle Tree to it. Later, the channel object can be called to provide random numbers or random field elements. [source,python] ---- from channel import Channel channel = Channel() channel.send(f_merkle.root) ---- Lastly - you can retrieve the proof-so-far (i.e., everything that was passed in the channel up until a certain point) by printing the member `+Channel.proof+`. [source,python] ---- print(channel.proof) ----"}
{"title": "part1_trace_and_low_degree_extension_rs.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "_ License, Version 2.0 (the \"License\"). You may not use this file except in compliance with the License. You may obtain a copy of the License at Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License._ == Part 1: Trace and Low-Degree Extension * Lecture (youtube)] * (PDF)] Today we will develop a STARK prover for the FibonacciSq sequence over a finite field. The FibonacciSq sequence is defined by the recurrence relation latexmath:[a_{n+2} = a_{n+1} ^2 + a_n ^2]. By the end of the day, your code will produce a _STARK_ proof attesting to the following statement: *I know a field element latexmath:[X\\in \\mathbb{F}] such that the 1023rd element of the FibonacciSq sequence starting with latexmath:[1, X] is latexmath:[2338775057]*. === The Basics ==== FieldElement class We use our `+FieldElement+` struct to represent field elements. You can construct values of type `+FieldElement+` from integers, and then add, multiply, divide, get inverse, and so on. The underlying field of this class is latexmath:[\\mathbb{F}_{3221225473}] (latexmath:[3221225473 = 3 \\cdot 2^{30} + 1]), so all operations are done modulo 3221225473. Try it by running the following cell (shift + enter): [source,rust] ---- :dep stark101-rs = { path = \"stark101\" } :dep sha256 = \"1.1.2\" ---- [source,rust] ---- use stark101_rs::*; println!(\"The result is: {:?}\", FieldElement::new(3221225472) + FieldElement::new(10)); ---- .... The result is: FieldElement(9) .... == FibonacciSq Trace To start, let's construct a vector `+a+` of length 1023, whose first two elements will be FieldElement objects representing 1 and 3141592, respectively. The next 1021 elements will be the FibonacciSq sequence induced by these two elements. `+a+` is called the trace of FibonacciSq, or, when the context is clear, the trace. Correct the code below to fill `+a+`: [source,rust] ---- let mut a = vec![FieldElement::new(1), FieldElement::new(3141592)]; todo!(\"Put your code here\"); ---- .... thread '' panicked at 'not yet implemented: Put your code here', src/lib.rs:160:1 stack backtrace: 0: _rust_begin_unwind 1: core::panic_fmt 2: 3: 4: evcxr::Runtime::run_loop 5: evcxr::runtime_hook 6: evcxr_jupyter::main note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace. .... Solution (click to the ... to unhide): [source,rust] ---- let mut a = vec![FieldElement::new(1), FieldElement::new(3141592)]; let mut n = 2usize; while a.len() = vec![]; ---- Solution: [source,rust] ---- let g = FieldElement::generator().pow(3 * 2usize.pow(20)); let G: Vec = (0..1024).into_iter().map(|i| g.pow(i)).collect(); ---- Run the next cell to test your code. [source,rust] ---- // Checks that g and G are correct. assert!(g.is_order(1024), \"The generator g is of wrong order.\"); let mut b = FieldElement::one(); for i in 0..1023 { assert_eq!(b, G[i], \"The i-th place in G is not equal to the i-th power of g.\"); b = b * g; let wrong_order = i + 1; assert!(b != FieldElement::one(), \"g is of order {wrong_order}\"); } if b * g == FieldElement::one() { println!(\"Success!\"); } else { println!(\"g is of order > 1024\"); } ---- .... Success! .... .... () .... == Polynomial class We provide you with a struct called `+Polynomial+`. The simplest way to construct a `+Polynomial+` is by using the function *x()* which represents the formal variable latexmath:[x]: [source,rust] ---- use stark101_rs::*; // The polynomial 2x^2 + 1. let p: Polynomial = 2*x().pow(2) + 1; // Evaluate p at 2: println!(\"{:?}\", p(2)); ---- .... FieldElement(9) .... == Interpolating a Polynomial Our `+Polynomial+` datatype provides a Lagrange interpolation method, whose arguments are: * x_values: x-values of G that the polynomial's values for them is known. &[FieldElement] * y_values: the corresponding y-values. &[FieldElement] It returns the unique `+Polynomial+` of degree ' panicked at 'not yet implemented: Put your code here.', src/lib.rs:162:1 stack backtrace: 0: _rust_begin_unwind 1: core::panic_fmt 2: 3: 4: evcxr::Runtime::run_loop 5: evcxr::runtime_hook 6: evcxr_jupyter::main note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace. .... Solution: [source,rust] ---- let xs: Vec = G.into_iter().rev().skip(1).rev().collect(); let f: Polynomial = Polynomial::interpolate(&xs, &a); let v = f(2); ---- Run test: [source,rust] ---- assert_eq!(v, FieldElement::new(1302089273)); println!(\"Success!\"); ---- .... Success! .... == Evaluating on a Larger Domain The trace, viewed as evaluations of a polynomial latexmath:[f] on latexmath:[G], can now be extended by evaluating latexmath:[f] over a larger domain, thereby creating a *Reed-Solomon error correction code*. === Cosets To that end, we must decide on a larger domain on which latexmath:[f] will be evaluated. We will work with a domain that is 8 times larger than latexmath:[G]. A natural choice for such a domain is to take some group latexmath:[H] of size 8192 (which exists because 8192 divides latexmath:[|\\mathbb{F}^\\times|]), and shift it by the generator of latexmath:[\\mathbb{F}^\\times], thereby obtaining a of latexmath:[H]. Create a vec called `+H+` of the elements of latexmath:[H], and multiply each of them by the generator of latexmath:[\\mathbb{F}^\\times] to obtain a vec called `+eval_domain+`. In other words, eval_domain = latexmath:[\\{w\\cdot h^i | 0 \\leq i = todo!(); let eval_domain: Vec = todo!(); ---- .... thread '' panicked at 'not yet implemented', src/lib.rs:160:23 stack backtrace: 0: _rust_begin_unwind 1: core::panic_fmt 2: core::panic 3: 4: 5: evcxr::Runtime::run_loop 6: evcxr::runtime_hook 7: evcxr_jupyter::main note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace. .... Solution: [source,rust] ---- let w = FieldElement::generator(); let exp = (2usize.pow(30) * 3) / 8192; let h = w.pow(exp); let H: Vec = (0..8192).into_iter().map(|i| h.pow(i)).collect(); let eval_domain: Vec = H.into_iter().map(|x| w * x).collect(); ---- Run test: [source,rust] ---- let field_generator = FieldElement::generator(); let w_inverse = w.inverse(); for i in 0..8192 { assert_eq!((w_inverse * eval_domain[1]).pow(i) * field_generator, eval_domain[i]); } println!(\"Success!\"); ---- .... Success! .... == Evaluate on a Coset Time to use `+interpolate+` and `+eval+` to evaluate over the coset. Note that it is implemented fairely naively in our Rust module, so interpolation may take some seconds. Indeed - interpolating and evaluating the trace polynomial is one of the most computationally-intensive steps in the STARK protocol, even when using more efficient methods (e.g. FFT). [source,rust] ---- // Fill f_eval with the evaluations of f on eval_domain. let f_eval: FieldElement = todo!(); ---- .... thread '' panicked at 'not yet implemented', src/lib.rs:162:28 stack backtrace: 0: _rust_begin_unwind 1: core::panic_fmt 2: core::panic 3: 4: 5: evcxr::Runtime::run_loop 6: evcxr::runtime_hook 7: evcxr_jupyter::main note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace. .... Solution: [source,rust] ---- let G_values: Vec = (0..1024).into_iter().map(|i| g.pow(i)).collect();; let x_values: Vec = G_values.into_iter().rev().skip(1).rev().collect(); let interpolated_f: Polynomial = Polynomial::interpolate(&x_values, &a); let interpolated_f_eval: Vec = eval_domain.into_iter().map(|d| interpolated_f.clone().eval(d)).collect(); ---- Run test: [source,rust] ---- // Test against a precomputed hash. use sha256::digest; let hashed = digest(format!(\"{:?}\", interpolated_f_eval)); assert_eq!(\"d78b6a5f70e91dd8fa448f628528434dbfaf3caefab0a26519e1f2d8ac992f23\".to_string(), hashed); println!(\"Success!\"); ---- .... Success! .... == Commitments We will use Trees] as our commitment scheme. A simple implementation of it is available to you in the `+MerkleTree+` class. Run the next cell (for the sake of this tutorial, this also serves as a test for correctness of the entire computation so far): [source,rust] ---- //from merkle import MerkleTree //f_merkle = MerkleTree(f_eval) //assert f_merkle.root == '6c266a104eeaceae93c14ad799ce595ec8c2764359d7ad1b4b7c57a4da52be04' //print('Success!') ---- == Channel Theoretically, a STARK proof system is a protocol for interaction between two parties - a prover and a verifier. In practice, we convert this interactive protocol into a non-interactive proof using the Heuristic]. In this tutorial you will use the `+Channel+` class, which implements this transformation. This channel replaces the verifier in the sense that the prover (which you are writing) will send data, and receive random numbers or random `+FieldElement+` instances. This simple piece of code instantiates a channel object, sends the root of your Merkle Tree to it. Later, the channel object can be called to provide random numbers or random field elements. [source,rust] ---- ///from channel import Channel //channel = Channel() //channel.send(f_merkle.root) ---- Lastly - you can retrieve the proof-so-far (i.e., everything that was passed in the channel up until a certain point) by printing the member `+Channel.proof+`. [source,rust] ---- //print(channel.proof) ----"}
{"title": "part2_constraints.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "_ License, Version 2.0 (the \"License\"). You may not use this file except in compliance with the License. You may obtain a copy of the License at Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License._ == Part 2: Constraints * Lecture (youtube)] * (PDF)] In this part, we are going to create a set of constraints over the trace `a`. The constraints will be expressions in the trace's cells that are polynomials (rather than functions]) if and only if the trace represents a valid computation of the FibonacciSq. We will get there in three steps: . Start by specifying the constraints we care about (the *FibonacciSq constraints*). . Translate the FibonacciSq constraints into *polynomial constraints*. . Translate those into *rational functions* that represent polynomials if and only if the original constraints hold. == Step 1 - FibonacciSq Constraints For `a` to be a correct trace of a FibonacciSq sequence that proves our claim: . The first element has to be 1, namely latexmath:[a[0] = 1]. . The last element has to be 2338775057, namely latexmath:[a[1022] = 2338775057]. . The FibonacciSq rule must apply, that is - for every latexmath:[i<1021], latexmath:[a][i+2]=a[i+1]\u00b2+a[i]\u00b2. == Step 2 - Polynomial Constraints Recall that `f` is a polynomial over the trace domain, that evaluates exactly to `a` over latexmath:[$G \\setminus \\{g^{1023}\\}$] where latexmath:[$G=\\{g^i : 0\\leq i\\leq 1023\\}$] is the \"small\" group generated by latexmath:[$g$]. We now rewrite the above three constraints in a form of polynomial constraints over `f`: . latexmath:[$a[0] = 1$] is translated to the polynomial latexmath:[$f(x) - 1$], which evalutes to 0 for latexmath:[$x = g^0$] (note that latexmath:[$g^0$] is latexmath:[$1$]). . latexmath:[$a[1022] = 2338775057$] is translated to the polynomial latexmath:[$f(x) - 2338775057$], which evalutes to 0 for latexmath:[$x = g^{1022}$]. . latexmath:[$a[i+2]=a[i+1]^2+a[i]^2$] for every latexmath:[$i<1021$] is translated to the polynomial latexmath:[$f(g^2 \\cdot x) - (f(g \\cdot x))^2 - (f(x))^2$], which evaluates to 0 for latexmath:[$x \\in G \\backslash \\{g^{1021}, g^{1022}, g^{1023}\\}$]. == Hands on First, since this is a separate notebook from Part 1, let's run the following piece of code to have all the variables here with their correct values. Note that it may take up to 30 seconds, since it reruns the polynomial interpolation. [source,python] ---- from channel import Channel from field import FieldElement from merkle import MerkleTree from polynomial import interpolate_poly, X, prod from tutorial_sessions import part1 a, g, G, h, H, eval_domain, f, f_eval, f_merkle, channel = part1() print('Success!') ---- You will obtain each of the three constraints as a quotient of two polynomials, making sure the remainder is the zero polynomial. == Step 3 - Rational Functions (That are in Fact Polynomials) Each of the constraints above is represented by a polynomial latexmath:[$u(x)$] that supposedly evaluates to latexmath:[$0$] on certain elements of the group latexmath:[$G$]. That is, for some latexmath:[$x_0, \\ldots, x_k \\in G$], we claim that [latexmath] ++++ \\[u(x_0) = \\ldots = u(x_k) = 0\\] ++++ (note that for the first two constraints, latexmath:[$k=0$] because they only refer to one point and for the third latexmath:[$k=1021$]). This is equivalent to saying that latexmath:[$u(x)$] is divisible, as a polynomial, by all of latexmath:[$\\{(x-x_i)\\}_{i=0}^k$], or, equivalently, by [latexmath] ++++ \\[\\prod_{i=0}^k (x-x_i)\\] ++++ Therefore, each of the three constraints above can be written as a rational function of the form: [latexmath] ++++ \\[\\frac{u(x)}{\\prod_{i=0}^k (x-x_i)}\\] ++++ for the corresponding latexmath:[$u(x)$] and latexmath:[$\\{x_i\\}_{i=0}^k$]. In this step we will construct these three rational functions and show that they are indeed polynomials. == The First Constraint: In the first constraint, latexmath:[$f(x) - 1$] and latexmath:[$\\{x_i\\} = \\{1\\}$]. We will now construct the *polynomial* latexmath:[$p_0(x)=\\frac{f(x) - 1}{x - 1}$], making sure that latexmath:[$f(x) - 1$] is indeed divisible by latexmath:[$(x-1)$]. Solution: [source,python] ---- numer0 = f - 1 denom0 = X - 1 ---- Convince yourself that latexmath:[$f(x) - 1$] vanishes at latexmath:[$x=1$] by making sure that evaluating this polynomial at latexmath:[$1$] yields latexmath:[$0$]. The fact that latexmath:[$f(x) - 1$] has a root at latexmath:[$1$] implies that it is divisible by latexmath:[$(x - 1)$]. Run the following cell to convince yourself that the remainder of `numer0` modulo `denom0` is latexmath:[$0$], and therefore division indeed yields a polynomial: [source,python] ---- numer0 % denom0 ---- Run the following cell to construct `p0`, the polynomial representing the first constraint, by dividing `numer0` by `denom0`: [source,python] ---- p0 = numer0 / denom0 ---- Run test: [source,python] ---- assert p0(2718) == 2509888982 print('Success!') ---- == The Second Constraint Construct the polynomial `p1` representing the second constraint, latexmath:[$p_1(x)= \\frac{f(x) - 2338775057}{x - g^{1022}}$], similarly. Solution: [source,python] ---- numer1 = f - 2338775057 denom1 = X - g**1022 p1 = numer1 / denom1 ---- Run test: [source,python] ---- assert p1(5772) == 232961446 print('Success!') ---- == The Third Constraint - Succinctness The last constraint's rational function is slightly more complicated: [latexmath] ++++ \\[p_2(x) = \\frac{f(g^2 \\cdot x) - (f(g \\cdot x))^2 - (f(x))^2}{\\prod\\limits_{i=0}^{1020} (x-g^i)}\\] ++++ whose denominator can be rewritten, so that the entire expression is easier to compute: [latexmath] ++++ \\[\\frac{f(g^2 \\cdot x) - (f(g \\cdot x))^2 - (f(x))^2}{\\frac{x^{1024} - 1}{(x-g^{1021})(x-g^{1022})(x-g^{1023})}}\\] ++++ This follows from the equality [latexmath] ++++ \\[\\prod\\limits_{i=0}^{1023} (x-g^i) = x^{1024} - 1\\] ++++ Convince yourself of this equality using the function `prod` that takes a list and computes its product. Solution: [source,python] ---- lst = [(X - g**i) for i in range(1024)] prod(lst) ---- For more information, see our blog post titled II]. Let's pause for a moment, and look at a simple example on how polynomials are composed. After that we will generate the third constraint. == Composing Polynomials (a detour) Create the two polynomials latexmath:[$q(x) = 2x^2 +1$], latexmath:[$r(x) = x - 3$]: [source,python] ---- q = 2*X ** 2 + 1 r = X - 3 ---- Composing latexmath:[$q$] on latexmath:[$r$] yields a new polynomial: latexmath:[$q(r(x)) = 2(x-3)^2 + 1 = 2x^2-12x+19$] Run the following cell to create a third polynomial `cmp` by composing `q` on `r` and convince yourself that `cmp` is indeed the composition of `q` and `r`: [source,python] ---- cmp = q(r) cmp ---- == Back to Polynomial Constraints Construct the third constraint `p2` in a similar manner to the construction of `p0` and `p1`, using polynomial composition. Along the way, verify that latexmath:[$g^{1020}$] is a root of the *numerator* while latexmath:[$g^{1021}$] is not. Solution: [source,python] ---- numer2 = f(g**2 * X) - f(g * X)**2 - f**2 print(\"Numerator at g^1020 is\", numer2(g**1020)) print(\"Numerator at g^1021 is\", numer2(g**1021)) denom2 = (X**1024 - 1) / ((X - g**1021) * (X - g**1022) * (X - g**1023)) p2 = numer2 / denom2 ---- Run test: [source,python] ---- assert p2.degree() == 1023, f'The degree of the third constraint is {p2.degree()} when it should be 1023.' assert p2(31415) == 2090051528 print('Success!') ---- Run the following cell to observe the degrees of the constraint polynomials `p0`, `p1` and `p2`, all less than latexmath:[$1024$]. This will be important in the next part. [source,python] ---- print('deg p0 =', p0.degree()) print('deg p1 =', p1.degree()) print('deg p2 =', p2.degree()) ---- == Step 4 - Composition Polynomial Recall that we're translating a problem of checking the validity of three polynomial constraints to checking that each of the rational functions latexmath:[$p_0, p_1, p_2$] are polynomials. Our protocol uses an algorithm called to do so, which will be discussed in the next part. In order for the proof to be succinct (short), we prefer to work with just one rational function instead of three. For that, we take a random linear combination of latexmath:[$p_0, p_1, p_2$] called the *composition polynomial* (CP for short): [latexmath] ++++ \\[CP(x) = \\alpha_0 \\cdot p_0(x) + \\alpha_1 \\cdot p_1(x) + \\alpha_2 \\cdot p_2(x)\\] ++++ where latexmath:[$\\alpha_0, \\alpha_1, \\alpha_2$] are random field elements obtained from the verifier, or in our case - from the channel. Proving that (the rational function) latexmath:[$CP$] is a polynomial guarantess, with high probability, that each of latexmath:[$p_0$], latexmath:[$p_1$], latexmath:[$p_2$] are themselves polynomials. In the next part, you will generate a proof for an equivalent fact. But first, let's create `CP` using `Channel.receive_random_field_element` to obtain latexmath:[$\\alpha_i$]. Solution: [source,python] ---- def get_CP(channel): alpha0 = channel.receive_random_field_element() alpha1 = channel.receive_random_field_element() alpha2 = channel.receive_random_field_element() return alpha0*p0 + alpha1*p1 + alpha2*p2 ---- Run test: [source,python] ---- test_channel = Channel() CP_test = get_CP(test_channel) assert CP_test.degree() == 1023, f'The degree of cp is {CP_test.degree()} when it should be 1023.' assert CP_test(2439804) == 838767343, f'cp(2439804) = {CP_test(2439804)}, when it should be 838767343' print('Success!') ---- == Commit on the Composition Polynomial Lastly, we evaluate latexmath:[$cp$] over the evaluation domain (`eval_domain`), build a Merkle tree on top of that and send its root over the channel. This is similar to commiting on the LDE trace, as we did at the end of part 1. Solution: [source,python] ---- def CP_eval(channel): CP = get_CP(channel) return [CP(d) for d in eval_domain] ---- Construct a Merkle Tree over the evaluation and send its root over the channel. Solution: [source,python] ---- channel = Channel() CP_merkle = MerkleTree(CP_eval(channel)) channel.send(CP_merkle.root) ---- Test your code: [source,python] ---- assert CP_merkle.root == 'a8c87ef9764af3fa005a1a2cf3ec8db50e754ccb655be7597ead15ed4a9110f1', 'Merkle tree root is wrong.' print('Success!') ----"}
{"title": "part2_constraints_rs.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "_ License, Version 2.0 (the \"License\"). You may not use this file except in compliance with the License. You may obtain a copy of the License at Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License._ == Part 2: Constraints * Lecture (youtube)] * (PDF)] In this part, we are going to create a set of constraints over the trace `a`. The constraints will be expressions in the trace's cells that are polynomials (rather than functions]) if and only if the trace represents a valid computation of the FibonacciSq. We will get there in three steps: . Start by specifying the constraints we care about (the *FibonacciSq constraints*). . Translate the FibonacciSq constraints into *polynomial constraints*. . Translate those into *rational functions* that represent polynomials if and only if the original constraints hold. == Step 1 - FibonacciSq Constraints For `a` to be a correct trace of a FibonacciSq sequence that proves our claim: . The first element has to be 1, namely latexmath:[a[0] = 1]. . The last element has to be 2338775057, namely latexmath:[a[1022] = 2338775057]. . The FibonacciSq rule must apply, that is - for every latexmath:[i = todo!(); // Compute the product of `lst` and see that it is indeed the succinct polynomial x**1024 - 1 Polynomial::prod(&lst); ---- .... thread '' panicked at 'not yet implemented', src/lib.rs:134:28 stack backtrace: 0: _rust_begin_unwind 1: core::panic_fmt 2: core::panic 3: as core::FnOnce>::call_once 4: _run_user_code_14 5: evcxr::Runtime::run_loop 6: evcxr::runtime_hook 7: evcxr_jupyter::main note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace. .... Solution: [source,rust] ---- let lst: Vec = (0..1024).into_iter().map(|i| x() - g.pow(i)).collect(); Polynomial::prod(&lst) ---- .... Polynomial([FieldElement(3221225472), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(1)]) .... For more information, see our blog post titled II]. Let's pause for a moment, and look at a simple example on how polynomials are composed. After that we will generate the third constraint. == Composing Polynomials (a detour) Create the two polynomials latexmath:[$q(x) = 2x^2 +1$], latexmath:[$r(x) = x - 3$]: [source,rust] ---- let q: Polynomial = x().pow(2)*2usize + 1; let r = x() - 3usize; ---- Composing latexmath:[$q$] on latexmath:[$r$] yields a new polynomial: latexmath:[$q(r(x)) = 2(x-3)^2 + 1 = 2x^2-12x+19$] Run the following cell to create a third polynomial `cmp` by composing `q` on `r` and convince yourself that `cmp` is indeed the composition of `q` and `r`: [source,rust] ---- let cmp = q(r); cmp ---- .... Polynomial([FieldElement(19), FieldElement(3221225461), FieldElement(2)]) .... == Back to Polynomial Constraints Construct the third constraint `p2` in a similar manner to the construction of `p0` and `p1`, using polynomial composition. Along the way, verify that latexmath:[$g^{1020}$] is a root of the *numerator* while latexmath:[$g^{1021}$] is not. [source,rust] ---- let p2: Polynomial = todo!(); ---- Solution: [source,rust] ---- let numer_1: Polynomial = f(x() * g.pow(2)); let numer_2: Polynomial = f(x() * g).pow(2) * FieldElement::new((-1 + FieldElement::k_modulus() as i128) as usize); let numer_3: Polynomial = f.pow(2) * FieldElement::new((-1 + FieldElement::k_modulus() as i128) as usize); let numer2: Polynomial = numer_1 + numer_2 + numer_3; println!(\"Numerator at g^1020 is {:?}\", numer2.clone()(g.pow(1020))); println!(\"Numerator at g^1021 is {:?}\", numer2(g.pow(1021usize))); let denom2 = (x().pow(1024usize) - 1) / ((x() - g.pow(1021)) * (x() - g.pow(1022)) * (x() - g.pow(1023))); let p2: Polynomial = numer2 / denom2; ---- .... Numerator at g^1020 is FieldElement(0) Numerator at g^1021 is FieldElement(230576507) .... Run test: [source,rust] ---- let p2_degree = p2.degree(); assert_eq!(p2.degree(), 1023, \"The degree of the third constraint is {p2_degree} when it should be 1023.\"); assert_eq!(p2(31415), 2090051528); println!(\"Success!\"); ---- .... Success! .... Run the following cell to observe the degrees of the constraint polynomials `p0`, `p1` and `p2`, all less than latexmath:[$1024$]. This will be important in the next part. [source,rust] ---- println!(\"deg p0 = {}\", p0.degree()); println!(\"deg p1 = {}\", p1.degree()); println!(\"deg p2 = {}\", p2.degree()); ---- .... deg p0 = 1021 deg p1 = 1021 deg p2 = 1023 .... == Step 4 - Composition Polynomial Recall that we're translating a problem of checking the validity of three polynomial constraints to checking that each of the rational functions latexmath:[$p_0, p_1, p_2$] are polynomials. Our protocol uses an algorithm called to do so, which will be discussed in the next part. In order for the proof to be succinct (short), we prefer to work with just one rational function instead of three. For that, we take a random linear combination of latexmath:[$p_0, p_1, p_2$] called the *compostion polynomial* (CP for short): [latexmath] ++++ \\[CP(x) = \\alpha_0 \\cdot p_0(x) + \\alpha_1 \\cdot p_1(x) + \\alpha_2 \\cdot p_2(x)\\] ++++ where latexmath:[$\\alpha_0, \\alpha_1, \\alpha_2$] are random field elements obtained from the verifier, or in our case - from the channel. Proving that (the rational function) latexmath:[$CP$] is a polynomial guarantess, with high probability, that each of latexmath:[$p_0$], latexmath:[$p_1$], latexmath:[$p_2$] are themselves polynomials. In the next part, you will generate a proof for an equivalent fact. But first, let's create `CP` using `Channel.receive_random_field_element` to obtain latexmath:[$\\alpha_i$]: [source,rust] ---- // Note that alpha0, alpha1, alpha2 have to be drawn from the channel in this order. fn get_CP(p1: Polynomial, p2: Polynomial, p3: Polynomial, channel: Channel) -> Polynomial { todo!(); } ---- Solution: [source,rust] ---- fn get_CP(p0: Polynomial, p1: Polynomial, p2: Polynomial, channel: &mut Channel) -> Polynomial { let alpha0 = channel.receive_random_field_element(); let alpha1 = channel.receive_random_field_element(); let alpha2 = channel.receive_random_field_element(); (p0 * alpha0) + (p1 * alpha1) + (p2 * alpha2) } ---- Run test: [source,rust] ---- let mut test_channel: Channel = Channel::new(); let cp_test = get_CP(p0, p1, p2, &mut test_channel); let cp_test_degree = cp_test.degree(); assert_eq!(cp_test.degree(), 1023, \"The degree of cp is {cp_test_degree} when it should be 1023.\"); let expected = cp_test(2439804); assert_eq!(cp_test(2439804), 838767343, \"cp(2439804) = {expected:?}, when it should be 838767343\"); println!(\"Success!\"); ---- .... Success! .... == Commit on the Composition Polynomial Lastly, we evaluate latexmath:[$cp$] over the evaluation domain (`eval_domain`), build a Merkle tree on top of that and send its root over the channel. This is similar to commiting on the LDE trace, as we did at the end of part 1. [source,rust] ---- // Fix this. CP_eval is the evaluation of CP on all the points in domain. For a hint - look at \"Evaluate on a Coset\" on part 1. fn cp_eval(p0: Polynomial, p1: Polynomial, p2: Polynomial, domain: Vec, channel: &mut Channel) { let cp = get_CP(p0, p1, p2, channel); todo!(); } ---- Solution: [source,rust] ---- fn cp_eval(p0: Polynomial, p1: Polynomial, p2: Polynomial, domain: Vec, channel: &mut Channel) -> Vec { let cp = get_CP(p0, p1, p2, channel); domain.into_iter().map(|d| cp(d)).collect() } ---- Construct a Merkle Tree over the evaluation and send its root over the channel. [source,rust] ---- let channel = Channel::new(); let cp_merkle = MerkleTree::new(todo!()); // Fix this line channel.send(cp_merkle.root); ---- Solution: [source,rust] ---- use stark101_rs::MerkleTree; let mut channel = Channel::new(); let cp_merkle: MerkleTree = MerkleTree::new(cp_eval(p0, p1, p2, eval_domain, &mut channel)); channel.send(cp_merkle.root()); ---- Test your code: [source,rust] ---- assert_eq!(cp_merkle.root(), \"26db4de93f69af9591eac0bf224a26f5ffd99d07a325b82ee34381069a205a53\", \"Merkle tree root is wrong.\"); println!(\"Success!\"); ---- .... Success! ...."}
{"title": "part3_fri_commitments.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "_ License, Version 2.0 (the \"License\"). You may not use this file except in compliance with the License. You may obtain a copy of the License at Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License._ == Part 3: FRI Commitments * Lecture (youtube)] * (PDF)] == Load Previous Session Run the next cell to load the relevant variables. As usual - it will take a while to run. [source,python] ---- from channel import Channel from field import FieldElement from merkle import MerkleTree from polynomial import interpolate_poly, Polynomial from tutorial_sessions import part1, part2 cp, cp_eval, cp_merkle, channel, eval_domain = part2() print(\"Success\") ---- == FRI Folding Our goal in this part is to construct the FRI layers and commit on them. To obtain each layer we need: . To generate a domain for the layer (from the previous layer's domain). . To generate a polynomial for the layer (from the previous layer's polynomial and domain). . To evaluate said polynomial on said domain - *this is the next FRI layer*. == Domain Generation The first FRI domain is simply the `eval_domain` that you already generated in Part 1, namely a coset of a group of order 8192. Each subsequent FRI domain is obtained by taking the first half of the previous FRI domain (dropping the second half), and squaring each of its elements. Formally - we got `eval_domain` by taking: [latexmath] ++++ \\[w, w\\cdot h, w\\cdot h^2, ..., w\\cdot h^{8191}\\] ++++ The next layer will therefore be: [latexmath] ++++ \\[w^2, (w\\cdot h)^2, (w\\cdot h^2)^2, ..., (w\\cdot h^{4095})^2\\] ++++ Note that taking the squares of the second half of each elements in `eval_domain` yields exactly the same result as taking the squares of the first half. This is true for the next layers as well. For example: [source,python] ---- print(eval_domain[100] ** 2) half_domain_size = len(eval_domain) // 2 print(eval_domain[half_domain_size + 100] ** 2) ---- Similarly, the domain of the third layer will be: [latexmath] ++++ \\[w^4, (w\\cdot h)^4, (w\\cdot h^2)^4, ..., (w\\cdot h^{2047})^4\\] ++++ And so on. Write a function `next_fri_domain` that takes the previous domain as an argument, and outputs the next one. Solution: [source,python] ---- def next_fri_domain(fri_domain): return [x ** 2 for x in fri_domain[:len(fri_domain) // 2]] ---- Run test: [source,python] ---- # Test against a precomputed hash. from hashlib import sha256 next_domain = next_fri_domain(eval_domain) assert '5446c90d6ed23ea961513d4ae38fc6585f6614a3d392cb087e837754bfd32797' == sha256(','.join([str(i) for i in next_domain]).encode()).hexdigest() print('Success!') ---- == FRI Folding Operator The first FRI polynomial is simply the composition polynomial, i.e., `cp`. Each subsequent FRI polynomial is obtained by: . Getting a random field element latexmath:[$\\beta$] (by calling `Channel.receive_random_field_element`). . Multiplying the odd coefficients of the previous polynomial by latexmath:[$\\beta$]. . Summing together consecutive pairs (even-odd) of coefficients. Formally, let's say that the k-th polynomial is of degree latexmath:[$ 0: beta = channel.receive_random_field_element() next_poly, next_domain, next_layer = next_fri_layer(fri_polys[-1], fri_domains[-1], beta) fri_polys.append(next_poly) fri_domains.append(next_domain) fri_layers.append(next_layer) fri_merkles.append(MerkleTree(next_layer)) channel.send(fri_merkles[-1].root) channel.send(str(fri_polys[-1].poly[0])) return fri_polys, fri_domains, fri_layers, fri_merkles ---- Run test: [source,python] ---- test_channel = Channel() fri_polys, fri_domains, fri_layers, fri_merkles = FriCommit(cp, eval_domain, cp_eval, cp_merkle, test_channel) assert len(fri_layers) == 11, f'Expected number of FRI layers is 11, whereas it is actually {len(fri_layers)}.' assert len(fri_layers[-1]) == 8, f'Expected last layer to contain exactly 8 elements, it contains {len(fri_layers[-1])}.' assert all([x == FieldElement(-1138734538) for x in fri_layers[-1]]), f'Expected last layer to be constant.' assert fri_polys[-1].degree() == 0, 'Expected last polynomial to be constant (degree 0).' assert fri_merkles[-1].root == '1c033312a4df82248bda518b319479c22ea87bd6e15a150db400eeff653ee2ee', 'Last layer Merkle root is wrong.' assert test_channel.state == '61452c72d8f4279b86fa49e9fb0fdef0246b396a4230a2bfb24e2d5d6bf79c2e', 'The channel state is not as expected.' print('Success!') ---- Run the following cell to execute the function with your channel object and print the proof so far: [source,python] ---- fri_polys, fri_domains, fri_layers, fri_merkles = FriCommit(cp, eval_domain, cp_eval, cp_merkle, channel) print(channel.proof) ----"}
{"title": "part3_fri_commitments_rs.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "_ License, Version 2.0 (the \"License\"). You may not use this file except in compliance with the License. You may obtain a copy of the License at Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License._ == Part 3: FRI Commitments * Lecture (youtube)] * (PDF)] == Load Previous Session Run the next cell to load the relevant variables. As usual - it will take a while to run. [source,rust] ---- :dep stark101-rs = { path = \"stark101\" } :dep sha256 = \"1.1.2\" use stark101_rs::{field::FieldElement, channel::Channel, polynomial::{Polynomial, x}, merkle_tree::MerkleTree}; use stark101_rs::part2; let (cp, cp_eval, cp_merkle, channel, eval_domain) = part2(); println!(\"Success!\"); ---- .... Success! .... == FRI Folding Our goal in this part is to construct the FRI layers and commit on them. To obtain each layer we need: . To generate a domain for the layer (from the previous layer's domain). . To generate a polynomial for the layer (from the previous layer's polynomial and domain). . To evaluate said polynomial on said domain - *this is the next FRI layer*. == Domain Generation The first FRI domain is simply the `eval_domain` that you already generated in Part 1, namely a coset of a group of order 8192. Each subsequent FRI domain is obtained by taking the first half of the previous FRI domain (dropping the second half), and squaring each of its elements. Formally - we got `eval_domain` by taking: [latexmath] ++++ \\[w, w\\cdot h, w\\cdot h^2, ..., w\\cdot h^{8191}\\] ++++ The next layer will therefore be: [latexmath] ++++ \\[w^2, (w\\cdot h)^2, (w\\cdot h^2)^2, ..., (w\\cdot h^{4095})^2\\] ++++ Note that taking the squares of the second half of each elements in `eval_domain` yields exactly the same result as taking the squares of the first half. This is true for the next layers as well. For example: [source,rust] ---- println!(\"{:?}\", eval_domain[100].pow(2)); let half_domain_size: usize = eval_domain.len() / 2; println!(\"{:?}\", eval_domain[half_domain_size + 100].pow(2)); ---- .... FieldElement(2848063603) FieldElement(2848063603) .... Similarly, the domain of the third layer will be: [latexmath] ++++ \\[w^4, (w\\cdot h)^4, (w\\cdot h^2)^4, ..., (w\\cdot h^{2047})^4\\] ++++ And so on. Write a function `next_fri_domain` that takes the previous domain as an argument, and outputs the next one. [source,rust] ---- fn next_fri_domain(fri_domain: Vec) -> Vec { // Fix this. } ---- Solution: [source,rust] ---- fn next_fri_domain(fri_domain: Vec) -> Vec { let fri_domain_len = fri_domain.len(); fri_domain.into_iter().take(fri_domain_len / 2).map(|x| x.pow(2)).collect() } ---- Run test: [source,rust] ---- // Test against a precomputed hash. let next_domain = next_fri_domain(eval_domain); assert_eq!(\"5446c90d6ed23ea961513d4ae38fc6585f6614a3d392cb087e837754bfd32797\", sha256(','.join([str(i) for i in next_domain]).encode()).hexdigest()); println!(\"Success!\"); ---- .... Error: expected `;`, found `println` \u256d\u2500[command_5:1:1] \u2502 3 \u2502 assert_eq!(\"5446c90d6ed23ea961513d4ae38fc6585f6614a3d392cb087e837754bfd32797\", sha256(','.join([str(i) for i in next_domain]).encode()).hexdigest()) \u00b7 \u2502 \u00b7 \u2570\u2500 error: expected `;`, found `println` \u00b7 \u2502 \u00b7 \u2570\u2500 help: add `;` here: `;` 4 \u2502 println!(\"Success!\"); \u00b7 \u2500\u2500\u2500\u252c\u2500\u2500\u2500 \u00b7 \u2570\u2500\u2500\u2500\u2500\u2500 unexpected token \u2500\u2500\u2500\u256f .... == FRI Folding Operator The first FRI polynomial is simply the composition polynomial, i.e., `cp`. Each subsequent FRI polynomial is obtained by: . Getting a random field element latexmath:[$\\beta$] (by calling `Channel.receive_random_field_element`). . Multiplying the odd coefficients of the previous polynomial by latexmath:[$\\beta$]. . Summing together consecutive pairs (even-odd) of coefficients. Formally, let's say that the k-th polynomial is of degree latexmath:[$ Polynomial { let odd_coefficients = poly.poly[1::2]; // fix this line. let even_coefficients = poly.poly[::2]; // No need to fix this line either. let multiplied_by_beta: Vec = odd_coefficients.into_iter().map(|c| c * beta).collect(); let odd = Polynomial::new(&multiplied_by_beta); let even = Polynomial(even_coefficients); odd + even } ---- .... Error: expected one of `.`, `?`, `]`, or an operator, found `::` \u256d\u2500[command_39:1:1] \u2502 2 \u2502 let odd_coefficients = poly.poly[1::2]; // fix this line. \u00b7 \u2500\u252c \u00b7 \u2570\u2500\u2500 expected one of `.`, `?`, `]`, or an operator \u2500\u2500\u2500\u256f .... Solution: [source,rust] ---- fn next_fri_polynomial(poly: Polynomial, beta: FieldElement) -> Polynomial { let odd_coefficients: Vec = poly.0.clone().into_iter().skip(1).step_by(2).collect(); let even_coefficients: Vec = poly.0.into_iter().step_by(2).collect(); let odd = Polynomial::new(&odd_coefficients) * beta; let even = Polynomial::new(&even_coefficients); odd + even } ---- Run test: [source,rust] ---- let next_p = next_fri_polynomial(cp, FieldElement::new(987654321)); assert_eq!(\"6bff4c35e1aa9693f9ceb1599b6a484d7636612be65990e726e52a32452c2154\", sha256(','.join([str(i) for i in next_p.poly]).encode()).hexdigest()); println!(\"Success!\"); ---- .... Success! .... == Putting it Together to Get the Next FRI Layer Write a function `next_fri_layer` that takes a polynomial, a domain, and a field element (again - latexmath:[$\\beta$]), and returns the next polynomial, the next domain, and the evaluation of this next polynomial on this next domain. [source,rust] ---- fn next_fri_layer(poly: Polynomial, domain: Vec, beta: FieldElement) -> (Polynomial, Vec, Vec) { todo!() } ---- Solution: [source,rust] ---- fn next_fri_layer(poly: Polynomial, domain: Vec, beta: FieldElement) -> (Polynomial, Vec, Vec) { let next_poly = next_fri_polynomial(poly, beta); let next_domain = next_fri_domain(domain); let next_layer: Vec = next_domain.clone().into_iter().map(|x| next_poly(x)).collect(); (next_poly, next_domain, next_layer) } ---- Run test: [source,rust] ---- let test_poly = Polynomial::new(&[FieldElement::new(2), FieldElement::new(3), FieldElement::new(0), FieldElement::new(1)]); let test_domain = vec![FieldElement::new(3), FieldElement::new(5)]; let beta = FieldElement::new(7); let (next_p, next_d, next_l) = next_fri_layer(test_poly, test_domain, beta); assert_eq!(next_p, Polynomial::new(&[FieldElement::new(23), FieldElement::new(7)])); assert_eq!(next_d, vec![FieldElement::new(9)]); assert_eq!(next_l, vec![FieldElement::new(86)]); println!(\"Success!\"); ---- .... Success! .... == Generating FRI Commitments We have now developed the tools to write the `FriCommit` method, that contains the main FRI commitment loop. It takes the following 5 arguments: . The composition polynomial, that is also the first FRI polynomial, that is - `cp`. . The coset of order 8192 that is also the first FRI domain, that is - `eval_domain`. . The evaluation of the former over the latter, which is also the first FRI layer , that is - `cp_eval`. . The first Merkle tree (we will have one for each FRI layer) constructed from these evaluations, that is - `cp_merkle`. . A channel object, that is `channel`. The method accordingly returns 4 lists: . The FRI polynomials. . The FRI domains. . The FRI layers. . The FRI Merkle trees. The method contains a loop, in each iteration of which we extend these four lists, using the last element in each. The iteration should stop once the last FRI polynomial is of degree 0, that is - when the last FRI polynomial is just a constant. It should then send over the channel this constant (i.e. - the polynomial's free term). The `Channel` class only supports sending strings, so make sure you convert anything you wish to send over the channel to a string before sending. [source,rust] ---- // Fix this according to the instructions (lines with no specific comments are okay). fn fri_commit(cp, domain, cp_eval, cp_merkle, channel) -> (Vec, Vec>, Vec>, Vec) { let fri_polys: Vec = vec![cp]; let fri_domains: Vec> = vec![domain]; let fri_layers: Vec> = vec![cp_eval]; let fri_merkles: Vec = vec![cp_merkle]; while cp.degree() > 1 { // Replace this with the correct halting condition. let beta = channel.receive_random_field_element(); // Change to obtain a random element from the channel. let (next_poly, next_domain, next_layer) = next_fri_layer(cp, domain, beta); // Fix to obtain the next FRI polynomial, domain, and layer. fri_polys.push(next_poly); fri_domains.push(next_domain); fri_layers.push(next_layer); fri_merkles.push(MerkleTree::new(next_layer)); // Fix to construct the correct Merkle tree. channel.send(fri_merkles.last().unwrap().root()); // Fix to send the correct commitment. } channel.send(fri_polys.last().unwrap()) // Fix to send the last layer's free term. (fri_polys, fri_domains, fri_layers, fri_merkles) } ---- Solution: [source,rust] ---- fn fri_commit(cp: Polynomial, domain: Vec, cp_eval: Vec, cp_merkle: MerkleTree, channel: &mut Channel) -> (Vec, Vec>, Vec>, Vec) { let mut fri_polys: Vec = vec![cp]; let mut fri_domains: Vec> = vec![domain]; let mut fri_layers: Vec> = vec![cp_eval]; let mut fri_merkles: Vec = vec![cp_merkle]; while fri_polys.last().unwrap().degree() > 0 { let beta = channel.receive_random_field_element(); let last_poly = fri_polys.last().unwrap().clone(); let last_domain = fri_domains.last().unwrap().clone(); let (next_poly, next_domain, next_layer) = next_fri_layer(last_poly, last_domain, beta); fri_polys.push(next_poly.clone()); fri_domains.push(next_domain.clone()); fri_layers.push(next_layer.clone()); fri_merkles.push(MerkleTree::new(next_layer)); channel.send(fri_merkles.last().unwrap().root()) } channel.send(fri_polys.last().unwrap().0[0].0.to_string()); (fri_polys, fri_domains, fri_layers, fri_merkles) } ---- Run test: [source,rust] ---- let mut test_channel = Channel::new(); let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp.clone(), eval_domain.clone(), cp_eval.clone(), cp_merkle.clone(), &mut test_channel); let fri_layers_len = fri_layers.len(); assert_eq!(fri_layers_len, 11, \"Expected number of FRI layers is 11, whereas it is actually {fri_layers_len}\"); assert_eq!(fri_layers.last().unwrap().len(), 8, \"Expected last layer to contain exactly 8 elements\"); assert_eq!(fri_polys.last().unwrap().degree(), 0, \"Expected last polynomial to be constant (degree 0).\"); assert_eq!(fri_merkles.last().unwrap().root(), \"6e09c7e19275df2155bd575833aa441f3058446726938420c0acabb1c332c40f\", \"Last layer Merkle root is wrong.\"); println!(\"Success!\"); ---- .... [E0425] Error: cannot find value `cp` in this scope \u256d\u2500[command_60:1:1] \u2502 2 \u2502 let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp.clone(), eval_domain.clone(), cp_eval.clone(), cp_merkle.clone(), &mut test_channel); \u00b7 \u2500\u252c \u00b7 \u2570\u2500\u2500 not found in this scope \u2500\u2500\u2500\u256f .... .... [E0425] Error: cannot find value `eval_domain` in this scope \u256d\u2500[command_60:1:1] \u2502 2 \u2502 let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp.clone(), eval_domain.clone(), cp_eval.clone(), cp_merkle.clone(), &mut test_channel); \u00b7 \u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500 \u00b7 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500 not found in this scope \u2500\u2500\u2500\u256f .... .... [E0425] Error: cannot find value `cp_eval` in this scope \u256d\u2500[command_60:1:1] \u2502 2 \u2502 let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp.clone(), eval_domain.clone(), cp_eval.clone(), cp_merkle.clone(), &mut test_channel); \u00b7 \u2500\u2500\u2500\u252c\u2500\u2500\u2500 \u00b7 \u2570\u2500\u2500\u2500\u2500\u2500 not found in this scope \u2500\u2500\u2500\u256f .... .... [E0425] Error: cannot find value `cp_merkle` in this scope \u256d\u2500[command_60:1:1] \u2502 2 \u2502 let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp.clone(), eval_domain.clone(), cp_eval.clone(), cp_merkle.clone(), &mut test_channel); \u00b7 \u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500 \u00b7 \u2570\u2500\u2500\u2500\u2500\u2500\u2500 not found in this scope \u2500\u2500\u2500\u256f .... Run the following cell to execute the function with your channel object and print the proof so far: [source,rust] ---- let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp, eval_domain, cp_eval, cp_merkle, channel); println!(\"{}\", channel.proof); ---- .... [E0425] Error: cannot find value `cp` in this scope \u256d\u2500[command_59:1:1] \u2502 1 \u2502 let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp, eval_domain, cp_eval, cp_merkle, channel); \u00b7 \u2500\u252c \u00b7 \u2570\u2500\u2500 not found in this scope \u2500\u2500\u2500\u256f .... .... [E0425] Error: cannot find value `eval_domain` in this scope \u256d\u2500[command_59:1:1] \u2502 1 \u2502 let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp, eval_domain, cp_eval, cp_merkle, channel); \u00b7 \u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500 \u00b7 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500 not found in this scope \u2500\u2500\u2500\u256f .... .... [E0425] Error: cannot find value `cp_eval` in this scope \u256d\u2500[command_59:1:1] \u2502 1 \u2502 let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp, eval_domain, cp_eval, cp_merkle, channel); \u00b7 \u2500\u2500\u2500\u252c\u2500\u2500\u2500 \u00b7 \u2570\u2500\u2500\u2500\u2500\u2500 not found in this scope \u2500\u2500\u2500\u256f .... .... [E0425] Error: cannot find value `cp_merkle` in this scope \u256d\u2500[command_59:1:1] \u2502 1 \u2502 let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp, eval_domain, cp_eval, cp_merkle, channel); \u00b7 \u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500 \u00b7 \u2570\u2500\u2500\u2500\u2500\u2500\u2500 not found in this scope \u2500\u2500\u2500\u256f .... .... [E0308] Error: mismatched types \u256d\u2500[command_59:1:1] \u2502 1 \u2502 let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp, eval_domain, cp_eval, cp_merkle, channel); \u00b7 \u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u252c\u2500\u2500\u2500 \u00b7 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 arguments to this function are incorrect \u00b7 \u2502 \u00b7 \u2570\u2500\u2500\u2500\u2500\u2500 expected `&mut Channel`, found `Channel` \u00b7 \u2502 \u00b7 \u2570\u2500\u2500\u2500\u2500\u2500 help: consider mutably borrowing here: `&mut channel` \u2500\u2500\u2500\u256f .... .... [E0277] Error: `Vec` doesn't implement `std::Display` \u256d\u2500[command_59:1:1] \u2502 2 \u2502 println!(\"{}\", channel.proof); \u00b7 \u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500 \u00b7 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 `Vec` cannot be formatted with the default formatter \u2500\u2500\u2500\u256f .... [source,rust] ---- ----"}
{"title": "part4_query_phase.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "_ License, Version 2.0 (the \"License\"). You may not use this file except in compliance with the License. You may obtain a copy of the License at Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License._ == Part 4: Query Phase * Lecture (youtube)] * (PDF)] == Load the Previous Session Run the next cell to load the variables we'll use in this part. Since it repeats everything done in previous parts - it will take a while to run. [source,python] ---- from channel import Channel from tutorial_sessions import part1, part3 _, _, _, _, _, _, _, f_eval, f_merkle, _ = part1() fri_polys, fri_domains, fri_layers, fri_merkles, _ = part3() print('Success!') ---- == Decommit on a Query Our goal in this part is to generate all the information needed for verifying the commitments of the three previous parts. In this part we write two functions: . `decommit_on_fri_layers` - sends over the channel data showing that each FRI layer is consistent with the others, when sampled at a specified index. . `decommit_on_query` - sends data required for decommiting on the trace and then calls `decommit_on_fri_layers`. == Decommit on the FRI Layers Implement `decommit_on_fri_layers` function. The function gets an index and a channel, and sends over the channel the relevant data for verifying the correctness of the FRI layers. More specifically, it iterates over `fri_layers` and `fri_merkles` and in each iteration it sends the following data (in the stated order): . The element of the FRI layer at the given index (using `fri_layers`). . Its authentication path (using the corresponding Merkle tree from `fri_merkles`). . The element's FRI sibling (i.e., if the element is latexmath:[$cp_i(x)$], then its sibling is latexmath:[$cp_i(-x)$], where latexmath:[$cp_i$] is the current layer's polynomial, and latexmath:[$x$] is an element from the current layer's domain). . The authentication path of the element's sibling (using the same merkle tree). To get an authentication path of an element, use `get_authentication_path()` of the `MerkleTree` class, with the corresponding index each time. Note that the index of the element's sibling equals to (idx + latexmath:[$\\frac k 2$]) mod latexmath:[$k$], where latexmath:[$k$] is the length of the relevant FRI layer. Note that we do *not* send the authentication path for the element in the last layer. In the last layer, all the elements are equal, regardless of the query, as they are evaluations of a constant polynomial. _(Remember to convert non-string variables into string before sending over the channel.)_ Solution: [source,python] ---- def decommit_on_fri_layers(idx, channel): for layer, merkle in zip(fri_layers[:-1], fri_merkles[:-1]): length = len(layer) idx = idx % length sib_idx = (idx + length // 2) % length channel.send(str(layer[idx])) channel.send(str(merkle.get_authentication_path(idx))) channel.send(str(layer[sib_idx])) channel.send(str(merkle.get_authentication_path(sib_idx))) channel.send(str(fri_layers[-1][0])) ---- Test your code: [source,python] ---- # Test against a precomputed hash. test_channel = Channel() for query in [7527, 8168, 1190, 2668, 1262, 1889, 3828, 5798, 396, 2518]: decommit_on_fri_layers(query, test_channel) assert test_channel.state == 'ad4fe9aaee0fbbad0130ae0fda896393b879c5078bf57d6c705ec41ce240861b', 'State of channel is wrong.' print('Success!') ---- == Decommit on the Trace Polynomial To prove that indeed the FRI layers we decommit on were generated from evaluation of the composition polynomial, we must also send: . The value latexmath:[$f(x)$] with its authentication path. . The value latexmath:[$f(gx)$] with its authentication path. . The value latexmath:[$f(g^2x)$] with its authentication path. The verifier, knowing the random coefficients of the composition polynomial, can compute its evaluation at latexmath:[$x$], and compare it with the first element sent from the first FRI layer. The function `decommit_on_query` should therefore send the above (1, 2, and 3) over the channel, and then call `decommit_on_fri_layers`. Importantly, even though latexmath:[$x, gx, g^2x$] are consecutive elements (modulo the group size latexmath:[$|G|$]) in the trace, the evaluations of `f_eval` in these points are actually 8 elements apart. The reason for this is that we \"blew up\" the trace to 8 times its size in part I, to obtain a Reed Solomon codeword. _Reminder: `f_eval` is the evaluation of the composition polynomial, and `f_merkle` is the corresponding Merkle tree._ Solution: [source,python] ---- def decommit_on_query(idx, channel): assert idx + 16 < len(f_eval), f'query index: {idx} is out of range. Length of layer: {len(f_eval)}.' channel.send(str(f_eval[idx])) # f(x). channel.send(str(f_merkle.get_authentication_path(idx))) # auth path for f(x). channel.send(str(f_eval[idx + 8])) # f(gx). channel.send(str(f_merkle.get_authentication_path(idx + 8))) # auth path for f(gx). channel.send(str(f_eval[idx + 16])) # f(g^2x). channel.send(str(f_merkle.get_authentication_path(idx + 16))) # auth path for f(g^2x). decommit_on_fri_layers(idx, channel) ---- Test your code: [source,python] ---- # Test against a precomputed hash. test_channel = Channel() for query in [8134, 1110, 1134, 6106, 7149, 4796, 144, 4738, 957]: decommit_on_query(query, test_channel) assert test_channel.state == '16a72acce8d10ffb318f8f5cd557930e38cdba236a40439c9cf04aaf650cfb96', 'State of channel is wrong.' print('Success!') ---- == Decommit on a Set of Queries To finish the proof, the prover gets a set of random queries from the channel, i.e., indices between 0 to 8191, and decommits on each query. Use the function that you just implemented `decommit_on_query()`, and `Channel.receive_random_int` to generate 3 random queries and decommit on each. Solution: [source,python] ---- def decommit_fri(channel): for query in range(3): # Get a random index from the verifier and send the corresponding decommitment. decommit_on_query(channel.receive_random_int(0, 8191-16), channel) ---- Test your code: [source,python] ---- test_channel = Channel() decommit_fri(test_channel) assert test_channel.state == 'eb96b3b77fe6cd48cfb388467c72440bdf035c51d0cfe8b4c003dd1e65e952fd', 'State of channel is wrong.' print('Success!') ---- == Proving Time! Run the following cell that ties it all together, running all previous code, as well as the functions you wrote in this part, and prints the proof. [source,python] ---- import time from tutorial_sessions import part1, part3 start = time.time() start_all = start print(\"Generating the trace...\") _, _, _, _, _, _, _, f_eval, f_merkle, _ = part1() print(f'{time.time() - start}s') start = time.time() print(\"Generating the composition polynomial and the FRI layers...\") fri_polys, fri_domains, fri_layers, fri_merkles, channel = part3() print(f'{time.time() - start}s') start = time.time() print(\"Generating queries and decommitments...\") decommit_fri(channel) print(f'{time.time() - start}s') start = time.time() print(channel.proof) print(f'Overall time: {time.time() - start_all}s') print(f'Uncompressed proof length in characters: {len(str(channel.proof))}') ----"}
{"title": "part4_query_phase_rs.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "_ License, Version 2.0 (the \"License\"). You may not use this file except in compliance with the License. You may obtain a copy of the License at Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License._ == Part 4: Query Phase * Lecture (youtube)] * (PDF)] == Load the Previous Session Run the next cell to load the variables we'll use in this part. Since it repeats everything done in previous parts - it will take a while to run. [source,rust] ---- :dep stark101-rs = { path = \"stark101\" } :dep sha256 = \"1.1.2\" use stark101_rs::{field::FieldElement, channel::Channel, polynomial::{Polynomial, x}, merkle_tree::MerkleTree}; use stark101_rs::{part1, part3}; let (_, _, _, _, _, _, _, f_eval, f_merkle, _) = part1(); let (fri_polys, fri_domains, fri_layers, fri_merkles, _ch): (Vec, Vec>, Vec>, Vec, Channel) = part3(); println!(\"Success!\"); ---- .... Success! .... == Decommit on a Query Our goal in this part is to generate all the information needed for verifying the commitments of the three previous parts. In this part we write two functions: . `decommit_on_fri_layers` - sends over the channel data showing that each FRI layer is consistent with the others, when sampled at a specified index. . `decommit_on_query` - sends data required for decommiting on the trace and then calls `decommit_on_fri_layers`. == Decommit on the FRI Layers Implement `decommit_on_fri_layers` function. The function gets an index and a channel, and sends over the channel the relevant data for verifying the correctness of the FRI layers. More specifically, it iterates over `fri_layers` and `fri_merkles` and in each iteration it sends the following data (in the stated order): . The element of the FRI layer at the given index (using `fri_layers`). . Its authentication path (using the corresponding Merkle tree from `fri_merkles`). . The element's FRI sibling (i.e., if the element is latexmath:[$cp_i(x)$], then its sibling is latexmath:[$cp_i(-x)$], where latexmath:[$cp_i$] is the current layer's polynomial, and latexmath:[$x$] is an element from the current layer's domain). . The authentication path of the element's sibling (using the same merkle tree). To get an authentication path of an element, use `get_authentication_path()` of the `MerkleTree` class, with the corresponding index each time. Note that the index of the element's sibling equals to (idx + latexmath:[$\\frac k 2$]) mod latexmath:[$k$], where latexmath:[$k$] is the length of the relevant FRI layer. Note that we do *not* send the authentication path for the element in the last layer. In the last layer, all the elements are equal, regardless of the query, as they are evaluations of a constant polynomial. _(Remember to convert non-string variables into string before sending over the channel.)_ [source,rust] ---- // Fix this. fn decommit_on_fri_layers(idx: usize, channel: &mut Channel, fri_layers: Vec>, fri_merkles: Vec) { for layer, merkle in zip(fri_layers[:-1], fri_merkles[:-1]) { // Fix this: send elements and authentication pathes of all the FRI layers but the last one. channel.send(\"The element from the current layer\") // TODO channel.send(\"The authentication path for this element\") // TODO channel.send(\"The element\\'s sibling in the current layer\") // TODO channel.send(\"The sibling\\'s authentication path\") // TODO } // Send the element in the last FRI layer. channel.send(\"The last element\") } ---- Solution: [source,rust] ---- fn decommit_on_fri_layers(idx: usize, channel: &mut Channel, fri_layers: Vec>, fri_merkles: Vec) { for (layer, merkle) in zip(fri_layers[:-1], fri_merkles[:-1]) { let length = layer.len(); let idx = idx % length; let sib_idx = (idx + length / 2) % length channel.send(layer[idx].to_string()); channel.send(merkle.get_authentication_path(idx)); channel.send(str(layer[sib_idx])); channel.send(str(merkle.get_authentication_path(sib_idx))); } channel.send(str(fri_layers[-1][0])) } ---- Test your code: [source,rust] ---- // Test against a precomputed hash. let mut test_channel = Channel(); for query in vec![7527, 8168, 1190, 2668, 1262, 1889, 3828, 5798, 396, 2518] { decommit_on_fri_layers(query, &mut test_channel, fri_layers.clone()); } assert_eq!(test_channel.state, \"ad4fe9aaee0fbbad0130ae0fda896393b879c5078bf57d6c705ec41ce240861b\", \"State of channel is wrong.\"); println!(\"Success!\"); ---- == Decommit on the Trace Polynomial To prove that indeed the FRI layers we decommit on were generated from evaluation of the composition polynomial, we must also send: . The value latexmath:[$f(x)$] with its authentication path. . The value latexmath:[$f(gx)$] with its authentication path. . The value latexmath:[$f(g^2x)$] with its authentication path. The verifier, knowing the random coefficients of the composition polynomial, can compute its evaluation at latexmath:[$x$], and compare it with the first element sent from the first FRI layer. The function `decommit_on_query` should therefore send the above (1, 2, and 3) over the channel, and then call `decommit_on_fri_layers`. Importantly, even though latexmath:[$x, gx, g^2x$] are consecutive elements (modulo the group size latexmath:[$|G|$]) in the trace, the evaluations of `f_eval` in these points are actually 8 elements apart. The reason for this is that we \"blew up\" the trace to 8 times its size in part I, to obtain a Reed Solomon codeword. _Reminder: `f_eval` is the evaluation of the composition polynomial, and `f_merkle` is the corresponding Merkle tree._ [source,rust] ---- fn decommit_on_query(idx: usize, channel: &mut Channel, fri_layers: Vec>) { // Send elements and authentication pathes for f(x), f(gx) and f(g^2x) over the channel. channel.send(\"f(x)\"); // TODO channel.send(\"f(x)\\'s authentication path\"); // TODO channel.send(\"f(gx)\"); // TODO channel.send(\"f(gx)\\'s authentication path\"); // TODO channel.send(\"f(g^2x)\"); // TODO channel.send(\"f(g^2x)\\'s authentication path\"); // TODO decommit_on_fri_layers(idx, &mut channel, fri_layers) // No need to fix this line. } ---- Solution: [source,rust] ---- fn decommit_on_query(idx: usize, channel: &mut Channel, fri_layers: Vec>) { let f_eval_len = f_eval.len(); assert!(idx + 16 < f_eval.len(), \"query index: {idx} is out of range. Length of layer: {f_eval_len}.\"); channel.send(f_eval[idx].to_string()); // f(x). channel.send(f_merkle.get_authentication_path(idx).to_string())); // auth path for f(x). channel.send(f_eval[idx + 8].to_string()); // f(gx). channel.send(f_merkle.get_authentication_path(idx + 8).to_string()); // auth path for f(gx). channel.send(f_eval[idx + 16].to_string()); // f(g^2x). channel.send(f_merkle.get_authentication_path(idx + 16).to_string()); // auth path for f(g^2x). decommit_on_fri_layers(idx, channel, fri_layers); } ---- Test your code: [source,rust] ---- // Test against a precomputed hash. let mut test_channel = Channel(); for query in vec![8134, 1110, 1134, 6106, 7149, 4796, 144, 4738, 957] { decommit_on_query(query, test_channel) } assert_eq!(test_channel.state, \"16a72acce8d10ffb318f8f5cd557930e38cdba236a40439c9cf04aaf650cfb96\", \"State of channel is wrong.\"); println!(\"Success!\"); ---- == Decommit on a Set of Queries To finish the proof, the prover gets a set of random queries from the channel, i.e., indices between 0 to 8191, and decommits on each query. Use the function that you just implemented `decommit_on_query()`, and `Channel.receive_random_int` to generate 3 random queries and decommit on each. [source,rust] ---- // Fix this. fn decommit_fri(channel: &mut Channel) { for query in 0..3 { todo!(); // Get a random index from the channel and send the corresponding decommitment. } } ---- Solution: [source,rust] ---- fn decommit_fri(channel: &mut Channel) { for query in 0..3 { // Get a random index from the verifier and send the corresponding decommitment. decommit_on_query(channel.receive_random_int(0, 8191-16), channel); } } ----"}
{"title": "starks_snarks.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"starks_snarks\"] = STARKs and SNARKs: Differences .STARK vs SNARK |====================================== | | STARK | SNARK | Verification | log^2^(n)| constant | Proof Size | ~400 KB | 288 bytes | Trusted Setup | No | Yes | Quantum Secure | Yes | No |====================================== [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "trust_verification.adoc", "repo_owner": "starknet-edu", "repo_name": "starknetbook", "text": "[id=\"trust_verification\"] = Trust vs. Verification Computational Integrity (CI) is a fundamental property that underlies commerce. In simple terms, it means that the output of a certain computation is correct. CI is what allows us to trust an account balance presented to us, or the bill at a store. This Chapter delves into how permissionless blockchains achieve CI without requiring trust, the dramatic price they pay for this in terms of scalability and privacy, and how STARKs can save the day. == \"`Old World`\": Trust, or Delegated Accountability Financial systems (banks, brokers, exchanges, etc.) need to operate with integrity to serve their societal functions. What mechanisms incentivize them to operate with integrity? The \"`old world`\" assumes trust as a proxy for integrity. We trust banks, pension funds, etc., to operate honestly. Let's go down the rabbit hole and examine the basis for this trust, ignoring the \"`integrity theater`\" -- the tall buildings and fancy suits -- set to impress us. From a purely rational and utilitarian perspective, the thing that prevents the financial system from seizing all our funds is the threat of social disgrace, jail, and fines. There's also a carrot -- reputation, which attracts future customers and generates future profits. By signing on financial statements with their names, people in the \"`old world`\" stake their personal freedom, existing and future finances as a collateral for integrity, and we, the public, base our trust on this arrangement. The verification of this integrity is delegated to experts like accountants, auditors, and regulators. We will call this Delegated Accountability. It's not a bad system: it's been serving modern economies faithfully for quite some time. A new variant of the \"`old world`\" approach is the Trusted Execution Environment (TEE). A trusted hardware manufacturer (like Intel) produces a physical machine (like the SGX chip) that cannot deviate from the specified computation and signs correct states using a secret key known only to that physical machine. Integrity is now based on trust in the hardware and its manufacturer and on the assumption that it is impossible to extract secret keys from such physical devices. \"`New World`\": Verify, or Inclusive Accountability Blockchains offer a more direct way to reach integrity, captured by the motto \"`Don't Trust, Verify`\". This \"`new world`\" does not require an integrity theater, it doesn't rely on accountants, nor do its developers and network maintainers stake their personal freedom to gain public trust. Integrity is guaranteed by Inclusive Accountability: a node with a standard computational setup (a web-connected laptop) should be able to verify the integrity of all transactions in the system. The prevalent method to verify CI in permissionless blockchains is via naive replay: all nodes are asked to re-execute (replay) the computations that verify each and every transaction. Inclusive Accountability, in this naive form, leads to two immediate challenges: * *Privacy*: If everyone gets to inspect all transactions then privacy might be compromised. The absence of privacy deters businesses, as it means sensitive information may not remain proprietary. It also deters individuals, as it erodes dignity]. * *Scalability*: Demanding that the system be accountable to a standard laptop means it cannot scale up by simply moving to bigger computers and larger bandwidth. This leads to a severe bound on the throughput of the system. Proofs systems (discussed next) are an excellent solution to both challenges. Zero Knowledge (ZK) proof systems are by now an established tool to address privacy in blockchains and explained excellently in several posts of Zcash (see and Let's review an example for a CI statement (the claim that the output of a certain computation is correct): the total sum we should pay at the supermarket was computed correctly. The conventional proof for this particular statement is the receipt. Typically, the items in the receipt are listed with their prices, and the total sum is indicated at the bottom, like so: image::receipt.png[receipt] For simplicity -- we only consider this to be a statement that the summation is correct. To see whether this CI statement holds, one can go over the list -- not skipping any item -- to compute the total sum, and check it against the number at the bottom of the receipt. This is a very naive example, but we'll use it further down this article to demonstrate the idea of _succinct testability_. === Proof Systems Proof Systems started with the introduction of the Proof] (IP) model by Goldwasser, Micali, and Rackoff in 1985. Interactive proofs are protocols that involve two kinds of entities: a prover and a verifier, who interact over a number of rounds by sending messages. The prover and verifier have conflicting objectives: the prover wants to convince the verifier of the integrity of a certain computation, and the verifier is a suspicious gatekeeper entrusted by the public with the task of distinguishing between truisms and falsities. The prover and verifier communicate interactively, taking turns in sending messages to one another. These messages depend on the statement being proved, on prior messages, and may also use some randomness. On the prover side, randomness is used to achieve zero knowledge and on the verifier side randomness is needed to generate queries to the prover. At the end of the interactive process the verifier outputs a decision, to either accept the new state or reject it. A good analogy is the examination process practiced in a court of law when one party submits a claim and its counterparty questions its validity. For the claim to be accepted as true, the answers provided by the claimant (prover) to the examiner's (verifier's) queries must be consistent and valid. The examination process is expected to expose any mismatch between a statement and reality, and thus expose it as false. We say that a proof system _solves_ CI if when updating the system from state A to state B, the following properties hold: * *Completeness*: If the prover indeed knows how to change the state from A to B in a valid way then the prover will manage to convince the verifier to accept the change. * {blank} ** *Soundness*: If the prover doesn't know how to change the state from A to B, then the verifier will notice an inconsistency in the interaction and reject the suggested state transition. There remains a tiny false-positive probability, i.e., a probability of the verifier accepting an invalid proof. This probability is a system security parameter which can be set to an acceptable level like 1/(2\u00b9\u00b2\u2078), similar odds to winning the powerball five times in a row. This pair of properties has a crucial implication to the principle of Inclusive Accountability discussed earlier. The verifier can accept the state transition suggested by the prover without making any assumptions about the integrity of the prover. In fact, the prover can run on faulty hardware, it can be closed source and it can be executed on a computer controlled by a malicious entity. The only thing that matters\u00b9 is that the messages sent by the prover lead the verifier to accept the statement. If that is the case, we know that computational integrity holds. == (extra) Probabistically Checkable Proofs. When polling an election, the margin of error is independent from the sample size. That is, the sample size is what determines the margin of error and not the population size. The image below exemplifies this fact.++++++[#modular_arithmetic] == Margin of error The margin of error does not depend on the size of the population. image:marginError.png[marginError] The same principle holds for mathematical proofs and for validating the integrity of a computation. If you want to sample a computation of a proof and know to a high degree of certainty (and a small margin of error) whether this computation was done with integrity (i.e. the proof is correct), the margin of error only depends on the sample size and not on how long or complicated the computation of proof is. This is huge: you can cjheck the validity of any proof (the integrity of any computation) by reading only a small number of bits of it. In other words, the computation size does not matter, what matter is the number of bits you sample. This has implications for scalability. A single reliable smart contract in Ethereum monitors the operation of a very large computer, the prover, the processor of Starknet transactions. We do not care at all if that super computer is on top of unreliable sofware or untested hardware. All we have to do is trust the smart contract! This was already discovered since the 1990s, however, it was not implemented because the computation to create a proof that could be verified efficiently was too hard. However, Eli Ben-Sasson and other scientists worked on the problem to create smaller and smaller proofs. [NOTE] ==== The Book is a community-driven effort created for the community. * If you've learned something, or not, please take a moment to provide feedback through 3-question survey]. * If you discover any errors or have additional suggestions, don't hesitate to open an on our GitHub repository]. ==== == Contributing [quote, The Starknet Community] ____ *Unleash Your Passion to Perfect StarknetBook* StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others. Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our and join our vibrant community. Let's fearlessly build Starknet! ____"}
{"title": "index.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"overview\"] = Introduction Starknet is a permissionless decentralized Validity-Rollup (also known as a _ZK-Rollup_). It operates as an L2 network over Ethereum, enabling any dApp to achieve unlimited scale for its computation \u2013 without compromising Ethereum\u2019s composability and security \u2013 thanks to Starknet\u2019s reliance on the safest and most scalable cryptographic proof system: STARK. Starknet contracts and the Starknet OS are written in Cairo \u2013 supporting the deployment and scaling of any use case, whatever the business logic."}
{"title": "approach.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"starknet_account_structure\"] = Starknet account interface A Starknet account contract must include the following two functions: * `&lowbar;&lowbar;validate&lowbar;&lowbar;` * `&lowbar;&lowbar;execute&lowbar;&lowbar;` These serve distinct purposes to ensure that only the account owner can initiate transactions and that fees can be charged for the resources you use. Starknet's account type is inspired by Ethereum's EIP-4337, where instead of EOAs, you now use smart contract accounts with arbitrary verification logic. Through the use of smart contracts, you are provided with complete flexibility within your account implementation. While not mandatory at the protocol level, a richer standard interface for accounts was developed by the community. This standard was developed by OpenZeppelin, in a close collaboration with wallet teams and other Core Starknet developers. You can see the IAccount interface [id=\"replay_protection\"] == Replay protection In Starknet, similar to Ethereum, every contract has a nonce. This nonce is sequential; when a transaction is sent from an account, its nonce must match the account's nonce and it's incremented after the transaction is executed (whether or not it was reverted). Note that, similar to Ethereum, only the nonce of account contracts (that is, those adhering to the above structure) can be non-zero. A nonce serves two important roles: * It guarantees transaction hash uniqueness (this is important for good UX) * It provides replay protection to the account (since the signature refers to a particular nonce, the transaction can't be replayed by a malicious party) As seen above, Starknet currently determines the nonce structure (sequential) at the protocol level. In the future, Starknet will consider a more flexible design, extending account abstraction to nonce management (previously referred to as \"nonce abstraction\")."}
{"title": "deploying_new_accounts.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"deploying_new_accounts\"] = Deploying new accounts Starknet provides the `deploy_account` transaction in order to deploy new accounts to the network. ## Deploy account transaction In order to deploy a new account on StarkNet you need to complete the following steps: * Decide on the account contract that you want to deploy * Compute your would-be account address off-chain * Send funds to this address Once the address has enough funds to pay for the deployment, you can then send a `deploy_account` transaction. ## Transaction flow Upon receiving a `deploy_account` transaction, the sequencer will: * Verify that the address has funds to pay for the deployment * Execute the constructor with the given arguments * Execute the `&lowbar;&lowbar;validate_deploy&lowbar;&lowbar;` entry point (See below) * Charge fee from the new account address * Advance the nonce to 1 ## Validate deploy There are two potential issues that arise from sending a `deploy_account` transaction without any extra validation: * Sequencers having the ability to charge arbitrarily high fees, thus potentially draining user funds from a pre-funded account * A bad actor having the ability to carry out a sequencer DOS attack by sending multiple, invalid `deploy_account` transactions. This would result in the sequencer not being compensated for work completed. To prevent the scenario described in the first point, a new optional validation entrypoint is provided: `&lowbar;&lowbar;validate_deploy&lowbar;&lowbar;`. To prevent the potential DOS attack from the second point, we introduce some limitations on the constructor and __validate_deploy_ _ executions, namely: * Limited # of Cairo steps * Limited # of builtin applications * No external contract calls (library calls and self-calls are allowed) This entrypoint should be included in any accounts or contracts that wish to allow this new deployment flow. ### Using validate deploy `&lowbar;&lowbar;validate_deploy&lowbar;&lowbar;` expects the following arguments: * class hash * contract address salt * constructor arguments - the arguments expected by the contract\u2019s constructor (this will be enforced in the compiler). [NOTE] ==== In determining the contract address, deployer address 0 will be used. ==== Consider an account with the following constructor signature: [#constructor_signature] [source,cairo] ---- @constructor func constructor{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}( _public_key: felt ) ---- Then the signature of `&lowbar;&lowbar;validate_deploy`&lowbar;&lowbar; must be: [#call_validate_deploy] [source,cairo] ---- func __validate_deploy__{ syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr, ecdsa_ptr: SignatureBuiltin* }(class_hash: felt, contract_address_salt: felt, _public_key: felt) ---- [NOTE] ==== The transaction hash and `max_fee` are accessible through the `get_tx_info` system call. ===="}
{"title": "introduction.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"what_is_an_account\"] = What is an account? An account is a user's representation on-chain and the way of interacting with the blockchain. Through an account, you may send transactions and interact with other contracts. To \"own\" an on-chain asset (e.g. ERC20 token or an NFT), it has to be associated with your account address. [id=\"ethereum_account_structure\"] == Ethereum account structure Within Ethereum individual user accounts are known as Externally Owned Accounts (EOAs). EOAs differ from smart contracts in that they are not controlled by code. An EOA is determined by a pair of private and public keys. The account's address is derived from those keys and only by possessing the private key can you initiate transactions from an account. While Ethereum contracts are \"passive\", i.e., they can only change if they were called inside a transaction, EOAs can initiate transactions. While simple, EOAs have a major drawback \u2013 there's no flexibility in the account behavior, i.e. the Ethereum protocol dictates what it means for a transaction initiated by an EOA to be valid (the signature scheme is fixed). In particular, control over the private key gives complete control over the account. Although this is theoretically a secure method of account management, in practice it has some drawbacks, such as requiring you to keep your seed phrase secure yet accessible to you and limited flexibility surrounding wallet functionality. EIP-4337, a design proposal for Ethereum outlines _account abstraction_ whereby all accounts are managed via a dedicated smart contract on the Ethereum network, as a way to increase flexibility and usability. You can add custom logic on top of the basic EOA functionality, thereby bringing account abstraction into Ethereum. [id=\"account_abstraction\"] == What is Account Abstraction? The idea behind account abstraction is to allow more flexibility in the management of accounts rather than have their behavior determined at the protocol level. This can be achieved by introducing account contracts - smart contracts with programmable logic that determines the user's account. Using account abstraction you can now program how your account functions. For example, you can: * Determine what it means for a signature to be valid or what contracts your account is allowed to interact with. This is known as \"signature abstraction\" * Pay transaction fees in different tokens - this is sometimes known as \"fee abstraction\" * Design your own replay protection mechanism and allow sending multiple uncoupled transactions in parallel. Compare this to the sequential nonce solution used in Ethereum, which results in transactions being inherently sequential, i.e., even if you want to send two transactions in parallel, you must wait for some confirmation on the first before sending the second. Otherwise, the second transaction may be rejected due to an invalid nonce. With account abstraction, one can discuss different solutions that bypass the need for a sequential nonce. This is known as \"nonce abstraction\" Today, Starknet offers signature abstraction. In the future, we will enrich the current account abstraction design (see e.g. the proposal] for fee abstraction). [id=\"examples\"] == Examples of customizing account functionality Two examples of how you might program an account to function using account abstraction are: Social recovery:: A process where if you lose your wallet, you are able to retrieve it via a selected social network, vastly improving the typical experience of wallet recovery. Operating your account via facial recognition:: With signature abstraction, you can use your phone's native hardware to sign transactions, making it practically impossible to take control of another user's account (even in the case of the phone itself being stolen)."}
{"title": "simplified_transaction_flow.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"simplified_transaction_flow\"] = Simplified transaction flow The key stages of transaction lifetime are: . The sequencer selects a transaction from the mempool and executes `&lowbar;&lowbar;validate&lowbar;&lowbar;` . If the transaction was valid, the `&lowbar;&lowbar;execute&lowbar;&lowbar;` function is called . If `&lowbar;&lowbar;execute&lowbar;&lowbar;` ran successfully, the sequencer includes the transaction in the block, charges the fee and proceeds to work on the next transaction (once the block is concluded, it will be sent to the prover) [id=\"a_payment_mechanism\"] == The payment mechanism The sequencer receives fees in ETH in return for including transactions in a block. For more details on how the transaction fee is computed, see xref:Fees/fee-mechanism.adoc[the fees section]"}
{"title": "validate_and_execute.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"validate_and_execute\"] = Validate and execute As previously stated, Starknet's account structure is not completely arbitrary, but must include the following two functions, which account transactions call: * `&lowbar;&lowbar;validate&lowbar;&lowbar;` * `&lowbar;&lowbar;execute&lowbar;&lowbar;` Separating the `&lowbar;&lowbar;validate&lowbar;&lowbar;` and `&lowbar;&lowbar;execute&lowbar;&lowbar;` functions guarantees payment to sequencers for work completed and protects them from Denial of Service (DoS) attacks. [id=\"the_validate_function\"] == The validate function The `&lowbar;&lowbar;validate&lowbar;&lowbar;` function ensures that any transaction submitted was indeed initiated by the account owner and therefore will not take up unjustified resources during the execution process. Without this mechanism, a forged transaction can result in the sequencer stealing the user's funds. In short, `&lowbar;&lowbar;validate&lowbar;&lowbar;` ensures that the sequencer may only include transactions that were approved by the account owner. The arbitrary logic allowed in the `&lowbar;&lowbar;validate&lowbar;&lowbar;` function gives the account's designer the ability to determine what it means for a transaction to be valid. This gives rise to the usage of different signature schemes and other xrefAccount_Abstraction/introduction.adoc#examples[exotic accounts]. [id=\"invalid_transactions\"] == Invalid transactions When the `&lowbar;&lowbar;validate&lowbar;&lowbar;` function fails, no fee will be taken from the account in question. [id=\"validate_limitations\"] == Validate limitations There are some limitations set on the `&lowbar;&lowbar;validate&lowbar;&lowbar;` function. The purpose of these limitations is twofold: * We want to avoid the sequencer having to do a lot of work only to discover that the validation failed and the sequencer is then not eligible to charge a fee (if this was possible, the sequencer would be completely exposed to DOS attacks). Validation, while now abstract and in control of the account owner rather than the protocol, should still be a simple operation. This is why in the future, Starknet will place max steps limitation upon the `&lowbar;&lowbar;validate&lowbar;&lowbar;` function. * Even if the validation is simple, we could still face the following attack: ** An attacker fills the mempool with transactions that are valid at time T. ** A sequencer may start executing them, thinking that at the time he will produce his block, they will still be valid. ** However, shortly after, at time T', the attacker sends one transaction that somehow invalidates all the previous ones and makes sure it's included before the sequencer gets to publish his block (the attacker may do this by offering higher fees for this one transaction). As a concrete example, think of many `&lowbar;&lowbar;validate&lowbar;&lowbar;` functions checking that the value of a storage slot is 1 and the attacker's transaction later sets it to 0. To handle this issue, we add some further limitations. Currently, Starknet enforces that `&lowbar;&lowbar;validate&lowbar;&lowbar;` does not call external contracts. NOTE: The property that we achieve with the above restrictions is that a single storage update may only invalidate transactions from a single account (this is the best we can do, an account can always invalidate its own past transactions by changing its keys). Thus, the price (in fees) required to invalidate transactions in the mempool is linear in the number of unique accounts that we want to invalidate. [id=\"the_execute_function\"] == The execute function The purpose of the `&lowbar;&lowbar;execute&lowbar;&lowbar;` function is to abstract away the remaining actions performed by a transaction. In Ethereum, a transaction is necessarily a call to a specific function in a smart contract. With the `&lowbar;&lowbar;execute&lowbar;&lowbar;` abstraction, the account designer controls the flow of the transaction. For example, multicalls can be natively supported in your account, saving the need to send multiple transactions (in practice, this is even harder to manage without multicalls due to nonces). [id=\"reverted_transactions\"] == Reverted transactions A transaction is considered reverted when the `&lowbar;&lowbar;execute&lowbar;&lowbar;` function failed. Today, reverted transactions are not included in blocks, but in the future, they will be and the sequencer will be eligible to charge a fee for the work done up to the point of failure, similar to Ethereum. Currently, the sequencer charges only for successful transactions that result from the successful completion of the `&lowbar;&lowbar;execute&lowbar;&lowbar;` function."}
{"title": "header.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "latexmath [id=\"block_structure\"] = Block structure In Starknet, the block is defined as a list of transactions and a block header. [id=\"block_header\"] == Block header The following fields define the block header: [%autowidth] |=== | Name | Type | Description | Implemented | `parent_block_hash` | `FieldElement` | The hash of this block's parent | &#10003; |`block_number` | `Integer` | The number (height) of this block | &#10003; | `global_state_root` | `FieldElement` | The state xref:../State/starknet-state.adoc#state_commitment[commitment] after this block | &#10003; |`sequencer_address` | `FieldElement` | The Starknet address of the sequencer who created this block | &#10003; | `block_timestamp` | `Timestamp` | The time the sequencer created this block before executing transactions | &#10003; |`transaction_count` | `Integer` | The number of transactions in a block | &#10003; | `transaction_commitment` | `FieldElement` | A commitment to the transactions included in the block | &#10003; |`event_count` | `Integer` | The number of events | &#10003; | `event_commitment` | `FieldElement` | A commitment to the events produced in this block | &#10003; | `protocol_version` | `Integer` | The version of the Starknet protocol used when creating this block | | `extra data` | `FieldElement` | Extraneous data that might be useful for running transactions | |=== [NOTE] ==== The commitment fields `event_commitment` and `transaction_commitment` are the roots of a height 64 binary Merkle Patricia tree. For `event_commitment`, the leaf at index stem:[$i$] corresponds to the hash of the stem:[$i'th$] event. For `transaction_commitment`, the leaf at index stem:[$i$] corresponds to stem:[$h(transaction \\ hash, signature)$] if the stem:[$i'th$] transaction is an `invoke` transaction and stem:[$h(0,0)$] otherwise. ==== [id=\"block_hash\"] == Block hash The block hash is defined as the Pedersen hash over the header's elements. [stem] ++++ \\begin{aligned} h(B)=h(&\\text{block_number}, \\text{ global_state_root}, \\text{ sequencer_address}, \\text{ block_timestamp}, \\\\ &\\text{transaction_count}, \\text{ transaction_commitment}, \\text{ event_count},\\\\ & \\text{event_commitment}, 0, 0, \\text{ parent_block_hash}) \\end{aligned} ++++ Where stem:[$h$] is the xref:../Hashing/hash-functions.adoc#pedersen-hash[Pedersen] hash. [NOTE] ==== Zeros inside the hash computation of an object are used as placeholders, to be replaced in the future by meaningful fields. ===="}
{"title": "transaction-life-cycle.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"transaction_lifecycle\"] = Transaction lifecycle The following are the possible statuses of a transaction from the moment it's sent by the user to the moment it's validated by L1. [id=\"transaction_status\"] == Transaction status [id=\"not_received\"] === NOT_RECEIVED Transaction is not yet known to the sequencer. [id=\"received\"] === RECEIVED Transaction was received by the sequencer. Transaction will now either execute successfully or be rejected. [id=\"pending\"] === PENDING Transaction executed successfully and entered the xref:./transaction-life-cycle.adoc#the_pending_block[pending block]. [id=\"accepted_on_l2\"] === ACCEPTED_ON_L2 Transaction passed validation and entered an actual created block on L2. [id=\"accepted_on_l1\"] === ACCEPTED_ON_L1 Transaction was accepted on-chain. [id=\"rejected\"] === REJECTED Transaction executed unsuccessfully and thus was skipped (applies both to a pending and an actual created block). Possible reasons for transaction rejection: * An assertion failed during the execution of the transaction (in Starknet, unlike in Ethereum, transaction executions do not always succeed). * The block may be rejected on L1, thus changing the transaction status to `REJECTED`. [id=\"the_pending_block\"] == The pending block Today, Starknet supports querying the new block before its construction is complete. This feature improves the responsiveness of the system prior to the decentralization phase, but will probably become obsolete once the system is decentralized, as full nodes will only propagate finalized blocks through the network. During the construction of the block, as it is accumulating new transactions, the block's status is `PENDING`. While status is `PENDING`, new transactions are dynamically added to the block. Once the sequencer decides to close the block, it becomes `ACCEPTED_ON_L2` and its hash is computed. The following example is a query for the pending mainnet block: See the xrefCLI/commands.adoc[CLI section] for information on how to call the gateway with respect to the pending block. [id=\"transaction_receipt\"] == Transaction receipt The transaction receipt contains basic transaction details (block identifiers and the index within the block), a summary of the execution resources used by the transaction, the events emitted, a list of messages sent to L1, and a consumed L1 message (in case the transaction invokes an L1 handler). The following is an example of a receipt: [source,json] ---- { \"execution_resources\": { \"builtin_instance_counter\": { \"pedersen_builtin\": 0, \"range_check_builtin\": 0, \"bitwise_builtin\": 0, \"output_builtin\": 0, \"ecdsa_builtin\": 0, \"ec_op_builtin\": 0 }, \"n_steps\": 178, \"n_memory_holes\": 0 }, \"block_number\": 6807, \"transaction_index\": 0, \"transaction_hash\": \"0x3f187b7522320f1c87271772fedd6ad119f62595e2d9208824367463df94a5d\", \"status\": \"PENDING\", \"block_hash\": \"0x23173d4e2d5c0ecc1376b8dbe345c028aa424048c67f68812a9a83873a2d87f\", \"l2_to_l1_messages\": [], \"events\": [ { \"data\": [\"0\", \"4321\"], \"from_address\": \"0x14acf3b7e92f97adee4d5359a7de3d673582f0ce03d33879cdbdbf03ec7fa5d\", \"keys\": [ \"1744303484486821561902174603220722448499782664094942993128426674277214273437\" ] } ] } ----"}
{"title": "transactions.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"transaction_structure\"] = Transaction types Starknet supports the following types of transactions: * _invoke_ transaction * _declare_ transaction * _deploy_account_ transaction This topic describes the available fields for these transaction types and how each transaction hash is calculated. [IMPORTANT] ==== The `deploy` transaction has now been removed in the current release of Starknet. To deploy new contract instances, you can use the xref:Contracts/system-calls.adoc#deploy[deploy syscall]. ==== [id=\"transaction_versioning\"] == Transaction versioning Starknet supports the transaction versions described here. When the fields that comprise a transaction change, either with the addition of a new field or the removal of an existing field, then the transaction version increases. [WARNING] ==== Do not submit a transaction that uses an unsupported transaction type, because it cannot be included in a proof, and so cannot become part of a Starknet block. ==== [id=\"deploy_transaction\"] === Deploy transaction hash calculation In order to calculate the transaction hash, we first need to obtain the deployed contract address. The Deploy transaction's hash is calculated as follows: [stem] ++++ \\begin{aligned} \\text{deploy_tx_hash} = h( & \\text{\"deploy\"}, \\text{version}, \\text{ contract_address}, \\text{sn_keccak}(\\text{\"constructor\"}), \\\\ & h(\\text{constructor_calldata}), 0, \\text{chain_id}) \\end{aligned} ++++ Where: * The placeholder zero is used to align the hash computation for the different types of transactions. * \u201cdeploy\u201d and \u201cconstructor\u201d are constant strings encoded in ASCII. * stem:[$h$] is the xref:../Hashing/hash-functions.adoc#pedersen_hash[Pedersen] hash and stem:[$sn\\_keccak$] is xref:../Hashing/hash-functions.adoc#starknet_keccak[Starknet Keccak]. * `chain_id` is a constant value that specifies the network to which this transaction is sent. See xref:chain-id[Chain-Id]. * `contract_address` is calculated as described xref:../Contracts/contract-address.adoc[here]. == Invoke transaction The invoke transaction is the main transaction type used to invoke contract functions in Starknet. [IMPORTANT] ==== Invoke transaction version 0 is deprecated and will be removed in a future release of Starknet. ==== === Invoke v1 .Transaction fields [%autowidth] |=== | Name | Type | Description | `sender_address` | `FieldElement` | The address of the sender of this transaction. | `calldata` | `List` | The arguments that are passed to the `validate` and `execute` functions. | `signature` | `List` | Additional information given by the sender, used to validate the transaction. | `max_fee` | `FieldElement` | The maximum fee that the sender is willing to pay for the transaction | `nonce` | `FieldElement` | The transaction nonce. | `version` | `FieldElement` | The transaction's version. The value is 1. + When the fields that comprise a transaction change, either with the addition of a new field or the removal of an existing field, then the transaction version increases. |=== === v1 hash calculation The `invoke` v1 transaction hash is calculated as a hash over the given transaction elements, specifically: [stem] ++++ \\begin{aligned} \\text{invoke_v1_tx_hash} = h( & ``\\text{invoke\"}, \\text{version}, \\text{sender_address}, 0, h(\\text{calldata}), \\\\ & \\text{max_fee}, \\text{chain_id}, \\text{nonce}) \\end{aligned} ++++ Where: * stem:[\\text{invoke}] is a constant prefix string, encoded in ASCII. * The placeholder zero is used to align the hash computation for the different types of transactions. * stem:[\\text{chain_id}] is a constant value that specifies the network to which this transaction is sent. See xref:chain-id[Chain-Id]. * stem:[$h$] is the xref:../Hashing/hash-functions.adoc#pedersen_hash[Pedersen] hash === Deprecated features ==== v0 hash calculation The hash of a v0 invoke transaction is computed as follows: [stem] ++++ \\begin{aligned} \\text{invoke_v0_tx_hash} = h( & \\text{\"invoke\"}, \\text{version}, \\text{contract_address}, \\text{entry_point_selector}, \\\\ & h(\\text{calldata}), \\text{max_fee}, \\text{chain_id}) \\end{aligned} ++++ Where: * stem:[\\text{invoke}] is a constant prefix string, encoded in (ASCII). * stem:[\\text{chain_id}] is a constant value that specifies the network to which this transaction is sent. See xref:chain-id[Chain-Id]. * stem:[$h$] is the xref:../Hashing/hash-functions.adoc#pedersen_hash[Pedersen] hash == Declare transaction The declare transaction is used to introduce new classes into the state of Starknet, enabling other contracts to deploy instances of those classes or use them in a library call. For more information, see xref:../Contracts/contract-classes.adoc[contract classes]. [IMPORTANT] ==== New Cairo 1.0 classes can only be declared via the declare v2 transaction. v1 used to declare Cairo 0 classes are deprecated and will be removed in a future Starknet version. v0 is no longer supported. ==== [id=\"declare_v2\"] === Declare v2 // todo add flow for invoke /deploy transaction flows examples, from upcoming versions / account // abstraction./ Link to flow in AA section. .Transaction fields [%autowidth] |=== | Name | Type | Description | `chain_id` | `FieldElement` | The id of the chain to which the transaction is sent. | `contract_class` | `ContractClass` | The (Cairo 1.0) xref:Contracts/class-hash.adoc#definition_of_a_cairo_1_class[class]. | `compiled_class_hash` | `FieldElement` | The hash of the compiled class (see xrefstarknet_versions:upcoming_versions.adoc#what_to_expect[here] for more information) | `sender_address` | `FieldElement` | The address of the account initiating the transaction. | `signature` | `List` | Additional information given by the sender, used to validate the transaction. | `max_fee` | `FieldElement` | The maximum fee that the sender is willing to pay for the transaction. | `nonce` | `FieldElement` | The transaction nonce. | `version` | `FieldElement` | The transaction's version. The value is 1. + When the fields that comprise a transaction change, either with the addition of a new field or the removal of an existing field, then the transaction version increases. Transaction version 0 is deprecated and will be removed in a future version of Starknet. |=== === v2 hash calculation The hash of a v2 declare transaction is computed as follows: [stem] ++++ \\begin{aligned} \\text{declare_v2_tx_hash} = h( & \\text{\"declare\"}, \\text{version}, \\text{sender_address}, 0, \\text{class_hash}, \\text{max_fee}, \\text{chain_id}, \\\\ & \\text{nonce}, \\text{compiled_class_hash}) \\end{aligned} ++++ Where: * stem:[$h$] is the xrefarchitecture_and_concepts:Hashing/hash-functions.adoc#poseidon_hash[Poseidon hash function] * `class_hash` is the hash of the contract class. See xref:Contracts/class-hash.adoc#computing_the_cairo_1_class_hash[Class Hash] for details about how the hash is computed * `compiled_class_hash` is the hash of the xrefupcoming_versions.adoc#what_to_expect[compiled class] generated by the Sierra->Casm compiler which is currently used in Starknet === Deprecated features [IMPORTANT] ==== These old versions used to declare Cairo 0 classes are deprecated and will be removed in a future Starknet version. ==== ==== Declare v1 .Transaction fields [%autowidth] |=== | Name | Type | Description | `contract_class` | `ContractClass` | The class object. | `sender_address` | `FieldElement` | The address of the account initiating the transaction. | `max_fee` | `FieldElement` | The maximum fee that the sender is willing to pay for the transaction. | `signature` | `List` | Additional information given by the sender, used to validate the transaction. | `nonce` | `FieldElement` | The transaction nonce. | `version` | `FieldElement` | The transaction's version. Possible values are 1 or 0. + When the fields that comprise a transaction change, either with the addition of a new field or the removal of an existing field, then the transaction version increases. Transaction version 0 is deprecated and will be removed in a future version of Starknet. |=== ==== v1 hash calculation The hash of a v1 declare transaction is computed as follows: [stem] ++++ \\begin{aligned} \\text{declare_v1_tx_hash} = h( & \\text{\"declare\"}, \\text{version}, \\text{sender_address}, 0, \\text{class_hash}, \\text{max_fee}, \\\\ & \\text{chain_id}, \\text{nonce}) \\end{aligned} ++++ Where: * stem:[\\text{declare}] is a constant prefix string, encoded in ASCII. * stem:[\\text{class_hash}] is the hash of the xref:../Contracts/contract-classes.adoc[contract class]. See xref:../Contracts/class-hash.adoc[Class Hash] for details about how the hash is computed. * The placeholder zero is used to align the hash computation for the different types of transactions. * stem:[\\text{chain_id}] is a constant value that specifies the network to which this transaction is sent. See xref:chain-id[Chain-Id]. * stem:[$h$] is the xref:../Hashing/hash-functions.adoc#pedersen_hash[Pedersen] hash ==== v0 hash calculation The hash of a v0 declare transaction is computed as follows: [stem] ++++ \\begin{aligned} \\text{declare_v0_tx_hash} = h( & \\text{\"declare\"}, \\text{version}, \\text{sender_address}, 0, 0, \\text{max_fee}, \\\\ & \\text{chain_id}, \\text{class_hash}) \\end{aligned} ++++ Where: * stem:[\\text{declare}] is a constant prefix string, encoded in ASCII. * The placeholder zeros are used to align the hash computation for the different types of transactions. * stem:[\\text{class_hash}] is the hash of the xref:../Contracts/contract-classes.adoc[contract class]. See xref:../Contracts/class-hash.adoc[Class Hash] for details about how the hash is computed. * stem:[\\text{chain_id}] is a constant value that specifies the network to which this transaction is sent. See xref:chain-id[Chain-Id]. * stem:[$h$] is the xref:../Hashing/hash-functions.adoc#pedersen_hash[Pedersen] hash ## Deploy account transaction Since xrefversion_notes.adoc#version0.10.1[StarkNet v0.10.1] the `deploy_account` transaction replaces the `deploy` transaction for deploying account contracts. To use it, you should first pre-fund your would-be account address so that you could pay the transaction fee (see xref:Account_Abstraction/deploying_new_accounts.adoc[here] for more details) . You can then send the `deploy_account` transaction. A `deploy_account` transaction has the following fields: .Deploy account fields [%autowidth] |=== | Name | Type | Description | `class_hash` | `FieldElement` | The hash of the desired account class. | `constructor_calldata` | `List` | The arguments to the account constructor. | `contract_address_salt` | `FieldElement` | A random salt that determines the xref:Contracts/contract-address.adoc[account address]. | `signature` | `List` | Additional information given by the sender, used to validate the transaction. | `max_fee` | `FieldElement` | The maximum fee that the sender is willing to pay for the transaction | `nonce` | `FieldElement` | The transaction nonce. | `version` | `FieldElement` | The transaction's version. The value is 1. + |=== === Deploy account hash calculation The hash of a `deploy_account` transaction is computed as follows: [stem] ++++ \\begin{aligned} \\text{deploy_account_tx_hash} = h( & \\text{\"deploy_account\"}, \\text{version}, \\text{contract_address}, 0, \\\\ & h(\\text{constructor_calldata}, \\text{class_hash}, \\text{contract_address_salt}), \\\\ & \\text{max_fee}, \\text{chain_id}, \\text{nonce}) \\end{aligned} ++++ == Signature While Starknet does not have a specific signature scheme built into the protocol, the Cairo language, in which smart contracts are written, does have an efficient implementation for ECDSA signature with respect to a xref:../Hashing/hash-functions.adoc#stark_curve[STARK-friendly curve]. The generator used in the ECDSA algorithm is stem:[G=\\left(g_x, g_y\\right)] where: stem:[g_x=874739451078007766457464989774322083649278607533249481151382481072868806602] stem:[g_y=152666792071518830868575557812948353041420400780739481342941381225525861407] [id=\"chain-id\"] == Chain-Id Starknet currently supports three chain IDs. Chain IDs are given as numbers, representing the ASCII encoding of specific constant strings, as illustrated by the following Python snippet: [source,python] ---- chain_id = int.from_bytes(value, byteorder=\"big\", signed=False) ---- Three constants are currently used: * `SN_MAIN` for Starknet's main network. * `SN_GOERLI` for Starknet's public testnet. * `SN_GOERLI2` for Starknet developers."}
{"title": "cairo-1-and-sierra.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"sierra\"] = Cairo 1.0 and Sierra Up until xrefstarknet_versions:upcoming_versions.adoc[Starknet Alpha v0.11.0] users would write contracts in Cairo 0 and compile them locally to Cairo assembly (or Casm for short). Next, the user would submit the compilation output (the xrefarchitecture_and_concepts:Contracts/contract-classes.adoc[contract class]) to the Starknet sequencer via a `declare` transaction. With Cairo 1.0, the contract class resulting from xrefarchitecture_and_concepts:Contracts/class-hash.adoc#cairo1_class[compiling Cairo 1.0] does not include Casm. Instead of Casm, it includes instructions in an intermediate representation called Sierra (Safe Intermediate Representation). This new contract class is then compiled by the sequencer, via the Sierra &rarr; Casm compiler, to generate the Cairo assembly associated with this class. == Why do we need Casm? Starknet is a validity rollup, which means that the execution inside every block needs to be proven, and this is where STARKs come in handy. However, STARK proofs can address statements that are formulated in the language of polynomial constraints, and have no knowledge of smart contract execution. To overcome this gap, we developed link: Cairo instructions (which we referred to previously as Casm) are translated to polynomial constraints that enforce the correct execution of a program (according to semantics the of Cairo). Thanks to Cairo, we can formulate the statement \"this Starknet block is valid\" in a way that we can prove. Note that we can only prove things about Casm. That is, regardless of what the user sends to the Starknet sequencer, what's proven is the correct Casm execution. This means that we need a way to translate Sierra into Casm, and this is achieved with the Sierra &rarr; Casm compiler. == Why do we need Sierra? To understand why we chose to add an additional layer between the code that the user writes (Cairo 1.0) and the code that is being proven (Casm), we need to consider more components in the system and the limitations of Cairo. === Reverted transactions, unsatisfiable AIRs, and DOS attacks A crucial property of every decentralized L2 is that the sequencers are guaranteed to be compensated for the work they do. The notion of reverted transactions is a good example: even if the user's transaction failed mid-execution, the sequencer should be able to include it in a block and charge execution fees up to the point of failure. If the sequencer cannot charge for such transactions, then sending transactions that will eventually fail (after a lot of computation steps) is an obvious DOS attack on the sequencer. However, the sequencer cannot look at a transaction and conclude that it would fail without actually doing the work (this is equivalent to solving the undecidable halting problem). The obvious solution to the above predicament is to include such transactions in the block, similar to Ethereum. However, this may not be as simple to do in a validity rollup. With Cairo 0, there is no separating layer between the user code and what is being proven. This means that users can write code that is unprovable in some cases. In fact, such code is very easy to write, e.g. `assert 0=1` is a valid Cairo instruction that cannot be proven, as it translates to polynomial constraints that are not satisfiable. As such, any Casm execution that contains this instruction cannot be proven. Sierra is, therefore, the layer between the user code and the provable statement, that allows us to make sure all transactions are eventually provable. === Safe Casm The method by which Sierra guarantees that user code is always provable is by compiling Sierra instructions to a subset of Casm, which we call \"safe Casm\". The important property that we require from safe Casm is being provable for _all_ inputs. A canonical example of safe Casm is using `if/else` instructions instead of `assert`, i.e. making sure all failures are graceful. To better understand the considerations that go into designing the Sierra &rarr; Casm compiler, consider the `find_element` function from the common library of Cairo 0: [source,cairo] ---- func find_element{range_check_ptr}(array_ptr: felt*, elm_size, n_elms, key) -> (elm_ptr: felt*) { alloc_locals; local index; %{ ... %} assert_nn_le(a=index, b=n_elms - 1); tempvar elm_ptr = array_ptr + elm_size * index; assert [elm_ptr] = key; return (elm_ptr=elm_ptr); } ---- [NOTE] ==== Below we abuse the \"Casm\" notation by not distinguishing Cairo 0 from Casm and referring to the above as Casm (while we actually refer to the compilation result of the above). ==== For brevity, we have omitted the hint in the above snippet, but it's clear that this function can only execute correctly if the requested element exists in the array (otherwise it would fail for every possible hint, as there is nothing we can substitute `index` for that will make the following lines run successfully). Such Casm cannot be generated by the Sierra&rarr;Casm compiler. Furthermore, simply replacing the assertion with an if/else statement doesn't do, as this results in a non-deterministic execution (that is, different hint values can yield different results for the same input). A malicious prover can use this freedom to harm the user - in this example, they are able to make it seem as if an element isn't part of the array, even though it actually is. The safe Casm for finding an element in an array behaves like the above snippet in the happy flow (the element is there): an index is given in a hint, and we verify that the array at the hinted index contains the requested element. However, in the unhappy flow (the element isn't there), we *must* go over the entire array to verify this. This was not the case in Cairo 0, as we were fine with certain paths not being provable (in the above snippet, the unhappy flow in which the element isn't in the array is never provable). [NOTE] ==== Sierra's gas metering adds further complications to the above example. If we take gas limitations into consideration, the user may have enough gas for the happy flow, but not for the unhappy one, making the execution stop mid-search, and allowing the prover to get away with lying about the element not being present. The way we plan to handle this is by requiring the user to have enough gas for the unhappy flow before actually calling `find_element`. ==== === Hints in Cairo 1.0 Smart contracts written with Cairo 1.0 cannot contain user-defined hints. This is already somewhat true for Cairo 0 contracts (only whitelisted hints are accepted), but with Cairo 1.0 the hints in use are determined only by the Sierra &rarr; Casm compiler. Since this compilation is there to ensure that only safe Casm is generated, there is no room for hints that are not generated by the compiler. In the future, native Cairo 1.0 may contain hint syntax similar to Cairo 0, but it will not be available in Starknet smart contracts (such functionality may be used by link: on top of Starknet). Note that this is currently not part of Starknet's roadmap."}
{"title": "contract-syntax.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "# Contract syntax - migration guide With the link: release] of the Cairo compiler, the Starknet contract syntax has evolved. This affects how external functions, storage, and events are organized inside the contract. This page highlights the technical steps required to migrate from the old Starknet contract syntax to the new. For a comprehensive breakdown of the changes, see the link: forum post]. ## New contract syntax - concrete steps for migrating Given a contract written with the previous compiler version (v1.1.0), you can follow the steps below in order to make it compatible with the new syntax. ### Contract anotation Outside the contract module, Starknet related attributes are expected to have the `starknet::` prefix. [tabs] ==== old:: + [source,rust] ---- #[contract] mod CounterContract { ... } ---- new:: + [source,rust] ---- #[starknet::contract] mod CounterContract { ... } ---- ==== ### Storage anotation Anotate the `Storage` struct with the `#[storage]` attribute [tabs] ==== old:: + [source,rust] ---- struct Storage { counter: u128, other_contract: IOtherContractDispatcher } ---- new:: + [source,rust] ---- #[storage] struct Storage { counter: u128, other_contract: IOtherContractDispatcher } ---- ==== ### Contract interface Gather your contract\u2019s external and view function signatures under a trait annotated with `#[starknet::interface]`: * Add a generic parameter to the trait, here we use the name `TContractState` as it stands for the state of your contract * For view functions, add the `self: @TContractState` argument * For external functions, add the `ref self: TContractState` argument * Static functions that do not touch storage or emit events do not require an addition argument [tabs] ==== old:: + [source,rust] ---- #[contract] mod CounterContract { #[external] fn increase_counter(amount: u128) { ... } #[external] fn decrease_counter(amount: u128) { ... } #[view] fn get_counter() -> u128 { ... } } ---- new:: + [source,rust] ---- #[starknet::interface] trait ICounterContract { fn increase_counter(ref self: TContractState, amount: u128); fn decrease_counter(ref self: TContractState, amount: u128); fn get_counter(self: @TContractState) -> u128; } #[starknet::contract] mod CounterContract { ... } ---- ==== ### Add interface `Impl` Add the external and view function bodies under an impl of the interface trait, and mark the impl with the `[external(v0)]` attribute [tabs] ==== old:: + [source,rust] ---- #[contract] mod CounterContract { #[external] fn increase_counter(amount: u128) { ... } #[external] fn decrease_counter(amount: u128) { ... } #[view] fn get_counter() -> u128 { ... } } ---- new:: + [source,rust] ---- #[starknet::interface] trait ICounterContract { fn increase_counter(ref self: TContractState, amount: u128); fn decrease_counter(ref self: TContractState, amount: u128); fn get_counter(self: @TContractState) -> u128; } #[starknet::contract] mod CounterContract { #[external(v0)] impl CounterContract of super::ICounterContract { fn increase_counter(ref self: ContractState, amount: u128) { ... } fn decrease_counter(ref self: ContractState, amount: u128) { ... } fn get_counter(self: @ContractState) -> u128 { ... } } } ---- ==== ### Replace the `abi` attribute with `starknet::interface` These attributes are responsible for generating the dispatcher type, used to call the contract. Replace the `#[abi]` attribute with `#[starknet::interface]`. While it doesn't affect the generated code, we recommended adding to the trait a generic parameter `T` representing the contract's state, and adding the `ref self: T` argument to external functions and `self: @T` argument for view functions. [tabs] ==== old:: + [source,rust] ---- #[abi] trait IOtherContract { fn decrease_allowed() -> bool; } ---- new:: + [source,rust] ---- #[starknet::interface] trait IOtherContract { fn decrease_allowed(self: @TContractState) -> bool; } ---- ==== ### Storage access Modify storage access to happen through `ContractState` or `@ContractState` (none external functions in the contract that access storage also need to get it as an argument). [tabs] ==== old:: + [source,rust] ---- let current = counter::read(); ---- new:: + [source,rust] ---- let current = self.counter.read(); ---- ==== ### Events definition Unify all the contract's events under the `Event` enum, and add a corresponding struct for every variant (all the structs must derive the `Event` trait, and each member type has to implement the `Serde` trait) [tabs] ==== old:: + [source,rust] ---- #[event] fn counter_increased(amount: u128) {} #[event] fn counter_decreased(amount: u128) {} ---- new:: + [source,rust] ---- #[event] #[derive(Drop, starknet::Event)] enum Event { CounterIncreased: CounterIncreased, CounterDecreased: CounterDecreased } #[derive(Drop, starknet::Event)] struct CounterIncreased { amount: u128 } #[derive(Drop, starknet::Event)] struct CounterDecreased { amount: u128 } ---- ==== ### Events emition Emit events via the `ContractState` type [tabs] ==== old:: + [source,rust] ---- fn increase_counter(amount: u128) { ... counter_increased(amount); } ---- new:: + [source,rust] ---- fn increase_counter(ref self: ContractState, amount: u128) { ... self.emit(CounterIncreased { amount }); } ---- ===="}
{"title": "class-hash.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"contract_hash\"] = Class hash latexmath The class hash is a hash chain of the definition of the class. [id=\"cairo1_class\"] == Definition of a (Cairo 1) class Classes that were written in Cairo 1 are defined by their Sierra code ( resulting from the compilation of the Cairo code into Sierra, see xref:../Cairo_on_Starknet/cairo-1-and-sierra.adoc[here] for more details). The elements that define a class are: [horizontal,labelwidth=35] contract_class_version:: The version of the contract class object. Currently, the Starknet OS supports version 0.1.0 Array of external functions entry points:: An entry point is a pair `(_selector_, _function_idx_)`, where `_function_idx_` is the index of the function inside the Sierra program. + [NOTE] ==== The selector is an identifier through which the function is callable in transactions or in other classes. The selector is the xref:../Hashing/hash-functions.adoc#starknet_keccak[starknet_keccak] hash of the function name, encoded in ASCII. ==== Array of xrefarchitecture_and_concepts:L1-L2_Communication/messaging-mechanism.adoc#l1-l2_message_fees[L1 handlers] entry points :: - Array of constructors entry points:: Currently, the compiler allows only one constructor. ABI:: A string representing the ABI of the class. The ABI hash (which affects the class hash) is given by: + [source,python] ---- starknet_keccak(bytes(ABI, \"UTF-8\")) ---- + [NOTE] ==== This string is supplied by the user declaring the class (and is signed on as part of the `DECLARE` transaction), and is not enforced to be the true ABI of the associated class. Without seeing the underlying source code (i.e. the Cairo code generating the class's Sierra), this ABI should be treated as the \"intended\" ABI by the declaring party, which may be incorrect (intentionally or otherwise). The \"honest\" string would be the json serialization of the contract's ABI as produced by the Cairo 1 compiler. ==== Sierra program:: An array of field elements representing the Sierra instructions. === Computing the (Cairo 1) class hash The hash of the class is the chain hash of its components, computed as follows: [stem] ++++ \\begin{aligned} \\text{class_hash} = h( & \\text{contract_class_version}, \\\\& \\text{external_entry_points}, \\\\& \\text{l1_handler_entry_points}, \\\\& \\text{constructor_entry_points}, \\\\ & \\text{abi_hash}, \\\\&\\text{sierra_program_hash}) \\end{aligned} ++++ Where * stem:[$h$] is the xref:../Hashing/hash-functions.adoc#poseidon_hash[Poseidon] hash function * The hash of an entry point array stem:[$(selector,index)_{i=1}^n$] is given by stem:[$h(\\text{selector}_1,\\text{index}_1,...,\\text{selector}_n,\\text{index}_n)$] * The `sierra_program_hash` is the xref:../Hashing/hash-functions.adoc#poseidon_hash[Poseidon] hash of the bytecode array [NOTE] ==== The Starknet OS currently supports contract class version 0.1.0, which is represented in the above hash computation as the ASCII encoding of the string `CONTRACT_CLASS_V0.1.0` (hashing the version in this manner gives us domain separation between the hashes of classes and other objects). ==== For more details, see the implementation]. == Definition of a (Cairo 0) class [IMPORTANT] ==== Cairo 0 classes are deprecated, and will no longer be supported after regenesis. ==== The elements that define a class are: [horizontal,labelwidth=35] API version:: The version of the class, currently always 0. Array of external functions entry points:: An entry point is a pair `(_selector_, _offset_)`, where `_offset_` is the offset of the instruction that should be called inside the class's bytecode. + [NOTE] ==== The selector is an identifier through which the function is callable in transactions or in other classes. The selector is the xref:../Hashing/hash-functions.adoc#starknet_keccak[starknet_keccak] hash of the function name, encoded in ASCII. ==== Array of xrefarchitecture_and_concepts:L1-L2_Communication/messaging-mechanism.adoc#l1-l2_messages[L1 handlers] entry points :: - Array of constructors entry points:: Currently, the compiler allows only one constructor. Array of used builtin names:: An ASCII-encode array, ordered by declaration. Program hash:: The xref:../Hashing/hash-functions.adoc#starknet_keccak[starknet_keccak] of the class's program. The class's program is the abi and program part of the `.json` file that the Starknet compiler outputs when you run the following command: + [source,shell] ---- $ starknet-compile --no_debug_info ---- + The compiler outputs the abi, entrypoint selectors, and program. For the program hash, only the `starknet_keccak` of the abi and program needs to be calculated. To see the exact computation of this field, see Bytecode:: Represented by an array of field elements. === Computing the (Cairo 0) class hash The hash of the class is the chain hash of its components, computed as follows: [stem] ++++ \\begin{aligned} \\text{class_hash} = h( & \\text{api_version}, \\\\& \\text{external_entry_points}, \\\\& \\text{l1_handler_entry_points}, \\\\& \\text{constructor_entry_points}, \\\\ & \\text{builtin_names}, \\\\& \\text{program_hash}, \\\\& \\text{bytecode_hash}) \\end{aligned} ++++ Where * stem:[$h$] is the xref:../Hashing/hash-functions.adoc#pedersen_hash[Pedersen] hash function * The hash of an entry point array stem:[$(\\text{selector},\\text{offset})_{i=1}^n$] is given by stem:[$h(\\text{selector}_1,\\text{offset}_1,...,\\text{selector}_n,\\text{offset}_n)$] * The `program_hash` is the `starknet_keccak` of the json described above * The `bytecode_hash` is the xref:../Hashing/hash-functions.adoc#pedersen_hash[Pedersen] hash of the bytecode array"}
{"title": "contract-abi.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"contract_abi\"] = Contract ABI Contract ABI is a representation of a Starknet contract's interface. It is formatted as JSON and describes the functions, structs and events which are defined in the contract. You can get the contract's ABI by compiling: [tabs] ==== Cairo 0:: + [source,bash] ---- starknet-compile contract.cairo \\ --output contract_compiled.json \\ --abi contract_abi.json ---- Cairo 1.0:: + [source,bash] ---- cargo run --bin starknet-compile -- /path/to/input.cairo /path/to/output.json ---- ==== The following is an example contract ABI: [tabs] ==== Cairo 0:: + [source,json] ---- [ { \"members\": [ { \"name\": \"x\", \"offset\": 0, \"type\": \"felt\" }, { \"name\": \"y\", \"offset\": 1, \"type\": \"felt\" } ], \"name\": \"Point\", \"size\": 2, \"type\": \"struct\" }, { \"members\": [ { \"name\": \"x\", \"offset\": 0, \"type\": \"felt\" }, { \"name\": \"p\", \"offset\": 1, \"type\": \"Point\" } ], \"name\": \"Test\", \"size\": 3, \"type\": \"struct\" }, { \"data\": [ { \"name\": \"a\", \"type\": \"felt\" }, { \"name\": \"b\", \"type\": \"felt\" } ], \"keys\": [], \"name\": \"status_update\", \"type\": \"event\" }, { \"inputs\": [ { \"name\": \"a_len\", \"type\": \"felt\" }, { \"name\": \"a\", \"type\": \"felt*\" } ], \"name\": \"constructor\", \"outputs\": [], \"type\": \"constructor\" }, { \"inputs\": [ { \"name\": \"user\", \"type\": \"felt\" } ], \"name\": \"extend_range\", \"outputs\": [], \"type\": \"function\" }, { \"inputs\": [ { \"name\": \"points_len\", \"type\": \"felt\" }, { \"name\": \"points\", \"type\": \"(felt, Point, Point)*\" } ], \"name\": \"input_arrays\", \"outputs\": [], \"type\": \"function\" }, { \"inputs\": [ { \"name\": \"nested_len\", \"type\": \"felt\" }, { \"name\": \"nested\", \"type\": \"Test*\" } ], \"name\": \"input_nested_arrays\", \"outputs\": [ { \"name\": \"res\", \"type\": \"felt\" } ], \"type\": \"function\" }, { \"inputs\": [ { \"name\": \"array_len\", \"type\": \"felt\" }, { \"name\": \"array\", \"type\": \"felt*\" } ], \"name\": \"output_arrays\", \"outputs\": [ { \"name\": \"array_len\", \"type\": \"felt\" }, { \"name\": \"array\", \"type\": \"felt*\" } ], \"type\": \"function\" }, { \"inputs\": [ { \"name\": \"points\", \"type\": \"(Point, Point)\" } ], \"name\": \"input_output_struct\", \"outputs\": [ { \"name\": \"res\", \"type\": \"Point\" } ], \"type\": \"function\" } ] ---- Cairo 1.0:: + [source,json] ---- [ { \"type\": \"function\", \"name\": \"constructor\", \"inputs\": [ { \"name\": \"name_\", \"type\": \"core::felt252\" }, { \"name\": \"symbol_\", \"type\": \"core::felt252\" }, { \"name\": \"decimals_\", \"type\": \"core::u8\" }, { \"name\": \"initial_supply\", \"type\": \"core::u256\" }, { \"name\": \"recipient\", \"type\": \"core::ContractAddress\" } ], \"outputs\": [], \"state_mutability\": \"external\" }, { \"type\": \"function\", \"name\": \"get_name\", \"inputs\": [], \"outputs\": [ { \"type\": \"core::felt252\" } ], \"state_mutability\": \"view\" }, { \"type\": \"function\", \"name\": \"get_symbol\", \"inputs\": [], \"outputs\": [ { \"type\": \"core::felt252\" } ], \"state_mutability\": \"view\" }, { \"type\": \"function\", \"name\": \"get_decimals\", \"inputs\": [], \"outputs\": [ { \"type\": \"core::u8\" } ], \"state_mutability\": \"view\" }, { \"type\": \"function\", \"name\": \"get_total_supply\", \"inputs\": [], \"outputs\": [ { \"type\": \"core::u256\" } ], \"state_mutability\": \"view\" }, { \"type\": \"function\", \"name\": \"balance_of\", \"inputs\": [ { \"name\": \"account\", \"type\": \"core::ContractAddress\" } ], \"outputs\": [ { \"type\": \"core::u256\" } ], \"state_mutability\": \"view\" }, { \"type\": \"function\", \"name\": \"allowance\", \"inputs\": [ { \"name\": \"owner\", \"type\": \"core::ContractAddress\" }, { \"name\": \"spender\", \"type\": \"core::ContractAddress\" } ], \"outputs\": [ { \"type\": \"core::u256\" } ], \"state_mutability\": \"view\" }, { \"type\": \"function\", \"name\": \"transfer\", \"inputs\": [ { \"name\": \"recipient\", \"type\": \"core::ContractAddress\" }, { \"name\": \"amount\", \"type\": \"core::u256\" } ], \"outputs\": [], \"state_mutability\": \"external\" }, { \"type\": \"function\", \"name\": \"transfer_from\", \"inputs\": [ { \"name\": \"sender\", \"type\": \"core::ContractAddress\" }, { \"name\": \"recipient\", \"type\": \"core::ContractAddress\" }, { \"name\": \"amount\", \"type\": \"core::u256\" } ], \"outputs\": [], \"state_mutability\": \"external\" }, { \"type\": \"function\", \"name\": \"approve\", \"inputs\": [ { \"name\": \"spender\", \"type\": \"core::ContractAddress\" }, { \"name\": \"amount\", \"type\": \"core::u256\" } ], \"outputs\": [], \"state_mutability\": \"external\" }, { \"type\": \"function\", \"name\": \"increase_allowance\", \"inputs\": [ { \"name\": \"spender\", \"type\": \"core::ContractAddress\" }, { \"name\": \"added_value\", \"type\": \"core::u256\" } ], \"outputs\": [], \"state_mutability\": \"external\" }, { \"type\": \"function\", \"name\": \"decrease_allowance\", \"inputs\": [ { \"name\": \"spender\", \"type\": \"core::ContractAddress\" }, { \"name\": \"subtracted_value\", \"type\": \"core::u256\" } ], \"outputs\": [], \"state_mutability\": \"external\" }, { \"type\": \"event\", \"name\": \"Transfer\", \"inputs\": [ { \"name\": \"from\", \"type\": \"core::ContractAddress\" }, { \"name\": \"to\", \"type\": \"core::ContractAddress\" }, { \"name\": \"value\", \"type\": \"core::u256\" } ] }, { \"type\": \"event\", \"name\": \"Approval\", \"inputs\": [ { \"name\": \"owner\", \"type\": \"core::ContractAddress\" }, { \"name\": \"spender\", \"type\": \"core::ContractAddress\" }, { \"name\": \"value\", \"type\": \"core::u256\" } ] } ] ---- ==== [NOTE] ==== The Cairo 0 compiler is no longer maintained, see link: for more details on Cairo 1 contracts compilation. ===="}
{"title": "contract-address.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"contract_address\"] = Contract address The contract address is a unique identifier of the contract on Starknet. It is a chain hash of the following information: * `prefix` - the ASCII encoding of the constant string \"`STARKNET_CONTRACT_ADDRESS`\" * `caller_address` - currently always zero * `salt` - part of the xref:../Blocks/transactions.adoc#deploy-transaction[deploy transaction] * `contract_hash` - see xref:./class-hash.adoc[the docs] * `calldata_hash` - xref:../Hashing/hash-functions.adoc#array_hashing[array hash] of the inputs to the constructor The computation is roughly the following: [source,js] ---- contract_address := pedersen( \u201cSTARKNET_CONTRACT_ADDRESS\u201d, caller_address, salt, pedersen(contract_code), pedersen(constructor_calldata)) ---- You can find the address computation on our repo"}
{"title": "contract-classes.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"contract_classes\"] = Contract Classes Taking inspiration from object-oriented programming, Starknet distinguishes between a contract and its implementation by separating contracts into classes and instances. A contract class is the definition of the contract: Cairo byte code, hint information, entry point names, and everything that defines its semantics unambiguously. Each class is identified by its xrefContracts/class-hash.adoc[class hash], which is analogous to a class name in an object-oriented programming language. A contract instance is a deployed contract corresponding to a class. Notice that only contract instances behave as contracts in that they have their own storage and can be called by transactions or other contracts. A contract class does not necessarily have a deployed instance in Starknet. [id=\"using_classes\"] == Using Classes New classes can be added to the state of Starknet with the xref:../Blocks/transactions.adoc#declare_transaction[`declare`] transaction. New instances of a previously declared class can be deployed via the xrefContracts/system-calls.adoc#deploy[`deploy`] system call. To use the functionality of a declared class, without deploying an instance of that class, you can use the xref:Contracts/system-calls.adoc#library_call[`library_call`] system call. This system call is an analogue of Ethereum's delegate call in the world of classes. You can use class code directly, instead of having a placeholder contract deployed, which is used only for its code."}
{"title": "contract-storage.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"contract_storage\"] = Contract storage [id=\"storage_layout\"] == Storage layout The contract's storage is a persistent storage space where you can read, write, modify, and persist data. The storage is a map with stem:[$2^{251}$] slots, where each slot is a felt which is initialized to 0. [id=\"storage_low_level_functions\"] == Storage low level functions The basic function for writing to storage writes value to key is: [tabs] ==== Cairo 0:: + [source,js] ---- storage_write(key, value); ---- Cairo 1.0:: + [source,js] ---- storage_write_syscall(address_domain, address, value) ---- ==== // todo add description explaining what address_domain is Both are system calls that can be imported by adding the line: [tabs] ==== Cairo 0:: + [source,javascript] ---- from starkware.starknet.common.syscalls import storage_read, storage_write ---- Cairo 1.0:: + [source,javascript] ---- use starknet::storage_read_syscall; use starknet::storage_write_syscall; ---- ==== Another basic function is used for getting the storage address, this function is created by the compiler when defining a storage variable, as explained below. This function returns the address of the storage variable. Below we discuss how this address is determined from the variable's name and keys. [id=\"storage_variables\"] == Storage variables The most common way for interacting with a contract's storage is through storage variables. The `@storage_var` decorator declares a variable that will be kept as part of the contract storage. The variable can consist of a single felt, or it can be a mapping from multiple arguments to a tuple of felts or structs. To use this variable, the `var.read(args)`, `var.write(args, value)` and `var.addr(args)` functions are automatically created by the `@storage_var` decorator, for reading the storage value, writing the storage value and getting the storage address, respectively. The Starknet contract compiler generates the Cairo code that maps the storage variable's name and argument values to an address -- so that it can be part of the generated proof. The address of a storage variable is computed as follows: * If it is a single value, then the address is `sn_keccak(variable_name)`, where variable_name is the ASCII encoding of the variable's name. * If it is a (nested) mapping, then the address of the value at key `+k_1,...,k_n+` is `+h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)+` where stem:[$h$] is the Pedersen hash and the final value is taken stem:[$\\bmod 2^{251}-256$] * If it is a mapping to complex values (e.g., tuples or structs), then this complex value lies in a continuous segment starting from the address calculated in the previous point. Note that 256 field elements is the current limitation on the maximal size of a complex storage value. * Note that when calling `var.addr(args)` for a storage variable with complex values, the returned value is the address of the first element in the storage. We can summarize the above as follows: `storage variable address := pedersen(keccak(variable name), keys)` In the following example we define a storage variables with complex values. [tabs] ==== Cairo 0:: + [source,js] ---- @storage_var func range(user : felt) -> (res : (felt, felt)): end ---- Cairo 1.0:: + [source,js] ---- struct Storage { name: felt252, symbol: felt252, decimals: u8, total_supply: u256, balances: LegacyMap::, allowances: LegacyMap::, } ---- ===="}
{"title": "system-calls-cairo0.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "= System Calls Writing smart contracts requires various associated operations, such as calling another contract or accessing the contract\u2019s storage, that standalone programs do not require. The Starknet contract language supports these operations by using system calls. System calls enable a contract to require services from the Starknet OS. You can use system calls in a function to get information that depends on the broader state of Starknet, which would otherwise be inaccessible, rather than local variables that appear in the function\u2019s scope. [id=\"getters\"] == Getters Below we describe the collection of system calls that can be used to get information regarding the block, transaction, or execution context during runtime (e.g. block number, account address, and caller address). [id=\"get_block_number\"] === `get_block_number` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func get_block_number{syscall_ptr : felt*}() -> (__block_number__ : felt) ---- [discrete] ==== Description Gets the number of the block in which the transaction is executed. [discrete] ==== Arguments None. [discrete] ==== Return values [horizontal,labelwidth=35] `_block_number_`:: The number of the block in which the transaction is executed. [discrete] ==== Common library link: [id=\"get_block_timestamp\"] === `get_block_timestamp` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func get_block_timestamp{syscall_ptr : felt*}() -> (__block_timestamp__ : felt) ---- [discrete] ==== Description Gets the timestamp of the block in which the transaction is executed. [discrete] ==== Arguments None. [discrete] ==== Return values [horizontal,labelwidth=35] `_block_timestamp_`:: The timestamp of the block in which the transaction is executed. [discrete] ==== Common library link: [id=\"get_caller_address\"] === `get_caller_address` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func get_caller_address{syscall_ptr : felt*}() -> (__caller_address__ : felt) ---- [discrete] ==== Description Returns the address of the calling contract, or 0 if the call was not initiated by another contract. [discrete] ==== Arguments None. [discrete] ==== Return values [horizontal,labelwidth=35] `__caller_address__`:: The address of the calling contract, or 0 if the call was not initiated by another contract. [discrete] ==== Common library link: [id=\"get_contract_address\"] === `get_contract_address` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func get_contract_address{syscall_ptr : felt*}() -> (__contract_address__ : felt) ---- [discrete] ==== Description Gets the address of the contract who raised the system call. [discrete] ==== Arguments None. [discrete] ==== Return values [horizontal,labelwidth=35] `_contract_address_`:: The address of the contract that raised the system call. [discrete] ==== Common library link: [id=\"get_sequencer_address\"] === `get_sequencer_address` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func get_sequencer_address{syscall_ptr : felt*}() -> (__sequencer_address__ : felt) ---- [discrete] ==== Description Returns the address of the sequencer that generated the current block. [discrete] ==== Arguments None. [discrete] ==== Return values [horizontal,labelwidth=35] `_sequencer_address_`:: The address of the sequencer that generated the current block. [discrete] ==== Common library link: [id=\"get_transaction_info\"] === `get_transaction_info` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func get_tx_info{syscall_ptr : felt*}() -> (__tx_info__ : TxInfo*) ---- [discrete] ==== Description Gets information about the original transaction. [discrete] ==== Arguments None. [discrete] ==== Return values [horizontal,labelwidth=35] `_tx_info_`:: The following information about the original transaction: + * The version of the transaction. * The address of the account that initiated this transaction. * The maximum fee that is allowed to be charged for the inclusion of this transaction. * The signature of the account that initiated this transaction. * The transaction's hash. * The intended chain id. [discrete] ==== Common library link: [id=\"call_contract\"] == `call_contract` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func call_contract{syscall_ptr : felt*}( __contract_address__ : felt, __function_selector__ : felt, __calldata_size__ : felt, __calldata__ : felt* ) -> (__retdata_size__ : felt, __retdata__ : felt*) ---- [discrete] ==== Description Calls a given contract. This system call expects the address of the called contract, a selector for a function within that contract, and call arguments. [discrete] ==== Arguments [horizontal,labelwidth=35] `_contract_address_`:: The address of the contract you want to call. `_function_selector_`:: A selector for a function within that contract. `_calldata_size_`:: The size, in number of felts, of the calldata. `_calldata_`:: The calldata. [discrete] ==== Return values [horizontal,labelwidth=35] `_retdata_size_`:: The size, in number of felts, of the return data. `_retdata_`:: The return data. [discrete] ==== Common library link: [NOTE] ==== This is considered a lower-level syntax for calling contracts. If the interface of the called contract is available, then you can use a more straightforward syntax. ==== [id=\"deploy\"] == `deploy` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func deploy{syscall_ptr : felt*}( __class_hash__ : felt, __contract_address_salt__ : felt, __constructor_calldata_size__ : felt, __constructor_calldata__ : felt*, __deploy_from_zero__: felt, ) -> (__contract_address__ : felt) ---- [discrete] ==== Description Deploys a new instance of a previously declared class. [discrete] ==== Arguments [horizontal,labelwidth=35] `_class_hash_`:: The class hash of the contract to be deployed. `_contract_address_salt_`:: The salt, an arbitrary value provided by the sender, used in the computation of the xref:Contracts/contract-address.adoc[contract's address]. `_constructor_calldata_size_`:: The number of arguments to pass to the constructor, equal to the number of felts in `_constructor_calldata_`. `_constructor_calldata_`:: The constructor's calldata. An array of felts. `__deploy_from_zero__`:: A flag used for the contract address computation. If set, the new contract's deployer address will be `0`. Otherwise, the caller's address will be used. [discrete] ==== Return values [horizontal,labelwidth=35] `_contract_address_`:: The address of the deployed contract. [discrete] ==== Common library link: [id=\"emit_event\"] == `emit_event` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func emit_event{syscall_ptr : felt*}(__keys_len__ : felt, __keys__ : felt*, __data_len__ : felt, __data__ : felt*) ---- [discrete] ==== Description Emits an event with a given set of keys and data. For more information, and for a higher-level syntax for emitting events, see xref:Events/starknet-events.adoc[Starknet events]. [discrete] ==== Arguments [horizontal,labelwidth=35] `_keys_len_`:: The number of keys in the event. Analogous to Ethereum's event topics, you can use the link: method to filter by these keys. `_keys_`:: The event's keys. `_data_len_`:: The number of data elements in the event. `_data_`:: The event's data. [discrete] ==== Return values None. [discrete] ==== Common library link: [discrete] ==== Example The following example emits an event with two keys, the `status` and `deposit` and three data elements: `1`, `2`, and `3`. [source,cairo] ---- let (keys : felt*) = alloc() assert keys[0] = 'status' assert keys[1] = 'deposit' let (data : felt*) = alloc() assert data[0] = 1 assert data[1] = 2 assert data[2] = 3 emit_event(2, keys, 3, data) ---- [id=\"library_call\"] == `library_call` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func library_call{syscall_ptr : felt*}( __class_hash__ : felt, __function_selector__ : felt, __calldata_size__ : felt, __calldata__ : felt* ) -> (__retdata_size__ : felt, __retdata__ : felt*) ---- [discrete] ==== Description Calls the requested function in any previously declared class. The class is only used for its logic. This system call replaces the known delegate call functionality from Ethereum, with the important difference that there is only one contract involved. [discrete] ==== Arguments [horizontal,labelwidth=35] `_class_hash_`:: The hash of the class you want to use. `_function_selector_`:: A selector for a function within that class. `_calldata_size_`:: The size, in number of felts, of the calldata. `_calldata_`:: The calldata. [discrete] ==== Return values [horizontal,labelwidth=35] `_retdata_size_`:: The size, in number of felts, of the return data. `_retdata_`:: The return data. [discrete] ==== Common library link: [id=\"library_call_l1_handler\"] == `library_call_l1_handler` [WARNING] ==== This system call is not currently not supported in Cairo 1.0. In practice, this was only used for proxy contracts, which in Cairo 1.0 can be implemented instead via the `replace_class` system call, making `library_call_l1_handler` redundant. ==== [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func library_call_l1_handler{syscall_ptr : felt*}( __class_hash__ : felt, __function_selector__ : felt, __calldata_size__ : felt, __calldata__ : felt* ) -> (__retdata_size__ : felt, __retdata__ : felt*) ---- [discrete] ==== Description Calls the requested L1 handler in any previously declared class. Same as the `library_call` system call, but also enables you to call an L1 handler that cannot otherwise be called directly. For more information, see Starknet's xref:L1-L2_Communication/messaging-mechanism.adoc#l1-l2_messages[messaging mechanism] (note that when you invoke an L1 handler with this system call, the sequencer does not consume an L1->L2 message). [TIP] ==== It is recommended to raise this system call only inside an L1 handler in order to use the logic inside an L1 handler of a different class. ==== [discrete] ==== Arguments [horizontal,labelwidth=35] `_class_hash_`:: The hash of the class you want to use. `_function_selector_`:: A selector for an L1 handler function within that class. `_calldata_size_`:: The size, in number of felts, of the calldata. `_calldata_`:: The calldata. [discrete] ==== Return values [horizontal,labelwidth=35] `_retdata_size_`:: The size, in number of felts, of the return data. `_retdata_`:: The return data. [discrete] ==== Common library link: [id=\"send_message_to_L1\"] == `send_message_to_L1` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func send_message_to_l1{syscall_ptr : felt*}( __to_address__ : felt, __payload_size__ : felt, __payload__ : felt* ) ---- [discrete] ==== Description Sends a message to L1. This system call includes the message parameters as part of the proof's output and exposes these parameters to the Starknet Core contract on L1 once the state update, including the transaction, is received. For more information, see Starknet's xref:L1-L2_Communication/messaging-mechanism.adoc[messaging mechanism]. [discrete] ==== Arguments [horizontal,labelwidth=35] `_to_address_`:: The recipient's L1 address. `_payload_size_`:: The size of the message payload. `_payload_`:: A pointer to an array containing the contents of the message. [discrete] ==== Return values None. [discrete] ==== Common library link: [discrete] ==== Example The following example sends a message whose content is `(1,2)` to the L1 contract whose address is `3423542542364363`. [source,cairo,subs=\"+quotes,+macros\"] ---- let payload = alloc() payload[0] = 1 payload[1] = 2 send_message_to_l1(3423542542364363,2,payload) ---- [id=\"replace_class\"] == `replace_class` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- replace_class(class_hash: felt) ---- [discrete] ==== Description Once `replace_class` is called, the class of the calling contract (i.e. the contract whose address is returned by `get_contract_address` at the time the syscall is called) will be replaced by the class whose hash is given by the class_hash argument. [NOTE] ==== After calling `replace_class`, the code currently executing from the old class will finish running. The new class will be used from the next transaction onwards or if the contract is called via the call_contract syscall in the same transaction (after the replacement). ==== [discrete] ==== Arguments [horizontal,labelwidth=35] `_class_hash_`:: The hash of the class you want to use as a replacement. [discrete] ==== Return values None. [discrete] ==== Common library link: [id=\"storage_read\"] == `storage_read` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func storage_read{syscall_ptr : felt*}(__address__ : felt) -> (__value__ : felt) ---- [discrete] ==== Description Gets the value of a key in the storage of the calling contract. This system call provides direct access to any possible key in storage, in contrast with `var.read()`, which enables you to read storage variables that are defined explicitly in the contract. For information on accessing storage by using the storage variables, see xref:./contract-storage.adoc#storage_variables[storage variables]. [discrete] ==== Arguments [horizontal,labelwidth=35] `_address_`:: The address of the storage key you want to read. [discrete] ==== Return values [horizontal,labelwidth=35] `_value_`:: The value of the key. [discrete] ==== Common library link: [discrete] ==== Example [source,cairo,subs=\"+quotes,+macros\"] ---- let value = storage_read(3534535754756246375475423547453) ---- [id=\"storage_write\"] == `storage_write` Sets the value of a key in the storage of the calling contract. [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func storage_write{syscall_ptr : felt*}(__address__ : felt, __value__ : felt) ---- [discrete] ==== Description Sets the value of a key in the storage of the calling contract. This system call provides direct access to any possible key in storage, in contrast with `var.write()`, which enables you to write to storage variables that are defined explicitly in the contract. For information on accessing storage by using the storage variables, see xref:./contract-storage.adoc#storage_variables[storage variables]. [discrete] ==== Arguments [horizontal,labelwidth=35] `_address_`:: The address of the storage key to which you want to write. `_value_`:: The value to write to the key. [discrete] ==== Return values None. [discrete] ==== Common library link:"}
{"title": "system-calls-cairo1.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "= System Calls Writing smart contracts requires various associated operations, such as calling another contract or accessing the contract's storage, that standalone programs do not require. The Starknet contract language supports these operations by using system calls. System calls enable a contract to require services from the Starknet OS. You can use system calls in a function to get information that depends on the broader state of Starknet, which would otherwise be inaccessible, rather than local variables that appear in the function's scope. [id=\"get_execution_info\"] == `get_execution_info` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn get_execution_info_syscall() -> SyscallResult> implicits( GasBuiltin, System ) nopanic; ---- [discrete] ==== Description Gets information about the original transaction. In Cairo 1.0, all block/transaction/execution context getters are batched into this single system call. [discrete] ==== Arguments None. [discrete] ==== Return values * A link: containing the execution info. [discrete] ==== Common library link: [id=\"call_contract\"] == `call_contract` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn call_contract_syscall( address: ContractAddress, entry_point_selector: felt252, calldata: Span ) -> SyscallResult> implicits(GasBuiltin, System) nopanic; ---- [discrete] ==== Description Calls a given contract. This system call expects the address of the called contract, a selector for a function within that contract, and call arguments. [discrete] ==== Arguments [horizontal,labelwidth=35] `_address_`:: The address of the contract you want to call. `_entry_point_selector_`:: A selector for a function within that contract. `_calldata_`:: The calldata array. [discrete] ==== Return values * The call response, of type `SyscallResult>`. [discrete] ==== Common library link: [NOTE] ==== This is considered a lower-level syntax for calling contracts. If the interface of the called contract is available, then you can use a more straightforward syntax. ==== [id=\"deploy\"] == `deploy` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn deploy_syscall( class_hash: ClassHash, contract_address_salt: felt252, calldata: Span, deploy_from_zero: bool, ) -> SyscallResult)> implicits(GasBuiltin, System) nopanic; ---- [discrete] ==== Description Deploys a new instance of a previously declared class. [discrete] ==== Arguments [horizontal,labelwidth=35] `_class_hash_`:: The class hash of the contract to be deployed. `_contract_address_salt_`:: The salt, an arbitrary value provided by the sender, used in the computation of the xref:Contracts/contract-address.adoc[contract's address]. `_calldata_`:: The constructor's calldata. An array of felts. `_deploy_from_zero_`:: A flag used for the contract address computation. If not set, the caller address will be used as the new contract's deployer address, otherwise 0 is used. .Return values * A tuple wrapped with `SyscallResult` where: ** The first element is the address of the deployed contract, of type `ContractAddress`. ** The second element is the response array from the contract's constructor, of type `Span::`. [discrete] ==== Common library link: [id=\"emit_event\"] == `emit_event` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn emit_event_syscall( keys: Span, data: Span ) -> SyscallResult implicits(GasBuiltin, System) nopanic; ---- [discrete] ==== Description Emits an event with a given set of keys and data. For more information, and for a higher-level syntax for emitting events, see xref:Events/starknet-events.adoc[Starknet events]. [discrete] ==== Arguments [horizontal,labelwidth=35] `_keys_`:: The event's keys. These are analogous to Ethereum's event topics, you can use the link: method to filter by these keys. `_data_`:: The event's data. [discrete] ==== Return values None. [discrete] ==== Common library link: [discrete] ==== Example The following example emits an event with two keys, the strings `status` and `deposit` and three data elements: `1`, `2`, and `3`. [source,cairo] ---- let keys = ArrayTrait::new(); keys.append('key'); keys.append('deposit'); let values = ArrayTrait::new(); values.append(1); values.append(2); values.append(3); emit_event_syscall(keys, values).unwrap_syscall(); ---- [id=\"library_call\"] == `library_call` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn library_call_syscall( class_hash: ClassHash, function_selector: felt252, calldata: Span ) -> SyscallResult> implicits(GasBuiltin, System) nopanic; ---- [discrete] ==== Description Calls the requested function in any previously declared class. The class is only used for its logic. This system call replaces the known delegate call functionality from Ethereum, with the important difference that there is only one contract involved. [discrete] ==== Arguments [horizontal,labelwidth=35] `_class_hash_`:: The hash of the class you want to use. `_function_selector_`:: A selector for a function within that class. `_calldata_`:: The calldata. [discrete] ==== Return values * The call response, of type `SyscallResult>`. [discrete] ==== Common library link: [id=\"send_message_to_L1\"] == `send_message_to_L1` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn send_message_to_l1_syscall( to_address: felt252, payload: Span ) -> SyscallResult implicits(GasBuiltin, System) nopanic; ---- [discrete] ==== Description Sends a message to L1. This system call includes the message parameters as part of the proof's output and exposes these parameters to the Starknet Core contract on L1 once the state update, including the transaction, is received. For more information, see Starknet's xref:L1-L2_Communication/messaging-mechanism.adoc[messaging mechanism]. [discrete] ==== Arguments [horizontal,labelwidth=35] `_to_address_`:: The recipient's L1 address. `_payload_`:: The array containing the message payload [discrete] ==== Return values None. [discrete] ==== Common library link: [discrete] ==== Example The following example sends a message whose content is `(1,2)` to the L1 contract whose address is `3423542542364363`. [source,cairo,subs=\"+quotes,+macros\"] ---- let payload = ArrayTrait::new(); payload.append(1); payload.append(2); send_message_to_l1_syscall(payload).unwrap_syscall(); ---- [id=\"replace_class\"] == `replace_class` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn replace_class_syscall( class_hash: ClassHash ) -> SyscallResult implicits(GasBuiltin, System) nopanic; ---- [discrete] ==== Description Once `replace_class` is called, the class of the calling contract (i.e. the contract whose address is returned by `get_contract_address` at the time the syscall is called) will be replaced by the class whose hash is given by the class_hash argument. [NOTE] ==== After calling `replace_class`, the code currently executing from the old class will finish running. The new class will be used from the next transaction onwards or if the contract is called via the `call_contract` syscall in the same transaction (after the replacement). ==== [discrete] ==== Arguments [horizontal,labelwidth=35] `_class_hash_`:: The hash of the class you want to use as a replacement. [discrete] ==== Return values None. [discrete] ==== Common library link: [id=\"storage_read\"] == `storage_read` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn storage_read_syscall( address_domain: u32, address: StorageAddress, ) -> SyscallResult implicits(GasBuiltin, System) nopanic; ---- [discrete] ==== Description Gets the value of a key in the storage of the calling contract. This system call provides direct access to any possible key in storage, in contrast with `var.read()`, which enables you to read storage variables that are defined explicitly in the contract. For information on accessing storage by using the storage variables, see xref:./contract-storage.adoc#storage_variables[storage variables]. [discrete] ==== Arguments [horizontal,labelwidth=35] `_address_domain_`:: The domain of the key, used to separate between different data availability modes. This separation is used in Starknet to offer different data availability modes. Currently, only the on-chain mode (where all updates go to L1), indicated by domain `0`, is supported. Other address domains which will be introduced in the future will behave differently in terms of publication (in particular, they will not be posted on L1, creating a tradeoff between cost and security). `_address_`:: The requested storage address. [discrete] ==== Return values * The value of the key, of type `SyscallResult`. [discrete] ==== Common library link: [discrete] ==== Example [source,cairo,subs=\"+quotes,+macros\"] ---- use starknet::storage_base_address_from_felt252; ... let storage_address = storage_base_address_from_felt252(3534535754756246375475423547453) storage_read_syscall(0, storage_address).unwrap_syscall() ---- [id=\"storage_write\"] == `storage_write` [discrete] ==== Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn storage_write_syscall( address_domain: u32, address: StorageAddress, value: felt252 ) -> SyscallResult implicits(GasBuiltin, System) nopanic; ---- [discrete] ==== Description Sets the value of a key in the storage of the calling contract. This system call provides direct access to any possible key in storage, in contrast with `var.write()`, which enables you to write to storage variables that are defined explicitly in the contract. For information on accessing storage by using the storage variables, see xref:./contract-storage.adoc#storage_variables[storage variables]. [discrete] ==== Arguments [horizontal,labelwidth=35] `_address_domain_`:: The domain of the key, used to separate between different data availability modes. This separation is used in Starknet to offer different data availability modes. Currently, only the on-chain mode (where all updates go to L1), indicated by domain `0`, is supported. Other address domains which will be introduced in the future will behave differently in terms of publication (in particular, they will not be posted on L1, creating a tradeoff between cost and security). `_address_`:: The requested storage address. `_value_`:: The value to write to the key. [discrete] ==== Return values None. .Common library link:"}
{"title": "system-calls.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "= System calls Starknet smart contracts are written in Cairo. However, Cairo is a general purpose language that you can use for much more than just contract language. For details, see link: \u2013 a Turing-complete STARK-friendly CPU architecture]. So writing smart contracts requires some operations, such as calling another contract or accessing the contract's storage, that standalone programs do not require. The Starknet contract language supports these operations by using system calls. System calls enable a contract to require services from the Starknet OS. You can use system calls in a function to get information that depends on the broader state of Starknet, which would otherwise be inaccessible, rather than local variables that appear in the function's scope. [id=\"getters\"] == getters (Cairo 0) Below we describe the collection of system calls that can be used to get information regarding the block, transaction or execution context during runtime (e.g. block number, account address, and caller address). [id=\"get_block_number\"] === `get_block_number` [source,cairo,subs=\"+quotes,+macros\"] ---- func get_block_number{syscall_ptr : felt*}() -> (__block_number__ : felt) ---- .Description Gets the number of the block in which the transaction is executed. .Arguments None. .Return values [horizontal,labelwidth=35] `_block_number_`:: The number of the block in which the transaction is executed. .Common library link: [id=\"get_block_timestamp\"] === `get_block_timestamp` .Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func get_block_timestamp{syscall_ptr : felt*}() -> (__block_timestamp__ : felt) ---- .Description Gets the timestamp of the block in which the transaction is executed. .Arguments None. .Return values [horizontal,labelwidth=35] '_block_timestamp_':: The timestamp of the block in which the transaction is executed .Common library link: .Common library [id=\"get_caller_address\"] === `get_caller_address` .Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func get_caller_address{syscall_ptr : felt*}() -> (__caller_address__ : felt) ---- .Description Returns the address of the calling contract, or 0 if the call was not initiated by another contract. .Arguments None. .Return values [horizontal,labelwidth=35] `__caller_address__`:: The address of the calling contract, or 0 if the call was not initiated by another contract. .Common library link: [id=\"get_contract_address\"] === `get_contract_address` .Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func get_contract_address{syscall_ptr : felt*}() -> (__contract_address__ : felt) ---- .Description Gets the address of the contract who raised the system call. .Arguments None. .Return values [horizontal,labelwidth=35] `_contract_address_`:: The address of the contract who raised the system call. .Common library link: [id=\"get_sequencer_address\"] === `get_sequencer_address` .Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func get_sequencer_address{syscall_ptr : felt*}() -> (__sequencer_address__ : felt) ---- .Description Returns the address of the sequencer that generated the current block. .Arguments None. .Return values [horizontal,labelwidth=35] `_sequencer_address_`:: The address of the sequencer that generated the current block. .Common library link: [id=\"get_transaction_info\"] ===`get_transaction_info` Gets information about the original transaction. .Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func get_tx_info{syscall_ptr : felt*}() -> (__tx_info__ : TxInfo*) ---- .Description Gets information about the original transaction. .Arguments None. .Return values [horizontal,labelwidth=35] `_tx_info_`:: The following information about the original transaction: + * the version of the transaction * the address of the account that initiated this transaction * the maximum fee that is allowed to be charged for the inclusion of this transaction * the signature of the account that initiated this transaction * the transaction's hash * the intended chain id .Common library link: == getters (Cairo 1.0) In Cairo 1.0, all block/transaction/execution context getters are batched into a single system call: `get_execution_info`. [id=\"get_execution_info\"] === `get_execution_info` .Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn get_execution_info_syscall() -> SyscallResult> implicits( GasBuiltin, System ) nopanic; ---- .Description Gets information about the original transaction. .Arguments None. .Return values [horizontal,labelwidth=35] `_ExecutionInfo_`:: A link: containing the execution info [id=\"call_contract\"] == `call_contract` .Description Calls a given contract. This system call expects the address of the called contract, a selector for a function within that contract, and call arguments. .Syntax [tabs] ==== Cairo 0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- func call_contract{syscall_ptr : felt*}( __contract_address__ : felt, __function_selector__ : felt, __calldata_size__ : felt, __calldata__ : felt* ) -> (__retdata_size__ : felt, __retdata__ : felt*) ---- Cairo 1.0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn call_contract_syscall( address: ContractAddress, entry_point_selector: felt252, calldata: Span ) -> SyscallResult> implicits(GasBuiltin, System) nopanic; ---- ==== .Arguments [horizontal,labelwidth=35] `_contract_address_`:: The address of the contract you want to call. `_function_selector_`:: A selector for a function within that contract. `_calldata_size_`:: The size, in number of felts, of the calldata. `_calldata_`:: The calldata. .Return values [horizontal,labelwidth=35] `_retdata_size_`:: The size, in number of felts, of the return data. `_retdata_`:: The return data. .Common library link: [NOTE] ==== This is considered a lower level syntax for calling contracts. If the interface of the called contract is available, then you can use a more straightforward syntax. ==== [id=\"deploy\"] == `deploy` .Syntax [tabs] ==== Cairo 0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- func deploy{syscall_ptr : felt*}( __class_hash__ : felt, __contract_address_salt__ : felt, __constructor_calldata_size__ : felt, __constructor_calldata__ : felt*, __deploy_from_zero__: felt, ) -> (__contract_address__ : felt) ---- Cairo 1.0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn deploy_syscall( class_hash: ClassHash, contract_address_salt: felt252, calldata: Span, deploy_from_zero: bool, ) -> SyscallResult)> implicits(GasBuiltin, System) nopanic; ---- ==== .Description Deploys a new instance of a previously declared class. .Arguments [horizontal,labelwidth=35] `_class_hash_`:: The class hash of the contract to be deployed `_contract_address_salt_`:: The salt, an arbitrary value provided by the sender, used in the computation of the xref:Contracts/contract-address.adoc[contract's address]. `_constructor_calldata_size_`:: The number of arguments to pass to the constructor, equal to the number of felts in `_constructor_calldata_`. `_constructor_calldata_`:: The constructor's calldata. An array of felts. `__deploy_from_zero__`:: A flag used for the contract address computation. If not set, the caller address will be used as the new contract's deployer address, otherwise 0 is used. .Return values [horizontal,labelwidth=35] `_contract_address_`:: The address of the deployed contract. .Common library link: [id=\"emit_event\"] == `emit_event` .Syntax [tabs] ==== Cairo 0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- func emit_event{syscall_ptr : felt*}(__keys_len__ : felt, __keys__ : felt*, __data_len__ : felt, __data__ : felt*) ---- Cairo 1.0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn emit_event_syscall( keys: Span, data: Span ) -> SyscallResult implicits(GasBuiltin, System) nopanic; ---- ==== .Description Emits an event with a given set of keys and data. For more information, and for a higher level syntax for emitting events, see xref:Events/starknet-events.adoc[Starknet events]. .Arguments [horizontal,labelwidth=35] `_keys_len_`:: The number of keys in the event. Analogous to Ethereum's event topics, you can use the link: method to filter by these keys. `_keys_`:: The event's keys `_data_len_`:: The number of data elements in the event. `_data_`:: The event's data .Return values None. .Common library link: .Example The following example emits an event with two keys, the `status` and `deposit` and three data elements: `1`, `2`, and `3`. [tabs] ==== Cairo 0:: + [source,cairo] ---- let (keys : felt*) = alloc() assert keys[0] = 'status' assert keys[1] = 'deposit' let (data : felt*) = alloc() assert data[0] = 1 assert data[1] = 2 assert data[2] = 3 emit_event(2, keys, 3, data) ---- Cairo 1:: + [source,cairo] ---- let keys = ArrayTrait::new(); keys.append('key'); keys.append('deposit'); let values = ArrayTrait::new(); values.append(1); values.append(2); values.append(3); emit_event_syscall(keys, values).unwrap_syscall(); ---- ==== [id=\"library_call\"] == `library_call` .Syntax [tabs] ==== Cairo 0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- func library_call{syscall_ptr : felt*}( __class_hash__ : felt, __function_selector__ : felt, __calldata_size__ : felt, __calldata__ : felt* ) -> (__retdata_size__ : felt, __retdata__ : felt*) ---- Cairo 1.0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn library_call_syscall( class_hash: ClassHash, function_selector: felt252, calldata: Span ) -> SyscallResult> implicits(GasBuiltin, System) nopanic; ---- ==== .Description Calls the requested function in any previously declared class. This system call replaces the known delegate call functionality from Ethereum, with the important difference that there is only one contract involved. The class is only used for its logic. .Arguments [horizontal,labelwidth=35] `_class_hash_`:: The hash of the class you want to use. `_function_selector_`:: A selector for a function within that class. `_calldata_size_`:: The size, in number of felts, of the calldata. `_calldata_`:: The calldata. .Return values [horizontal,labelwidth=35] `_retdata_size_`:: The size, in number of felts, of the return data. `_retdata_`:: The return data. .Common library link: [id=\"library_call_l1_handler\"] == `library_call_l1_handler` [WARNING] ==== This system call is not currently not supported in Cairo 1.0. In practice, this was only used for proxy contracts, which in Cairo 1.0 can be implemented instead via the `replace_class` system call, making `library_call_l1_handler` redundant. ==== .Syntax [source,cairo,subs=\"+quotes,+macros\"] ---- func library_call_l1_handler{syscall_ptr : felt*}( __class_hash__ : felt, __function_selector__ : felt, __calldata_size__ : felt, __calldata__ : felt* ) -> (__retdata_size__ : felt, __retdata__ : felt*) ---- .Description Calls the requested L1 handler in any previously declared class. Same as the `library_call` system call, but also enables you to call an L1 handler that cannot otherwise be called directly. For more information, see Starknet's xref:L1-L2_Communication/messaging-mechanism.adoc#l1-l2_messages[messaging mechanism]. When you invoke an L1 handler with this system call, the sequencer does not consume an L1->L2 message. This system call enables an L1 handler to use the logic inside an L1 handler in a different class. [TIP] ==== It is recommended to raise this system call only inside an L1 handler. ==== .Arguments [horizontal,labelwidth=35] `_class_hash_`:: The hash of the class you want to use. `_function_selector_`:: A selector for an L1 handler function within that class. `_calldata_size_`:: The size, in number of felts, of the calldata. `_calldata_`:: The calldata. .Return values [horizontal,labelwidth=35] `_retdata_size_`:: The size, in number of felts, of the return data. `_retdata_`:: The return data. .Common library link: [id=\"send_message_to_L1\"] == `send_message_to_L1` .Syntax [tabs] ==== Cairo 0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- func send_message_to_l1{syscall_ptr : felt*}( __to_address__ : felt, __payload_size__ : felt, __payload__ : felt* ) ---- Cairo 1.0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn send_message_to_l1_syscall( to_address: felt252, payload: Span ) -> SyscallResult implicits(GasBuiltin, System) nopanic; ---- ==== .Description Sends a message to L1. This system call includes the message parameters as part of the proof's output, and exposes these parameters to the Starknet Core contract on L1 once the state update, including the transaction, is received. For more information, see Starknet's xref:L1-L2_Communication/messaging-mechanism.adoc[messaging mechanism]. .Arguments [horizontal,labelwidth=35] `_to_address_`:: The recipient's L1 address. `_payload_size_`:: The size of the message payload. `_payload_`:: A pointer to an array containing the contents of the message. .Return values None. .Common library link: .Example The following example sends a message whose content is `(1,2)` to the L1 contract whose address is `3423542542364363`. [tabs] ==== Cairo 0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- let payload = alloc() payload[0] = 1 payload[1] = 2 send_message_to_l1(3423542542364363,2,payload) ---- Cairo 1:: + [source,cairo,subs=\"+quotes,+macros\"] ---- let payload = ArrayTrait::new(); payload.append(1); payload.append(2); send_message_to_l1_syscall(payload).unwrap_syscall(); ---- ==== [id=\"replace_class\"] == `replace_class` .Syntax [tabs] ==== Cairo 0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- replace_class(class_hash: felt) ---- Cairo 1.0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn replace_class_syscall( class_hash: ClassHash ) -> SyscallResult implicits(GasBuiltin, System) nopanic; ---- ==== .Description Once `replace_class` is called, the class of the calling contract (i.e. the contract whose address is returned by `get_contract_address` at the time the syscall is called) will be replaced by the class whose hash is given by the class_hash argument . [NOTE] ==== After calling `replace_class`, the code currently executing from the old class will finish running. The new class will be used from the next transaction onwards or if the contract is called via the call_contract syscall in the same transaction (after the replacement). ==== .Arguments [horizontal,labelwidth=35] `_class_hash_`:: The hash of the class you want to use as a replacement. .Return values None .Common library link: [id=\"storage_read\"] == `storage_read` .Syntax [tabs] ==== Cairo 0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- func storage_read{syscall_ptr : felt*}(__address__ : felt) -> (__value__ : felt) ---- Cairo 1.0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn storage_read_syscall( address_domain: u32, address: StorageAddress, ) -> SyscallResult implicits(GasBuiltin, System) nopanic; ---- ==== .Description Gets the value of a key in the storage of the calling contract. This system call provides direct access to any possible key in storage, in contrast with `balance.read()`, which enables you to read storage variables that are defined explicitly in the contract. For information on accessing storage by using the storage variables, see xref:./contract-storage.adoc#storage_variables[storage variables]. .Arguments [horizontal,labelwidth=35] `_address_`:: The address of the storage key you want to read. .Return values [horizontal,labelwidth=35] `_value_`:: The value of the key. .Common library link: .Example [tabs] ==== Cairo 0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- let value = storage_read(3534535754756246375475423547453) ---- Cairo 1.0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- use starknet::storage_base_address_from_felt252; ... let storage_address = storage_base_address_from_felt252(3534535754756246375475423547453) storage_read_syscall(0, storage_address).unwrap_syscall() ---- ==== [id=\"storage_write\"] == `storage_write` Sets the value of a key in the storage of the calling contract. .Syntax [tabs] ==== Cairo 0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- func storage_write{syscall_ptr : felt*}(__address__ : felt, __value__ : felt) ---- Cairo 1.0:: + [source,cairo,subs=\"+quotes,+macros\"] ---- extern fn storage_write_syscall( address_domain: u32, address: StorageAddress, value: felt252 ) -> SyscallResult implicits(GasBuiltin, System) nopanic; ---- ==== .Description Sets the value of a key in the storage of the calling contract. This system call provides direct access to any possible key in storage, in contrast with `balance.write()`, which enables you to write to storage variables that are defined explicitly in the contract. For information on accessing storage by using the storage variables, see xref:./contract-storage.adoc#storage_variables[storage variables]. .Arguments [horizontal,labelwidth=35] `_address_`:: The address of the storage key to which you want to write. .`_value_`:: The value to write to the key. .Return values None. .Common library link:"}
{"title": "on-chain-data.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"on_chain_data\"] = On-chain data [id=\"introduction\"] == Introduction In the current stage of the Alpha, Starknet operates in a ZK-Rollup mode. This means that upon the acceptance of a state update on-chain, the state diff between the previous and new state is sent as calldata to Ethereum. This data allows anyone that observes Ethereum to reconstruct the current state of Starknet. [NOTE] ==== To update the Starknet state on L1, it suffices to send a valid proof -- without information on the transactions or particular changes that this update caused. Consequently, more information must be provided in order to allow other parties to locally track Starknet's state. ==== == On-chain data: post v0.11.0 [id=\"v0.11.0_format\"] === v0.11.0 format The state diffs contain information on every contract whose storage was updated and additional information on contract deployments. For each affected contract, we have: * The contract address * A single word that encodes: ** class information flag (0 = Storage updates only / 1 = contract was deployed or replaced in this state update). When this flag is on, we will have an additional word before the storage updates section, which contains the new class hash ** nonce ** num_of_storage_updates See below for the expected format: [stem] ++++ \\underbrace{0\\cdots0}_{\\text{127 bits}}| \\underbrace{\\text{class information flag}}_{\\text{1 bit}}| \\underbrace{\\text{new nonce}}_{\\text{64 bits}}|{ \\underbrace{\\text{# of storage updates}}_{\\text{64 bits}}}_{\\text{LSB}} ++++ For each storage update: * key - the address inside the contract\u2019s storage where the value is updated * value - the new value Next, we have information about newly declared classes: * The # of (Cairo 1.0) classes that were declared in the block * For each class we have: ** The class hash ** xrefupcoming_versions.adoc[The compiled class hash] [id=\"v0.11.0_example\"] === v0.11.0 example Below we show an example of on chain data that was extracted from L1, and proceed to decode it according to the xrefarchitecture_and_concepts:Data_Availability/on-chain-data.adoc#v0.11.0_format [above format]. [source,json] ---- [ 1, 2019172390095051323869047481075102003731246132997057518965927979101413600827, 18446744073709551617, 100, 200, 1, 1351148242645005540004162531550805076995747746087542030095186557536641755046, 558404273560404778508455254030458021013656352466216690688595011803280448032 ] ---- * The first element, `1`, is the number of contracts whose state was updated * The second element, `2019172390095051323869047481075102003731246132997057518965927979101413600827`, is the address of the first (and only) contract whose state changed * The third element, `18446744073709551617`, which is stem:[$2^{64}+1$], encodes the following: ** The class information flag is `0`, that is, the contract was not just deployed or replaced, so we shouldn't treat the next word as the class hash ** The new nonce is `1` ** One storage cell was updated * The next two elements, `100` and `200` encode the storage update (the value of key `100` was set to `200`) * Next we have the new declare section: `1` means that we had a single xrefarchitecture_and_concepts:Blocks/transactions.adoc#declare_v2[declare v2] in this state update, and the next two elements encode xrefarchitecture_and_concepts:Contracts/class-hash.adoc[the class hash] and xrefupcoming_versions.adoc#what_to_expect[compiled class hash] of the declared class == On-chain data: pre v0.11.0 [id=\"pre_v0.11.0_format\"] === Pre v0.11.0 format The state diffs contain information on every contract whose storage was updated and additional information on contract deployments. Those differences are sent as `uint256[]` array as part of the calldata, and are encoded as follows: * Number of cells that encode contract deployments * For each deployed contract, we have: ** `contract_address` - the xref:../Contracts/contract-address.adoc[address] of the deployed contract ** `contract_hash` - the xref:../Contracts/class-hash.adoc[hash] of the class * Number of contracts whose storage is updated * For each such contract, we have: ** `contract_address` - the xref:../Contracts/contract-address.adoc[address] of the contract ** `num_of_storage_updates` - number of storage updates ** `nonce, num of storage updates ` - a uint256 value that encodes both the number of storage updates for that contract and the updated nonce: + [stem] ++++ \\underbrace{0\\cdots0}_{\\text{128 bits}} | \\underbrace{\\text{new nonce}}_{\\text{64 bits}} | {\\underbrace{\\text{# of storage updates}}_{\\text{64 bits}}}_{\\text{LSB}} ++++ ** For each storage update: *** `key` - the address inside the contract's storage where the value is updated *** `value` - the new value [id=\"pre_v0.11.0_example\"] === Pre v0.11.0 example Below we show an example of on chain data which was extracted from L1, and proceed to decode it according to the above format. [source,json] ---- [ 2, 2472939307328371039455977650994226407024607754063562993856224077254594995194, 1336043477925910602175429627555369551262229712266217887481529642650907574765, 5, 2019172390095051323869047481075102003731246132997057518965927979101413600827, 18446744073709551617, 5, 102, 2111158214429736260101797453815341265658516118421387314850625535905115418634, 2, 619473939880410191267127038055308002651079521370507951329266275707625062498, 1471584055184889701471507129567376607666785522455476394130774434754411633091, 619473939880410191267127038055308002651079521370507951329266275707625062499, 541081937647750334353499719661793404023294520617957763260656728924567461866, 2472939307328371039455977650994226407024607754063562993856224077254594995194, 1, 955723665991825982403667749532843665052270105995360175183368988948217233556, 2439272289032330041885427773916021390926903450917097317807468082958581062272, 3429319713503054399243751728532349500489096444181867640228809233993992987070, 1, 5, 1110, 3476138891838001128614704553731964710634238587541803499001822322602421164873, 6, 59664015286291125586727181187045849528930298741728639958614076589374875456, 600, 221246409693049874911156614478125967098431447433028390043893900771521609973, 400, 558404273560404778508455254030458021013656352466216690688595011803280448030, 100, 558404273560404778508455254030458021013656352466216690688595011803280448031, 200, 558404273560404778508455254030458021013656352466216690688595011803280448032, 300, 1351148242645005540004162531550805076995747746087542030095186557536641755046, 500 ] ---- * The first element, `2`, is the number of cells that encode contracts deployment. * The next two elements describe a single contract deployment with the following parameters: ** `contract_address`: + ---- 2472939307328371039455977650994226407024607754063562993856224077254594995194 ---- ** `contract_hash`: + ---- 1336043477925910602175429627555369551262229712266217887481529642650907574765 ---- * The next element, `5` (index 3 in the array), is the number of contracts whose storage was updated. We will take only the first contract as an example. ** `contract_address`: + ---- 2019172390095051323869047481075102003731246132997057518965927979101413600827 ---- ** Following the above contract address, we have `18446744073709551617` (index 8 in the array), which is stem:[$2^{64}+1$], thus: *** The new contract nonce is `1` *** One storage key is updated *** The value at key `5` was changed to `102` The next 4 contract storage updates are interpreted in the same manner. [id=\"extract_from_ethereum\"] == Extract from Ethereum The data described above is sent across several Ethereum transactions, each holding a part of this array as calldata. Each new Starknet block has its associated state diff transactions. You can find the code for extracting this data from Ethereum in repo]. Pathfinder is the first Starknet full node implementation. You may also take a look at the script] which extracts the same information."}
{"title": "starknet-events.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"starknet_events\"] = Starknet events latexmath A contract may emit events throughout its execution. Each event contains the following fields: * `from_address`: address of the contract emitting the events * `keys`: a list of field elements * `data`: a list of field elements The keys can be used for indexing the events, while the data may contain any information that we wish to log (note that we are dealing with two separate lists of possibly varying size, rather than a list of key-value pairs). [id=\"emitting_events\"] == Emitting events Events can be defined in a contract using the `@event` decorator. Once an event `E` has been defined, the compiler automatically adds the function `E.emit()`. The following example illustrates how an event is defined and emitted: [tabs] ==== Cairo 0:: + [source,js] ---- @event func message_received(a : felt, b: felt): end ---- Cairo 1.0:: + [source,js] ---- #[event] fn Transfer(from: ContractAddress, to: ContractAddress, value: u256) {} ---- ==== [tabs] ==== Cairo 0:: + [source,js] ---- message_received.emit(1, 2); ---- Cairo 1.0:: + [source,js] ---- Transfer(12345, 12345, 1) ---- ==== The emit function emits an event with a single key, which is an identifier of the event, given by stem:[$\\text{sn_keccak(event_name)}$], where stem:[$\\text{event_name}$] is the ASCII encoding of the event's name and stem:[$\\text{sn_keccak}$] is defined xref:../Hashing/hash-functions.adoc#starknet_keccak[here]. To emit custom keys, one should use the low level `emit_event` system call: [tabs] ==== Cairo 0:: + [source,js] ---- from starkware.starknet.common.syscalls import emit_event # ... let (keys : felt*) = alloc() assert keys[0] = 'status' assert keys[1] = 'deposit' let (data : felt*) = alloc() assert data[0] = 1 assert data[1] = 2 assert data[2] = 3 emit_event(2, keys, 3, data) ---- Cairo 1.0:: + [source,js] ---- use starknet::emit_event_syscall; let keys = ArrayTrait::new(); keys.append('key'); keys.append('deposit'); let values = ArrayTrait::new(); values.append(1); values.append(2); values.append(3); emit_event_syscall(keys, values).unwrap_syscall(); ---- ==== The above code emits an event with two keys, the \"status\" and \"deposit\" (think of those as identifiers of the event that can be used for indexing) and three data elments 1, 2, 3. [TIP] ==== When using the higher level `emit` syntax, the event's data may be of complex types, for example: [source,js] ---- struct Point: member x : felt member y : felt end @event func message_received(arr_len : felt, arr: felt*, p: Point): end # ... let (data : felt*) = alloc() assert data[0] = 1 assert data[1] = 2 let p = Point(3,4) message_received.emit(2, data, p) ---- ==== The emitted events are part of the xref:../Blocks/transaction-life-cycle.adoc#transaction_receipt[transaction receipt]. [id=\"event_abi\"] == Event ABI The event definition appears in the contract's ABI. It contains the list of data fields (name and type) and the list of the custom keys (that is, all keys except the event identifier discussed above). Below is an example of an event inside the ABI: [tabs] ==== Cairo 0:: + [source,json] ---- { \"data\": [ { \"name\": \"a\", \"type\": \"felt\" }, { \"name\": \"b\", \"type\": \"felt\" } ], \"keys\": [], \"name\": \"message_received\", \"type\": \"event\" } ---- Cairo 1.0:: + [source,json] ---- { \"type\": \"event\", \"name\": \"Transfer\", \"inputs\": [ { \"name\": \"from\", \"type\": \"core::ContractAddress\" }, { \"name\": \"to\", \"type\": \"core::ContractAddress\" }, { \"name\": \"value\", \"type\": \"core::u256\" } ] } ---- ==== [id=\"event_hash\"] == Event hash The event hash is given by: [stem] ++++ h(h(h(h(0,\\text{from_address}),\\text{keys_hash}),\\text{data_hash}),3) ++++ Where: * stem:[$\\text{keys_hash}$], stem:[$\\text{data_hash}$] are the hashes of the keys list and data list correspondingly (see xref:../Hashing/hash-functions.adoc#array_hashing[array hashing]). * stem:[$h$] is the xref:../Hashing/hash-functions.adoc#pedersen_hash[Pedersen] hash function. The event hashes are included in the xref:../Blocks/header.adoc[`event_commitment`] field of a block."}
{"title": "fee-mechanism.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "= Fee mechanism latexmath In this section, we will review Starknet Alpha fee mechanism. If you want to skip the motivation and deep dive into the mechanism, you can skip directly to the final xref:overall_fee[formula]. This section focuses on fees paid by an account on L2. For information about messaging fees that are paid on L1, see xref:../L1-L2_Communication/messaging-mechanism.adoc#l1-l2_message-fees[L1 \u2192 L2 message fees]. == Introduction Users can specify the maximum fee that they are willing to pay for a transaction via the `max_fee` xref:../Blocks/transactions.adoc[field]. The only limitation on the sequencer (enforced by the Starknet OS) is that the actual fee charged is bounded by `max_fee`, but for now, StarkWare's sequencer will only charge the fee required to cover the proof cost (potentially less than the max fee). Presently, the sequencer only takes into account L1 costs involving proof submission. There are two components affecting the L1 footprint of a transaction: * xref:computation[Computational complexity]: the heavier the transaction, the larger its portion in the proof verification cost. * xref:_on_chain_data[On chain data]: L1 calldata cost originating from xref:_on_chain_data[data availability] and L2\u2192L1 messages. == Fee units The fee is denominated in ETH (this may change in future versions). Each transaction is associated with a gas estimate (explained below), and combining this with the gas price yields the estimated fee. == How much fee is charged? High-level overview === Computation Let's analyze the correct metric for measuring transaction complexity. For simplicity, we will ignore Cairo's builtins for the sake of the explanation, and later see how to address them. ==== Without builtins Recall that a Cairo program execution yields an execution trace. When proving a Starknet block, we aggregate all the transactions appearing in that block to the execution trace. Starknet's prover generates proofs for execution traces, up to some maximal length stem:[$L$] (Derived from the specs of the proving machine and the desired proof latency). Tracking the execution trace length associated with each transaction is simple. Each assertion over field elements (such as verifying addition/multiplication over the field) requires the same, constant number of trace cells (this is where our \"`no-builtins`\" assumption kicks in! Obviously Pedersen occupies more trace cells than addition). Therefore, in a world without builtins, the fee of the transaction stem:[$tx$] is correlated with stem:[$\\text{TraceCells}[tx\\]/L$]. ==== Adding builtins The Cairo execution trace is separated -- and each builtin has its own slot. We have to mind this slot allocation when determining the fee. Let's go over a concrete example first. For example, imagine the following trace that the prover will occupy: [%autowidth] |=== | (up to) 500,000,000 Cairo Steps | (up to) 20,000,000 Pedersen hashes | (up to) 4,000,000 signature verifications | (up to) 10,000,000 range checks |=== The proof will be closed and sent to L1 when any of these components becomes full. It's important to realize that the division to builtins must be predetermined! We can't decide on the fly to have proof with 20,000,001 Pedersen and nothing else. Suppose, for example, that a transaction uses 10,000 Cairo steps and 500 Pedersen hashes. We can squeeze at most 40,000 such transactions into our hypothetical trace (20,000,000/500). Therefore, its gas price will be correlated with 1/40,000 of the cost of submitting proof. Notice we completely ignored the number of Cairo steps in this transaction performance estimation, as it is not the limiting factor (since 500,000,000/10,000 > 20,000,000/500). With this example in mind, we can now formulate the exact fee associated with L2 computation. ==== General case For each transaction, the sequencer calculates a vector `CairoResourceUsage` holding: * Number of Cairo steps * Number of applications of each Cairo builtin (e.g., five range checks and two Pedersen hashes) The sequencer crosses this information with the `CairoResourceFeeWeights` vector. For each resource type (step or a specific builtin application), `CairoResourceFeeWeights` has an entry that specifies the relative gas cost of that component in the proof. Going back to the above example, if the cost of submitting a proof with 20,000,000 Pedersen hashes is roughly 5m gas, then the weight of the Pedersen builtin is 0.25 gas per application (5,000,000/20,000,000). The sequencer has a pre-defined weights vector, in accordance with the proof parameters. The sequencer will charge only according to the limiting factor! Therefore the fee is correlated with: [stem] ++++ \\max_k[\\text{CairoResourceUsage}_k \\cdot \\text{CairoResourceFeeWeights}_k] ++++ Where stem:[$k$] here enumerates the Cairo resource components, i.e. the number of steps and builtins used. The weights are: [%autowidth] |=== | Cairo step | Pedersen |Poseidon | Range check | ECDSA | Bitwise | EC_OP | 0.01 gas/step | 0.32 gas/application | 0.32 gas/application | 0.16 gas/application | 20.48 gas/application | 0.64 gas/application | 10.24 gas/application |=== === On-chain data The on-chain data associated with a transaction is composed of three parts * Storage updates * L2\u2192L1 messages * Deployed contracts ==== Storage updates Whenever a transaction updates a key at the storage of some contract, the following xref:Data_Availability/on-chain-data.adoc[data] reaches L1: * Contract_address * Number of updated keys in that contract * Key to update * New value [NOTE] ==== Note that only the most recent value reaches L1. That is, the transaction's fee only depends on the number of *unique* storage updates (if the same storage cell is updated multiple times within the transaction, the fee remains that of a single update). ==== Consequently, the associated storage update fee for a transaction updating stem:[$n$] unique contracts and stem:[$m$] unique keys is: [stem] ++++ \\text{gas_price}\\cdot c_w\\cdot\\underbrace{(2n+2m)}_{\\text{number of words}} ++++ where stem:[$c_w$] is the calldata cost (in gas) per 32-byte word. [TIP] ==== Note that there are many possible improvements to the above pessimistic estimation that will be gradually presented in future versions of Starknet. For example, if different transactions within the same block update the same storage cell, there is no need to charge both of them (only the latest value reaches L1). In the future, Starknet may include a refund mechanism for such cases. ==== ==== L2\u2192L1 messages When a transaction that raises the `send_message_to_l1` syscall is included in a state update, the following xref:../Data_Availability/on-chain-data.adoc[data] reaches L1: * L2 sender address * L1 destination address * Payload size * Payload (list of field elements) Consequently, the fee associated with a single L2\u2192L1 message is: [stem] ++++ \\text{gas_price}\\cdot c_w\\cdot(3+\\text{payload_size}) ++++ where stem:[$c_w$] is the calldata cost (in gas) per 32-byte word. ==== Deployed contracts When a transaction that raises the `deploy` syscall is included in a state update, the following xref:../Data_Availability/on-chain-data.adoc#format[data] reaches L1: * Contract address * Class hash Consequently, the fee associated with a single deployment is: [stem] ++++ \\text{gas_price}\\cdot 2 c_w ++++ where stem:[$c_w$] is the calldata cost (in gas) per 32-byte word. == Overall fee The fee for a transaction with: * Cairo usage represented by the vector stem:[$v$] (the entries of stem:[$v$] correspond to the number of steps and number of applications per builtin) * stem:[$n$] unique contract updates * stem:[$m$] unique key updates * stem:[$t$] messages with payload sizes stem:[$q_1,...,q_t$] * stem:[$\\ell$] contract deployments is given by: [stem] ++++ F = \\text{gas_price}\\cdot\\left(\\max_k v_k w_k + c_w\\left(2(n+m) + 3t + \\sum\\limits_{i=1}^t q_i + 2\\ell\\right)\\right) ++++ where stem:[$w$] is the weights vector discussed xref:general_case[above] and stem:[$c_w$] is the calldata cost (in gas) per 32-byte word. == When is the fee charged? The fee is charged atomically with the transaction execution on L2. The Starknet OS injects a transfer of the fee-related ERC-20, with an amount equal to the fee paid, the sender equal to the transaction submitter, and the sequencer as a receiver."}
{"title": "hash-functions.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"hash_functions\"] = Hash functions latexmath [id=\"domain_and_range\"] == Domain and range All hashes outputs are eventually mapped to elements in stem:[$\\mathbb{F}_p$] with stem:[$p=2^{251}+17\\cdot 2^{192}+1$]. There are three hash functions used throughout Starknet's specifications: * stem:[$sn\\_keccak: \\{0,1\\}^* \\rightarrow \\mathbb{F}_p$] * stem:[$pedersen: \\mathbb{F}_p^*\\rightarrow\\mathbb{F}_p$] * stem:[$poseidon: \\mathbb{F}_p^*\\rightarrow \\mathbb{F}_p$] [id=\"starknet_keccak\"] == Starknet Keccak Starknet keccak, usually denoted by stem:[$sn\\_keccak$], is defined as the first 250 bits of the Keccak256 hash (this is just Keccak256 truncated in order to fit into a field element). [id=\"pedersen_hash\"] == Pedersen hash [id=\"stark_curve\"] === STARK curve Pedersen hash makes use of the following STARK-friendly elliptic curve over stem:[$\\mathbb{F}_p$]: [stem] ++++ y^2=x^3+\\alpha x +\\beta ++++ where * stem:[$\\alpha=1$] * stem:[$\\beta = 3141592653589793238462643383279502884197169399375105820974944592307816406665$] [id=\"pedersen_definition\"] === Definition Given an input stem:[$(a,b)\\in\\mathbb{F}_p^2$], we begin by breaking it into stem:[$a_{low}, a_{high}, b_{low}, b_{high}$], where the low part consists of the low 248 bits of the element and the high part consists of the high 4 bits of the element. Our Pedersen hash is then defined by: [stem] ++++ h(a,b) = \\left[shift\\_point + a_{low} \\cdot P_0 + a_{high} \\cdot P1 + b_{low} \\cdot P2 + b_{high} \\cdot P3\\right]_x ++++ where the values of the constants stem:[$shift\\_point, P_0, P_1, P_2, P_3$] can be found in link: and stem:[$[P\\]_x$] denotes the stem:[$x$] coordinate of the point stem:[$P$] on the STARK curve. [id=\"pedersen_array_hash\"] === Array hashing Let stem:[$h$] denote the Pedersen hash function, then given an array stem:[$a_1,...,a_n$] of stem:[$n$] field elements we define stem:[$h(a_1,...,a_n)$] to be: [stem] ++++ h(...h(h(0, a_1),a_2),...,a_n),n) ++++ [id=\"poseidon_hash\"] == Poseidon [id=\"poseidon_definition\"] === Definition link: is a family of hash functions designed for being very efficient as algebraic circuits. As such, they may be very useful in ZK-proving systems such as STARKs and others. Poseidon is a sponge construction based on the Hades permutation. Starknet's version of Poseidon is based on a three-element state permutation (see exact parameters xref:#poseidon_resources[below]). We define the Poseidon hash of up to 2 elements as follows: [stem] ++++ poseidon_1(a) := \\left[\\text{hades_permutation}(a,0,1)\\right]_0 ++++ [stem] ++++ poseidon_2(a,b) := \\left[\\text{hades_permutation}(a,b,2)\\right]_0 ++++ Where latexmath:[[\\cdot\\]_j] denotes taking the j'th coordinate of a tuple. [id=\"poseidon_array_hash\"] === Array hashing Let stem:[$\\text{hades}$] denote the Hades permutation (with Starknet's parameters), then given an array stem:[$a_1,...,a_n$] of stem:[$n$] field elements we define stem:[$poseidon(a_1,...,a_n)$] to be the first coordinate of stem:[$H(a_1,...,a_n;0,0,0)$], where: [stem] ++++ H(a_1,...,a_n;s_1,s_2,s_3)=\\begin{cases} H\\big(a_3,...,a_n;\\text{hades}(s_1+a_1, s_2+a_2, s_3)\\big), & \\text{if } n\\ge 2 \\\\ \\text{hades}(s_1+a_1,s_2+1,s_3), & \\text{if } n=1 \\\\ \\text{hades}(s_1+1,s_2,s_3), & \\text{if } n=0 \\\\ \\end{cases} ++++ [id=\"poseidon_resources\"] === Useful resources * The exact link: defining the permutation used in Starknet. * Reference implementations in link: and assembly], link: and link:"}
{"title": "messaging-mechanism.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"messaging_mechanism\"] = L1-L2 messaging [id=\"l2-l1_messages\"] == L2 \u2192 L1 messages Contracts on L2 can interact asynchronously with contracts on L1 via the L2\u2192L1 messaging protocol. During the execution of a Starknet transaction, a contract on Starknet sends an L2\u2192L1 message by calling the syscall. The message parameters (which contain the recipient contract on L1 and the relevant data) are then attached to the relevant state update that includes this syscall invocation. For example: [source,js] ---- let (message_payload : felt*) = alloc() assert message_payload[0] = // potentially add more elements to message_payload (message_payload[1], message_payload[2], etc.) assert_lt_felt(to_address, ETH_ADDRESS_BOUND) assert_not_zero(to_address) send_message_to_l1(to_address=to_address, payload_size=1, payload=message_payload) ---- After the state update that included this transaction is proved and the L1 state is updated, the message is stored on L1 in the Starknet Core Contract (and the relevant counter is increased), and the `LogMessageToL1` event (which contains the message parameters) is emitted. Later, the recipient address on L1 can access and consume the message as part of an L1 transaction by re-supplying the message parameters. This is done by calling in the Starknet Core Contract, who verifies that the hash corresponds to a stored message and that the caller is indeed the recipient on L1. In such a case, the reference count of the message hash in the Starknet Core Contract decreases by 1. The above flow is illustrated in the following diagram: image::l2l1.png[l2l1] [id=\"structure_and_hashing_l2-l1\"] === L2 \u2192 L1 structure and hashing As demonstrated above, the structure of an L2 \u2192 L1 message is given by: .L2 \u2192 L1 Message [%autowidth] |=== | FromAddress | ToAddress | Payload | `FieldElement` | `EthereumAddress` | `Payload` |=== The hash of an L2 \u2192 L1 message is computed on L1 as follows: [source,js] ---- keccak256( abi.encodePacked( FromAddress, ToAddress, Payload.length, Payload ) ); ---- NOTE: As the hash of the message being sent needs to be written to L1 storage (in the Starknet Core contract) there is always a fixed 20k gas cost associated with sending an L2 to L1 message. [id=\"l1-l2_messages\"] == L1 \u2192 L2 messages Contracts on L1 can interact asynchronously with contracts on L2 via the L1\u2192L2 messaging protocol. The protocol consists of the following stages: . An L1 contract initiates a message to an L2 contract on Starknet. It does so by calling the link: function on the Starknet Core Contract with the message parameters. .. The Starknet Core Contract hashes the message parameters and updates the L1\u2192L2 message mapping to indicate that a message with this hash was indeed sent. In fact, the L1 contract records the fee that the sender paid. For more information, see xref:l1-l2_message_fees[L1 \u2192 L2 message fees]. . The message is then decoded into a Starknet transaction that invokes a function annotated with the `l1_handler` decorator on the target contract. Transactions like this on L2 are called *_L1 handler transactions_*. .. The Starknet sequencer, upon seeing enough L1 confirmations for the transaction that sent the message, initiates the corresponding L2 transaction. .. The L2 transaction invokes the relevant `l1_handler`. . The L1 Handler transaction that was created in the previous step is added to a proof. . The state update is received on the Core contract. . the message is cleared from the Core contract's storage. At this point, the message is handled. The above flow is illustrated in the following diagram: image::l1l2.png[l1l2] An L1\u2192L2 message consists of: * The L1 sender address * The recipient contract address on Starknet * Function selector * Calldata array * Message nonce [NOTE] ==== *Message nonce* The message nonce is maintained on the Starknet Core contract on L1, and is bumped whenever a message is sent to L2. It is used to avoid hash collisions between different L1 handler transactions that are induced by the same message being sent on L1 multiple times (see xref:structure_and_hashing_l1-l2[below]). ==== [id=\"l2-l1_message_cancellation\"] === L1 \u2192 L2 message cancellation Imagine a scenario where a user transfers an asset from L1 to L2. The flow starts with the user sending the asset to a Starknet bridge and the corresponding L1\u2192L2 message generation. Now, imagine that the L2 message consumption doesn't function (this might happen due to a bug in the dApp's Cairo contract). This could result in the user losing custody over their asset forever. To mitigate this risk, we allow the contract that initiated the L1\u2192L2 message to cancel it after declaring the intent and waiting a suitable amount of time. The user starts by calling with the relevant message parameters in the Starknet Core Contract. Then, after a five days delay, the user can finalize the cancellation by calling The reason for the delay is to protect the sequencer from a DOS attack in the form of repeatedly sending and canceling a message before it is included in L1, rendering the L2 block which contains the activation of the corresponding L1 handler invalid. Note that this flow should only be used in edge cases such as bugs on the Layer 2 contract preventing message consumption. [id=\"l1-l2_message_fees\"] === L1 \u2192 L2 message fees An L1 \u2192 L2 message induces a transaction on L2, which, unlike regular transactions, is not sent by an account. This calls for a different mechanism for paying the transaction's fee, for otherwise the sequencer has no incentive of including L1 handler transactions inside a block. To avoid having to interact with both L1 and L2 when sending a message, L1 \u2192 L2 messages are payable on L1, by sending ETH with the call to the payable function `sendMessageToL2` on the Starknet Core contract. The sequencer takes this fee in exchange for handling the message. The sequencer charges the fee in full upon updating the L1 state with the consumption of this message. The fee itself is calculated in the xref:../Fees/fee-mechanism.adoc#overall_fee[same manner] as \"regular\" L2 transactions. You can use the xrefCLI/commands.adoc#starknet_estimate_fee[CLI] to get an estimate of an L1 \u2192 L2 message fee. [id=\"structure_and_hashing_l1-l2\"] === L1 \u2192 L2 structure and hashing For completeness, we describe the precise structure of both the message as it appears on L1 and the induced transaction as it appears on L2. .L1 \u2192 L2 Message [%autowidth] |=== | FromAddress | ToAddress | Selector | Payload | Nonce | | `EthereumAddress` | `FieldElement` | `FieldElement` | `List++++++` | `FieldElement` | |=== The hash of the message is computed on L1 as follows: [source,js] ---- keccak256( abi.encodePacked( uint256(FromAddress), ToAddress, Nonce, Selector, Payload.length, Payload ) ); ---- .L1 handler transaction [%autowidth] |=== | Version | ContractAddress | Selector | Calldata | Nonce | | `FieldElement` | `FieldElement` | `FieldElement` | `List++++++` | `FieldElement` | |=== The hash of the corresponding L1 handler transaction on L2 is computed as follows: [stem] ++++ \\begin{aligned} \\text{l1_handler_tx_hash} = h( & \\text{\"l1_handler\"}, \\text{ version}, \\text{ contract_address}, \\text{ entry_point_selector}, \\\\ & h(\\text{ calldata}), \\text{ max_fee}, \\text{ chain_id}, \\text{ nonce}) \\end{aligned} ++++ Where: - stem:[\\text{l1_handler}] is a constant prefix, encoded in bytes (ASCII), with big-endian. - stem:[\\text{chain_id}] is a constant value that specifies the network to which this transaction is sent. See xref:../Blocks/transactions.adoc#chain-id[Chain-Id]. - stem:[$$h$$] is the xref:../Hashing/hash-functions.adoc#pedersen_hash[Pedersen] hash [NOTE] ==== In an `l1_handler` transaction, the first element of the calldata is always the Ethereum address of the sender. ===="}
{"title": "token-bridge.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"starkgate_token_bridge\"] = StarkGate bridge [id=\"starkgate_general_architecture\"] == StarkGate general architecture StarkGate is the EthereumStarknet token bridge developed by StarkWare. Each supported token is associated with an L1 and L2 bridge contract that is communicating via Starknet's messaging mechanism. The bridges facilitate a user's ability to conduct their transactions with their ETH and ERC-20 tokens that reside on L1, via the Starknet Alpha network and its STARK-based computational compression capabilities. For simplicity, we use terms such as \"`deposit`\", \"`transact`\", and \"`transfer`\" to refer to various operations involving a bridge, even though ETH and ERC20 tokens never actually leave Ethereum. [id=\"starkgate_alpha_limitations\"] == StarkGate Alpha limitations In order to reduce the risks involved in using an Alpha version, StarkGate Alpha on Mainnet has limitations involving the deposit amount and total value locked in the L1 bridge contract: [%autowidth] |=== | Token | Max total value locked | ETH | 80,000 ETH | DAI | 5,000,000 DAI | USDC | 40,000,000 USDC | USDT | 10,000,000 USDT | WBTC | 30 WBTC |=== [NOTE] ==== We plan to gradually ease these limitations and lift them completely, as confidence grows. Changes will be updated here, stay tuned. ==== [id=\"l1l2_transfer_deposit\"] == L1\u2192L2 transfer (deposit) [id=\"step_1_call_the_deposit_function_on_l1\"] === Step 1: Call the deposit function on L1 The user calls the function `deposit` (see deposit] and deposit]), supplying as parameters the recipient address on Starknet and the amount to transfer in the case of ERC-20 token. The deposit function then: * Checks that the funds transferred are within the Alpha xref:./token-bridge.adoc#starkgate_alpha_limitations[limitations] * Transfers the funds from the user account to the Starknet bridge * Emits a deposit with the sender address on L1, the recipient address on L2, and the amount * Sends a message to the relevant L2 bridge with the amount to be transferred, and the recipient address as parameters. Note that, since every single bridge is dedicated to one token type, the token type doesn't have to be explicit here. At the end of this step (i.e., after the execution on L1) the deposit transaction is known to Starknet's sequencer, yet sequencers may wait for enough L1 confirmations before the corresponding deposit transaction is initiated on L2. During this step, the status of the L2 deposit transaction is xref:../Blocks/transaction-life-cycle.adoc#not_received[`NOT_RECEIVED`]. [id=\"step_2_deposit_triggered_on_starknet\"] === Step 2: deposit triggered on Starknet Once enough block confirmations are received for step 1, the sequencers may refer to the deposit request by triggering the L1 handler using the function on the L2 bridge. The function `handle_deposit` verifies that the deposit indeed came from the corresponding L1 bridge. It then calls to the relevant ERC-20 contract (e.g. the ERC-20 representing ETH on Starknet) and mints the tokens for the user. At the end of this step (i.e., after the sequencer processed this transaction, but before a proof is generated), the status of the deposit request will be xref:../Blocks/transaction-life-cycle.adoc#accepted_on_l2[`ACCEPTED_ON_L2`]. [id=\"step_3_the_block_that_includes_the_transfer_is_proved\"] === Step 3: The block that includes the transfer is proved Once the sequencer completes the block construction, Starknet's provers will prove its validity and submit a state update to L1. When this happens, the message confirming the funds transfer will be cleared from the Starknet Core Contract, and the fact that the user has transferred their funds will be part of the now finalized state of Starknet. Note that if the message wasn't on L1 to begin with (meaning Starknet \"`invented`\" a deposit request), the state update would fail. [id=\"l2l1_transfer_withdraw\"] == L2\u2192L1 transfer (withdraw) [id=\"step_1_call_the_withdraw_function_on_l2\"] === Step 1: Call the withdraw function on L2 To initiate a withdraw, a user calls the function on the L2 bridge contract, supplying as parameters the recipient address on Ethereum, as well as the amount to transfer. The withdraw function then: * Burns the transferred amount of tokens from the balance of the withdrawal's initiator * Sends a message to the relevant L1 bridge with the amount to be transferred, and the recipient address as parameters. As before, since the bridges are token-specific, the token itself is implicit here. [id=\"step_2_the_block_that_includes_the_transaction_is_proved\"] === Step 2: The block that includes the transaction is proved Once the sequencer completes the block construction, Starknet's provers will prove the validity of the block and submit a state update to L1. When this happens, the message from the previous step is stored in the Starknet Core Contract. [id=\"step_3_transfering_the_funds_on_l1\"] === Step 3: Transfering the funds on L1 After the withdraw message has been recorded on the Starknet Core Contract, anyone can finalize the transfer on L1 from the bridge back to the user, by calling the `withdraw` function (see withdraw] and withdraw]). [NOTE] ==== This step is permissionless, and may be performed by anyone. Since the user's address is part of the recorded message on L1, he will be the recepient of the funds, regardless of who called the `withdraw` function on L1. ===="}
{"title": "starknet-state.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"starknet_state\"] = Starknet state latexmath The state of Starknet consists of: * xrefContracts/contract-classes.adoc[Contract classes]: a mapping between class hash and the class definition * xrefContracts/contract-classes.adoc[Contract instances]: a mapping between addresses (251-bit field elements) and the contract's state. A contract state consists of: * xref:../Contracts/class-hash.adoc[Class hash]: defines the functionality of the contract * xref:../Contracts/contract-storage.adoc[Contract storage]: a key-value mapping where the key/values are field elements * xref:../Account_Abstraction/approach.adoc#replay_protection[Contract nonce]: the number of transactions sent from this contract With the above definition, we can provide a brief sketch of Starknet's transition function. A transaction stem:[$tx$] transitions the system from state stem:[$S$] to state stem:[$S'$] if: * stem:[$tx$] is an xref:../Blocks/transactions.adoc#invoke_transaction[invoke] transaction, and the storage of stem:[$S'$] is the result of executing the target contract code with respect to the previous state stem:[$S$] (the arguments, contract address, and the specific entry point are part of the transaction) * stem:[$tx$] is a xref:../Blocks/transactions.adoc#deploy_account_transaction[deploy_account] transaction, and stem:[$S'$] contains the new contract's state at the contract's address. Additionally, the storage of stem:[$S$] is updated according to the execution of the contract's constructor. * stem:[$tx$] is a xref:../Blocks/transactions.adoc#declare_transaction[declare] transaction, and stem:[$S'$] contains the class hash and definition in the contract classes mapping [id=\"state_commitment\"] == State commitment The state commitment is a digest which uniquely (up to hash collisions) encodes the state. In Starknet, the commitment combines the roots of two binary xref:#merkle_patricia_tree[Merkle-Patricia trees] of height 251 in the following manner: [stem] ++++ \\begin{aligned} \\text{state_commitment}=h( & \\text{\"STARKNET_STATE_V0\"}, \\\\& \\text{contracts_tree_root}, \\\\& \\text{classes_tree_root}) \\end{aligned} ++++ Where: * stem:[$h$] is the xref:../Hashing/hash-functions.adoc#poseidon_hash[Poseidon] hash function * `STARKNET_STATE_V0` is a constant prefix string encoded in ASCII (and represented as a field element). * `contracts_tree_root` is the root of the Merkle-Patricia tree whose leaves are the contracts states, see xref:#contracts_tree[below] * `classes_tree_root` is the root of the Merkle-Patricia tree whose leaves are the compiled class hashes, see xref:#classes_tree[below] [id=\"contracts_tree\"] === The contracts tree Like Ethereum, this is a 2-level structure where the contract address determines the path from the root to the leaf encoding the contract state. The information stored in the leaf is: [stem] ++++ h(h(h(\\text{class_hash}, \\text{storage_root}), \\text{nonce}),0) ++++ Where: * stem:[$h$] is the xref:../Hashing/hash-functions.adoc#pedersen_hash[Pedersen] hash function. * stem:[$\\text{class_hash}$] is the hash of the contract's definition discussed xrefarchitecture_and_concepts:Contracts/class-hash.adoc[here] * stem:[$\\text{storage_root}$] is the root of another Merkle-Patricia tree of height 251 that is constructed from the contract's storage * stem:[$\\text{nonce}$] is the current nonce of the contract [id=\"classes_tree\"] === The classes tree The classes tree encodes the information about the existing xref:../Contracts/contract-classes.adoc#[classes] in the state of Starknet. It maps (Cairo 1.0) xref:../Contracts/class-hash.adoc#cairo1_class[class hashes] to their compiled class hashes. The value of a leaf at a path corresponding to some class hash is given by: [stem] ++++ h(\\text{CONTRACT_CLASS_LEAF_V0}, \\text{compiled_class_hash}) ++++ Where: * stem:[$h$] is the xref:../Hashing/hash-functions.adoc#poseidon_hash[Poseidon] hash function * `CONTRACT_CLASS_LEAF_V0` is a constant prefix string encoded in ASCII (and represented as a field element). * `compiled_class_hash` is the hash of the Cairo assembly resulting from compiling the given class via the Sierra&rarr;Casm compiler [NOTE] ==== Cairo 1.0 classes that are part of the commitment are defined with Sierra, an intermediate representation between Cairo 1.0 and Cairo assembly (see xrefContracts/cairo-1-and-sierra.adoc[here] for more information). However, the prover only deals with Cairo assembly. This means that unless we want the compilation from Sierra to Casm to be part of every block in which the class is used, the commitment must have some information about the associated Cairo assembly. Today, the user signs the `compiled_class_hash` as part of a xref:../Blocks/transactions.adoc#declare_v2[declare v2] transaction. If the transaction was included in a block, then this `compiled_class_hash` becomes part of the commitment. In the future, when Sierra&rarr;Casm compilation becomes part of the Starknet OS, this value may be updated via a proof of the Sierra&rarr;Casm compiler execution, showing that compiling the same class with a newer compiler version results in some new compiled class hash. ==== [merkle_patricia_tree] === Merkle-Patricia tree [specifications] ==== Specifications As mentioned above, our commitment scheme uses a binary Merkle-Patricia tree with the Pedersen hash function. Each node in the tree is represented by a triplet stem:[$(length, path, bottom)$]. The actual data is placed in the leaves, and a leaf node with data stem:[$x$] is encoded by the triplet stem:[$(0,0,x)$]. Empty nodes (leaves or internal) are encoded by the zero triplet stem:[$(0,0,0)$]. A subtree rooted at a node stem:[$(length, path, bottom)$] has a single non-empty subtree, rooted at the node obtained by following the path specified by stem:[$path$]. stem:[$path$] is an integer in stem:[$[0, 2^{length}-1\\]$], and the binary expansion of stem:[$path$] indicates how should we proceed along the tree, where the first step is indicated by the most significant bit, and stem:[$0,1$] are interpreted as left, right correspondingly. [NOTE] ==== The reason that length is specified and cannot be deduced from stem:[$path$] is that we're dealing with field elements of fixed size (251 bits each). For a node with stem:[$length>0$], following stem:[$path$] leads the highest node whose both right and left child are none empty. ==== The following rules specify how the tree is constructed from a given set of leaves: The hash of a node stem:[$N =(length, path, bottom)$], denoted by stem:[$H(N)$], is: [stem] ++++ H(N)=\\begin{cases} bottom, & \\text{if } length = 0 \\\\ h(bottom, path) + length, & \\text{otherwise} \\end{cases} ++++ Note that any arithmetic operations in the above are done in our field. We can now proceed to recursively define the nodes in the tree. The triplet represents the parent of the nodes stem:[$left=(\\ell_L, p_L, b_L)$], stem:[$right=(\\ell_R, p_R, b_R)$] is given by: [stem] ++++ parent= \\begin{cases} (0,0,0), & \\text{if } left=right=(0,0,0)\\\\ (\\ell_L + 1, p_L, b_L), & \\text{if } right=(0,0,0) \\text{ and } left \\neq (0,0,0)\\\\ (\\ell_R + 1, p_R + 2^{\\ell_R}, b_R), & \\text{if } right\\neq (0,0,0) \\text{ and } left = (0,0,0)\\\\ (0, 0, h(H(left), H(right))), & \\text{otherwise} \\end{cases} ++++ [id=\"example_trie\"] === Example trie We now show an example of the construction of a height 3 Merkle-Patricia tree from the leaves stem:[$[0,0,1,0,0,1,0,0\\]$]: image::trie.png[trie] Where stem:[$r=h(H(2,2,1),H((2,1,1))$]. Note that in our example there is no skipping from the root (length is zero), so the final commitment to the tree will be stem:[$H((0,0,r))=r$]. Suppose that we want to prove, with respect to the commitment we have just computed, that the value of the leaf whose path is given by stem:[$101$] is stem:[$1$]. In a standard Merkle tree, the proof would have consisted of data from three nodes (siblings along the path to the root). Here, since the tree is sparse, we only need to send the two children of the root stem:[$(2,2,1), (2,1,1)$]. This suffices to reproduce the commitment stem:[$r$], and since the height of the tree, stem:[$3$], is known and fixed, we know that the path stem:[$01$] of length stem:[$2$] specified by the right child stem:[$(2,1,1)$] leads us to the desired leaf."}
{"title": "index.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"eol\"] = Deprecated and removed features The following features have been deprecated or removed from Starknet in recent releases. [cols=\"1,3\"] |=== |Status|Description |Deprecated|Feature or capability is no longer actively supported. It may still work, but future fixes or enhancements are unlikely. |Removed|Feature or capability has been removed from Starknet. |=== == Deprecated features [cols=\"1,3\"] |=== |Name|Description |Cairo 0 | xrefversion_notes.adoc#version0.11.0[Starknet v0.11.0] introduces Cairo 1.0 smart contracts. |=== == Removed features [cols=\"1,3\"] |=== |Name|Description |Free L1-> L2 messaging |Previously, sending a message from L1 to L2 had an optional fee associated. From xrefversion_notes.adoc#version0.11.0[Starknet v0.11.0], the fee mechanism is enforced and the ability to send L1->L2 messages without the corresponding L2 fee has been removed. See xrefarchitecture_and_concepts:L1-L2_Communication/messaging-mechanism.adoc#l1-l2_message_fees[here] for more details. |`invoke` transaction v0 |`invoke` transaction v0 has been removed since xrefversion_notes.adoc#version0.11.0[Starknet v0.11.0]. |`declare` transaction v0 |`declare` transaction v0 has been removed since xrefversion_notes.adoc#version0.11.0[Starknet v0.11.0]. |`deploy` transaction|The `deploy` transaction has been removed since xrefstarknet_versions:version_notes.adoc#version0.10.3[Starknet v0.10.3]. To deploy new contract instances, you can use the xrefContracts/system-calls.adoc#deploy[`deploy` system call]. |==="}
{"title": "account_setup.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"setting-up-a-starknet-account\"] = Setting up a Starknet account [id=\"introduction\"] == Introduction [NOTE] ==== Before you create a Starknet account, ensure you have completed the steps in the xref:environment_setup.adoc[environment setup section] of these docs. ==== In order to interact with Starknet, you need to set up a Starknet account. To deploy a new account on Starknet you will need to complete the following steps: 1. Generate a Starknet account and compute its address locally 2. Fund your account so that you can deploy the account to the Starknet network 3. Deploy the account to the Starknet network Starknet natively uses Account Abstraction at the protocol layer for account implementation. You can learn more about Starknet Account Abstraction xrefAccount_Abstraction/introduction.adoc[here]. [id=\"setting-up-the-network\"] == Setting up the network In this tutorial we will use the Starknet CLI (command line interface) to interact with Starknet. Setting the following environment variables will allow you to use the Starknet CLI to interact with a consistent set of configurations without having to pass them as arguments to each command: [#setup_starknet_env] [source,bash] ---- export STARKNET_NETWORK=alpha-goerli export CAIRO_COMPILER_DIR=~/.cairo/target/release/ export CAIRO_COMPILER_ARGS=--add-pythonic-hints ---- [id=\"choosing-a-wallet-provider\"] == Choosing a wallet provider Unlike Ethereum, a Starknet account is represented by a deployed contract that defines the account\u2019s logic. In this tutorial, we will use a slightly modified version of OpenZeppelin\u2019s standard for EOA contract (at the moment, the signature is computed differently). Set the `STARKNET_WALLET` environment variable as follows: [#setup_wallet] [source,bash] ---- export STARKNET_WALLET=starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount ---- [id=\"creating-an-account\"] == Creating an account Now that your environment variables are set, you can create a Starknet account. Run the following command to initialize an account: [#initialize_account] [source,bash] ---- starknet new_account --account ---- The output should resemble: [#initialize_account_output] [source,bash] ---- Account address: 0x04e93e1fb507d23b398f0a09f5873d3a7769b0e7ed40dbbe8fe7a2e8ea831006 Public key: 0x07a328511fa8552cd61aaaa89076fe40c3566f4594f29324aa754d41d7c7c55e Move the appropriate amount of funds to the account, and then deploy the account by invoking the 'starknet deploy_account' command. NOTE: This is a modified version of the OpenZeppelin account contract. The signature is computed differently. ---- [id=\"transferring-goerli-eth-to-the-account\"] == Transferring Goerli ETH to the account In order to pay the fees required to deploy the account and execute transactions on Starknet, you need enough ETH in your Starknet account. You can acquire Starknet Goerli ETH in the following ways: 1. Use the Faucet] to get small amounts of ETH directly to the account you have just created. This should suffice for simple transactions. 2. Use link: \u2013 the Starknet L2 bridge, to transfer your existing Goerli L1 ETH to and from your Starknet account. In either case, ensure that the funding transaction reaches the \"PENDING\" status on Starknet before proceeding. You can check the status of a transaction using the link: or link: block explorers for Starknet. [id=\"simulate-account-deployment\"] == Simulate deploy account You can estimate the fee required to deploy your account by running the following command. To account for fluctuations in fee prices, it is recommended to transfer more than the fee estimation value to ensure that your transaction is successful. [#deploy_account_simulate] [source,bash] ---- starknet deploy_account --simulate --account= ---- The output should resemble: [source,bash] ---- The estimated fee is: 822400000000000 WEI (0.000822 ETH). Gas usage: 8224 Gas price: 100000000000 WEI ---- [NOTE] ==== Alternatively you can run the following command for a less verbose output: [#deploy_account_estimate_fee] [source,bash] ---- starknet deploy_account --estimate_fee --account= ---- ==== [id=\"deploying-an-account\"] == Deploying an account To deploy the account you initialized, now run the following command: [#setup_deploy_account] [source,bash] ---- starknet deploy_account --account= ---- The output should resemble: [#setup_deploy_account_output] [source,bash] ---- Sending the transaction with max_fee: 0.000563 ETH (562652117844076 WEI). Sent deploy account contract transaction. Contract address: 0x04e93e1fb507d23b398f0a09f5873d3a7769b0e7ed40dbbe8fe7a2e8ea811006 Transaction hash: 0x69192a77c527fb10a71722400dbad15bdb3a8db237db4f72e06f3b4b63f2195 ---- You have now successfully deployed a new account to Starknet."}
{"title": "deploying_contracts.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"deploying_contracts\"] = Deploying Starknet contracts In this section, you will learn to compile, deploy and interact with a Starknet contract written in Cairo. Follow the below steps in order to accomplish your goal! == Set up an RPC Provider In order to interact with the Starknet main chain or any testnets, you'll need an RPC provider. Please refer to quickstart guide] to start developing with Starknet APIs! == Setting up environment variables The following commands must run every time you open a new terminal to interact with Starknet. Setting them saves you time when using the CLI within the same terminal session. [,Bash] ---- # Use Starknet testnet export STARKNET_NETWORK=alpha-goerli # Set the default wallet implementation to be used by the CLI export STARKNET_WALLET=starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount # Set the path to the cairo 1 compiler binary. Adapt this path to fit your installation if needed export CAIRO_COMPILER_DIR=~/.cairo/target/release/ # Compiler arguments export CAIRO_COMPILER_ARGS=--add-pythonic-hints ---- == Setting up an account You need to set up your CLI with an account contract and fund it. ____ Starknet accounts are smart contracts. As such, creating one involves sending a transaction, and takes a bit longer than creating an EOA on other networks. You can learn more in the section of the documentation. ____ This process will involve three steps: * Generating your account address locally * Funding it * Deploying it The Starknet account declared through the CLI are stored on your machine in folder `~/.starknet_accounts/`. [,Bash] ---- # Creating a new account. starknet new_account --account account_name ---- Your terminal will return your account's address. [,Bash] ---- Account address: 0x00d9d851f600d539a9f7811de4d9613a6b3c2634f8c0386a305c03216bd67559 Public key: 0x0293d6625d860b9a37a0319d1e3c1eecc27685075cbeaae4ef29ed717d93c58b Move the appropriate amount of funds to the account, and then deploy the account by invoking the 'starknet deploy_account' command. NOTE: This is a modified version of the OpenZeppelin account contract. The signature is computed differently. ---- Next step is to fund it. * Use the to get some funds and send them to the account * Bridge funds using However you chose to do it, please make sure that the funding transaction reaches the \"PENDING\" status before moving on. You can look for it on or [,Bash] ---- # Deploying your account starknet deploy_account --account account_name ---- Your sample output should look something like this: [,Bash] ---- Sending the transaction with max_fee: 0.000568 ETH (568383605914463 WEI). Sent deploy account contract transaction. Contract address: 0x03f42fc2355be54197a8b270ff2cb8e2eb7902e777b3498f8ad58c6c147cce60 Transaction hash: 0x3d15e05389ecd1ff65555220be57f0ab43729877b20ca086048276917ed2838 ---- Monitor the transaction until it passes the \"PENDING\" state. == Create and compile a contract Before we get started, make sure that the below commands are working properly on your system. If they don't, please check the xrefgetting_started:environment_setup.adoc[Setting up your environment] section. [,Bash] ---- starknet --version starknet-compile --version ---- You can now create a folder of your choice (in any location) where you would like to practice your Cairo skills . Inside the new folder, create a file name `hello_starknet.cairo`. [,Bash] ---- #Create a new folder for practicing your cairo skills cd ~/ mkdir cairo_practice && cd cairo_practice #Create a new file called hello_starknet.cairo touch hello_starknet.cairo ---- Copy and paste the following piece of code into your `hello_starknet.cairo` file: [,Rust] ---- #[contract] mod HelloStarknet { use starknet::get_caller_address; use starknet::ContractAddress; #[event] fn Hello(from:ContractAddress, value:felt252) {} #[external] fn say_hello(message:felt252) { let caller=get_caller_address(); Hello(caller, message); } } ---- Customize the above code by adding a new type of event. Find a name that is unique (this is important). Add the following code: ---- #[event] fn My_Unique_Event_Name(from:ContractAddress, value:felt252) {} ---- Compile the above Starknet contract using the following command: [,Bash] ---- starknet-compile hello_starknet.cairo hello_starknet.json ---- The above command should compile to produce a `hello_starknet.json` file in the same folder. == Declare a contract class On Starknet, the deployment process is in two steps: * Declaring the class of your contract, or sending your contract's code to the network * Deploying a contract, or creating an instance of the code you previously declared Let's start with declaring the above code. [,Bash] ---- starknet declare --contract hello_starknet.json --account account_name ---- ____ The above command may fail if you are using code that has already been declared by someone else! Please make sure to add custom code to your contract to create a new contract class. ____ You will see something like: [,Bash] ---- Sending the transaction with max_fee: 0.000132 ETH (131904173791637 WEI). Declare transaction was sent. Contract class hash: 0x8ceb9796d2809438d1e992b8ac17cfe83d0cf5944dbad948a370e0b5d5924f Transaction hash: 0x334f16d9da30913c4a30194057793379079f35efa6bf5753bc6e724a591e9f0 ---- The transaction hash allows you to track when the network will have received your contract's code. Once this transaction has moved to \"PENDING\", you can deploy an instance of your contract. == Deploy a contract Using the above generated class hash, deploy the contract: [,Bash] ---- starknet deploy --class_hash 0x8ceb9796d2809438d1e992b8ac17cfe83d0cf5944dbad948a370e0b5d5924f --account account_name ---- ____ If you run into any fee related issues, please add the flag `--max_fee 100000000000000000` to your CLI commands to set an arbitrary high gas limit for your deploy transaction. ____ You will see something like: [,Bash] ---- Sending the transaction with max_fee: 0.000197 ETH (197273405375932 WEI). Invoke transaction for contract deployment was sent. Contract address: 0x03a5cac216edec20350e1fd8369536fadebb20b83bfceb0c33aab0175574d35d Transaction hash: 0x7895267b3e967e1c9c2f7da145e323bed60dfdd1b8ecc8efd243c9d587d579a ---- Monitor the deploy transaction. Once it has passed \"PENDING\", your contract has been successfully deployed! Wohooo! You have just deployed your first Cairo 1.0 contract on StarkNet! Congratulations. == Interact with your contract If you quickly browse through the above contract (`hello_starknet.cairo`), you can see the contract has a simple function: `say_hello` which we are going to learn to trigger. [,Bash] ---- #Function that we will be invoking #[external] fn say_hello(message:felt252) { let caller=get_caller_address(); Hello(caller, message); } ---- The syntax to invoke a function in your contract is: [,Bash] ---- starknet invoke --function --address --account # Invoking our say_hello function starknet invoke --function say_hello --address 0x03a5cac216edec20350e1fd8369536fadebb20b83bfceb0c33aab0175574d35d --input 152 --account account_name ---- You will see something like: [,Bash] ---- Sending the transaction with max_fee: 0.000080 ETH (79590795788372 WEI). Invoke transaction was sent. Contract address: 0x03a5cac216edec20350e1fd8369536fadebb20b83bfceb0c33aab0175574d35d Transaction hash: 0xbfb3ec183b4ee58db67113cf8832c31e78fe8000f091cc598d5aa9ca6a62af ----"}
{"title": "environment_setup.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"environment\"] = Setting up the environment == Overview Setting up your local development environment to develop for Starknet involves the following steps: 1. xref:#installing_the_prerequisites[Installing the prerequisites]. 2. xref:#installing_the_additional_dependencies[Installing the additional dependencies]. 3. xref:#installing_the_cairo_cli[Installing the Cairo CLI]. 4. xref:#installing_the_cairo_compiler[Installing the Cairo compiler]. == Installing the prerequisites Using a link: virtual environment] is a good way to isolate your testing environment. To create and enter the Python virtual environment, do one of the following: * xref:#_manually_activating_the_cairo_virtual_environment[Activate your Cairo virtual environment manually]. * xref:#_using_the_python_environment_manager_to_activate_the_cairo_virtual_environment[Use the Python environment manager]. === Manually activating the Cairo virtual environment Run the following two commands to manually create and activate a Cairo virtual environment: [,Bash] ---- $ python3.9 -m venv ~/cairo_venv $ source ~/cairo_venv/bin/activate ---- After creating and activating the virtual environment, you should see `(cairo_venv)` in the command line prompt, indicating that the virtual environment is active, for example: [,Bash] ---- (cairo_venv) ---- === Using the Python environment manager to activate the Cairo virtual environment Alternatively, you can use the Python environment manager to create a virtual environment: [source,Bash] ---- $ curl | bash ---- Now add the following to your `.bashrc` or `.zshrc` file: [source,Bash] ---- $ export PATH=\"$HOME/.pyenv/bin:$PATH\" $ eval \"$(pyenv init -)\" $ eval \"$(pyenv virtualenv-init -)\" ---- Restart your terminal and run the following commands: [source,Bash] ---- $ pyenv install 3.9.0 $ pyenv virtualenv 3.9.0 cairo_venv $ pyenv activate cairo_venv ---- you should see `(cairo_venv)` in the command line prompt, indicating that the virtual environment is active, for example: [source,Bash] ---- (cairo_venv) ---- == Installing the additional dependencies Depending on your operating system, you may need to install the following, additional dependencies: |=== |Dependency |Description |`libgmp3-dev`/`gmp`|A software development library package for the GNU Multiple Precision Arithmetic Library. |`ECDSA` |(Elliptic Curve Digital Signature Algorithm) is a digital signature algorithm that is based on the mathematics of elliptic curves. |`FastECDSA`|An open-source software library that provides an implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA) for use in cryptographic applications. It is designed to be fast, efficient, and easy to use, and is written in the Python programming language. |`SymPy` |A Python library for symbolic mathematics. |=== === Linux On Ubuntu, you will need to run the following command to install the `libgmp3-dev` library: [source,Bash] ---- $ sudo apt install -y libgmp3-dev ---- === macOS On macOS, you can use Homebrew to install the `gmp` library: [source,Bash] ---- $ brew install gmp ---- After that, you need to install the `ecdsa`, `fastecdsa` and `sympy` dependencies (Linux and Mac): [source,Bash] ---- $ pip install ecdsa fastecdsa sympy ---- === Installing the Cairo CLI You can interact with Starknet using the Cairo command line interface. If you had a previous version of Cairo is installed, uninstall it and install the latest version: === Uninstalling the previous version (optional) [source,Bash] ---- $ pip uninstall cairo-lang ---- === Installing the latest version of Cairo You can use `pip` to install the latest version of Cairo: [source,Bash] ---- $ pip install cairo-lang ---- Alternatively, you can download a specific version of Cairo using this command: [source,Bash] ---- $ pip install $HOME/Downloads/cairo-lang-0.11.0.2.zip ---- Once you have installed the Cairo package, make sure to test your installation by running the following command: [source,Bash] ---- $ starknet --version ---- You should see an output in your terminal similar to the below: [source,Bash] ---- $ starknet 0.11.0.2 ---- Make sure the version output matches the link: release]. == Installing the Cairo compiler The Cairo compiler allows you to compile Cairo code into Cairo VM executable byte code. To install the Cairo compiler, run the following commands: === Cloning the repository and setting up the Cairo compiler Go to your $HOME directory [source,Bash] ---- $ cd ~/ ---- Clone the cairo Cairo 1 compiler to a folder called .cairo in your home directory [source,Bash] ---- $ git clone .cairo $ cd .cairo/ $ git checkout tags/v1.0.0-alpha.6 $ cargo build --all --release ---- === Adding the Cairo executables to your path After building the Cairo binaries, add them to the PATH environment variable by adding the following line to your `.bashrc` or `.zshrc` file: [source,Bash] ---- $ export PATH=\"$HOME/.cairo/target/release:$PATH\" ---- Then, open a new shell and check that the following command returns a version number: [source,Bash] ---- $ cairo-compile --version ---- Your output should look similar to the below: [source,Bash] ---- $ cairo-lang-compiler 1.0.0-alpha.6 ---- You are now able to compile, deploy and interact with smart contracts on Starknet"}
{"title": "juno_versions.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"juno\"] = Juno versions # Juno image::juno_icon_light.png[,,125] Juno is a golang Starknet node implementation by with the aim of decentralising Starknet. See the official GitHub repository] for more details. == (latest) === Added * Fetch and store compiled classes for each Sierra class. === Changed * Updated the behavior of synced nodes, which will now return false to `starknet_syncing`. === Fixed * Resolved issue with `NumAsHex(0)` being omitted in RPC. * Fixed a Goerli sync issue by relaxing decoder max array elements limit. **Full Changelog**: == === Added * Starknet v0.11.2 support * History for contracts, nonce, and class hash. * Implemented StateSnapshot. * New RPC endpoints: ** `starknet_syncing` ** `starknet_getNonce` ** `starknet_getStorageAt` ** `starknet_getClassHashAt` ** `starknet_getClass` ** `starknet_getClassAt` ** `starknet_getEvents` NOTE: For new RPC endpoints to fully work with data before the new version, the node needs to be resynced. === Changed * Optimized TransactionStorage encoding and refactored memStorage. * Refactored RPC implementation for better organization and maintainability. * Parallelized and refactored sync tests for faster execution, improved readability, and maintainability. === Fixed * Updated handling of non-existent keys to return a zero value. **Full Changelog**: == This patch release fixes handling of block versioning and ensures compatibility with non-sem-ver compliant Starknet. === Fixed * Ignore or add digits to block version string as necessary. **Full Changelog**: == This minor release introduces an important optimization that enhances sync performance. * Update gnark-crypto version: ** Implement precomputed point multiplication results for Pedersen hash operations. **Full Changelog**: == This release adds support for Staknet `v0.11.0`. WARNING: This release has breaking changes and database is not compatible with the previous version. === Added * Starknet `v0.11.0` support: ** Add Poseidon hash for new state commitment. ** Add `DeclareTransaction` version 2. ** Add and Store Cairo 1/Sierra class definition and hash calculations. * `pprof` option is added for profiling and monitoring. * Verify Class Hashes. === Changed * Starknet `v0.11.0` support: ** Update `InvokeTransaction` version 1's `contract address` to `sender address`. ** Update current JSON RPC endpoints to [`v.0.3.0-rc1`]( * Rename the `verbosity` option to `log-level` and `log-level` accepts `string` instead of `uint8`. See `help` for details. * `network` option accepts `string` instead of `uint8`. See `help` for details. * Database table is updated to account for Starknet `v0.11.0` changes. === Removed * Remove `metrics` and `eth-node` options since they are not used. === Fixed * Graceful shutdown: ensure all services have returned before exiting. **Full Changelog**: == This is Juno's first release (compatible with Starknet `v0.10.3`) with the following features: * Starknet state construction and storage using a path-based Merkle Patricia trie. * Pedersen and `starknet_keccak` hash implementation over starknet field. * Feeder gateway synchronisation of Blocks, Transactions, Receipts, State Updates and Classes. * Block and Transaction hash verification. * JSON-RPC Endpoints: ** `starknet_chainId` ** `starknet_blockNumber` ** `starknet_blockHashAndNumber` ** `starknet_getBlockWithTxHashes` ** `starknet_getBlockWithTxs` ** `starknet_getTransactionByHash` ** `starknet_getTransactionReceipt` ** `starknet_getBlockTransactionCount` ** `starknet_getTransactionByBlockIdAndIndex` ** `starknet_getStateUpdate`"}
{"title": "limits_and_triggers.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"limits_and_triggers\"] = Current limits and triggers Starknet alpha currently has a number of limits and triggers in place in order to keep the network stable and optimized for best performance. [NOTE] ==== These are subject to revisions and change on a regular basis ==== .StarkNet current limits and triggers [%header, stripes=even] |=== |Entity | Goerli | Mainnet |Block limit (Cairo steps) | 8M | 8M |Block limit (gas) |3M |3M |Max transaction size (Cairo steps)|1M |1M |Max contract bytecode size (No of felts in the program) | 61440 | 61440 |Max contract class size| 20MB | 20MB |Mempool size limit | No limitation|1000 transactions |IP address limits (read) | 100 per min|200 per min |IP address limits (write)|10 per min / per ip address |10 per min / per ip address |=== ## Block limit (Cairo steps) The execution of each transaction involves a certain number of computational steps. Starknet enforces a limit on the number of steps that can be completed within each block to ensure block production times remain consistent and predictable. ## Block limit (gas) Certain Starknet operations consume Ethereum gas, e.g L1/L2 messages. The current L1 state update mechanism involves an Ethereum transaction for each Starknet block. The gas limit for Starknet blocks is therefore inherited from the gas limit for Ethereum blocks. [NOTE] ==== The gas limit for Starknet blocks is inherited from the gas limit for Ethereum blocks. ==== ## Mempool size limit // The mempool contains transactions that have undergone preliminary verification by the sequencer and are candidates for inclusion into a block The mempool contains transactions that have undergone a preliminary verification by the sequencer and are candidates for inclusion into a block. // local to the sequencer (each has a mempool) ## IP address limits (read) In order to reduce network spam, Starknet limits the amount of contract reads that a single IP address can make. ## IP address limits (write) In order to reduce network spam, Starknet limits the amount of contract writes that a single IP address can make."}
{"title": "pathfinder_versions.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"pathfinder\"] = Pathfinder versions # Pathfinder Pathfinder is a Starknet full node giving you a safe view into Starknet. It provides the following features: * Access the full Starknet state history * Verifies state using Ethereum * Implements the Starknet JSON-RPC API * Run Starknet functions without requiring a Starknet transaction * Ability to do fee estimation for transactions See the official Github repository] for more details. ## v0.5.4 (latest) The primary focus of this release is to provide support for Starknet v0.11.1, and will continue to work for v0.11.0. Since this release is required for v0.11.1, you should update your node before the network is updated. ### Added - Starknet v0.11.1 support - CORS support via the `rpc.cors-domains` configuration option - Transaction hashes are now verified as part of the sync process. Previously, these were not verified as the exact algorithm was underdocumented and the transaction format was still evolving. ### Fixed - RPC server panic for unprefixed unregistered method names - Data can temporarily appear to go missing when transitioning from `PENDING` to `ACCEPTED ON L2` - This was commonly seen when rapidly monitoring a new transaction, which would go from `PENDING` to `TXN_HASH_NOT_FOUND` to `ACCEPTED_ON_L2` as pathfinder moved the ephemeral pending data to latest data on disk. ## v0.5.3 Fixes for minor issues and inconsistencies. ### Added - `max-rpc-connections` command-line argument. This sets the maximum number incoming RPC connections the pathfinder node will accept. This defaults to 1024 if not specified. - `cairo-lang` upgraded to 0.11.0.2 ### Fixed - `starknet_simulateTransaction` data model inconsistency - `poll-pending` default value restored to `false` - incoming RPC connections limited to 100. This limit was accidentily introduced in v0.5.2 as part of a dependency upgrade, whereas before it was unlimited. The default is now 1024 and can be configured using `--max-rpc-connections`. - handling of invalid JSON-RPC requests ## v0.5.2 This release fixes a few RPC bugs and adds support for bulk fee estimation and transaction simulation (traces) as part of v0.3 RPC specification. In addition it also adds a `pathfinder_getTransactionStatus` endpoint which lets you track a transactions status -- including `REJECTED` and `RECEIVED` -- in the same fashion as the gateway. ### Added - support `starknet_estimateFee` in the JSON-RPC v0.3 API - supports estimating multiple transactions - this includes declaring and immediately using a class (not currently possible via the gateway) - support `starknet_simulateTransaction` for JSON-RPC v0.3 - supports simulating multiple transactions - this includes declaring and immediately using a class (not currently possible via the gateway) - support `pathfinder_getTransactionStatus` which is exposed on all RPC routes - this enables querying a transactions current status, including whether the gateway has received or rejected it ### Fixed - RPC returns int for entrypoint offsets instead of hex - RPC rejects Fee values with more than 32 digits - RPC does not expose `pathfinder_getProof` on v0.3 route ## v0.5.1 This is a minor bugfix release, primarily to fix an issue with syncing on `testnet2`. ### Fixed * pathfinder sometimes spams nethermind L1 nodes * pathfinder stops syncing `testnet2` at block 95220 due to a Sierra class compilation issue ## v0.5.0 ### Highlights - starknet v0.11.0 support - RPC API v0.3 partial support - removed several deprecated config options - requires python 3.9 or 3.10 (no longer 3.8) ### Added - support for state commitment and class commitment in `pathfinder_getProof` - support for starknet v0.11 - partial support for RPC specification v0.3 - exposed on `/rpc/v0.3/` route - missing support for `starknet_estimateFee` and `starknet_simulate` ### Changed - `starknet_call` and `starknet_estimateFee` JSON-RPC methods return more detailed error messages - `python` version requirement has changed to `3.9` or `3.10` (was `3.8` or `3.9` previously) ### Fixed - RPC accepts hex inputs for Felt without '0x' prefix. This led to confusion especially when passing in a decimal string which would get silently interpretted as hex. - using a Nethermind Ethereum endpoint occasionally causes errors such as ` could not be found` to be logged. - sync can miss new block events by getting stuck waiting for pending data. ### Removed - `--config` configuration option (deprecated in [v0.4.1]( - `--integration` configuration option (deprecated in [v0.4.1]( - `--sequencer-url` configuration option (deprecated in [v0.4.1]( - `--testnet2` configuration option (deprecated in [v0.4.1]( - `starknet_addDeployTransaction` as this is no longer an allowed transaction since starknet v0.10.3 - RPC api version `0.1`, which used to be served on path `/rpc/v0.1` ### RPC API We added support for v0.3 and removed v0.1. We still support v0.2 at both `/rpc/v0.2` and `/rpc` (default) routes. In summary: ``` / # serves v0.2 /rpc/v0.2/ # serves v0.2 /rpc/v0.3/ # serves v0.3 ``` We are missing `starknet_estimateFee` and `starknet_simulate` support for v0.3, which will be added in an upcoming release. ### Python requirement Note: this only applies if you are building from source. This does not impact docker users. Pathfinder requires python to support the starknet VM used to simulate starknet transactions and function calls. Previous versions of the VM only worked with python 3.8 or 3.9 which was a hassle because most operating systems no longer directly support it. The new version of the VM bundled with starknet v0.11 now requires python version 3.9 or 3.10. ### Configuration changes Several configuration options are now removed, after they were deprecated in pathfinder v0.4.1. Here is a migration guide: - `--testnet2`: use `--network testnet2` instead - `--integration`: use `--network integration` instead - `--sequencer-url`: use `--network custom` in combination with `--feeder-gateway-url` and `gateway-url` - `--config`: use environment variables or env files as an alternative ## v0.4.5 Hotfix for a bug introduced in the previous version v0.4.4, which prevented a new node from syncing on blocks near genesis. ### Added Added Newton FAQ links to readme ### Fixed Node fails to sync old blocks ### New contributors @SecurityQQ made their first contribution in #799 ## v0.4.4 This minor release contains some nice performance improvements for `starknet_call` and `starknet_estimateFee` as well as some minor bug fixes. Also included is a major new feature: storage proofs - big thanks @pscott for his hard work on this feature! This is available via the `pathfinder_getProof` method which is served from both the pathfinder and Starknet endpoints for convenience: [source] /rpc/pathfinder/v0.1/pathfinder_getProof /rpc/v0.2/pathfinder_getProof The method is specified Its results can be used to formally verify what a contract's storage values are without trusting the pathfinder node. This is achieved by validating the merkle-proof that pathfinder returns and confirming that it correctly matches the known Starknet state root. ### Added storage proofs via `pathfinder_getProof` by @pscott ### Fixed * `starknet_getEvents` returns all events when from_block=\"latest\" * v0.1 `starknet_getStateUpdate` does not contain nonces ### Changed * Improved performance for `starknet_call` and `starknet_estimateFee` by caching classes * Improved performance for `starknet_call` and `starknet_estimateFee` by using Rust for hashing ### New contributors @pscott made their first contribution in #726 ## v0.4.3 The primary purpose of this release is to properly support testnet2 after the xrefversion_notes.adoc#version0.10.3[Starknet v0.10.3] update. The v0.10.3 update changed the testnet2 chain ID which impacts transaction signatures which in turn meant that `starknet_estimateFee` would fail for any signed transaction. This release updates pathfinder to use the correct chain ID. ### Fixed * Testnet2 and integration flags are ignored * `starknet_estimateFee` uses wrong chain ID for testnet2 ### Changed Updated to cairo-lang 0.10.3 ## v0.4.2 Contains several bug fixes, mostly hotfixes for bugs introduced in v0.4.1. ### Added Document that `--chain-id` expects text as input ### Fixed * Testnet2 and integration L1 addresses are swapped (bug introduced in v0.4.1) * Proxy network setups can't sync historical blocks (bug introduced in v0.4.1) * ABI serialization for `starknet_estimateFee` for declare transactions ## v0.4.1 ### Highlights * Soft deprecation of some configuration options * Support custom Starknet gateways * Pathfinder RPC extensions at `/rpc/pathfinder/` with `pathfinder_version` method * `starknet_events` optimisations * fix block timestamp in pending calls * Custom Starknet gateway support This release introduces support for custom Starknets. You can select this network by setting `--network` custom and specifying the `--gateway-url` and `--feeder-gateway-url` options. #### Configuration option deprecation Several configuration options have been soft deprecated. This means using them will continue to work as before (no breaking change), but they will emit a warning when used. They will be removed in a future version, so please migrate to the newer options. To re-emphasize: your current configuration setup will continue to work as is. #### Network selection `--testnet2` and `--integration` have been deprecated in favor of `--network` testnet2 and `--network` integration. #### Gateway proxy `--sequencer-url` has been deprecated in favor of `--network` custom along with `--gateway-url`, `--feeder-gateway-url` and `--chain-id`. In addition, you will need to rename your existing database file to custom.sqlite as this will be the expected filename for custom networks. #### Configuration file `--config` has been deprecated and will not be supported in the future. The utility this provided was valuable. Unfortunately it is starting to severely hinder how fast we can implement configuration changes and we decided to remove it. We suggest using environment variables along with environment files to configure pathfinder in a similar fashion. ### Changed The following configuration options are now marked as deprecated: `--testnet2`, `--integration`, `--config`, `--sequencer-url` Optimized starknet_events for queries with both a block range and a from address ### Fixed Block timestamps for pending in `starknet_call` and `starknet_estimateFee` were using the latest timestamp instead of the pending one. This meant contracts relying on accurate timestamps could sometimes fail unexpectedly. ### Added * Custom Starknet support * Pathfinder specific RPC extensions hosted at `/rpc/pathfinder/v0.1`. Currently, this only contains `pathfinder_version` which returns the pathfinder version of the node. ## v0.4.0- (breaking release) This release contains a breaking change, and also adds support for xrefstarknet_versions:version_notes.adoc#version0.10.2[Starknet v0.10.2]. The changes themselves are quite simple, but please read through each section as there are some caveats which might impact you when you apply this update. ### Default RPC version change This release changes the version of the RPC that is served at the root route, from v0.1 to v0.2 of the RPC specification. Version v0.1 is still available at the `/rpc/v0.1/` endpoint. This is the only breaking change in this release. Here is a summary of what routes are currently available, and what's changed: * `/` serves v0.2 (changed from v0.1) * `/rpc/v0.1` serves v0.1 (no change) * `/rpc/v0.2` serves v0.2 (no change) If possible, we recommend that you use the version specific routes as this will prevent such breaking changes from impacting you. ### Starknet v0.10.2 support This release includes an update to the cairo-vm embedded in pathfinder in order to support the upcoming v0.10.2 Starknet release. This bundled vm is a pre-release and may therefore contain differences to the final version used once Starknet updates testnet and mainnet. We will of course issue a new release if / when there is a new vm. [NOTE] ==== Since these changes are not yet live on testnet nor mainnet, this means upgrading to this release will cause deviations between what pathfinder outputs and what can be expected on the network. More specifically, `starknet_estimateFee` will compute different fees until the network has upgraded to xrefstarknet_versions:version_notes.adoc#version0.10.2[Starknet v0.10.2]. If you don't need the RPC route changes, it may be pertinent to delay updating until closer to the xrefstarknet_versions:version_notes.adoc#version0.10.2[v0.10.2] release dates on testnet and mainnet. The expected timeline for these upgrades is ~17/11 for testnets and ~24/11 for mainnet. ===="}
{"title": "upcoming_versions.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"upcoming_versions\"] # Upcoming Starknet versions ## Starknet Alpha v0.12.1 ### What to expect The focus of Starknet v0.12.1 is on improving the efficiency of the sequencer capacity. The proposed changes aim to address the issue of processing failed transactions and optimize the network's potential for valid transactions. ### Notable changes Here are some notable changes to expect: #### Mempool Validation: A validation stage will be added to the mempool to prevent invalid transactions from consuming valuable sequencer time. Only valid transactions will proceed further in the processing pipeline. #### Inclusion of Failed Transactions: Failed transactions during the execution stage will be included in the block with the status \"REVERTED\" and the user will be charged for the consumed resources. This inclusion ensures transparency and allows developers to analyze the reasons for transaction failures. These enhancements will significantly improve the efficiency of the sequencer capacity and optimize the processing potential of Starknet for valid transactions."}
{"title": "version_notes.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"upcoming\"] = Version notes The following version notes cover the ongoing version changes to Starknet. To get the latest version updates delivered to you, please subscribe to our mailing list == Starknet environments Within Starknet's deployment pipeline there are separate and distinct networks that operate independently of each other for testing before deployment. The current version on each environment are listed within the table below: |=== |*Environment* |*Starknet version*|*Cairo version* |Mainnet|0.11.2|1.1.0 |Goerli Testnet 1|0.12.0|2.0.0 |Goerli Testnet 2|0.12.0|2.0.0 |=== [id=\"version0.12.0\"] == Starknet v0.12.0 (July 4th, 23) Starknet v0.12.0 is live on both Testnets. === Technical release notes * Use the link: blockifier] and link: Cairo VM] to accelerate the sequencer's time to handle transactions. * Support link: 2.0.0] of the Cairo compiler. * Replace the `PENDING` status of transactions to `ACCEPTED_ON_L2` - once a transaction is in that status it means that it will be included in a block, this applies to transactions - blocks still have the `PENDING` status. * Add an experimental `get_block_hash` syscall. * Change HTTP error code from 500 to 400 on API errors. [id=\"version0.11.2\"] == Starknet v0.11.2 (May 31, 23) Starknet v0.11.2 is live on Mainnet. === Technical release notes Upgrade Cairo 1.0 version to v1.0.0-rc0 (Cairo 1.0 activated on Starknet!) [id=\"version0.11.1\"] == Starknet v0.11.1 (May 23, 23) Starknet v0.11.1 is live on Mainnet. === Technical release notes Upgrade Cairo 1.0 version to v1.0.0-rc0 (Currently disabled on Mainnet until version 0.11.2). * Charged transaction fee is now based on an average Ethereum gas price instead of a single sample (estimation API is unaffected). * API changes: ** Remove the state root in `get_state_update` for pending blocks to allow faster responses in future versions. * Testing framework: ** Allow declaring (and interacting with) Cairo 1.0 contracts. *** Currently, the Cairo 1.0 ABI is not supported yet, so a Cairo 0 ABI should be supplied to `declare()` manually. ** Split `deploy()` to two phases declare and deploy: `deprecated_declare()` (for Cairo 0 contract) or `declare()` (for Cairo 1.0 contracts) and `deploy()` (for both). * Add current block hash to the Starknet Core contract (currently not verified by the Starknet OS): ** Breaking change: The `LogStateUpdate` event's data is changed to include blockHash. [id=\"version0.11.0\"] == Starknet v0.11.0 (Mar 29, 23) Starknet v0.11.0 is live on Mainnet. [NOTE] ==== `invoke` and `declare` transactions of version 0 are no longer supported on this version. ==== === Technical release notes In Starknet v0.11.0, you can declare, deploy and run Cairo 1.0 smart contracts. We also introduce a new system call that allows a smooth transitioning of existing contracts to a Cairo 1.0 implementation. Historically, contract classes have been defined in terms of Cairo assembly, or Casm for short (the class definition also included more information needed for execution, e.g., hint data). The novelty of Cairo 1.0 is the introduction of Sierra (Safe Intermediate Representation), an intermediate layer between Cairo 1.0 and Casm. The introduction of Cairo 1.0 and Sierra has several effects on the system. Below we list the effects on each component; of particular note are: * A new version of the `declare` transaction, which allows sending the new class structure * The state commitment will now include contract classes * Changes to the on-chain data format * New system call - `replace_class` [id=\"version0.10.3\"] == Starknet v0.10.3 (Dec 12, 22) [NOTE] ==== The `deploy` transaction is no longer supported on this version. ==== === Technical release notes Starknet * Performance - Separate the state commitment computation from the execution of the transactions * Add `starknet-class-hash` command to compute the class hash of a compiled Starknet contract Cairo: * Autoformatter: Automatically break lines inside expressions [id=\"version0.10.2\"] == Starknet v0.10.2 (Nov 29, 22) - This version introduces sequencer parallelization! This is the first step in our roadmap of performance upgrades. Details about the specific mechanism of parallelization and the roadmap in general are described in medium post]. - A new endpoint, `estimate_fee_bulk`, is added to the feeder gateway. This will allow estimating the fee of several transactions at once, where each transaction is executed relative to the resulting state from applying the previous one. === Technical release notes * Sequencing performance improvements * Builtin ratio changes, which affects builtin costs * Add `estimate_fee_bulk` API that computes the fee of multiple transactions that will be executed consecutively As part of this version, we will also increase the finality of transactions in the pending block, by fixing the timestamp at the time of the block creation. This will solve the issue of transactions moving from pending to rejected on account of too old timestamp [id=\"version0.10.1\"] == Starknet v0.10.1 (Oct 25, 22) === Technical release notes Starknet: * Add `DeployAccount` transaction (which will replace the Deploy transaction for deploying account contracts). To use it, you should first add enough funds to your account address to pay the transaction fee, and then you can invoke DeployAccount * Split the `starknet deploy_account` CLI command into `starknet new_account` and `starknet deploy_account` * Account contracts that are expected to be deployed this way should implement the`__validate_deploy__()` entry point, which should check the signature of the `DeployAccount` transaction * Improve L1 fee computation: the fee is computed according to the diff of the storage state * API: Remove `entry_point_type` field from transaction information Cairo: * Add `uint256_mul_div_mod` to `uint256.cairo` [id=\"version0.10.0\"] == Starknet v0.10.0 (Sept 05, 22) This version introduces the next step in Starknet's account abstraction design, specifically the validate/execute separation. See for more information. === Technical release notes Starknet: * Contract (breaking changes): ** @external and @view functions should be imported directly by the main compiled file. Otherwise, they will not be usable as external functions ** Forbid using the same storage variable name in two modules * New transaction version (version 1) for `invoke` and `declare` transactions: ** Transactions of version 0 are deprecated and will not be supported in Starknet from the next version (v0.11.0). Please update your systems to use the new version [NOTE] ==== In order to use transactions of version 1 you will need to upgrade your account contracts ==== ** Add nonce field to the transactions. Nonce validation is now part of the Starknet protocol and is enforced to be executed sequentially ** `Invoke`: *** Split `__execute__` to two functions:` __validate__` (only validates the transaction) and `__execute__` (only executes the transaction) *** Remove the selector (which is now always `__execute__`) field, following the above change. ** Declare: *** `declare` transaction should now be sent from an account (and is validated using `__validate_declare__` in the account contract) * Support fee for sending L1 messages. At this point, it's not mandatory and messages with no fee will still be handled. Starting from the next version it will become mandatory. Cairo: Syntax changes in Cairo (to make it more similar to rust and C++): * You can use the cairo-migrate script to convert old code to the new syntax. Use the `-i` flag to apply the changes to the files * End statements with `;` [NOTE] ==== New lines are still part of the language at this point, and you cannot put more than one instruction per line. This will change in Cairo1.0. ==== * Use `{ \u2026 }` for code blocks (instead of `:` and `end`) * Add `()` around the condition of if statements * Remove the member keyword in structs * Change comment to use `//` instead of `#` * Use `..., ap++` instead of `...; ap++` in low level Cairo code * Support return types that are not tuples. For example, `func foo() -> felt` (instead of `func foo() -> (r: felt)`) As a result, it's now mandatory to specify return types. `func foo() -> (res)` should be replaced by `func foo() -> (res: felt)`. The cairo-migrate tool does that automatically. * Return statement accepts expressions, rather than only tuples. For example, you can write `let x = (5,); return x;` * A few standard library functions were changed to return felt. The cairo-migrate script also fixes calls to those functions * Support using functions as expressions * This only applies to functions with -> felt signature`, whose ap change is known at compile-time (e.g., recursive functions cannot be used this way) * Fix a bug in the secp signature verification code that allowed a malicious prover to ignore the value of `v` (this does not let the prover fake a signature, but allows it to claim that a valid signature is invalid). * Add Cairo code for the recursive STARK verifier Technical changes: * Move from python3.7 to python3.9 [id=\"version0.9.1\"] == Starknet v0.9.1 (July 20, 22) === Technical release notes Starknet: API changes: * Add `get_block_traces` API - returns all the transaction traces of a given block * Add a list of declared contracts in `get_state_update` * Add a 0x prefix for class hash in the API * Add `starknet_version` field for blocks (only applies to new blocks) Starknet CLI: * Change the default block number to pending * Using a wallet is the default, `--no_wallet` must be specified explicitly to override this * Deploying contracts: ** Add `deploy_contract` function to the account contract created by `starknet deploy_account` ** Use this function to deploy contract (unless using `--no_wallet`). In particular, `deploy` should be used after declaring the contract (it expects the contract class hash) * Support `--dry_run` to get the transaction information without signing or sending it * Support `deploy_from_zero` in the `deploy` syscall to deploy a contract to an address that does not depend on the deployer Cairo: * Support and in if statements (`if x == y and z == w`). [NOTE] ==== At the moment other boolean combinations are not supported ==== [id=\"version0.9.0\"] == Starknet v0.9.0 (June 06, 22) This version introduces the contract class/instance paradigm into Starknet. See for more information. === Technical release notes Starknet: * Enforce fees - `max_fee` must not be set to zero, and selector must be `__execute__` * Split the concepts of contract class and contract instance. * Add `declare` transaction type * New API and CLI commands: * `declare` - Declares a contract class * `get_class_by_hash` - Returns the contract class given its hash * `get_class_hash_at` - Returns the class hash for a given contract instance address * Rename `delegate_call` to `library_call`, and change the contract address argument to class hash. * Add a `deploy` system call. * Rename `ContractDefinition` to `ContractClass` * Reduce the compiled contract file's size by removing unnecessary identifiers (this optimization can be disabled using `--dont_filter_identifiers`) Cairo: * Initial support for the `EC-op` builtin (scalar multiplication over the STARK curve). Not supported in Starknet yet. * Add additional helper methods to `blake2s.cairo`, including big-endian support Technical changes: * Change function's `return` type from a struct to a named tuple. In particular, `foo.Return.SIZE` is no longer supported."}
{"title": "commands.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"commands\"] = Commands [NOTE] ==== An asterisk (*) denotes required arguments. ==== [id=\"basic_command_line_syntax\"] == Basic command line syntax To enter a starknet command, use the following syntax: [source,bash] ---- $ starknet ---- Where: `` represents a single command that executes an operation on Starknet. `` represents zero or more command line options, each of which modifies the operation of the command. [id=\"setting_the_starknet_network_environment\"] == Setting the Starknet network environment You need to set your Starknet network environment to use either testnet or Mainnet. You can set the environment using either a command-line option or an environment variable. Possible values are: `alpha-goerli`:: Sets the Starknet network to testnet `alpha-mainnet`:: Sets the Starknet network to Mainnet .Setting the network environment using a command-line option When you enter any command, include the `--network` option. For example to use Mainnet, enter a command as follows: [source,bash] ---- $ starknet --network alpha-mainnet ---- [NOTE] ==== You can place the `--network` option before or after any other option. ==== .Setting the network environment using an environment variable Set the `STARKNET_NETWORK` environment variable as follows: [source,bash] ---- $ export STARKNET_NETWORK= ---- For example, to use testnet, enter the following command: [source,bash] ---- $ export STARKNET_NETWORK=alpha-goerli ---- == Setting custom endpoints When working with the CLI, you can manually set the endpoints for the gateways that enable you to interact with Starknet, by including the following options: `--feeder_gateway_url`:: Sets the custom endpoint for read commands. `--gateway_url`:: Sets the custom endpoint for write commands. The following are the endpoints for Starknet testnet and Mainnet: * Testnet feeder gateway URL: * Mainnet feeder gateway URL: * Testnet gateway URL: * Mainnet gateway URL: .Example: Setting a custom read endpoint The following command returns the ABI using the Mainnet feeder gateway. [source,bash] ---- $ starknet get_code --feeder_gateway_url ---- .Example: Setting a custom write endpoint The following command sends a transaction to the Starknet sequencer using the Mainnet gateway. [source,bash] ---- $ starknet invoke --gateway_url ---- [id=\"starknet_call\"] == `starknet call` [source,terminal] ---- starknet call --address --abi --function --inputs --block_hash --block_number --signature --wallet --nonce ---- Calls a Starknet contract without affecting the state, accepts the following arguments: - `contract_address`* - address of the contract being called - `contract_abi`* - a path to a JSON file that contains the link: of the contract being called - `function_name`* - name of the function which is called - `arguments`* - inputs to the function being called, represented by a list of space-delimited values - `block_hash` - the hash of the block used as the context for the call operation. If this argument is omitted, the latest block is used - `block_number` - same as block_hash, but specifies the context block by number or xref:block_tag[tag] - `signature_information` - list of field elements as described xrefBlocks/transactions.adoc#signature[here] - `wallet_name` - the name of the desired wallet, use xref:starknet_deploy_account[deploy_account] to set-up new accounts in the CLI - `nonce` - account nonce, only relevant if the call is going through an account [id=\"block_tag\"] [NOTE] ==== *Block Tag* A block context can be specified via the `latest` or `pending` tags, where the former refers to the latest accepted on L2 block and the latter refers to the xrefBlocks/transaction-life-cycle.adoc#the-pending-block[pending block]. ==== [id=\"starknet_declare\"] == `starknet declare` [source,terminal] ---- starknet declare --contract ---- Declares a new contract class on Starknet, accepts the following arguement: - `contract_class` - path to a JSON file containing the contract\u2019s compiled code [id=\"starknet_deploy\"] == `starknet deploy` [source,terminal] ---- starknet deploy --salt --contract --inputs --token ---- Deploys a new contract, accepts the following arguments: - `salt` - a seed that is used in the computation of the contract\u2019s address (if not specified, the sequencer will choose a random string) - `contract_definition`* - path to a JSON file containing the contract\u2019s bytecode and abi (can be obtained by executing link: - `constructor_inputs`* - the arguments given to the contract\u2019s constructor, represented by a list of space-delimited values - `token` - a token allowing contract deployment (can be obtained by applying link: Only used in the Alpha stages and will be deprecated in the future [NOTE] ==== The deploy token is a temporary measure which will be deprecated when fees are incorporated in the system. Only relevant for Mainnet. ==== [id=\"starknet_deploy_account\"] == `starknet deploy_account` [source,terminal] ---- starknet deploy_account --wallet --account ---- Deploys an account contract, accepts the following arguments: - `account_name` - the name given to the account, used for managing multiple accounts from the CLI (if not specified, the name `+__default__+` is used. - `wallet_provider`* - the path to module which manages the account (responsible for key generation, signing, etc.) [NOTE] ==== Today, the Starknet CLI only works with the link: account contract]. The CLI uses this specific link: provider]. To use this provider, either set up the following environment variable or pass the same value directly to the `wallet_provider` parameter: [source,bash] ---- $ export STARKNET_WALLET=starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount ---- ==== [CAUTION] ==== Using the builtin wallet providers that are part of the cairo-lang package (starkware.starknet.wallets...) is _not secure_ (for example, the private key may be kept not encrypted and without backup in your home directory). You should only use them if you\u2019re not overly concerned with losing access to your accounts (for example, for testing purposes). ==== == `starknet estimate_fee` [source,terminal] ---- starknet estimate_fee --address --abi --function --inputs ---- Returns the fee estimation for a given contract call. Accepts the following arguments: - `address`* - the address of the contract being called - `contract_abi`* - a path to a JSON file that contains the xrefContracts/contract-abi.adoc[abi] of the contract being called - `function_name`*- the name of the function being called - `arguments`* - inputs to the function being called, represented by a list of space-delimited values` == `starknet estimate_message_fee` [source,terminal] ---- starknet estimate_message_fee --from_address --to_address --function --inputs ---- Returns the fee estimation for a given xrefL1-L2_Communication/messaging-mechanism.adoc#l1-l2-message-fees[L1 handler] application. Accepts the following arguments: - `from_address`* - the L1 address of the sender - `to_address`* - the L2 address of the recipient - `contract_abi`* - a path to a JSON file containing the xref/Contracts/contract-abi.adoc[abi] of the receiving contract on L2 - `function_name`*- the name of the desired L1 handler - `arguments`* - inputs to the called handler, represented by a list of space-delimited values == `starknet get_block` [source,terminal] ---- starknet get_block --hash --number ---- Returns the requested block, exactly one of the following arguments must be given: * `block_hash` - hash of the requested block * `block_number` - number or > of the requested block [id=\"starknet_get_code\"] == `starknet get_code` [source,terminal] ---- starknet get_code --contract_address --block_hash --block_number ---- Returns the ABI and the byte code of the requested contract, accepts the following arguments: - `contact_address`* - address of the requested contract - `block_hash` - the hash of the block used as the context for the operation. If this argument is omitted, the latest block is used - `block_number` - same as block_hash, but specifies the context block by number or xref:block_tag[tag] == `starknet get_storage_at` [source,terminal] ---- starknet get_storage_at --contract_address --key --block_hash --block_number ---- Queries a contract's storage at a specific key, accepts the following arguments: * `contract_address` *- address of the requested contract * `key`* - the requested key from the given contract's storage * `block_hash` - the hash of the block relative to which the storage will be provided. In case this argument is not given, the latest block is used * `block_number` - same as block_hash, but specifies the context block by number or > [id=\"starknet_get_transaction\"] == `starknet get_transaction` [source,terminal] ---- starknet get_transaction --hash ---- Returns the requested transaction, expects the following argument: - `transaction_hash`* - hash of the requested transaction == `starknet get_transaction_receipt` [source,terminal] ---- starknet get_transaction_receipt --hash ---- Returns the xrefBlocks/transaction-life-cycle.adoc#transaction-receipt[receipt] associated with the transaction, expects the following argument: * `transaction_hash`* - hash of the requested transaction starknet invoke starknet tx_status == `starknet invoke` [source,terminal] ---- starknet invoke --address --abi --function --inputs --signature --wallet --nonce ---- Sends a transaction to the Starknet sequencer, accepts the following arguments: * `address`* - the address of the contract being called * `contract_abi`* - a path to a JSON file that contains the of the contract being called * `function_name`*- the name of the function being called * `arguments`* - inputs to the function being called, represented by a list of space-delimited values * `signature_information` - list of field elements as described xrefBlocks/transactions.adoc#signature[here] * `wallet_name` - the name of the desired wallet, use xref:starknet_deploy_account[deploy_account] to set-up new accounts in the CLI. * `nonce` - account nonce, only relevant if the call is going through an account [TIP] ==== Today, interaction with Starknet may be done either via account or by a direct call. The `signature` argument can only be provided in the case of a direct call, since otherwise providing the signature is the responsibility of the account module. To use an account you must specify `wallet_name`, otherwise a direct call will be used (you may also explicitly perform a direct call by adding `--no_wallet` to the command). Note that in the future direct calls will be deprecated and the only way to interact with the system would be through accounts. ==== == `starknet tx_status` [source,terminal] ---- starknet tx_status --hash --contract --error_message ---- Returns the transaction status, accepts the following arguments: * `transaction_hash`* - hash of the requested transaction * `contract_definition` - path to a JSON file containing the compiled contract to which the transaction was addressed. If supplied, the debug information from the compiled contract will be used to add error locations. * `error_message` - if specified, only the error message will be returned (or empty response in case the transaction was successful) The possible statuses of a transaction are: * `NOT_RECEIVED` * `RECEIVED` * `PENDING` * `REJECTED` * `ACCEPTED_ON_L2` * `ACCEPTED_ON_L1` Refer to xrefBlocks/transaction-life-cycle.adoc[this] section for more information about the transaction lifecycle."}
{"title": "starknet-compiler-options.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"starknet-compiler-options\"] = Starknet compiler options reference When the Starknet compiler is installed, you can view this command-line help in a terminal by entering the following command: [source,bash] ---- starknet-compile --help ---- == Usage [source,bash,subs=\"+quotes,+macros\"] ---- starknet-compile [-h] [--abi _ABI_] [--disable_hint_validation] [--account_contract] [--dont_filter_identifiers] [-v] [--prime __PRIME__] [--cairo_path CAIRO_PATH] [--preprocess] [--output __OUTPUT__] [--no_debug_info] [--debug_info_with_source] [--cairo_dependencies __CAIRO_DEPENDENCIES__] [--no_opt_unused_functions] file [__file__ ...] ---- == Example The following example compiles the file `contract.cairo`. It generates two files: [horizontal] contract_compiled.json:: The contract class. This file contains the bytecode and all other information necessary to execute a contract. For information on contract classes, see xrefContracts/contract-classes.adoc[]. contract_abi.json:: The contract's ABI. [source,shell] ---- starknet-compile contract.cairo \\ --output contract_compiled.json \\ --abi contract_abi.json ---- == Description A tool to compile Starknet contracts. == Positional arguments === file File names. == Optional arguments === `-h`, `--help` Show this help message and exit. === `--abi _ABI_` Output the contract's ABI. === `--disable_hint_validation` Disable the hint validation. === `--account_contract` Compile as account contract. === `--dont_filter_identifiers` Disable the filter-identifiers-optimization.If True, all the identifiers will be kept, instead of just the ones mentioned in hints or 'with_attr' statements. === `-v`, `--version` show program's version number and exit === `--prime _PRIME_` The size of the finite field. === `--cairo_path _CAIRO_PATH_` A list of directories, separated by \":\" to resolve import paths. The full list will consist of directories defined by this argument, followed by the environment variable CAIRO_PATH, the working directory and the standard library path. === `--preprocess` Stop after the preprocessor step and output the preprocessed program. === `--output _OUTPUT_` The output file name (default: `stdout`). === `--no_debug_info` Don't include debug information in the compiled file. === `--debug_info_with_source` Include debug information with a copy of the source code. === `--cairo_dependencies _CAIRO_DEPENDENCIES_` Output a list of the Cairo source files used during the compilation as a CMake file. === `--no_opt_unused_functions` Disables unused function optimization."}
{"title": "api_rpc.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "= Full-nodes & API services A list of recommended full-nodes & API providers. .Node providers [cols=\"1,2,1\",stripes=even] [%header,cols=\"2,2,1\"] |=== | Provider name | Description | More information |Juno|A Starknet full-node written in go-lang by Nethermind |link: |Papyrus|A Starknet full-node written in Rust by StarkWare | link: |Pathfinder|A Starknet full-node written in Rust by Equilibrium |link: |=== .API providers [cols=\"1,2,1\",stripes=even] [%header,cols=\"2,2,1\"] |=== | Provider name | Description | More information |Alchemy |An API service for Starknet | link: |Bware labs | An API service for Starknet| link: |Chainstack | An API service for Starknet| link: |Infura | An API service for Starknet|link: |Lava Protocol|An open-source protocol for reliable access to RPC data | link: |==="}
{"title": "ref_block_explorers.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "= Starknet block explorers A _block explorer_, or blockchain explorer, enables you to see transactions, blockchain metrics and other information. The following block explorers provide information on Starknet. .Starknet block explorers, in alphabetical order [cols=\"1,2\",stripes=even] |=== | Block explorer name | URL |Starkscan | link: |ViewBlock | link: |Voyager | link: |==="}
{"title": "audit.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"audit_providers\"] = Audit service providers Building a Starknet project and want your contract to be audited? The companies listed below have designated teams that provide auditing services to Starknet contracts. .A list of companies providing contract audits for Starknet [cols=\"1,2\",stripes=even] |=== | Company name | URL |ABDK | link: |Chain Security | link: |Consensys Diligence | link: |Extropy | link: |Nethermind | link: |Open Zeppelin | link: |PeckShield | link: |Trail of Bits | link: |Zellic | link: |Ginger Security | link: |==="}
{"title": "index.adoc", "repo_owner": "starknet-io", "repo_name": "starknet-docs", "text": "[id=\"important_addresses\"] = Important addresses == Starknet Alpha on Mainnet The Starknet core contract:: link: Verifier address:: link: Sequencer base URL for API routing:: \\ == Starknet Alpha version on Goerli testnet 1 The Starknet core contract:: link: Verifier address:: link: Sequencer base URL for API routing:: \\ == Starknet Alpha version on Goerli testnet 2 The Starknet core contract:: link: Verifier address:: link: Sequencer base URL for API routing:: \\ == Bridged tokens The tokens that are currently bridged to Starknet are listed in the following `.json` files: link: The addresses of the tokens currently bridged to Starknet Mainnet. The addresses of the tokens currently bridged to Starknet testnet. The addresses of the tokens currently bridged to Starknet testnet2. Each token has the following parameters: Name:: Token name. Symbol:: Token symbol. Decimals:: Number of decimal places used to get the user representation. l1_token_address:: Address of the L1 ERC-20 contract. l2_token_address:: Address of the L2 ERC-20 contract. l1_bridge_address:: Address of the L1 bridge contract. l2_bridge_address:: Address of the L2 bridge contract."}
{"title": "how-to-contribute.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= How to contribute First off, thanks for taking the time to contribute! Contributions are what make the open-source community such an amazing place to learn, inspire, and create. Any contributions you make will benefit everybody else and are **greatly appreciated**. Please read xrefcontribution-guidelines.adoc[our contribution guidelines], and thank you for being involved! == Documentation contributions needed See below for a full list of content and what is currently missing: // Language constructs === Language Constructs * xrefmodules-and-source-files.adoc[3. Modules and source files] * xreftype-aliases.adoc[4.4 Type aliases] * xrefimpl-aliases.adoc[4.5 Impl aliases] * xrefconstant-items.adoc[4.8 Constant items] * xrefnamespaces.adoc[5.2 Namespaces] * xrefvisibility.adoc[5.3 Visibility] * xrefitem-statement.adoc[6.3 Item statement] * xrefpath-expressions.adoc[7.2 Path expressions] * xrefarithmetic-and-logical-operators.adoc[7.4.2 Arithmetic and logical operators] * xrefequality-operators.adoc[7.4.3 Equality operators] * xrefcomparison-operators.adoc[7.4.4 Comparison operators] * xrefboolean-operators.adoc[7.4.5 Boolean operators] * xreferror-propagation-operator.adoc[7.4.6 Error propagation operator] * xreffunction-calls.adoc[7.6 Function calls] * xrefmethod-calls.adoc[7.7 Method calls] * xrefmember-access-expressions.adoc[7.8 Member access expressions] * xrefstruct-expressions.adoc[7.10 Struct expressions] * xrefif-expressions.adoc[7.11 If expressions] * xrefmatch-expressions.adoc[7.12 Match expressions] * xreffor-loop-expressions.adoc[7.13 For loop expressions] * xrefpatterns.adoc[8. Patterns] * xreffelt252-type.adoc[9.1.2 Felt252 type] * xrefstring-types.adoc[9.1.4 String types] * xrefstruct-types.adoc[9.1.8 Struct types] * xrefenum-types.adoc[9.1.9 Enum types] * xrefarray-types.adoc[9.1.10 Array types] === Language Semantics * xrefmemory-model.adoc[Memory model] * xrefconstant-evaluation.adoc[Constant evaluation] * xrefapplication-binary-interface.adoc[Application binary interface] * xrefruntime.adoc[Runtime] ## Support - We encourage developers to ask and answer questions on - Contact options listed on link: GitHub profile] ## Project assistance If you want to say **thank you** or/and support active development of Cairo: - Add a Star] to the project. - Tweet about your Cairo work. - Write interesting articles about the project on or your personal blog. Together, we can make Cairo **better**! ## Authors & contributors For a full list of all authors and contributors, see link: contributors page]."}
{"title": "index.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "[id=\"index\"] = Welcome to Cairo 1.0 Cairo is the first Turing-complete language for creating provable programs for general computation. It is a Rust-like high-level language. Like Rust, it is intended to allow developers to easily write code that is efficient and safe. One of the most significant changes in Cairo 1.0 is the syntax. We have taken inspiration from Rust to create a more developer-friendly language that is easier to read and write. The new version of Cairo allows writing safer code (strongly typed, ownership and borrowing, etc.), while also being more expressive. Cairo 1.0 also introduces Sierra, a new intermediate representation that ensures every Cairo run can be proven. This makes Cairo 1.0 particularly well-suited for use in a permissionless network like link: where it can provide robust DoS protection and censorship resistance. You can read more about Sierra link: If you are looking for Cairo 0 documentation, please see link: ## Help us to improve this documentation This documentation site is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]. Please see xref:how-to-contribute.adoc[here] for a list of missing content and learn more about how to contribute by reading the xrefcontribution-guidelines.adoc[Contribution guidelines] of this site. |=== |*Useful links* |link: a Bug] |link: a feature] |link: a Question] |link: Workflow Status] |link: a pull requests] |==="}
{"title": "roadmap.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "# Cairo 0 feature parity The next milestone is to reach feature parity with Cairo version 0. In this section we track the missing features to reach feature parity with the old compiler version. We divided them by Cairo, Starknet and specific system calls in Starknet OS. ## Cairo features |=== |Name|Status |`if (x == y)` | |`if (x == y & z == w)` | |Short strings | |Structs | |Builtin Range check | |Builtin Pedersen | |Builtin Bitwise | |Uint256 | |Builtin ec-op | |Append-only arrays | |Named arguments | |Serde (serialization) | |Dict | |`if (cond1 && cond2)` | |Find element | |=== ## Starknet features (complete) |=== |Name|Status |Contract interface | |External functions and view functions | |Storage variables - felts | |Storage variables - mapping | |Storage variables - other types as values | |Events | |=== ## Starknet system calls (complete) |=== |Name|Status |storage_read | |storage_write | |get_caller_address | |call_contract | |library_call | |deploy | |get_block_number | |get_block_timestamp | |get_contract_address | |get_sequencer_address | |get_transaction_info | |send_message_to_l1 | |deploy | |==="}
{"title": "contribution-guidelines.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Contribution guidelines When contributing to the Cairo repository, please first discuss the change you wish to make via issue, email, or any other method with the owners of this repository before making a change. Please note we have a link: of conduct], please follow it in all your interactions with the project. == Issues and feature requests You've found a bug in the source code, a mistake in the documentation or maybe you'd like a new feature? Take a look at link: Discussions] to see if it's already being discussed. You can help us by link: an issue on GitHub]. Before you create an issue, make sure to search the issue archive - your issue may have already been addressed! Please try to create bug reports that are: - _Reproducible._ Include steps to reproduce the problem. - _Specific._ Include as much detail as possible: which version, what environment, etc. - _Unique._ Do not duplicate existing opened issues. - _Scoped to a Single Bug._ One bug per report. **Even better: Submit a pull request with a fix or new feature!** == How to submit a pull request 1. Search our repository for open or closed link: Requests] that relate to your submission. You don't want to duplicate effort. 2. Fork the project 3. Create your feature branch (`git checkout -b feat/amazing_feature`) 4. Implement your feature 5. Run the code formatter for Rust and Cairo (`scripts/rust_fmt.sh && scripts/cairo_fmt.sh`) 6. Commit your changes (`git commit -m 'feat: Add amazing_feature'`) 7. Push to the branch (`git push origin feat/amazing_feature`) 8. link: a Pull Request]"}
{"title": "full-grammar.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Full Grammar This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "security.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "# Security Cairo follows good practices of security, but 100% security cannot be assured. Cairo is provided **\"as is\"** without any **warranty**. Use at your own risk. ## Reporting a Vulnerability If there are any vulnerabilities in **Cairo**, don't hesitate to _report them_. 1. Use any of the link: contact addresses]. 2. Describe the vulnerability. If you have a fix, that is most welcome -- please attach or summarize it in your message! 3. We will evaluate the vulnerability and, if necessary, release a fix or mitigating steps to address it. We will contact you to let you know the outcome, and will credit you in the report. Please **do not disclose the vulnerability publicly** until a fix is released! 4. Once we have either a) published a fix, or b) declined to address the vulnerability for whatever reason, you are free to publicly disclose it."}
{"title": "compiling-and-running-cairo-files.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "# Compiling and running Cairo files Compile Cairo to Sierra: ```bash cargo run --bin cairo-compile -- --single-file /path/to/input.cairo /path/to/output.sierra --replace-ids ``` Compile Sierra to casm (Cairo assembly): ```bash cargo run --bin sierra-compile -- /path/to/input.sierra /path/to/output.casm ``` Run Cairo code directly: ```bash cargo run --bin cairo-run -- --single-file /path/to/file.cairo ``` For more information, see link: You can also find Cairo examples in the link: directory within the main Cairo repository. For running tests specifically, see link:"}
{"title": "compiling-starknet-contracts.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Compiling Starknet Contracts Compile a Starknet Contract to a Sierra ContractClass: ```bash cargo run --bin starknet-compile -- /path/to/input.cairo /path/to/output.json ``` Or specify the contract path if multiple contracts are defined in the same project: ```bash cargo run --bin starknet-compile -- /path/to/crate/ /path/to/output.json --contract-path path::contract ``` Compile the ContractClass of a CompiledClass: ```bash cargo run --bin starknet-sierra-compile -- /path/to/input.json /path/to/output.casm' ```"}
{"title": "development.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "# Development ## Install the language server Follow the instructions in link:"}
{"title": "prerequisits.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "# Prerequisites ## Install dependencies - Install link: - Setup Rust: ```bash rustup override set stable && rustup update ``` Ensure Rust was installed correctly by running the following from the root project directory: ```bash cargo test ``` Clone the Cairo repo: ```sh git clone ``` ## Development environment setup To set up a development environment, please follow these steps: 1 . Download and install link: 2 . Follow instructions in link: The `rustfmt` configuration used by cairo requires a nightly version of Rust. You can install the nightly version by running. ```sh rustup install nightly-2022-11-03 ```"}
{"title": "aliases.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Type and impl aliases A type alias is a new name for an existing type. It is not a new type. Type aliases are created with the type keyword: ```rust type NewName = ConcreteType; ``` Examples: ```rust type IntAlias = i32; type BoxIntAlias = Box; type BoxOption = Box>; ``` An impl alias is similar to a type alias, but for impls. An impl alias is a new name for an existing impl. It is not a new impl. Impl aliases are created with the impl keyword: ```rust impl NewName = ConcreteImpl; ``` Examples: ```rust // Pow implementation for any algebra. impl AnyAlgebraPow> of Pow { ... } // Impl alias for Pow of i32. impl Int32Pow = AnyAlgebraPow; ```"}
{"title": "arithmetic-and-logical-operators.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Arithmetic and logical operators This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "array-expressions.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Array expressions This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "array-types.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Array types This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "assignment-statement.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Assignment statement // TODO(spapini): Assignment is an expression. An _assignment statement_ moves a value into the specified target. An assignment statement consists of a xref:lvalue.adoc[lvalue] followed by an equals sign (=) and a expression. After the assignment, the value of the `lvalue` is changed to the value of the expression."}
{"title": "block-expression.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Block expression A block expression, or block, is a control flow expression. As a control flow expression, a block sequentially executes its component statements and then its optional tail expression. The syntax for a block is `{`, then any number of statements, then an optional tail expression, and finally a `}`. Statements are usually required to be followed by a semicolon, with one exception: Expression statements usually require a following semicolon except if its outer expression is a flow control expression. Furthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics. The type of a block is the type of the final operand if exists. Otherwise, if the last statement is a xref:never-type.adoc[never type] emitting statement (e.g. return, break) the block's type is the xref:never-type.adoc[never type], otherwise it is the xref:unit-type.adoc[unit type]. [source,rust] ---- // Evaluated to unit-type. let _: () = { fn_call(); }; // Evaluated to i32 type. let five: i32 = { fn_call(); 5 }; // Block evaluates to never-type, which is coerced to explicitly set i32. let never: i32 = { return 6; }; ----"}
{"title": "boolean-operators.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Boolean operators This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "boolean-types.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Boolean types The boolean type represents a logical value of either true or false. It is represented by the keyword `bool`. Values of this type are created using the keywords `true` and `false`. == Operators == The following operators are defined for the boolean type: [options=\"header\"] |=== | Operator | Description | Example | `\\|` | Or | `x \\| y` | `&` | And | `x & y` | `^` | Xor | `x ^ y` | `!` | Not | `!x` | `==` | Equality | `x == y` | `!=` | Inequality | `x != y` |=== == Examples == [source,rust] ---- fn main() { let x: bool = true; let y = false; let z1 = x | y; // z1 is true let z2 = x & y; // z2 is false let z3 = !x; // z3 is false let z4 = x ^ y; // z4 is true } ----"}
{"title": "comments.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Comments Comments follow general C++/Rust style of line (`//`) comments. == Example [source,rust] ---- // Comment. ----"}
{"title": "comparison-operators.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Comparison operators This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "constant-items.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Constant items This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "contracts.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Contracts Starknet contracts can be written in Cairo. == Example [source,rust] ---- #[starknet::contract] mod my_contract { struct Storage { x: felt252, m: LegacyMap::, } #[external(v0)] fn foo(value: felt252) -> felt252 { let y = x::read() + value; m::write(y, 3_u128); y } } ---- A contract is written as an inline module, with designated attributes. The main attribute is the `#[starknet::contract]` attribute that makes the starknet plugin treat the module as a contract. == Storage Unlike a Cairo program, which is stateless, a Starknet contract has a state, called \u201cthe contract\u2019s storage\u201d. Transactions invoked on such contracts may modify this state. In a contract, you can define a struct named `Storage`. The members of this struct are the storage variables. The storage variables may be of any Cairo type that implements the `StorageAccess` trait, and legacy mappings that store key-value pairs. Accessing a storage member is done using the `::read()` and `::write(value)` functions which are automatically created by the Starknet plugin. For example, for the storage member `x` above, access is done using `x::read()` and `x::write(value)`. Defining a mapping storage member is done using the `LegacyMap` \"type\" that is expanded by the Starknet plugin. The keys must implement the `LegacyHash` trait and the values must implement the `StorageAccess` trait. Accessing such storage members is done using the `::read(key)` and `::write(key, value)` functions which are also automatically created by the Starknet plugin. For example, for the storage member `m` above, access is done using `m::read(key)` and `m::write(key, value)`. When a contract is deployed, all of its storage variables are default-initialized (deserialized from zeroes). == Entry points Starknet contracts have no main() function. Instead, each function may be annotated as a special function using one of the attributes below: - `#[external(v0)]` functions may be called by Starknet users or by other contracts. For example: [source] ---- #[external(v0)] fn external_example(ref self: ContractState, value: felt252) { x::write(value); } ---- Note the first parameter. It represents the state of the contract storage. The `ref` modifier means that the state may change - by writing to storage, for example. Another possibility is to get a read-only reference to the storage: [source] ---- #[external(v0)] fn view_example(self: @ContractState) -> felt252 { x::read(value) } ---- This is a view function - it can only read from the storage. - `#[constructor]` function is called when the contract is deployed. There may be only one such function and it must be called `constructor`. If it is not defined, the contract is deployed with all storage variables default-initialized. For example: [source] ---- #[constructor] fn constructor() { x::write(3); } ---- - `#[l1_handler]` functions are called when the contract receives a message from L1. For example: [source] ---- #[l1_handler] fn l1_handler_example(from_address: felt252) { assert(from_address == 0x5678, 'EXPECTED_0x5678'); x::write(5); } ---- - Functions without any of the above attributes are private functions, and may only be called by other functions in the same contract. They are not entry points. For example: [source] ---- fn private_helper_add(a: felt252, b: felt252) -> felt252 { a + b } ---- == Events Contract events trigger events on Starknet. They can be triggered by the contract. The are defined using the `#[event]` attribute on an empty function. For example: [source] ---- #[event] fn event_example(event_data: felt252) {} ---- == ABI Each contract has an ABI (Application Binary Interface) that defines: - The entry points that can be called on it, of the kinds mentioned above. - The types in the entry points signatures. - The contract's events. == Calling Other Contracts The Starknet plugin generates a contract interface for each defined contract. It is a trait that can be found in `::__abi`. You can also write a contract interface manually, for contracts that are not implemented in your code. For example, the contract interface for `my_contract` above can be manually written as: [source,rust] ---- #[starknet::interface] trait IMyContract { fn foo(value: felt252) -> felt252; } ---- === Using the Contract Interface Dispatcher For each contract interface, 2 dispatchers are automatically created and exported: a contract-dispatcher and a library-dispatcher. That is, for every contract you implement or contract interface you manually add. You can use another contract interface contract-dispatcher to call another contract in the following way: [source,rust] ---- #[starknet::interface] trait IMyContract { fn foo(ref self: TContractState, value: felt252) -> felt252; } #[starknet::contract] mod my_second_contract { use super::IMyContractDispatcherTrait; use super::IMyContractDispatcher; #[external(v0)] fn call_foo( another_contract_address: starknet::ContractAddress, a: felt252 ) -> felt252 { let mut dispatcher = IMyContractDispatcher { contract_address: another_contract_address }; dispatcher.foo(a) } } ---- This will run the other contract's logic in its context, and may, for example, change its state. You can also call a function from another contract class as a library function. This means the function's logic is executed from the caller contract's context. This can be done using the library-dispatcher in the following way: [source,rust] ---- #[starknet::interface] trait IMyContract { fn foo(value: felt252); } #[starknet::contract] mod my_second_contract { use super::IMyContractDispatcherTrait; use super::IMyContractLibraryDispatcher; #[external(v0)] fn libcall_foo(a: felt252) -> felt252 { IMyContractLibraryDispatcher { class_hash: starknet::() }.foo(a) } } ---- Where `0x1234` is the `ClassHash` of the contract class implementing `foo`. === Using system calls Another way to call another contract is to use the `starknet::call_contract_syscall` system call. The dispatcher described above is the high-level syntax for the low-level system calls. Thus, prefer using the dispatcher method. You can use the system call directly if you want to have customized error handling or more control over the serialization/deserialization of the call data and the returned data. To directly call another contract using `starknet::call_contract_syscall` you can do the following, but the result is the serialized return value of the function which you need to deserialize yourself. You also need to compute the selector of the function you want to call, which is the keccak hash of the function name - in this case `starknet_keccak(\"foo\")`. [source,rust] ---- #[starknet::contract] mod my_second_contract { #[external(v0)] fn syscall_call_another_contract( address: starknet::ContractAddress, selector: felt252, calldata: Array ) -> Span:: { starknet::call_contract_syscall( :address, entry_point_selector: selector, calldata: calldata.span() ).unwrap_syscall() } } ---- // TODO(yuval): add links to compilation, abi format, declaring/deployment from hello_starknet."}
{"title": "derive-macro.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Derive macro The _derive macro_ is added to a type definition to provide it with some basic implementations. The derive macro is used to implement traits for structs and enums automatically. The compiler will generate implementations for the requested traits. Note this is supported for generic types as well. // TODO(spapini): Use cairo syntax highlighting. [source,rust] ---- #[derive(Copy, Drop, PartialEq)] struct Foo { x: i32, y: i32, } #[derive(Copy)] struct FeltAndT> { f: felt252, t: T, } ---- == Existing derived traits * `Copy` - Marks the type as being safe to copy by simply copying bits. All members of the type must also be `Copy`. See xref:linear-types.adoc[linear types] for more information. * `Clone` - Implements the clone method to explicitly create a copy of the type. All members of the type must also be `Clone`. See xref:linear-types.adoc[linear types] for more information. * `Drop` - Marks the type as being safe to drop. All members of the type must also be `Drop`. See xref:linear-types.adoc[linear types] for more information. * `Destruct` - Implements the destruct method to explicitly destroy the type. All members of the type must also be `Destruct`. See xref:linear-types.adoc[linear types] for more information. * `PartialEq` - Implements the xref::equality-operators.adoc[equality operators] `==` and `!=` for the type. All members of the type must also be `PartialEq`. * `Serde` - Implements the Serde trait for serialization and deserialization for the type. All members of the type must also be `Serde`."}
{"title": "enum-types.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Enum types This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "enums.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Enums An enum is a type that can hold one of the types from the list of its defined variants. Each variant has its own type, and when such an enum variable holds a variant, it contains a value of the type of the variant. It is one of the ways to define custom user types. The variants of an enum can be of any defined type, including user-defined types, like other enums or xref:structs.adoc[structs]. == Definition An enum is defined by the `enum` keyword. Here are a few examples of enum definitions: * An enum with only xref:unit-type.adoc[unit-type] variants: ```rust enum Color { red: (), green: (), blue: (), } ``` * An enum with only core type variants: ```rust enum Status { /// Time passed since submission. Pending: u32, /// true for success, false for failure. Done: bool, } ``` * An enum with members of other user-defined types: ```rust enum Car { /// color Sedan: Color, /// color, number of doors Hatchback: (Color, u32), } ``` == Usage An enum is instantiated with the `EnumName::VariantName(value)` syntax, where `value` is of the type of the variant `VariantName`. For example: ```rust let red = Color::red(()); let success = Status::Done(true); let red_sedan = Car::Sedan(Color::red(())); let blue_hatchback = Car::Hatchback((Color::blue(()), 5)); ``` To inspect an enum variable, it can be matched using the `match` keyword. A match expression must have an arm for each variant of the enum, that specifies the logic that should happen in the case the enum variable holds that variant. For example: ```rust fn car_color(car: Car) -> Color { match car { Car::Sedan(color) => color, Car::Hatchback((color, _)) => color, } } ``` For more details about match expressions, see xref:match-expressions.adoc[here]."}
{"title": "equality-operators.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Equality operators This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "error-propagation-operator.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Error propagation operator This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "error-type.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Error type This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "expression-statement.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Expression statement An _expression statement_ evaluates an xref:expressions.adoc[expression] and ignores its result. Its purpose is to trigger side effects of expression evaluation only. When an expression that ends with a block (i.e. '}') is used in a context where a statement is permitted, the trailing semicolon can be omitted without changing the semantic meaning. This is different than omitting the semicolon after a non-block expression. // TODO(spapini) Add links to the relevant expressions when they are written. This can include if, match, for, etc. This can cause an ambiguity between it being parsed as a standalone statement and as a part of another expression; in this case, it is parsed as a statement. // TODO(spapini): Use cairo syntax highlighting. [source,rust] ---- v.pop(); // Ignore the element returned from pop if v.is_empty() { v.push(5); } else { v.remove(0); } // Semicolon can be omitted. [1]; // Separate expression statement, not an indexing expression ---- When the trailing semicolon is omitted, the result return type of the expression must be the xref:unit-type.adoc[unit type]. [source,rust] ---- // bad: the block's type is i32, not () // Error: expected `()` because of default return type // if true { // 1 // } // good: the block's type is i32 if true { 1 } else { 2 }; ----"}
{"title": "expressions.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Expressions This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "felt252-type.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Felt252 type This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "felt252dict-type.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Felt252dict Cairo currently supports a dictionary type called `Felt252Dict` that maps keys of type `felt252` to other simple types, namely `u8`, `u16`, `u32`, `u64`, `u128`, `felt252` and `nullable`. The `nullable` type enables the dictionary to contain more complex types. By default, the value `0`, or value logically equivalent to `0`, is returned for non-existing keys. Here is a simple usage example for a dictionary: [source,rust] ---- let mut dict = Felt252DictTrait::new(); dict.insert(10, 110); dict.insert(11, 111); let val10 = dict[10]; // 110 let val11 = dict[11]; // 111 let val12 = dict[12]; // 0 dict.insert(10, 120); let val10 = dict[10]; // 120 ---- == Dictionary Entry Reading from a dictionary creates a copy of the value and thus requires the value to implement the Copy trait. However, dictionaries also support a special type of read access, using the dictionary `entry` method, which is useful for in-place updates of the dictionary. To create an entry, call `entry(key)`, which returns the current value of the given key and a `Felt252DictEntry` object. The `Felt252DictEntry` object is a temporary owner of the dictionary and can only be destructed by calling `finalize(new_value)` on it. This ensures that the dictionary is not used while it is being modified. [source,rust] ---- let mut dict = Felt252DictTrait::new(); dict.insert(10, 110); let (val10, entry) = dict.entry(10); let new_val = do_some_calculation(val10); entry.finalize(new_val); let val10 = dict[10]; // new_val ---- == Dictionary Destruction Dictionaries are automatically destroyed when they go out of scope. However, the destruction process of a dictionary is not trivial, and the `Destruct` trait is implemented for `Felt252Dict``. This means that `Destruct` must be derived for any type that contains a dictionary. For more information, see the xref:linear-types.adoc#Destructors[Destructors] section. [source,rust] ---- #[derive(Destruct)] struct MyStruct { dict: Felt252Dict, } ----"}
{"title": "for-loop-expressions.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= For loop expressions This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "function-calls.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Function calls A call expression calls a xref:functions.adoc[function]. The syntax for a call expression is the xref:path.adoc[concrete path] of the function followed by a list of arguments. The list of arguments is a comma-separated list of expressions enclosed in parentheses. [source,rust] ---- (,,...) ---- Examples: [source,rust] ---- cmp::max(a: 5, b: 1) get_info() increment(ref a.b) ---- A call expression evaluates to the value returned by the function. The expression's type is the return type of the function. For example, the expression `is_le(1, 3)` evaluates to `true`, and its type is `bool`. == Arguments The number of arguments passed should match the number of parameters defined in the function signature. The type of each argument should match the type of the corresponding parameter. There are 2 kinds of arguments: Expressions and references. A reference argument is passed to reference parameters, and an expression argument is passed to regular parameters. === Expression arguments Any expression can be passed to a regular parameter. The type of the expression should match the type of the parameter. Example: `cmp::max(a: 5, b: 1)`. === Reference arguments The syntax for a reference argument is xref:lvalue.adoc[`ref lvalue`]. The type of `lvalue` should match the type of the reference parameter. The behavior of passing a reference argument is similar to the xref:assignment-statement.adoc[assignment]. `lvalue` is passed to the function and then reassigned to when the function returns. Example: `increment(ref a.b)`. [source,rust] ---- fn main() { let x = 3; let mut y = A { z: 5 }; foo(x, ref y.z); } ---- == Argument evaluation order The arguments are evaluated from left to right, starting with all the expression arguments, and then the reference arguments. This is important, since the value of a reference argument may change during evaluation of the expression arguments. == Named arguments Arguments can also be specified explicitly by the parameter name. For example `inc_3(x: 7)`. This is called a \"named argument\" and it verifies that the name of the parameter is correct, to prevent mistakes. For example, a call to `inc_3(y: 7)` would not compile - If you use a variable as an argument and its name is the same as the parameter name, a shorthand for writing `inc_3(x: x)` is to simply write `inc_3(:x)`. This lets you write the name only once, but still verifies it. Here too, `inc_3(:y)` (assuming there is a variable `y` in the scope) would not compile. With a reference argument, you can write `mut_inc_3(ref x:y)`, or `mut_inc_3(ref :x)`."}
{"title": "functions.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Functions A function is a unit of code that performs some logic. It is defined using the `fn` keyword. Examples of functions are: [source] ---- fn main() { let x = 3; } fn inc(x: u32) -> u32 { x + 1 } ---- A function consists of 2 main parts: the function signature and the function body. For example, [source] ---- // Function signature | | Body starts here // V V fn inc_n(x: T) -> T { x + N } ---- == Function signature The function signature defines the function name, the xref:generics.adoc[generic parameters], the parameters and the return type. [source,rust] ---- fn [>]() [-> ] ---- In the example above, the signature is `fn inc_n(x: T) \\-> T`. === Function name The function name is the name used to refer to the function. The Cairo convention is to name functions using the 'snake_case' form. In the example above, the function name is `inc_n`. === Parameters Parameters define the types of the values that are passed to the function when it is called and define xref:variables.adoc[variables] to the function's body. Each such variable can be referred to using the parameter name to be used in the function body. The parameters are defined using a comma-separated list of `[] : ` items, enclosed by parentheses (`(...)`). In the `inc_n` example above, there is one parameter named `x` of the generic type `T`. You can specify modifiers of the function parameters. These can be either `mut` or `ref` (not both). A parameter that is defined with the `mut` modifier, defines a mutable variable, and can be modified in the function. A parameter that is defined with the `ref` modifier, simulates a reference to the value passed to the function. It behaves similarly to a mutable variable, but mutating it also affects its value in the caller function. For example: [source,rust] ---- fn foo(mut x: u32, ref y: u32) { x *= 3; y = x + 1; } ---- `x` is a mutable parameter and `y` is a reference parameter. See below an example of calling it. === Return type The return type defines the type of the value that is returned by the function when it is called. It is the type that appears in the signature after the `\\->`. Note that in Cairo, functions always return a value. When the function has no particular value it should return, it is common to return the xref:unit-type.adoc[unit type] (`()`). In this case, the return type can be omitted (including the `\\->`). In the example above, the return type is of type `T`. == Function body // TODO(yuval): move most of it to a separate page about block expressions. The function body is the code that is executed when the function is called. It is enclosed by the curly braces (`{...}`) and consists of a list of 0 or more xref:statements.adoc[statements], and an then an optional xref:expressions.adoc[expression] which is called the \"tail expression\". The statements are executed one after the other in the defined order. Then, if a tail expression exists, its evaluated value is returned by the function. If there is no tail expression, the function returns the xref:unit-type.adoc[unit type] (`()`). In the example above, the function body is `{ x + N }`, which consists of zero statements and a tail expression `x + N` whose value is the return value of the function. == Calling a function See xref:function-calls.adoc[Function calls]. // TODO(yuval): mention methods/self? // TODO(yuval): mention panics/implicits? (it's part of the signature). // TODO(yuval): mention inline. // TODO(yuval): mention local compilability."}
{"title": "generics.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Generics Generic programming is a way to define \"recipes\" for creating concrete link:items.adoc[items]. This recipe has parameters called \"generic parameters\" (in addition to the \"normal\" parameters). For example: [source,rust] ---- fn foo(x: T) -> T { x } ---- This is a recipe for creating an identity function for any type `T`. link:items.adoc[Items] such as link:functions.adoc[functions], structs, enums, traits, impls, extern types and type aliases can be generic. They are defined using a comma-separated list, enclosed by angle brackets (``), immediately following the item's name. If an item doesn't require generic parameters, the whole `` clause can be omitted. Each generic parameter has a name that is used to refer to it in the item's body. For example, the generic struct `Box` below defines a type that can hold any type of data: [source,rust] ---- fn main() { struct Box { value: T, } let box_u32 = Box:: { value: 5_u32 }; let box_u128 = Box:: { value: 1_u128 }; let box_box_u32 = Box::> { value: 100_u32 }; } ---- In this example, `T` is a generic parameter. When substituted with concrete types/data, the \"recipe\" forms a concrete item. Multiple concrete items can be formed from the same \"recipe\". The concrete values that substitute the generic parameters are called generic arguments. In the above example, `u32` and `u128` are generic arguments. In the last statement, `u32` is a generic argument to create the concrete type `Box::` (a `Box` that holds `u32`) and `Box::` is then used as a generic argument to create another concrete type: `Box::>` ((a `Box` that holds a `Box` that holds `u32`)). == Types of Generic Parameters Cairo supports several types of generic parameters: === Type Generic Parameters Type generic parameters are used to define generic types. This is the default type of a generic parameter, thus to add such a generic parameter, you should simply specify a name for it. For example, the generic struct `Box` above has a type generic parameter with the name `T`. === Impl Generic Parameters Impl generic parameters are used to declare impls that exist in the scope of the item. It can be used by the item when it refers to the relevant trait. This allows the item to use trait functions, while allowing its users to determine which impl will be actually used. For example: [source,rust] ---- trait MulTrait { fn mul(x: T) -> T; } impl Double of MulTrait:: { fn mul(x: u32) -> u32 { x * 2 } } impl Triple of MulTrait:: { fn mul(x: u32) -> u32 { x * 3 } } fn foo>(x: T) -> T { MyImpl::mul(x) } fn main() { let x = foo::>(5); assert(x == 10, 'Should be doubled'); let y = foo::>(5); assert(y == 15, 'Should be tripled'); } ---- The generic function `foo` defines an impl generic parameter named `MyImpl`. `main` uses 2 concrete forms of `foo`. One uses the `Double` implementation of the `MulTrait` trait, and one uses the `Triple` implementation of the `MulTrait` trait. Even if the impl generic parameter name is not used in the item body, the fact that it was specified as a generic parameter can be used to apply some restrictions to the generic types used by the item. For example, `foo` from the above example can't have a concrete form in which `T` is `u128` as there is no impl of `MulTrait` for `u128`. Note that in many cases generic arguments can be inferred and thus can be omitted from the use of the item. === Const Generic Parameters Const generic parameters are used to define generic constants. It is currently very partially supported and should not be used. === Generic arguments Generic arguments are the concrete values that are used to instantiate generic parameters. They are specified in xref:path.adoc[paths] that describe generic items. Each kind of generic parameter has its own kind of generic arguments: * Type generic parameters are instantiated with type expressions. * Impl generic parameters are instantiated with impl expressions. * Const generic parameters are instantiated with const expressions. These are not supported yet."}
{"title": "hints.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Hints This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "identifiers.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Identifiers An identifier is a sequence of one or more alphanumeric characters and underscores that is used to name a language construct. The exceptions are: - A single underscore character does not form an identifier. Using a single underscore instead of an identifier means no identifier is given to this construct. - Cairo xref:keywords.adoc[keywords] cannot be used as identifiers. [NOTE] ==== Identifiers starting with an underscore are typically used to indicate an identifier that is intentionally unused, and will silence the unused warning. ==== == Case sensitivity Cairo is a _case-sensitive_ language. This means that identifiers that differ by case of one or more of their characters are distinct."}
{"title": "if-expressions.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= If expressions This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "impl-aliases.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Impl aliases This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "implicit-arguments.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Implicit arguments // TODO(spapini): Fill with content. This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "inference.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Inference // TODO(spapini): Move to language semantics. Inference occurs when the compiler can deduce certain semantic info without it being explicitly specified in the source code. Inference applies to types, impls and generic arguments. Places where inference is enabled: * Type inference on link:let-statement.adoc[`let`] missing statement type clauses. * Impl inference on method calls. * Impl inference when calling by trait. * Generic argument inference. Examples: ```rust let x = 1_u8; // x is inferred to be u8 let y = Option::Some(x); // _ is inferred as u8, and y is inferred as Option let u: u32 = Into::::into(x); // concrete impl for Into is inferred let u: u32 = x.into(); // The generic arguments for Into and the concrete impl // are inferred ``` == Complex impl example ```rust trait Display { fn display(x: T) -> Array; } impl IntoArrayU8Display>> of Display { fn display(x: T) -> Array { x.into() // Inferred as TIntoArrayU8::into(x) } } impl U32IntoArrayU8 of Into> { fn into(x: u32) -> Array { // ... } } fn main() { let x = 1_u32; let y = Display::display(x); // Inferred as IntoArrayU8Display::display(x) } ``` == Search locations for impl When inferring an impl of a trait, the compiler will search for the impl in the following locations: * Defined generic parameters in the current scope. * The current module. * The core module. * Defining module of the trait. * Defining module of each of the generic arguments of the trait. For example, the impl for `Display` will be searched for in the module where `usize` is defined. == Multiple impls and ambiguity When searching for an impl, and multiple results are found for the same concrete trait (e.g. `Display`), the compiler will throw an error. This is to prevent ambiguity in the code. In this case, the user must specify the impl name explicitly."}
{"title": "integer-types.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Integer types Cairo uses the following integer types: [options=\"header\"] |=== | Type | Minimum | Maximum | u8 | 0 | 2^8 - 1 | u16 | 0 | 2^16 - 1 | u32 | 0 | 2^32 - 1 | u64 | 0 | 2^64 - 1 | u128 | 0 | 2^128 - 1 | u256 | 0 | 2^256 - 1 |=== The `usize` type is an alias to `u32`, and is used for array indexing. == Integer Creation All integer types except `u256` can be created as literals using the appropriate suffix. The `u256` type is only supported by construction from other types. [source,rust] ---- fn main() { let x: u8 = 10_u8; let y = 0xff_u64; // let z = 10_u256; // Error: u256 literals are not supported let z: u256 = u256 { high: 0_u128, low: 10_u128 } // 10 in u256 type } ---- == Integer Operations Currently, all integer types but `u256` support the operations in the following table. [options=\"header\"] |=== | Operation | Description | Supported by `u256` | `+` | Addition | Yes | `-` | Subtraction | Yes | `*` | Multiplication | Yes | `/` | Integer division | Yes | `%` | Modulo | No | `==` | Equality | Yes | `!=` | Inequality | Yes | `` | Greater than | Yes | `>=` | Greater than or equal | Yes | `\\|` | Bitwise or | Yes | `&` | Bitwise and | Yes | `^` | Bitwise xor | Yes |==="}
{"title": "item-statement.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Item statement This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "items.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Items // TODO(spapini): Fill with content. == Order of definitions The order of item definition does not matter. For example, an item definition can appear after its use."}
{"title": "keywords.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Keywords There are three keyword categories: - xref:keywords.adoc#strict_keywords[strict] - xref:keywords.adoc#reserved_keywords[reserved] - xref:keywords.adoc#contextual_keywords[contextual] == Strict keywords These keywords can only be used in their correct contexts. They cannot be used as names of any items. [source] ---- break const continue else enum false for fn hint if impl in match pub return struct trait true type use ---- == Reserved keywords These keywords aren't used yet, but they are reserved for future use. They have the same restrictions as strict keywords. The reasoning behind this is to make current programs forward compatible with future versions of Cairo by forbidding them to use these keywords. [source] ---- as assert do dyn extern let macro mod move ref Self self static_assert static super try typeof unsafe where while with yield ---- == Contextual keywords Some grammar productions may make use of new keywords not listed here. Such keywords have special meaning only in these certain contexts. Outside these places, these character sequences are treated as regular xref:identifiers.adoc[identifiers], thus it is possible to declare a function or variable with such names. [NOTE] ==== No contextual keywords are in use as for now. ===="}
{"title": "let-statement.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Let statement // TODO(spapini): Explain about mut and patterns. A _let statement_ introduces a new set of variables, given by an irrefutable pattern. The pattern is followed optionally by a type annotation and then by an initializer expression. Variables are _always_ initialized to some value. When no type annotation is given, the compiler infers the type, or signals an error if insufficient type information is available for definite inference. // TODO(spapini): Add an explanation about shadowing. Any variable introduced by a this declaration is visible from the point of declaration until the end of the enclosing block scope, except when it is shadowed by another variable declaration."}
{"title": "lexical-structure.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Lexical structure This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]. // TODO(spapini): Fille this with content."}
{"title": "linear-types.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Linear types // TODO(spapini): Move to language semantics. Linear types are a way to statically ensure that a value is used exactly once. Cairo supports linear types by having `move semantics` and forbidding copying and dropping values by default. == Move semantics When passing a value to a function, it is moved by default. This means that after a value is used for the first time, it cannot be used again. For example, the following code does not compile: ```rust struct A {} fn main() { let a = A {}; foo(a); // value is passed by value once here. foo(a); // error: Value was previously moved. } ``` To allow a value to be used multiple times, the `Copy` trait must be implemented for it. For example, the following code compiles: ```rust #[derive(Copy)] struct A {} fn main() { let a = A {}; foo(a); // value is passed by value once here. foo(a); // Now there is no error. } ``` Note: the snapshot operator `@` (See the docs about snapshot) is not considered moving a value. == Clone Sometime a value cannot not be trivially copied, but we can still use code to build a of copy it. For example, a value containing an `Array` cannot be copied, but we can still clone it by cloning the array it contains with `.clone()`. This can be done by implementing or deriving the `Clone` trait. The derived implementation requires that all fields implement `Clone`, and will automatically call `.clone()` on all the fields. == Variable dropping By default, a value may not go out of scope unless it was previously moved. For example, the following code does not compile: ```rust #[derive(Copy)] struct A {} fn main() { A {}; // error: Value not dropped. } ``` To allow a value to be dropped, the `Drop` trait must be implemented for it. For example, the following code compiles: ```rust #[derive(Drop)] struct A {} fn main() { A {}; // Now there is no error. } ``` == Destructors Sometime a value must not be dropped, but we can still use code to get rid of it. For example, a value containing a `Dict` cannot be dropped, but we can still deconstruct it by destructing the dict it contains with `.destruct()`. This can be done by implementing or deriving the `Destruct` trait, which will be called automatically when a non-droppable value goes out of scope. The derived implementation requires that all fields implement `Destruct`, and will automatically call `.destruct()` on all the fields. ```rust #[derive(Destruct)] struct A { d: Dict } fn main() { A {}; // No error, A will be destructed. } ``` When implementing `Destruct` manually, note that the implementation must be `nopanic`, because destructors are called when a value goes out of scope, which may happen in a panic. == Copy and drop restrictions `Copy` cannot be implemented for a type that contains a non-copyable field. Similarly, `Drop` cannot be implemented for a type that contains a non-droppable field. Some basic data types of Cairo are inherently non-copyable and non-droppable. `Array` is not copyable, while `Dict` is not copyable nor droppable. The reason for this has to do with Cairo's immutable memory model. == Snapshot The snapshot type is always copyable and droppable. It is used to create an immutable snapshot of a value. == Common pitfalls and solutions * How to avoid \"Value was previously moved\" errors? ** Use `@` to create a snapshot of the value. ** Use `ref` to pass the value by reference. ** Implement or derive `Copy` to allow the value to be copied. ** Implement or derive `Clone` to allow the value to be cloned. ** For a generic parameter, add another generic paramter for Copy or Clone (e.g. `impl TCopy: Copy`). * How to avoid \"Value was not dropped\" errors? ** Implement or derive `Drop` to allow the value to be dropped. ** Implement or derive `Destruct` to allow the value to be destructed. ** For structs, deconstruct them using `let A { .. } = a;`. ** For enums, deconstruct them using `match`. ** In particular, for the 'never' type, match like this: `match x {}`. ** For a generic parameter, add another generic paramter for Drop or Destruct (e.g. `impl TDrop: Drop`). ** Find a function that can be used to destroy the value, and call it."}
{"title": "literal-expressions.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Literal expressions A `literal expression` is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule. The supported literal expressions are described next. == Boolean literals The two values of the xref:boolean-types.adoc[boolean] type are `true` and `false`. example [source] ---- let a = true; let b = false; ---- == Numeric literals Cairo supports the following numeric literals: 1. A decimal literal that consists of only decimal digits. 2. A hexadecimal literal that start with the character sequence `0x` and continues with hex digits. 3. A binary literal that start with the character sequence `0b` and continues with binary digits. A numeric literal may be followed (immediately, without any spaces) by an underscore character (`_`) and then a __literal suffix__, which forcibly sets the type of the literal. The literal suffix is any valid identifier, but only selected values are semantically correct. [NOTE] ==== Floating-point numbers are not supported. ==== Examples of numeric literals of various forms: [cols=\"1,1,1\",options=\"header\"] |=== | Literal | Value | Type | `1234` | 1234 | `felt252` | `1234_felt252 | 1234 | `felt252` | `1234_u32 | 1234 | `i32` | `1234_u128 | 1234 | `u128` | `0x4D2` | 1234 | `felt252` | `0b10011010010` | 1234 | `felt252` |=== Examples of invalid numeric literals: - Invalid suffix: + `1234suffix` - Use of digits of wrong base: + `123AFB43`, `0b0102`, `0o0581`, `0xG`. - Binary and hexadecimal literals must have at least one digit: + `0b`, `0x_u128` [NOTE] ==== Cairo syntax considers `-1` as an application of the xref:negation-operators.adoc[unary minus operator] to the numeric literal `1`, rather than a single numeric literal. ==== == Short string literals A short string is a ascii-string whose length is limited by the type that holds it. The default type is a `felt252` which limits the length of the string to 31 characters. A short string literal may be followed by an underscore character (`_`) and then a __literal suffix__ just like a numerical literal. Examples of short string literals: - `'short_string'` - `'short_string'_u128` - `'a'_u8` Note that a short-string is a way to encode a string as a numerical value, it is not a string type. Cairo doesn't have a string type at the moment. The short string's first character is the most significant byte of the integer (big endian representation)."}
{"title": "lvalue.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= LValue An `lvalue` is a syntax element that represents a target that can be assigned values. The syntax of an `lvalue` is a member-path: A sequence of identifiers separated by dots. Example: 'a', `foo.bar.baz`. The first identifier must be a mutable xref:let-statement.adoc[local variable] (defined with the `mut` keyword). Each subsequent identifier must be a member of the type of the previous identifier, assuming the previous identifier is of a xref:structs.adoc[struct] type. // TODO(spapini): Move to a new page in language semantics. == Mutability in an immutable world A common misconception about assigning to lvalues is that it somehow changes the memory. However, Cairo's memory model is immutable. Values are immutable, and cannot be changed. However, variables *can* refer to different values. A variable does not represent a single memory target. Instead, it is a logical placeholder for some memory target. The meaning of assignment is that the variable now refers to a different memory target. == Member borrowing Assigning to a member path (e.g. `a.b`) is possible since the compiler keeps track of the individual member values. Not only variables are now logical placeholders, but also members."}
{"title": "match-expressions.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Match expressions A match xref:expressions.adoc[expression] is used for pattern matching, it allows you to match a value against a set of patterns and execute code based on the matching pattern. == Syntax A match expression starts with the xref:keywords.adoc[keyword] `match` followed by an expression and a list of arms. Each arm begins with a xref:patterns.adoc[pattern] which is followed by the `=>` operator, an expression, and a comma. A xref:block-expression.adoc[block expression] is typically used if the logic in the arm is more than a single expression. The pattern in a given arm may introduce xref:variables.adoc[variables] that can be used in expression of the said arm. If the pattern contains variables that are unused in the expression, then the wildcard `_` can be used in thier place. == Semantics A match expression is evaluated by evaluating the expression and then matching the value against the patterns in the arms in order. The first arm whose pattern matches the value of the expression is executed and the result of the expression in the arm is returned as the result of the match. [Note] ==== All the arms that don't break the control flow must evaluate to the same type. An arm breaks the control flow if it xref:return-expressions.adoc[returns] or xref:panic.adoc[panics]. ==== == Limitations Currently two kinds of match expression are supported: === Match on an Enum. [source, cairo] ---- match enum_var { varint_0(a, b, c) => { /* code */ } varint_1(_) => { /* code */ } ... variant_k(a, c) => { /* code */ } } ---- Where `enum_var` is an instance of some xref:enums.adoc[enum] and `varint_0``, `varint_1`, ..., `variant_k`` are all the variants of the said enum, order in the way that they were declered. === Match on an felt252. [source, cairo] ---- match felt_var { 0 => { /* code */ } _ => { /* code */ } } ---- Where `felt_var` is a xref:felt252-type.adoc[felt252] and the match patters are the xref:literal-expressions.adoc[literal] '0' and wildcard '_' (which matches any value)."}
{"title": "member-access-expressions.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Member access expressions A member access expression is an expression that consists of a primary expression followed by a dot (.) and an identifier. The primary expression must have a xref:structs.adoc[struct] type that contains a member with the identifier as its name. The type of the member access expression is the type of the member that the identifier refers to. Example: ```rust struct Point { x: usize, y: usize, } fn foo(p: Point) -> usize { p.x } ```"}
{"title": "method-calls.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Method calls A method call is an expression of the form `expr.method(arguments...)`. This expression is roughly equivalent to the xref:function-calls.adoc[function call] expression `method(expr, arguments...)`. The differences between the two are: // TODO(spapini): Link to snapshot and reference. * The expression can be coerced to either a snapshot `@expr` or a reference `ref expr`, depending on the method's signature. * `method` must be a trait function. == `self` and methods Methods can be defined only in traits and impls. The self parameter in Cairo trait and impl functions represents a value of a specified type, allowing for a more convenient method-like syntax for that type. It must be the first parameter of the function. A function defined in such a way can be called as a method on the value: [source,rust] ---- trait Display { fn display(self: T) -> Array; } impl DisplayUsize of Display { fn display(self: usize) -> Array { ... } } fn bar>(value: T) { ... // Can be called as a method. let c = value.display(); ... } ---- == Search locations for methods When a method is called, the compiler will search for a trait containing a function with a matching name in the current scope. For each matching trait, it will search for an impl (as specified above). If no traits with relevant impls are found, or if multiple such traits are found, the compiler will throw an error."}
{"title": "module.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Module item A module item is a declaration that defines a module. ```rust // This is a module defined in the current file. mod foo { // ... items ... } // This is a module defined in `a/bar.cairo`. mod bar; ``` See xref:modules-and-source-files.adoc[Modules & source files]"}
{"title": "modules-and-source-files.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Modules and crates Crates and modules are used to organize code into separate namespaces, allowing for easier management of code and better code reusability. A module is a named container for xref:items.adoc[items] such as structs, enums, functions, constants, and traits. A crate is a single compilation unit. It has a root directory, and a root module defined at the file `lib.cairo` under this directory. == Defining a module A module can be defined in two ways: inlined in the current file or in a separate file. When a module is defined in a separate file, the file is located according to the module hierarchy. For example, the module `crate_name::c` is defined in the file `/a/b/c.cairo`. ```rust a.cairo: // This is a module defined in the current file. mod foo { // ... items ... } // This is a module defined in `a/bar.cairo`. mod bar; ``` == Module hierarchy The module hierarchy is defined by the module definitions in the source code. When a module is defined inside another module, it is called a submodule, and it can be referred to using its name. The module containing the current module is called the parent module, and can be referred to using the `super` keyword. The root module of a crate has no parent. == Module scope Items defined inside a module are directly available within the module. In particular, items defined at outer modules are not directly available in inner modules, even when inlined. To refer to an item defined in another module, the item must be either fully qualified or imported with the xref:use.adoc[`use`] keyword. For more information, see xref:path.adoc[Paths]. ```rust struct A {} struct B {} mod foo { use super::B; // Import the struct `B` from the parent module. fn bar() { A {}; // This is not allowed, because `A` is not in scope. super::A {}; // This is allowed, because `super` refers to the parent module. B {}; // This is allowed, because `B` is imported. } } ```"}
{"title": "namespaces.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Namespaces This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "naming-conventions.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Naming conventions This chapter covers standard naming conventions. == Casing In general, use `PascalCase` for names of types or traits and use `snake_case` otherwise. More precisely: [cols=\"1,2\",options=\"header\"] |=== | Item | Convention | Modules | `snake_case` | Types | `PascalCase` | Traits | `PascalCase` | Enum variants | `PascalCase` | Struct fields | `snake_case` | Functions | `snake_case` | Methods | `snake_case` | Variables | `snake_case` | Constants | `UPPER_CASE` | Type parameters | `PascalCase` generally, a single letter like `T` usually |=== In `PascalCase`, acronyms count as one word: use `Sha` rather than `SHA`. In `snake_case`, acronyms are lower-cased: `sha3_hash`. In `snake_case` or `UPPER_CASE`, a _word_ should never consist of a single character unless it is a digit or the last _word_. So, we have `btree_map` rather than `b_tree_map`, but `PI_2` rather than `PI2`. // TODO: More suitable examples Language implementations can emit warnings when names do not follow these rules. == Underscore prefix (e.g. `_foo`) The name of an unused variable must start with an _ (a common example is simply \"_\"). [source,rust] ---- let _unused = compute_something(); ---- Language implementations can emit warnings when a variable **not** starting with an underscore is only written-to but is never read. The same applies when a variable starting with an underscore is read."}
{"title": "negation-operators.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Negation operators The following table summarizes the behavior of negation operators and which traits are used to overload them for other types: [cols=\"1,2,2,2\",options=\"header\"] |=== | Symbol | Operation | Accepted types | Overloading trait | `-` | Negation | `felt`, `int`, `i*` family | `std::Neg` | `!` | Logical NOT | `bool` | `std::Not` |==="}
{"title": "never-type.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Never type A _never type_ is a type of an expression that should not be evaluated in the encapsulating block, but should cause a flow control change - this may be caused by `return` or `break` statements."}
{"title": "notation.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Notation == Grammar The following notational convention is used in grammar snippets: [cols=\"1,1,2\",options=\"header\"] |=== | Notation | Example | Meaning | `CAPITAL_CASE` | `IDENTIFIER` | A named nonterminal or lexer token | `\"string\"` | `\"if\"`, `\"+\"` | The exact character(s) | `` \\`string` `` | `` \\`\"` `` | Alternative syntax for exact character(s) | `snake_case` | `let_stmt`, `item` | A syntactical production | `\\x` | `\\n`, `\\r`, `\\t`, `\\0` | The character represented by this escape | `x?` | `pub?` | An optional item | `x*` | `item*` | 0 or more of `x` | `x+` | `item+` | 1 or more of `x` | `x{a}` | `[0-9a-fA-F]{2}` | Exactly `a` repetitions of `x` | `x{a,b}` | `[0-9a-fA-F]{1,6}` | `a` to `b` repetitions of `x` | `&#124;` | `felt &#124; int` | Either one or another | `[ ]` | `[bB]` | Any of the characters listed | `[ - ]` | `[a-z]` | Any of the characters in the range | `~[ ]` | `~[bB]` | Any characters, except those listed | `~\"string\"` | `~\"\\n\"`, `~\"*/\"` | Any characters, except this sequence | `~CAPITAL_CASE` | `~EOL*` | Any characters, except sequences matching the lexer token | `( )` | `( \",\" parameter )?` | Group items | `/* text */` | `ITEM /* except IMPL_ITEM */` | Human words supplementation |==="}
{"title": "operator-expressions.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Operator expressions This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "packed-structs.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Packed structs This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "panic.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Panic Code in _Cairo1.0_ may _panic_ - which means it may fail with an unrecoverable error - meaning it is impossible to catch and handle. When the program panics, using the xref:linear-types.adoc[linear type system] all living variables on the stack would be `Dropped` or otherwise destructed, which makes sure the run remains provable and valid. == `panic` function The basic function that all panic stems from is the `panic` function. It is defined as: [source,rust] ---- extern fn panic(data: Array) -> never; ---- The `panic` function takes a single argument, which is a `felt252` array. This array is the data that is passed as the reason the run panicked. The `panic` function never returns, and is marked as such with the xref:never-type.adoc[never type]. == `nopanic` notation Functions may be marked with the `nopanic` notation. This means that the function will never panic. This can be useful for writing code that may never fail. Only _nopanic_ functions may be called from a _nopanic_ function. === `nopanic` and traits If a trait function is marked with `nopanic`, all implementations of that trait must also be marked with `nopanic`, as the trait function may be called from a _nopanic_ function. An example for such a function is `Destruct` trait `destruct` function, which is _nopanic_ as it is called during panic handling, see xref:linear-types.adoc[linear type system] for more info. If a trait function is not marked with `nopanic`, all implementations of that trait may be marked with `nopanic` or not. An example for such a function is `Add` trait `add` function, which is _nopanic_ for `felt252` addition, but isn't so for integer addition. == `panic_with` macro A function returning an `Option` or `Result` may be marked with the `panic_with` macro. This macro takes two arguments, which is the data that is passed as the panic reason as well as the name for a wrapping function. If the function returns `None` or `Err`, _panic_ function will be called with the given data. [source,rust] ---- #[panic_with('got none value', unwrap)] fn identity(value: Option) -> Option { a } ---- Some `fn unwrap(value: Option) -> u128` that internally may panic may be created."}
{"title": "parentheses.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Parenthesized expressions Parentheses can be used to enforce a particular order of evaluation in expressions that contain multiple operators. An example of a parenthesized expression: [source,rust] ---- 2 + 2 * 2 // == 6 (2 + 2) * 2 // == 8 ----"}
{"title": "path-expressions.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Path expressions A path expression is a standalone xref:path.adoc[concrete path]. It resolves to one of these items: * A local variable. In this case the path is a single identifier. * A xref:constant-items.adoc[constant item]. * A generic const parameter. In this case the path is a single identifier. These are still unsupported."}
{"title": "path.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Path A path is a sequence of one or more path segments separated by a namespace qualifier (`::`). If a path consists of only one segment, it refers to either an xref:items.adoc[item] or a xref:variables.adoc[variable] in the scope. If a path has multiple segments, it always refers to an item. Two examples of paths consisting of only identifier segments: ```rust x; x::z; ``` There are two kinds of paths: generic and concrete. == Generic paths A generic path is composed of segments which are identifiers, e.g. `x::z`. It refers to an item. Generic paths are used at: * Use statements. * Enum variant pattern. == Concrete paths Concrete paths are composed of concrete segments, which are identifers that may be followed by a xref:generics.adoc[generic] argument clause like this: ``` IDENT[[::]] ``` The additional `::` is mandatory where ambiguity would otherwise arise, such as in expressions. For example, `x::::::z` is a concrete path. Otherwise, it can be omitted. For example, in type expressions `fn foo(x: Option)`. A concrete path refers to a concrete item (e.g. a function, type, etc.). When the generic arguments clause is not provided, or less generic arguments are provided than the item expects, the compiler xref:inference.adoc[infers] the missing generic arguments. Examples: ```rust fn foo(a: A, b: B) { ... } fn main() { foo::(false, 3_u2); // OK foo::(false, 3_u2); // OK, B is inferred to be u32 foo::(false, 3_u2); // OK, B is inferred to be u32 foo(false, 3_u2); // OK, A, B are inferred as bool and u32 respectively } ``` Concrete paths are used at: * xref:expressions.adoc[Expressions] ```rust foo::() // Function call expression Option::::Some(true) // Enum variant expression ``` * Type expressions - `let x: Option = None; // Let statement type clause` - `Option::> // Generic type argument` * Trait expressions ```rust impl MyImpl of MyTrait { // trait expression after `of` keyword ... } fn foo>() { ... } // trait expression after `:` in an impl generic argument ``` == Path resolution The path is resolved by looking up the first segment identifier in the current local scope. This includes local variables and generic parameters defined in containing items, up to the module level. If not found, it is looked up in the core module. Note that it is not looked up in the containing modules. If the found item has a scope (e.g. a module or an enum) then the second identifier is looked up inside this scope, and so on."}
{"title": "patterns.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Patterns Patterns are used to match values to specific structures. They can be used in xref:let-statement.adoc[`let` statements] and xref:match-expressions.adoc[`match`] arms. == Pattern examples [source] ---- MyStruct {a: a, b : _b, c: _} MyEnum(a, b, c) (a, b, c) var_name 12344 'short_string' _ ----"}
{"title": "prelude.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Prelude A _prelude_ is a collection of items that are always available in every module in a program. The _standard library prelude_ is a module defined in the standard library: `std::v1`. It is automatically used in every module. It is not possible to disable standard library prelude importing."}
{"title": "punctuation.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Punctuation Punctuation symbol tokens are listed here for completeness. Their individual usages and meanings are defined in the linked pages. [cols=\"1,1,1\",options=\"header\"] |=== | Symbol | Name | Usage | TODO | TODO | TODO |=== == Brackets Bracket punctuation is used in various parts of the grammar. An open bracket must always be paired with a close bracket. The three types of brackets are: [cols=\"1,1\",options=\"header\"] |=== | Bracket | Type | `{` `}` | Curly braces | `[` `]` | Square brackets | `(` `)` | Round parentheses |==="}
{"title": "return-expressions.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Return expressions This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "slice-types.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Slice types This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "statements.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Statements Cairo is an expression-oriented language, where most syntax productions producing values or causing effects when evaluated are _expressions_. Many expressions can nest within each other, and sequence of evaluation is driven by precedence and associativity rules. There are not a lot of statements kinds, which role is limited to containing explicitly sequential xref:expression-statement.adoc[expression evaluation] and declaring xref:items.adoc[items] and xref:let-statement.adoc[variables] in xref:block-expression.adoc[code blocks]. The kinds of statements are: - xref:expression-statement.adoc[Expression statement]. - xref:let-statement.adoc[Let statement]. - Return statement. - Break statement. == Semicolons Statements are _usually_ separated with a semicolon (`;`). Extraneous semicolons are ignored. Semicolons _after_ last statement in code block _may_ be omitted and have a separate semantic meaning as it makes the statement define returned value of enclosing code block (see xref:block-expression.adoc[code blocks] for more details)."}
{"title": "string-types.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= String types This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "struct-expressions.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Struct expressions This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "struct-types.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Struct types This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "structs.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Structs A struct is a collection of named fields. It is one of the ways to define custom user types. The fields of a struct, called members, can be of any defined type, including user-defined types, like other structs or xref:enums.adoc[enums]. == Definition A struct is defined by the `struct` keyword. Here are a few examples of struct definitions: * A struct with only core type members: ```rust struct Tree { height: u16, number_of_leaves: u32, } ``` * A struct with members of user-defined types: ```rust struct Forest { number_of_trees: u32, highest_tree: Tree, lowest_tree: Tree, } ``` * A struct with members of the same type: ```rust struct ListNode { value: u8, next: Option>, } ``` == Usage A struct is instantiated with the `StructName { member1: value1, member2: value2, ... }` syntax. For example: ```rust let mut tree = Tree { height: 6, number_of_leaves: 10000, }; ``` All members must be specified in the instantiation, but their order does not matter. If a member should be initialized with a variable with the same name of the member, instead of `name: name` you can simply specify `name`. For example: ```rust let height = 6; let mut tree = Tree { number_of_leaves: 10000, height, }; ``` It can then be accessed in two ways: === Deconstruction A struct can be deconstructed with the `let struct_name { member1, member2, ... } = struct_instance` syntax. For example: ```rust let Tree { height, number_of_leaves } = tree; let higher_tree = Tree { height: height + 1, number_of_leaves } ``` You can use different patterns (for example change the order and names of the new variables) in the deconstruction. See xref:patterns.adoc[patterns] for more information. === The Dot (`.`) operator: Another way to access struct members is with the dot (`.`) operator. ```rust let old_tree_height = tree.height; tree.height = old_tree_height + 1; ``` [NOTE] ==== As Cairo's memory is immutable behind the scenes, assigning to a member of a struct using the dot (`.`) operator actually copies the memory of the whole struct. This does not affect the correctness of your program, but it may affect its performance if the struct is big. ==== A more expressive way to mutate a struct similar to the last example is: ```rust let old_tree_height = tree.height; tree = Tree { height: old_tree_height + 1, number_of_leaves: tree.number_of_leaves }; ``` This way also lets you guarantee avoiding extra copies of the struct's memory if you want to change multiple members. For example, this code might copy the struct's memory twice (but is mostly optimized by the compiler): ```rust tree.height = 1; tree.number_of_leaves = 100; ``` While this code has the same logical effect, but guarantees to copy the struct's memory only once: ```rust tree = Tree { height: 1, number_of_leaves: 100 }; ```"}
{"title": "traits.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Traits and impls Traits and impls provide a way to define abstract behavior and implement it in a concrete manner. Traits define a set of related functions, while impls provide the actual implementation of those functions. This feature promotes code reusability and modular design. == Example [source,rust] ---- trait Display { fn display(x: T) -> Array; } impl DisplayUsize of Display { fn display(x: usize) -> Array { ... } } fn main() { // Can be called by the trait name. let a = Display::display(5_usize); // Can be called by the impl name. let b = DisplayUsize::display(5_usize); // Cannot be called by the type name. // T::display(value) - Does not work. } ---- Note that unlike Rust, impls have names, so that they can be explicitly specified. == Impls as generic parameters In Cairo, impls can be used as generic parameters, allowing for a more flexible and modular design. For example, the following code defines a function that takes a generic parameter `T` and an implementation of the `Display` trait: [source,rust] ---- fn foo>(value: T) { let a = TDisplay::display(5_usize); let b = Display::display(value); } ---- == Impl inference When a trait function is called, the compiler will try to xref:inference.adoc[infer] the impl. == Methods Impls are used to define xref:method-calls.adoc[methods]. == \"of\" keyword and difference from Rust In Cairo, the `of` keyword is used in impls to specify the concrete trait that is being implemented, rather than implementing the trait for a specific type, as is done in Rust with the `for` keyword. The main difference between Cairo and Rust in this context is that Cairo doesn't have a direct type-to-trait implementation relationship. Instead, Cairo emphasizes implementing the trait directly, with the concrete trait name specified after the of keyword."}
{"title": "tuple-expressions.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Tuple expressions A tuple expression constructs xref:tuple-types.adoc[tuple] values. The syntax for tuple expressions is a parenthesized, comma separated list of expressions. 1-ary tuple expressions require a comma after their tuple initializer operand to be disambiguated with a parenthetical expression. Tuple expressions without any tuple initializer operands produce the unit tuple value. Examples: [cols=\"1,1\",options=\"header\"] |=== | Expression | Type | () | () | (1_u32,) | (u32,) | (1_u32, Option::Some(3_u8)) | (u32, Option) | (True, False, 'abc') | (bool, bool, felt252)"}
{"title": "tuple-types.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Tuple types A tuple type is a parenthesized, comma-separated list of types. 1-ary tuples require a comma after their element type to be disambiguated with a parenthesized type. A tuple type has a number of fields equal to the length of the list of types. This number of fields determines the arity of the tuple. A tuple with n fields is called an n-ary tuple. For example, a tuple with 2 fields is a 2-ary tuple. The tuple type with no fields `()` is also called the xref:unit-type.adoc[Unit type] Examples: [source, cairo] --- () // Unit type. (bool,) (u32, u256) (felt252, u16, Option) --- Values of this type are constructed using a xref:tuple-expressions.adoc[tuple expressions]. Tuples can be deconstructed using xref:patterns.adoc[patterns]."}
{"title": "type-aliases.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Type aliases This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "type-layout.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Type layout This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "type-system.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Type system This chapter describes the type system of Cairo."}
{"title": "types.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Types Cairo is strongly-typed and offers a variety of types to represent different kinds of data. In this section, we'll cover the different types available in Cairo. // TODO(Gil): add links to the different types pages when added. == Basic data types * xref:boolean-types.adoc[Boolean] * Numeric types: ** xref:felt252-type.adoc[felt252] ** xref:integer-types.adoc[Integers] * xref:never-type.adoc[Never type] * xref:unit-type.adoc[Unit type] == Sequence types * xref:tuple-types.adoc[Tuple] * `Array` * xref:felt252dict-type.adoc[`Felt252Dict`] == Pointer types * `Box` * `Snapshot` == User-defined types * xref:struct-types.adoc[Struct] * xref:enum-types.adoc[Enum] == Helper macros * xref:derive-macro.adoc[Derive macro]"}
{"title": "unit-type.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Unit type A _unit type_ is a type which has only one value (xref:literal-expressions.adoc[unit literal], ` ()`). It is represented by a tuple with no elements. Its size is always zero, and it is guaranteed to not exist in the compiled code."}
{"title": "use.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Use The `use` item in the Cairo programming language is used to make an item from another module directly accessible in the current module. ```rust mod foo { fn bar() { // ... } } // Bring the `bar` function into the current module. use foo::bar; fn main() { bar(); } ``` The syntax for `use` is `use path::item;`, where `path::item` is as described in xref:path.adoc[Paths]. The position of the `use` item does not matter (like any other item), but it is recommended to put them in the beginning of the module. == Aliasing The `use` item can also be used to alias an item: ```rust // Bring the `bar` function into the current module and alias it to `baz`. use foo::bar as baz; fn main() { baz(); } ``` == Cycles The `use` item can lead to an import cycle: ```rust mod foo { use super::bar; } use foo::bar; ``` In this case, the compiler throws an error."}
{"title": "variables.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Variables A variable is a named entity that holds a value. It provides a way to store data and refer to it later in the program by a name. By using variables, you can manipulate the data in different ways, perform computations, and create more complex programs. There are several ways to introduce variables in a Cairo program. == Let statement Variables can be defined using the link:let-statement.adoc[`let`] keyword with the following syntax: [source] ---- let x: u32 = 5_u32; ---- declares a variable named `x` of type `u32` with an initial value of `5`. The type annotation can be omitted in cases where the type can be deduced. For example: [source] ---- let x = 5_u32; ---- Variables are immutable unless declared otherwise. A variable can be declared as mutable using the `mut` keyword. A mutable variable can be link:assignment-statement.adoc[assigned] a different value after the initialization. For example: [source] ---- let mut x = 17; x = x + 3; ---- == Function parameters Every function parameter introduces a variable that is accessible in the body of a function. For example: [source] ---- fn add(x: u32, mut y: u32) -> u32 { y += x; y } fn test() { let x = 1; ley y = 2; assert(add(x, y) == 3, 'Should be equal.'); assert(y == 1, 'Should be equal.'); } ---- A function parameter can have the `mut` modifier and it has the same meaning as in let statements, that is, we can change it inside the body of the function, but the change is not reflected in the caller. A function parameter may also have the `ref` modifier which means that the variable is an input and an output. In this case, the caller must pass a mutable variable and use the `ref` keyword. Changing the variable in the called function also changes it in the caller. Note that `ref` parameters are mutable. Using both modifiers on the same parameter is not allowed. For example: [source] ---- fn inc_by_one(ref x: u32) { x = x + 1; } fn test() { let mut y = 2; inc_by_one(ref y); assert(y == 3, 'Should be equal.'); } ---- == Patterns in match arms A variable can be introduced inside a match arm. for example: [source] ---- match opt { Option::Some(x) => x, Option::None(_) => 0, } ---- == Shadowing A variable name can be reused in an inner scope (or the same scope). In this case, the variable shadows the variable in the outer scope, but it does not change the variable in the outer scope. for example: [source] ---- let x = 5; { let x = 8; } assert(x == 5, 'Should be equal.'); ---- In contrast when a mutable variable is assigned in an inner scope, it also changes in the outer scope. [source] ---- let mut x = 5; { x = 8; } assert(x == 8, 'Should be equal.'); ----"}
{"title": "visibility.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Visibility This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "whitespace.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Whitespace Whitespace is any non-empty string containing only characters that have the Unicode property, namely: - `U+0009` (horizontal tab, `'\\t'`) - `U+000A` (line feed, `'\\n'`) - `U+000B` (vertical tab) - `U+000C` (form feed) - `U+000D` (carriage return, `'\\r'`) - `U+0020` (space, `' '`) - `U+0085` (next line) - `U+200E` (left-to-right mark) - `U+200F` (right-to-left mark) - `U+2028` (line separator) - `U+2029` (paragraph separator) Cairo is a \"free-form\" language, meaning that all forms of whitespace serve only to separate _tokens_ in the grammar, and have no semantic significance. A Cairo program has identical meaning if each whitespace element is replaced with any other legal whitespace element, such as a single space character."}
{"title": "application-binary-interface.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Application binary interface This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "constant-evaluation.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Constant evaluation This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "memory-model.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Memory model This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "runtime.adoc", "repo_owner": "starkware-libs", "repo_name": "cairo", "text": "= Runtime This section is a work in progress. You are very welcome to contribute to this documentation by link: a pull request]."}
{"title": "01-introduction.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "--- sidebar_label: Introduction --- # Introduction Protostar is a toolchain for developing Starknet smart contracts. It helps with writing, [deploying](07-interacting-with-starknet/README.md), and [testing](06-testing/README.md) your smart contracts. It is loosely inspired by [Foundry]( ## Reference Protostar is designed to be easily discoverable from the terminal. To view information about available commands and flags, run: ``` protostar --help ``` For detailed information about a specific command and its flags, run: ``` protostar COMMAND --help ``` For example, `protostar test --help`."}
{"title": "02-installation.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "--- sidebar_label: Installation --- # Installation Protostar is easy to install on Linux and Mac systems. In this section, we will walk through the process of installing and upgrading Protostar. ### Requirements To use Protostar with Cairo 1, you need [Scarb]( installed and added to your `PATH` environment variable. ### Linux and Mac 1. Open a terminal and run the following command: ```console curl -L | bash ``` 2. Close and reopen the terminal. 3. To check if the Protostar is installed correctly, run `protostar -v`. ### Specifying version If you want to install a specific version of Protostar, run the following command with the desired version number: ```console curl -L | bash -s -- -v 0.3.2 ``` ### Windows Compatibility Protostar is not currently supported on Windows. ## Upgrading Protostar To upgrade Protostar, run: ```shell protostar upgrade ``` Protostar will inform you when a new version is available. ## How to build Protostar from source code If you are unable to install Protostar using the instructions above, you can try building it from the [source code]( as follows: 1. [Set up a development environment.]( 1. Run `poe build`. This will create a `dist` directory. 1. Move the `dist` directory to the desired location (e.g. `~/.protostar`). 1. Add `DESIRED_LOCATION/dist/protostar` to the `PATH`."}
{"title": "03-project-initialization.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "--- sidebar_label: Project initialization --- # Project initialization ## Creating a project To create a new Protostar project with Cairo 1 support, run ```shell protostar init my_project ``` This will create a new directory with the specified name, generate [protostar.toml](05-protostar-toml.md) and [Scarb.toml](04-understanding-cairo-packages.md#dependencies-management) configuration files, and create an example [multimodule](04-understanding-cairo-packages.md#modules) project containing two [test](06-testing/README.md) files and a [package](04-understanding-cairo-packages.md#packages) with a contract. ``` my_project/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 business_logic/ \u2502 \u2502 \u2514\u2500\u2500 utils.cairo \u2502 \u251c\u2500\u2500 contract/ \u2502 \u2502 \u2514\u2500\u2500 hello_starknet.cairo \u2502 \u251c\u2500\u2500 business_logic.cairo \u2502 \u251c\u2500\u2500 contract.cairo \u2502 \u2514\u2500\u2500 lib.cairo \u2514\u2500\u2500 Scarb.toml \u251c\u2500\u2500 tests/ \u2502 \u251c\u2500\u2500 test_hello_starknet.cairo \u2502 \u2514\u2500\u2500 test_utils.cairo \u2514\u2500\u2500 protostar.toml ``` ### Minimal project template If you don't plan to develop a complex project, and you just want to quickly set up the easiest possible one, you can use the `--minimal` flag like this: ```shell protostar init --minimal my_project ``` This will generate the following file structure: ``` my_project/ \u251c\u2500\u2500 Scarb.toml \u251c\u2500\u2500 protostar.toml \u251c\u2500\u2500 src/ \u2502 \u2514\u2500\u2500 lib.cairo \u2514\u2500\u2500 tests/ \u2514\u2500\u2500 test_hello_starknet.cairo ```"}
{"title": "04-understanding-cairo-packages.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# Understanding Cairo packages There are several requirements that Cairo packages have to follow. These are explained in the following sections. You can refer to [official Cairo documentation]( for more details. Keep in mind that Protostar does not support `cairo_project.toml`. It uses [Scarb]( and its [manifest files]( instead. ## Dependencies management Protostar uses [Scarb]( and its [manifest files]( to manage dependencies in your project. In order to use Protostar with Cairo 1, you must have Scarb executable added to the `PATH` environment variable. The `PATH` variable is a list of directories that your system searches for executables. To learn how to manage dependencies with Scarb, check [the documentation]( :::info The name of your package is always the value of the `name` key in the `[package]` section of your `Scarb.toml`. ::: ## Modules A module consists of one or more Cairo files, usually organized in a single directory. To define a module, create a `.cairo` file named like the module and define components of this module with the `mod` keyword. ``` my_module/ \u251c\u2500\u2500 a.cairo \u251c\u2500\u2500 b.cairo \u2514\u2500\u2500 c.cairo my_module.cairo ``` ```cairo title=\"my_module.cairo\" mod a; mod b; mod c; ``` Alternatively, modules can be defined within a file using ```cairo title=\"my_module.cairo\" mod my_module { fn function_a() -> (); // ... } ``` ## Packages Package consist of multiple modules and must define `Scarb.toml` and `src/lib.cairo` files. :::info Some other tools and resources, including [official Cairo documentation]( use the term \"crates\" for packages. ::: ### `Scarb.toml` It is a [Scarb's manifest files]( containing dependencies for your package. Example content of this file: ```toml title=\"Scarb.toml\" [package] name = \"my_package\" version = \"0.1.0\" [dependencies] ``` ### `lib.cairo` It is the root of the package tree, and it ***must*** be placed inside `src` folder. Here you can define functions, declare used modules, etc. ```cairo title=\"lib.cairo\" mod my_module; mod my_other_module; ``` ### Package with multiple modules The module system in Cairo is inspired by [Rust's]( one. An example package with multiple modules: ``` my_project/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 mod1/ \u2502 \u2502 \u2514\u2500\u2500 functions.cairo \u2502 \u251c\u2500\u2500 mod1.cairo \u2502 \u251c\u2500\u2500 utils.cairo \u2502 \u2514\u2500\u2500 lib.cairo \u2514\u2500\u2500 Scarb.toml ``` ```cairo title=\"lib.cairo\" mod mod1; mod utils; ``` ```cairo title=\"mod1.cairo\" mod functions; ``` ```cairo title=\"utils.cairo\" fn returns_two() -> felt252 { 2 } ``` ```cairo title=\"mod1/functions.cairo\" fn returns_three() -> felt252 { 3 } ``` You can now use the defined functions with `my_package::mod1::returns_three()` and `my_package::returns_two()`. ## Project with multiple contracts Due to limitations of the Cairo 1 compiler, having multiple contracts defined in the package will cause the `protostar build` command and other commands to fail. **That is, having projects structured like this is not valid and will not work correctly.** ### Multi-contract project structure Each contract must be defined in the separate package: a different directory with separate `Scarb.toml` and `src/lib.cairo` files defined. ``` my_project/ \u251c\u2500\u2500 package1/ \u2502 \u251c\u2500\u2500 src/ \u2502 \u2502 \u251c\u2500\u2500 contract/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 hello_starknet.cairo \u2502 \u2502 ... \u2502 \u2502 \u251c\u2500\u2500 contract.cairo \u2502 \u2502 \u2514\u2500\u2500 lib.cairo \u2502 \u2514\u2500\u2500 Scarb.toml \u251c\u2500\u2500 package2/ \u2502 \u251c\u2500\u2500 src/ \u2502 \u2502 \u251c\u2500\u2500 contract/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 other_contract.cairo \u2502 \u2502 ... \u2502 \u2502 \u251c\u2500\u2500 contract.cairo \u2502 \u2502 \u2514\u2500\u2500 lib.cairo \u2502 \u2514\u2500\u2500 Scarb.toml ... \u251c\u2500\u2500 src/ \u2502 \u2514\u2500\u2500 lib.cairo \u251c\u2500\u2500 Scarb.toml \u2514\u2500\u2500 protostar.toml ``` :::caution Notice that the whole project itself is a package too. This is due to the fact that [Scarb]( does not support workspaces yet. If you do not need to include any code in the top level package, just leave the `my_project/src/lib.cairo` file empty. ::: Define each contract in the `[contracts]` section of the protostar.toml. ```toml title=\"protostar.toml\" # ... [contracts] hello_starknet = [\"package1/src\"] other_contract = [\"package2/src\"] ``` Remember to include the packages as [dependencies]( in `my_project/Scarb.toml`. ```toml title=\"my_project/Scarb.toml\" [package] name = \"my_package\" version = \"0.1.0\" [dependencies] package1 = { path = \"package1\" } package2 = { path = \"package2\" } ``` ### Testing multi-contract projects For example, to test function `returns_two` defined in the `package1/business_logic/utils.cairo` write ```cairo title=\"my_project/test_package1.cairo\" #[test] fn test_returns_two() { assert(package1::returns_two() == 2, 'Should return 2'); } ``` Or using the `use path::mod` syntax ```cairo title=\"my_project/test_package2.cairo\" use package1::returns_two; #[test] fn test_returns_two() { assert(returns_two() == 2, 'Should return 2'); } ``` Make sure that the `path::module` is correct for your package structure. For more details on how to test contracts, see [this page](./06-testing/README.md). ## Packages and modules names considerations The name must be a valid Cairo identifier which means: - it must use only ASCII alphanumeric characters or underscores - it cannot start with a digit - it cannot be empty - it cannot be a valid Cairo keyword or a single underscore (`_`)"}
{"title": "05-protostar-toml.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# Understanding protostar.toml Protostar can be configured with file `protostar.toml`, which is located in the root of your project. The file uses the [TOML]( format and allows you to specify various options and settings for Protostar. Here is an example `protostar.toml` file: ```toml title=\"protostar.toml example\" [project] protostar-version = \"PROTOSTAR_VERSION\" # Defines contract names for the use with cheatcodes and commands [contracts] hello_starknet = [\"hello_starknet\"] # Per command configuration profile [profile.integration.test] target = [\"tests/integration\"] report-slowest-tests = 5 # Shared configration profile [profile.devnet.project] gateway-url = \" chain-id = 1536727068981429685321 [profile.testnet.project] network = \"testnet\" ``` ### `[project]` section The `[project]` section of the `protostar.toml` file allows you to specify global options and settings for your project. #### `protostar-version` This attribute defines which Protostar version should be used with your project. ### `[contracts]` section Define packages containing contracts to be used by Protostar commands like [declare](../cli-reference.md#declare) and by [cheatcodes](./06-testing/03-cheatcodes.md). ```toml [contracts] my_contract = [\"my_contract_package/src\"] other_contract = [\"other_contract_package/src\"] ``` :::info Notice that a value assigned to a contract name key is always a path to `src` folder of a package defining the contract. ::: ### Command Arguments Configuration Section This section of the `protostar.toml` file allows you to specify arguments for a specific Protostar command. For example, you can define a different build dir for the [build](../cli-reference.md#build) ```toml title=\"Configuration File\" [build] compiled-contracts-dir = \"my_dir\" ``` These arguments will be automatically used when running a command. ### Configuration Profiles Configuration profiles allow you to easily switch between different Protostar configurations. When you use a profile, it will override the default settings specified in the `protostar.toml` file with the settings specified in the profile. To create a configuration profile, add a new section to the `protostar.toml`. For example: - to create a configuration named `mainnet` for the [`declare` command](../cli-reference.md#declare), add `[profile.mainnet.declare]` section - to create a shared configuration named `testnet`, add `[profile.testnet.project]` section To use a profile, add the [-p or --profile argument](../cli-reference.md#-p---profile-string) followed by the name of the profile. For example, to use the [`declare` command](../cli-reference.md#declare) with the `testnet` profile, run: ```console protostar -p testnet declare ```"}
{"title": "01-unit-testing.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "--- sidebar_label: Unit testing --- # Unit testing Protostar lets you test standalone Cairo functions. This technique is referred to as unit testing. You should write as many unit tests as possible as these are **much faster** than [integration tests](./02-integration-testing.md). ## Writing your first test First, add the following code to the `src/lib.cairo` file: ``` fn sum(a: felt252, b: felt252) -> felt252 { return a + b; } ``` Now, let's test this function. Create a file `tests/test_sum.cairo`: ``` use your_project_name::sum; #[test] fn test_sum() { assert(sum(2, 3) == 5, 'sum incorrect'); } ``` Now run your test using this command: ``` protostar test ./tests ``` You should see something like this: ``` Collected 2 suites, and 3 test cases (10.64) [PASS] tests/test_sum.cairo test_sum (time=0.00s) Test suites: 1 passed, 1 total Tests: 1 passed, 1 total Seed: 2752673895 17:20:43 [INFO] Execution time: 5.0 s ``` ## Test collecting Protostar collects all test suites specified under the path passed as an argument. You can pass either directory or a specific file. A test suite is every `.cairo` file with a name starting from `test_` or ending with `_test`. Protostar considers as a test case each function, inside a test suite, with `#[test]` attribute. :::warning Test cases cannot return any values and cannot take any arguments. ::: ## Failing tests Your tests fail when code *panics*. To write a test that fails, you will need to use `panic` function, here's how you do it: ``` use array::ArrayTrait; // Single value in the panic payload #[test] fn test_panic_single_value() { let mut data = ArrayTrait::new(); data.append('this one should fail'); panic(data) } ``` Of course, if any of the functions you call from tests *panics*, your test will fail as well."}
{"title": "02-integration-testing.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "--- sidebar_label: Integration testing --- # Integration testing Using [unit testing](./01-unit-testing.md) as much as possible is a good practice, as it makes your test suites run faster. However, when writing smart contracts you often want your test to cover the on-chain state and interactions between multiple contracts. In this section, you will learn how to deploy and interact with a smart contract in Protostar for testing purposes. ## How to test a contract To test a contract, you need to use an important Protostar feature: [cheatcodes](./03-cheatcodes.md). Cheatcodes are additional library functions that Protostar exposes to help you with testing. Let's write a test which deploys and calls a contract. First let's define our contract in the file `src/lib.cairo` ```cairo title=\"Deployed contract\" #[contract] mod MinimalContract { #[external] fn hello() { assert(5 == 5, 'always true'); } } ``` You need to define contract in [protostar.toml](../05-protostar-toml.md) configuration file. Add it to the `[contracts]` section ```toml title=\"Configuration file\" [contracts] minimal = [\"your_project_name\"] ``` We can write a test that deploys and calls this contract. Let's create a file `test_contract.cairo`: ```cairo title=\"Example\" use array::ArrayTrait; use result::ResultTrait; #[test] fn test_deploy() { let deployed_contract_address = deploy_contract('minimal', @ArrayTrait::new()).unwrap(); invoke(deployed_contract_address, 'hello', @ArrayTrait::new()).unwrap(); } ``` [deploy_contract](./cheatcodes-reference/deploy_contract.md) will declare and deploy the given contract. [invoke](./cheatcodes-reference/invoke.md) will invoke `hello` method. ## Transaction reverts Cheatcodes [deploy](./cheatcodes-reference/deploy.md), [invoke](./cheatcodes-reference/invoke.md) and [call](./cheatcodes-reference/call.md) execute code on chain which can be reverted. In such case, they return `RevertedTransaction` structure. You can use it, for example, to verify if your contract reverts the transaction in a certain scenario. Here's how the structure looks: ```#[derive(Drop, Clone)] struct RevertedTransaction { panic_data: Array::, } trait RevertedTransactionTrait { fn first(self: @RevertedTransaction) -> felt252; // Gets the first felt of the panic data } ``` ### Example usage ```cairo title=\"Deployed contract\" #[contract] mod MinimalContract { #[external] fn panic_with(panic_data: Array::) { panic(panic_data); } } ``` ```cairo title=\"Test\" use cheatcodes::RevertedTransactionTrait; use array::ArrayTrait; use result::ResultTrait; #[test] fn test_invoke_errors() { let deployed_contract_address = deploy_contract('minimal', @ArrayTrait::new()).unwrap(); let mut panic_data = ArrayTrait::new(); panic_data.append(2); // Array length panic_data.append('error'); panic_data.append('data'); match invoke(deployed_contract_address, 'panic_with', @panic_data) { Result::Ok(x) => assert(false, 'Shouldnt have succeeded'), Result::Err(x) => { assert(x.first() == 'error', 'first datum doesnt match'); assert(*x.panic_data.at(1_u32) == 'data', 'second datum doesnt match'); } } } ``` ## Cheatcodes in contract constructors If you ever want to use `prank`, `roll`, `warp` or any of the environment-modifying cheatcodes in the constructor code, just split the `deploy_contract` into `declare`, `prepare` and `deploy` - so that you have a contract address (from `prepare` call) just before the deployment. Then you can use the cheatcode of your choice on the obtained address, and it will work in the constructor as well! ### Example: ```cairo title=\"with_constructor.cairo\" #[contract] mod WithConstructor { use starknet::get_caller_address; use starknet::ContractAddress; use starknet::ContractAddressIntoFelt252; use traits::Into; struct Storage { owner: ContractAddress, } #[constructor] fn constructor() { let caller_address = get_caller_address(); owner::write(caller_address); } #[view] fn get_owner() -> felt252 { owner::read().into() } } ``` ```cairo title=\"test_with_constructor.cairo\" #[test] fn test_prank_constructor() { let class_hash = declare('with_constructor').unwrap(); let prepared = prepare(class_hash, @ArrayTrait::new()).unwrap(); let owner_address = 123; start_prank(owner_address, prepared.contract_address).unwrap(); // felt252 { custom_struct.a + custom_struct.b + custom_struct.c.d + another_struct.e + standalone_arg } ``` You can test the `#[view]` using `Serde` to serialize the arguments into calldata (just like an external contract call would work) ```cairo title=\"ExampleContract test\" use array::ArrayTrait; use result::ResultTrait; use serde::Serde; use example::ExampleContract::CustomStruct; use example::ExampleContract::NestedStruct; use example::ExampleContract::AnotherCustomStruct; #[test] fn test_add_multiple_structs() { let contract_address = deploy_contract('example', @ArrayTrait::new()).unwrap(); let mut calldata = ArrayTrait::new(); let ns = NestedStruct { d: 1 }; let cs = CustomStruct { a: 2, b: 3, c: ns }; let acs = AnotherCustomStruct { e: 4 }; let standalone_arg = 5; Serde::serialize(@cs, ref calldata); // First argument Serde::serialize(@acs, ref calldata); // Second argument calldata.append(standalone_arg); // Third argument (no need for serde call here) let result = call(contract_address, 'add_multiple_parts', @calldata).unwrap(); assert(*result.at(0_usize) == 1 + 2 + 3 + 4 + 5, 'Invalid sum'); } ``` You would use the same method for passing arguments for `deploy_contract`, `deploy` or `invoke` cheatcodes."}
{"title": "03-cheatcodes.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "--- sidebar_label: Cheatcodes --- # Cheatcodes Often while testing your contract, you want to emulate complex scenarios. As an example, you might want to test how your contract behaves when not authorized contract calls it. Protostar lets you test such scenarios with *cheatcodes*. In this section, you will learn what cheatcodes are and how to use them to create strong tests for your contracts. ## Let's prank a contract Assume you want to test a user validation mechanism in your contract. You can leverage [start_prank](./cheatcodes-reference/start_prank.md) cheatcode to do that. Let's write a simple contract which validates a caller address. ```cairo title=\"Deployed contract\" #[contract] mod MinimalContract { use starknet::get_caller_address; use starknet::ContractAddress; use starknet::ContractAddressIntoFelt252; use traits::Into; #[external] fn is_expected_user() { let caller_address = get_caller_address(); assert(caller_address.into() == 123, 'not authorized'); } } ``` We know [from previous section](./02-integration-testing.md#under-the-hood) that if we call `is_expected_user` method, `caller_address` will be `0`. To pass such a test, we have to use [start_prank](./cheatcodes-reference/start_prank.md) cheatcode. It sets the value returned by `get_caller_address()` for a targeted contract. ```cairo title=\"Test\" use cheatcodes::RevertedTransactionTrait; use result::ResultTrait; use array::ArrayTrait; #[test] fn test_invoke_errors() { let contract_address = deploy_contract('minimal', @ArrayTrait::new()).unwrap(); start_prank(123, contract_address); invoke(contract_address, 'is_expected_user', @ArrayTrait::new()).unwrap(); } ``` Such test will pass. ## Other cheatcodes You can find a list of all available cheatcodes in [cheatcode reference](./cheatcodes-reference/README.md)"}
{"title": "03-gas.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "--- sidebar_label: Gas --- # Limiting gas To limit gas available in a test case you can use `#[available_gas(x)]` attribute, replacing `x` with the desired limit. Example: ``` use array::ArrayTrait; fn fib(a: felt252, b: felt252, n: felt252) -> felt252 { match gas::withdraw_gas() { Option::Some(_) => {}, Option::None(_) => { let mut data = ArrayTrait::new(); data.append('Out of gas'); panic(data); } } match n { 0 => a, _ => fib(b, a + b, n - 1), } } // With no decorator gas is unlimited #[test] fn test_unlimited_gas() { assert(fib(0, 1, 10) == 55, 'invalid result'); } // This test will pass #[test] #[available_gas(100000)] fn test_enough_gas() { assert(fib(0, 1, 10) == 55, 'invalid result'); } // This test will fail, due to not enough gas #[test] #[available_gas(1)] fn test_not_enough_gas() { assert(fib(0, 1, 10) == 55, 'invalid result'); } ``` :::warning All cheatcodes have cost `0` so validating gas cost makes sense only for [unit tests](./01-unit-testing.md). :::"}
{"title": "04-debugging.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "--- sidebar_label: Debugging --- # Debugging Currently, Cairo does not support a debugging mechanism per se, but we can print variables' values to the standard output. # Printing to stdout In order to print a variable's value to the standard output, we have to use `PrintTrait`: ``` use array::ArrayTrait; use protostar_print::PrintTrait; use result::ResultTrait; #[test] fn test_print_basic() { 1.print(); 'hello'.print(); let mut array = ArrayTrait::new(); array.append('veni'); array.append('vidi'); array.append('vici'); array.print(); (1 == 2).print(); true.print(); assert(1 == 1, 'xxx'); } ``` You can print numbers, booleans, and [Cairo short strings]( as well as arrays containing values of these types."}
{"title": "05-e2e.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# End-to-end tests There are three main levels of software testing: unit tests, integration tests, and end-to-end tests. Protostar provides an environment to write unit tests for Starknet smart contracts in Cairo language itself. With the help of cheatcodes like [`deploy_contract`] it is also easy to write integration tests, deploying single or multiple contracts and examining the internal behavior of such small systems. ## Recommended approach In end-to-end testing, the goal is to examine interactions not only within a system of contracts deployed on the blockchain, but also to examine interactions triggered by external services, like web frontends, and observing effects happening within these services themselves. :::note As an example, an end-to-end test of a voting application could trigger a click on a _Vote_ button, causing a transaction to be executed on the blockchain. The test waits for the transaction to be accepted, then examines changes of the publicly available state of the voting contract, e.g. the final result of the voting. ::: End-to-end testing should focus on the bigger picture of the whole system, not only the smart contracts. Modifications and readings of the on-chain state should be done through exposed interfaces of contracts. Therefore, it is recommended to include end-to-end tests in test suites of client applications, implemented in their technologies. The following tools are suggested to set up the described testing environment: 1. [Starknet Devnet] for running a local Starknet network, 2. [Starknet SDKs] like [Starknet.js] or [Starknet.py] for [interacting with Starknet] from tests' code, 3. Protostar CLI for [building contracts] and [deploying][interacting with Starknet] in tests' setup phases and CI. ### Testing standalone contracts In case the smart contracts are standalone and supposed to be used by independent clients, one could write the test suite as an independent project using SDKs in general purpose languages, for example, in [Jest] and [Starknet.js] or [pytest] and [Starknet.py]. [`deploy_contract`]: ./cheatcodes-reference/deploy_contract.md [building contracts]: ../07-interacting-with-starknet/09-compiling.md [interacting with Starknet]: ../07-interacting-with-starknet/README.md [jest]: [pytest]: [starknet devnet]: [starknet sdks]: [starknet.js]: [starknet.py]:"}
{"title": "README.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "--- sidebar_label: Testing --- # Testing Protostar provides developers with a comprehensive testing environment. You can test your code using fast [unit tests](./01-unit-testing.md) or flexible [integration tests](./02-integration-testing.md)"}
{"title": "README.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# Cheatcodes reference Some tests require specific setup beyond what is possible using standard flow. Protostar exposes additional functions called cheatcodes that let you modify the state beyond what is normally possible. Cheatcodes do not require any specific imports or `use` declarations. ## Error handling in cheatcodes All cheatcodes return a `Result` enum: ```cairo title=\"Result\" enum Result { Ok: T, Err: E, } ``` On successful cheatcode execution, a positive result is returned (`OK`) - its exact type depends on the cheatcode. Depending on cheatcode the type of `Err` may also vary. ### Failing test on cheatcode error The simplest handling of `Result` is to `unwrap()` them. It either returns a cheatcode success value or causes the test to fail entirely: ```cairo title=\"Simple handling\" use result::ResultTrait; let prepared_contract = prepare(class_hash, @calldata).unwrap(); ``` ### `RevertedTransaction` Cheatcodes `invoke`, `call`, `deploy`, `deploy_contract` and `deploy_contract_cairo0` and return an `Err` of type `RevertedTransaction` in case of failure. ```cairo struct RevertedTransaction { panic_data: Array::, } ``` It also implements a trait: ```cairo trait RevertedTransactionTrait { fn first(self: @RevertedTransaction) -> felt252; } ``` An example handling of `RevertedTransaction` may look like this ```cairo title=\"Match handling\" match invoke(deployed_contract_address, 'panic_with', @panic_data) { Result::Ok(x) => assert(false, 'Shouldnt have succeeded'), Result::Err(x) => { assert(x.first() == 'error', 'first datum doesnt match'); assert(*x.panic_data.at(1_u32) == 'data', 'second datum doesnt match'); } } ``` ## Available cheatcodes ```mdx-code-block import DocCardList from '@theme/DocCardList'; import {useCurrentSidebarCategory} from '@docusaurus/theme-common'; ```"}
{"title": "call.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `call` ```cairo extern fn call(contract: felt252, function_name: felt252, calldata: @Array::) -> Result::), RevertedTransaction> nopanic; ``` Calls a [deployed](./deploy.md) contract. Unlike [invoke](./invoke.md), it **does not** mutate the blockchain state. - `contract` - deployed contract address - `function_name` - the name of the function you wish to call, this is the [Cairo short string]( which can be at most 31-characters long. - `calldata` - arguments to the target function ```cairo title=\"Example\" use array::ArrayTrait; use result::ResultTrait; #[test] fn test_call() { let mut calldata = ArrayTrait::new(); calldata.append(3); calldata.append(2); calldata.append(5); let return_data2 = call(deployed_contract_address, 'foo', @calldata).unwrap(); assert(*return_data2.at(0_u32) == 25, 'check call result'); } ``` You can find more examples [here]("}
{"title": "declare-cairo0.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `declare_cairo0` ```cairo fn declare_cairo0(contract: felt252) -> Result:: nopanic; ``` Declares a Cairo0 (old syntax) contract given a contract name defined in the [protostar.toml](../../05-protostar-toml.md) configuration file. - `contract` name of a contract as Cairo shortstring (e.g. `declare_cairo0('mycontract')`). ```cairo title=\"Example\" use result::ResultTrait; #[test] fn test_declare_cairo0() { let class_hash = declare_cairo0('myoldcontract').unwrap(); // ... } ```"}
{"title": "declare.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `declare` ```cairo fn declare(contract: felt252) -> Result:: nopanic; ``` Declares a contract given its name defined in the [protostar.toml](../../05-protostar-toml.md) configuration file. - `contract` name of a contract as Cairo shortstring (e.g. `declare('mycontract')`). :::info Declare only supports Cairo 1 (new syntax) contracts. To declare old Cairo 0 contracts, use [declare_cairo0](./declare-cairo0.md). ::: ```cairo title=\"Example\" use result::ResultTrait; #[test] fn test_declare() { let class_hash = declare('mycontract').unwrap(); // ... } ```"}
{"title": "deploy.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `deploy` ```cairo fn deploy(prepared_contract: PreparedContract) -> Result:: nopanic; ``` Deploys a [prepared](./prepare.md) contract. - `prepared_contract` - an object of the struct `PreparedContract` that consists of the following fields: - `contract_address` - the address of the contract calculated during contract [preparation](./prepare.md) - `class_hash` - class hash calculated during contract [declaration](./declare.md) - `constructor_calldata` - calldata for the constructor. If the constructor exists, it is called by `deploy`. ```cairo title=\"Example\" use array::ArrayTrait; use result::ResultTrait; #[test] fn test_deploy() { let class_hash = declare('minimal').unwrap(); assert(class_hash != 0, 'class_hash != 0'); let prepare_result = prepare(class_hash, @ArrayTrait::new()).unwrap(); assert(prepare_result.contract_address != 0, 'prepared contract_address != 0'); assert(prepare_result.class_hash != 0, 'prepared class_hash != 0'); let deployed_contract_address = deploy(prepare_result).unwrap(); assert(deployed_contract_address != 0, 'deployed_contract_address != 0'); } ``` You can find more examples [here]("}
{"title": "deploy_contract.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `deploy_contract` ```cairo fn deploy_contract(contract: felt252, calldata: @Array::) -> Result:: ``` Declares and deploys a contract given its name defined in the [protostar.toml](../../05-protostar-toml.md) configuration file. ```cairo title=\"Example\" use result::ResultTrait; use array::ArrayTrait; #[test] fn test_deploy_contract() { let mut calldata = ArrayTrait::new(); calldata.append(10); calldata.append(11); calldata.append(12); let address = deploy_contract('mycontract', @calldata).unwrap(); // ... } ``` Errors raised by the constructor can be handled in the same way as for [deploy](./deploy.md) :::info `deploy_contract` is just a function which calls cheatcodes `declare` -> `prepare` -> `deploy`, and it's what it does under the hood. :::"}
{"title": "deploy_contract_cairo0.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `deploy_contract_cairo0` ```cairo fn deploy_contract_cairo0(contract: felt252, calldata: @Array::) -> Result:: ``` Declares and deploys a Cairo 0 contract given its name defined in the [protostar.toml](../../05-protostar-toml.md) configuration file. ```cairo title=\"Example\" use result::ResultTrait; use array::ArrayTrait; #[test] fn test_deploy_contract_cairo0() { let mut calldata = ArrayTrait::new(); calldata.append(10); calldata.append(11); calldata.append(12); let address = deploy_contract_cairo0('mycontract', @calldata).unwrap(); // ... } ``` :::info `deploy_contract_cairo0` is just a function which calls cheatcodes `declare_cairo0` -> `prepare` -> `deploy`, and it's what it does under the hood. :::"}
{"title": "invoke.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `invoke` ```cairo fn invoke(contract_address: felt252, function_name: felt252, calldata: @Array::) -> Result:: nopanic; ``` Invokes a contract's function. `function_name` parameter should be provided as a short string. `invoke` can mutate the state of the contract and does not return a value to query the contract for values use [call](./call.md). ```cairo title=\"Example\" use result::ResultTrait; use array::ArrayTrait; #[test] fn test_invoke() { let contract_address = 123; let mut calldata = ArrayTrait::new(); calldata.append(10); calldata.append(11); calldata.append(12); invoke(contract_address, 'function_name', @calldata).unwrap(); // ... } ```"}
{"title": "prepare.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `prepare` ```cairo fn prepare(class_hash: felt252, calldata: @Array::) -> Result:: nopanic; ``` Prepares contract for deployment. ```cairo title=\"Example\" use result::ResultTrait; use array::ArrayTrait; #[test] fn test_prepare() { let class_hash = declare('mycontract').unwrap(); let mut calldata = ArrayTrait::new(); calldata.append(10); calldata.append(11); calldata.append(12); let prepared_contract = prepare(class_hash, @calldata).unwrap(); // ... } ```"}
{"title": "start_prank.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `start_prank` ```cairo fn start_prank(caller_address: felt252, target_contract_address: felt252) -> Result:: nopanic; ``` Changes a caller address returned by `get_caller_address()` for the targeted contract until the prank is stopped with [stop_prank](./stop_prank.md). - `caller_address` address that will start being returned by `get_caller_address()` - `target_contract_address` address for which `get_caller_address()` result will be replaced ```cairo title=\"Example\" #[contract] mod MyContract { use starknet::get_caller_address; use starknet::ContractAddress; use starknet::ContractAddressIntoFelt252; use option::Option; use traits::Into; struct Storage { stored_value: felt252 } #[external] fn will_be_pranked() { let caller_address: ContractAddress = get_caller_address(); if (caller_address.into() == 123) { stored_value::write(100); } else { stored_value::write(50); } } #[view] fn get_stored_value() -> felt252 { stored_value::read() } } #[test] fn test_start_prank() { invoke(deployed_contract_address, 'will_be_pranked', @ArrayTrait::new()).unwrap(); let return_data = call(deployed_contract_address, 'get_stored_value', @ArrayTrait::new()).unwrap(); // Standard value is set assert(*return_data.at(0_u32) == 50, 'check call result'); // Pranked the address start_prank(123, deployed_contract_address).unwrap(); invoke(deployed_contract_address, 'will_be_pranked', @ArrayTrait::new()).unwrap(); let return_data = call(deployed_contract_address, 'get_stored_value', @ArrayTrait::new()).unwrap(); // Special value (100) is set assert(*return_data.at(0_u32) == 100, 'check call result'); } ```"}
{"title": "start_roll.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `start_roll` ```cairo fn start_roll(block_number: felt252, target_contract_address: felt252) -> Result:: nopanic; ``` Sets a block number for a [deployed](./deploy.md) contract, until [`stop_roll`](./stop_roll.md) is called. - `block_number` - the new block number - `target_contract_address` - address of the deployed contract, for which the block number will be set. :::note The default `block_number` value in tests is set to -1 for every contract. ::: ## Usage example ### Tested contract ```cairo title=\"simple contract\" #[contract] mod MinimalContract { use starknet::get_block_info; use box::BoxTrait; #[view] fn check_block_number() -> u64 { get_block_info().unbox().block_number } } ``` ### Test file ```cairo title=\"Example test\" use array::ArrayTrait; use result::ResultTrait; #[test] fn test_start_roll() { let deployed_contract_address = deploy_contract('simple', @ArrayTrait::new()).unwrap(); assert(deployed_contract_address != 0, 'deployed_contract_address != 0'); let result = call(deployed_contract_address, 'check_block_number', @ArrayTrait::new()).unwrap(); assert(*result.at(0_u32) == -1, *result.at(0_u32)); start_roll(100, deployed_contract_address); let result = call(deployed_contract_address, 'check_block_number', @ArrayTrait::new()).unwrap(); assert(*result.at(0_u32) == 100, *result.at(0_u32)); } ```"}
{"title": "start_spoof.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `start_spoof` ```cairo fn start_spoof(contract_address: felt252, mock: TxInfoMock) nopanic; ``` Changes `TxInfo` returned by `get_tx_info()` for the targeted contract until the spoof is stopped with [stop_spoof](./stop_spoof.md). - `contract_address` address of the contract for which `get_tx_info()` result will be mocked. - `TxInfoMock` - a struct with same structure as `TxInfo` (returned by `get_tx_info()`), To mock the field of `TxInfo`, set the corresponding field of `TxInfoMock` to `Some(mocked_value)`. Setting the field to `None` will use a default value - the field will not be mocked. Using `None` will also cancel current mock for that field. See below for practical example. ```cairo title=\"TxInfoMock\" struct TxInfoMock { version: Option, account_contract_address: Option, max_fee: Option, signature: Option>, transaction_hash: Option, chain_id: Option, nonce: Option, } trait TxInfoMockTrait { // Returns a default object initialized with Option::None for each field fn default() -> TxInfoMock; } ``` ```cairo title=\"Contract example\" #[contract] mod SimpleContract { use box::BoxTrait; use starknet::get_tx_info; struct Storage { stored_hash: felt252 } #[external] fn store_tx_hash() { let tx_info = get_tx_info().unbox(); stored_hash::write(tx_info.transaction_hash); } #[view] fn get_stored_tx_hash() -> felt252 { stored_hash::read() } } ``` ```cairo title=\"Test example\" use array::ArrayTrait; use result::ResultTrait; use cheatcodes::TxInfoMockTrait; use option::OptionTrait; #[test] fn test_start_spoof() { let contract_address = deploy_contract('simple', @ArrayTrait::new()).unwrap(); let version_before_mock = call(contract_address, 'get_transaction_version', @ArrayTrait::new()).unwrap(); // Change transaction_hash to 1234 // All other fields of `TxInfo` remain unchanged let mut tx_info = TxInfoMockTrait::default(); tx_info.transaction_hash = Option::Some(1234); start_spoof(contract_address, tx_info); // Stores tx_hash in contract storage invoke(contract_address, 'store_tx_hash', @ArrayTrait::new()).unwrap(); // Retrieve stored tx_hash let return_data = call(contract_address, 'get_stored_tx_hash', @ArrayTrait::new()).unwrap(); assert(*return_data.at(0_u32) == 1234, *return_data.at(0_u32)); // Verify that only transaction_hash has been mocked let return_data = call(contract_address, 'get_transaction_version', @ArrayTrait::new()).unwrap(); assert(*return_data.at(0_u32) == *version_before_mock.at(0_u32), *return_data.at(0_u32)); } ```"}
{"title": "start_warp.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `start_warp` ```cairo fn start_warp(block_timestamp: felt252, target_contract_address: felt252) -> Result:: nopanic; ``` Sets a block timestamp for a [deployed](./deploy.md) contract, until [`stop_warp`](./stop_warp.md) is called. - `block_timestamp` - value of the timestamp - `target_contract_address` - address of the deployed contract, for which the block timestamp will be set. :::note The default `block_timestamp` value in tests is set to 0 for every contract. ::: ## Usage example ### Tested contract ```cairo title=\"simple contract\" #[contract] mod MinimalContract { use starknet::get_block_info; use box::BoxTrait; #[view] fn check_timestamp() -> u64 { get_block_info().unbox().block_timestamp } } ``` ### Test file ```cairo title=\"Example test\" use array::ArrayTrait; use result::ResultTrait; #[test] fn test_start_warp_simple() { let deployed_contract_address = deploy_contract('simple', ArrayTrait::new()).unwrap(); assert(deployed_contract_address != 0, 'deployed_contract_address != 0'); let result = call(deployed_contract_address, 'check_timestamp', ArrayTrait::new()).unwrap(); assert(*result.at(0_u32) == 0, *result.at(0_u32)); start_warp(100, deployed_contract_address); let result = call(deployed_contract_address, 'check_timestamp', ArrayTrait::new()).unwrap(); assert(*result.at(0_u32) == 100, *result.at(0_u32)); } ```"}
{"title": "stop_prank.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `stop_prank` ```cairo fn stop_prank(target_contract_address: felt252) -> Result:: nopanic; ``` Stops a prank started by [`start_prank`](./start_prank.md). - `target_contract_address` address that was previously pranked. ```cairo title=\"Example\" #[test] fn test_stop_prank() { stop_prank(pranked_address).unwrap(); // Address is no longer pranked from here } ```"}
{"title": "stop_roll.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `stop_roll` ```cairo fn stop_roll(target_contract_address: felt252) -> Result:: nopanic; ``` Stops a roll started by [`start_roll`](./start_roll.md). - `target_contract_address` address that was previously rolled. ```cairo title=\"Example\" #[test] fn my_test() { stop_roll(rolled_address).unwrap(); // Block number is no longer rolled from here (defaults to -1) } ```"}
{"title": "stop_spoof.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `stop_spoof` ```cairo fn stop_spoof(contract_address: felt252) nopanic; ``` Stops a spoof started by [`start_spoof`](./start_spoof.md). - `contract_address` address of the contract that was previously spoofed. ```cairo title=\"Example\" #[test] fn test_stop_spoof() { stop_spoof(spoofed_contract_address).unwrap(); // Contract is no longer spoofed from here } ```"}
{"title": "stop_warp.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# `stop_warp` ```cairo fn stop_warp(target_contract_address: felt252) -> Result:: nopanic; ``` Stops a warp started by [`start_warp`](./start_warp.md). - `target_contract_address` address that was previously warped. ```cairo title=\"Example\" #[test] fn my_test() { stop_warp(warped_address).unwrap(); // Block timestamp is no longer warped from here (defaults to 0) } ```"}
{"title": "01-invoke.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# Invoking contracts ## Overview This command allows you to send an invoke transaction to Starknet. The basic inputs that you need for the commands are: - [Signing credentials](#signing) - Contract address - Function name - Inputs to the function - Fee specification (concrete amount, or auto-estimation) - Network you want to target (i.e. its name or gateway URL) For detailed API description, see [invoke command reference](../../cli-reference.md#invoke). ## Signing Credentials for paying the fee are needed, which are: - Account address (which pays the fee) - - in hex (prefixed with '0x') or decimal representation. - Private key for that account (from ArgentX, Braavos etc.) - in hex (prefixed with '0x') or decimal representation. This can be provided with `PROTOSTAR_ACCOUNT_PRIVATE_KEY` env variable or with a file on local filesystem containing that key in plaintext, in which case you should use `--private-key-path`. Custom signing logic is made possible by using custom signers - see details [here](./07-signing.md). ## Usage example ```shell title=\"Example\" protostar invoke \\ --contract-address 0x4a739ab73aa3cac01f9da5d55f49fb67baee4919224454a2e3f85b16462a911 \\ --function \"setter_tester_success\" \\ --network testnet \\ --account-address 0x0481Eed2e02b1ff19Fd32429801f28a59DEa630d81189E39c80F2F60139b381a \\ --max-fee auto \\ --inputs 3 \\ --private-key-path ./.pkey Invoke transaction was sent. Transaction hash: 0x05d2362b9b5a5aba8a02a41d2f1fcbdc06cde89f90cf33c0ea4957846c86aeef ``` To avoid having to repeat `--account-address` and `--private-key-path` in every command, they can be included in `protostar.toml` configuration profiles. See [this page](./README.md#using-configuration-profiles) for more details. :::warning Setting `max-fee` to `auto` is discouraged as it may cause **very high transaction cost**. Always prefer manually specifying the `max-fee`. ::: :::note If you need to print machine-readable output in JSON format, you should use `--json` flag. This may come in handy for writing scripts that include Protostar commands. For more information, go to [this page](./08-scripting.md) :::"}
{"title": "02-declare.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# Declaring new contracts Starknet provides a distinction between contract class and instance. This is similar to difference between writing the code of a `class MyClass {}` and creating a new instance of it `let myInstance = MyClass()` in object-oriented programming languages. To deploy a new contract, for instance, you need to: 1. Declare a contract on the network 2. Deploy an instance of that declared contract For detailed API description, see [declare command reference](../../cli-reference.md#declare). ## Usage example :::note Building a contract before running `declare` is not required. Protostar builds a contract during declaration under the hood. ::: First make sure contract is defined in the [`protostar.toml`](../05-protostar-toml.md): ```toml title=protostar.toml # ... [contracts] my_contract = [\"src\"] ``` Then run: ```shell title=\"Example\" protostar declare my_contract \\ --network testnet \\ --account-address 0x0481Eed2e02b1ff19Fd32429801f28a59DEa630d81189E39c80F2F60139b381a \\ --max-fee auto \\ --private-key-path ./.pkey Declare transaction was sent. Class hash: 0x038cc... Transaction hash: 0x3c6c... ``` :::info The declare transaction must be signed and requires paying a fee, similarly to how invoke transaction does. See [signing](./01-invoke.md#signing) for more details. :::"}
{"title": "03-deploy.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# Deploying new contracts ## Overview Protostar supports deploying smart contracts to a given network with the `protostar deploy` command. It works by invoking a [Universal Deployer Contract]( which deploys the contract with the given class hash and constructor arguments. The basic inputs needed for this command are: - Class hash of the declared contract class, that you want to deploy - Network you want to target (i.e. its name or gateway URL) [Read the CLI reference for the deploy command](../../cli-reference.md#deploy) to learn more about all supported arguments. ## Usage example After [declaring your contract](./02-declare.md), you can deploy the contract in the following way. ```shell title=\"Example\" protostar deploy 0xdeadbeef \\ --network testnet \\ --account-address 0x0481Eed2e02b1ff19Fd32429801f28a59DEa630d81189E39c80F2F60139b381a \\ --max-fee auto \\ --private-key-path ./.pkey [INFO] Invoke transaction was sent to the Universal Deployer Contract. Contract address: 0x06a5ea9e42c921bd58e24b8da9d1fc91a488df0700b173f1c6bb0e453f68afec Transaction hash: 0x1cbba90ba0d1fbfba09b1f7a0f987134dd9a02a845ca89244b3272374d37ede ``` :::info Deploying a contract is a transaction must be signed and requires paying a fee, similarly to how invoke transaction does. See [signing](./01-invoke.md#signing) for more details. ::: :::note If you need to print machine-readable output in JSON format, you should use `--json` flag. This may come in handy for writing scripts that include Protostar commands. For more information, go to [this page](./08-scripting.md) :::"}
{"title": "04-call.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# Calling contracts ## Overview The `protostar call` command allows you to call any `#view` function without mutating the blockchain state. The basic inputs that you need for the commands are: - Contract address - Function name - Inputs to the function - Network you want to target (i.e. its name or gateway URL) For detailed API description, see [call command reference](../../cli-reference.md#call). ## Usage example ```shell title=\"Example\" protostar call \\ --contract-address 0x07ee8ac4d0c1b11eca79b347fb47be5a431cf84a854542b9fbe14f11cfba5466 \\ --function \"add_3\" \\ --network testnet \\ --inputs 3 Call successful. Response: { \"res\": 6 } ``` :::note If you need to print machine-readable output in JSON format, you should use `--json` flag. This may come in handy for writing scripts that include protostar commands. For more information, go to [this page](./08-scripting.md) :::"}
{"title": "05-deploy-account.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# Creating an account ## Overview In order to create a new account, you need to deploy an account contract. :::tip Instead of manually deploying an account through Protostar, you can consider using a [wallet provider]( Please note that the Protostar team doesn't verify the safety or compatibility of these wallets. ::: There are multiple account contracts to choose from, and it is the end user responsibility to find an account that works for them. Some examples of already existing account contracts are [OpenZeppelin]( and [ArgentX]( :::info You can read more about accounts in Starknet [here]( ::: There are two ways of deploying a new account contract: - sending [`DEPLOY_ACCOUNT` transaction]( - using already deployed account contract and deploying new one via [the Universal Deployer Contract]( If you do not have access to any existing account on Starknet, you will most likely have to use the `DEPLOY_ACCOUNT` transaction. ## Sending `DEPLOY_ACCOUNT` transaction Protostar supports sending [`DEPLOY_ACCOUNT`]( transactions. ### Prerequisites You must know a `class_hash` of already [declared](./02-declare.md) account contract. It will be used to create an instance of your account. :::info Contract used for `DEPLOY_ACCOUNT` transaction define `__validate_deploy__` entrypoint to support creation through `DEPLOY_ACCOUNT` transaction. ::: ### Precalculating the address First, calculate the address of the account you will be deploying using [`protostar calculate-account-address` command](/docs/cli-reference#calculate-account-address). ```shell title=\"Example\" protostar calculate-account-address \\ --account-address-salt .. \\ # provide a valid integer for salt --account-class-hash 0x1234 \\ --account-constructor-input 1 2 3 4 Address: 0x1234 ``` Depending on your account contract used, input expected by the constructor will vary. ### Prefund the calculated address Transfer enough funds to the calculated address to cover the cost of `DEPLOY_ACCOUNT` transaction. For Starknet testnet you can use [this faucet]( to obtain testnet ETH. For mainnet, you will have to bridge enough tokens from other networks. See [token bridges]( for more details. ### Deploy the account Once funds has been transferred to the address, run `protostar deploy-account` command. ```shell title=\"Example\" protostar deploy-account \\ --account-address-salt .. \\ # provide a valid integer for salt --account-class-hash 0x1234 \\ --account-constructor-input 1 2 3 4 \\ --network testnet \\ --max-fee 10 \\ # provide a valid max-fee in WEI --private-key-path ./.pkey Transaction hash: 0x060e83c1de4e6ec2cec20239943fd19402f4e23cc88c62afed63f63f6fad4063 ``` Once the transaction gets accepted, your account will be available to use at the address you calculated in [previous step](#precalculating-the-address) using the credentials you provided when sending the transaction."}
{"title": "06-multicall.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# Multicall ## Overview Multicall executes multiple calls as a single transaction. If one call fails, the entire operation is aborted. Use it to prevent leaving your system in an inconsistent state. ## Usage example First, create a toml file containing calls defined as [array of tables]( In this file, you can use contract address of a contract to be deployed by using references (`$DEPLOY_CALL_ID`). References can be used in `contract-address` and `inputs` attributes as demonstrated in the example below. ```toml title=\"calls.toml\" [[call]] type = \"deploy\" class-hash = 0xDEADBEEF inputs = [] id = \"my_contract\" [[call]] type = \"invoke\" contract-address = \"$my_contract\" function = \"increase_balance\" inputs = [42] ``` Multicall supports two types of transactions \u2014 `deploy` and `invoke`, which take similar arguments to [`deploy` command](/docs/cli-reference#deploy) and [`invoke` command](/docs/cli-reference#invoke). With the `deploy` transaction type, the deployment happens through the Universal Deployer Contract (UDC), see the [`deploy` command](/docs/cli-reference#deploy) for more information. ```toml title=\"protostar.toml\" [project] protostar-version = \"0.8.1\" [multicall] account-address = 0x... gateway-url = \" chain-id = 1536727068981429685321 max-fee = \"auto\" ``` ```shell title=\"Calling multicall\" export PROTOSTAR_ACCOUNT_PRIVATE_KEY 0x... protostar multicall calls.toml ``` ```shell title=\"Protostar shows transaction hash and addresses of deployed contracts\" Multicall has been sent. transaction hash: 0x... my_contract : 0x... ```"}
{"title": "07-signing.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# Signing Protostar offers two ways of providing the signature: ## Default signer By default, Protostar uses the [StarkCurveSigner class]( from Starknet.py to sign transactions. The way of signing used by this class requires providing a private key (for signing) and account contract's address (to fetch the nonce). Depending on what account you use, these can be obtained in different ways. Refer to your account documentation for more details. ### Providing account details in Protostar commands To provide your account details when running Protostar commands, these arguments should be used - `--private-key-path` - a path to the file containing private key, either in hex (prefixed with '0x') or decimal format. - `--account-address` - your account contract's address on the appropriate network, either in hex (prefixed with '0x') or decimal format. If you prefer not to store your private key in a file, define a `PROTOSTAR_ACCOUNT_PRIVATE_KEY` environment variable. Protostar will use that variable for the private key automatically when running commands. ## Using a custom signer class If your account contract requires a different way of signing, you can create a custom signer class which inherits from [BaseSigner]( abstract class if To use a custom signer, provide a `--signer-class` argument when executing Protostar commands. :::caution The custom signer class must not take any arguments in the constructor, since we don't pass any args on instantiation. ::: The Python file containing this class can be put next to Cairo source code. Protostar synchronizes `PYTHONPATH` with project's `cairo_path`. Modules that are dependencies of Protostar (like `starknet_py` or `cairo-lang`) should be available for importing by default. If you want to import other custom modules, you should extend `PYTHONPATH` yourself ( when running this command."}
{"title": "08-scripting.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "# Scripting In order to automate a process that includes Protostar operations, you may want to build a script in the language of your choice. This tutorial shows a simple example of how to do such a thing using scripting in bash. We are going to write a script that builds, tests, declares, deploys, and, in the end, calls the contract. We are also going to make use of the Protostar's structured output, so we can use previous' commands outputs in the following ones. ### File Structure First, let's create a basic Protostar file structure. You can generate it by calling [`protostar init`](../03-project-initialization.md). It looks like this: ``` my_project/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 business_logic/ \u2502 \u2502 \u2514\u2500\u2500 utils.cairo \u2502 \u251c\u2500\u2500 contract/ \u2502 \u2502 \u2514\u2500\u2500 hello_starknet.cairo \u2502 \u251c\u2500\u2500 business_logic.cairo \u2502 \u251c\u2500\u2500 contract.cairo \u2502 \u2514\u2500\u2500 lib.cairo \u2514\u2500\u2500 Scarb.toml \u251c\u2500\u2500 tests/ \u2502 \u251c\u2500\u2500 test_hello_starknet.cairo \u2502 \u2514\u2500\u2500 test_utils.cairo \u2514\u2500\u2500 protostar.toml ``` #### The contract `protostar init` automatically fills generated files with sample content. We're not going to change them because the example contract is sufficient for us, and it is not important for this tutorial what it does exactly. #### protostar.toml file You can read about how to compose the Protostar configuration file [here](../05-protostar-toml.md). The point is to keep Protostar commands clean and simple and leave such things as the network configuration away from them. In this file, you should create the following sections: - `declare` - `deploy` - `call` In these sections, you can specify properties like `network`, `account-address`, or `private-key-path`. ### Bash script #### Set up the script Let's start with something like this: ```shell title=\"automate_protostar_operations.sh\" #!/bin/bash set -e ``` The first line informs the system which interpreter should be used to run the script. The `set -e` instruction tells the interpreter to exit the script immediately if any command returns a non-zero status. This is good for us because we don't want to run the following instructions if one of them fails, for example, we do not want to deploy a contract if the tests for this contract failed. #### Make sure the contract is correct ```shell title=\"automate_protostar_operations.sh\" protostar build protostar test ``` These two instructions ensure that the contract builds properly and all tests pass. #### Declare and deploy the contract Now, we need to first [declare](./02-declare.md) the contract and then [deploy](./03-deploy.md) it. Normally, we would start with something like this: ```shell protostar declare hello_starknet ``` But the `deploy` command needs the contract's class hash that comes from the `declare` command output. Therefore, we need to get this output in a standardized way. That's when the `--json` flag comes into play. By doing: ```shell protostar declare hello_starknet --json ``` we get an output like this: ```json { \"class_hash\": \"0x07a70656b5612a2f87bd98af477c0be5fa2113d13fe1069e55ad326a3e6f4fe6\", \"transaction_hash\": \"0x01f6a2c391d1bd0a51322ba73037ada20e0b30da8232bb86028f813a0d4c1fdb\" } ``` :::note The `--json` output is, in fact, formatted in [NDJSON]( but here we operate on commands that return a single message, therefore, we can treat them as JSONs. ::: Now, we can parse the json and pull all the desired information from it easily as json is a format that is widely supported. We could do something like this in our bash script: ```shell title=\"automate_protostar_operations.sh\" OUTPUT=$(protostar declare hello_starknet --json) CLASS_HASH=$(python -c \"import sys, json; print(json.loads(sys.argv[1])['class_hash'])\" $OUTPUT) protostar deploy $CLASS_HASH --inputs 100 ``` You can use any alternative to python that will parse the json for you. This is how it would work with [jq]( ```shell title=\"automate_protostar_operations.sh\" OUTPUT=$(protostar declare hello_starknet --json) CLASS_HASH=$(echo $OUTPUT | jq -r \".class_hash\") protostar deploy $CLASS_HASH --inputs 100 ``` #### Call the contract Now, let's say we want to call our contract. In this case, we need the contract address that is being returned from the `deploy` command call. We are basically going to do the same thing as previously to pass the contract address from `deploy` to `call`: ```shell title=\"automate_protostar_operations.sh\" OUT=$(protostar deploy $CLASS_HASH --inputs 100 --json) CONTRACT_ADDRESS=$(python -c \"import sys, json; print(json.loads(sys.argv[1])['contract_address'])\" $OUT) protostar call --contract-address $CONTRACT_ADDRESS --function get_balance ``` In the end, our bash script looks like this: ```shell title=\"automate_protostar_operations.sh\" #!/bin/bash set -e protostar build protostar test DECLARE_OUTPUT=$(protostar declare hello_starknet --json) CLASS_HASH=$(python -c \"import sys, json; print(json.loads(sys.argv[1])['class_hash'])\" $DECLARE_OUTPUT) DEPLOY_OUTPUT=$(protostar deploy $CLASS_HASH --inputs 100 --json) CONTRACT_ADDRESS=$(python -c \"import sys, json; print(json.loads(sys.argv[1])['contract_address'])\" $DEPLOY_OUTPUT) protostar call --contract-address $CONTRACT_ADDRESS --function get_balance ``` Of course, we could exclude pulling a specific field from the output to a separate bash function, but that's not important. Using the `--json` flag may also be good if you prefer the more compressed output from protostar commands. ### Python script The main advantage of using the JSON format is that the user may automate protostar operations easily no matter what languages and technologies they use. We can achieve the same result as above writing the equivalent python script: ```python title=\"automate_protostar_operations.py\" import subprocess, json def run_command(cmd): out = subprocess.check_output(cmd.split(\" \")) return out.decode(\"utf-8\") print(\"BUILD\") run_command(\"./protostar build\") print(\"TEST\") run_command(\"./protostar test\") print(\"DECLARE\") out = run_command(\"./protostar declare hello_starknet --json\") print(\"DEPLOY\") class_hash = json.loads(out)['class_hash'] out = run_command(f\"./protostar deploy {class_hash} --inputs 100 --json\") print(\"CALL\") contract_address = json.loads(out)['contract_address'] out = run_command(f\"./protostar call --contract-address {contract_address} --function get_balance --json\") print(out) print(\"DONE\") ```"}
{"title": "09-compiling.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "--- sidebar_label: Compilation --- # Compiling a Cairo 1 Project with Protostar To build your contracts, first define them in [`protostar.toml`](../05-protostar-toml.md#contracts-section) To build run ```shell title=\"build\" protostar build ``` [Check CLI reference](../../cli-reference.md#build) for more details. ## Output directory Running [`protostar build`](../../cli-reference.md#build) command will generate the compiled contracts in the `build` directory by default. You can specify a custom output directory using the [`--compiled-contracts-dir`](../../cli-reference#compiled-contracts-dir-pathbuild-1) argument. ```shell title=\"Example\" $ protostar build --compiled-contracts-dir out ``` `.sierra.json` files contain contracts compiled to the sierra format. This format is used to declare contracts on Starknet. Read more about sierra [here]( `.casm.json` files contain contracts compiled to the casm format which can be executed on the Cairo Virtual Machine. This format is used to calculate `compiled_class_hash` of a contract. `.class_hash` files contain class hash of the built contract `.compiled_class_hash` files contain compiled class hash of the built contract :::note If you need to print machine-readable output in JSON format, you should use `--json` flag. ::: ## Compiling a single contract If your `protostar.toml` file defines multiple contracts, and you wish to compile only one of them, you can specify the [`--contract-name`](../../cli-reference.md#--contract-name-string-1) argument: ``` $ protostar build --contract-name my_contract ```"}
{"title": "README.md", "repo_owner": "software-mansion", "repo_name": "protostar", "text": "## Interacting with Starknet Protostar provides a couple of commands allowing users to interact with Starknet without the need to install [`cairo-lang`]( Python package locally. Protostar offers similar CLI to [Starknet's CLI]( However, with Protostar you can move deployment configuration to [`protostar.toml`](../05-protostar-toml.md) and display help for each command. ```mdx-code-block import DocCardList from '@theme/DocCardList'; import {useCurrentSidebarCategory} from '@docusaurus/theme-common'; ``` ## Using [configuration profiles](../05-protostar-toml.md#configuration-profiles) Configuration profiles allow you to easily reuse configuration for devnet, testnet, and mainnet networks. You can define a network configuration in the `protostar.toml` as demonstrated in the snippet below. ```toml title=protostar.toml # ... # [\"profile.devnet.protostar.deploy\"] gateway-url = \" [\"profile.testnet.protostar.deploy\"] network = \"testnet\" [\"profile.mainnet.protostar.deploy\"] network = \"mainnet\" ``` Then, run `deploy` command with the `--profile` argument. ```text protostar -p devnet deploy ./build/main.json ```"}
{"title": "Account.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'Account' title: 'Class: Account' sidebar_label: 'Account' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - [`Provider`](Provider.md) \u21b3 **`Account`** ## Implements - [`AccountInterface`](AccountInterface.md) ## Constructors ### constructor \u2022 **new Account**(`providerOrOptions`, `address`, `pkOrSigner`, `cairoVersion?`) #### Parameters | Name | Type | Default value | | :------------------ | :--------------------------------------------------------------------------------------------------------- | :------------ | | `providerOrOptions` | [`ProviderOptions`](../interfaces/types.ProviderOptions.md) \\| [`ProviderInterface`](ProviderInterface.md) | `undefined` | | `address` | `string` | `undefined` | | `pkOrSigner` | `string` \\| `Uint8Array` \\| [`SignerInterface`](SignerInterface.md) | `undefined` | | `cairoVersion` | [`CairoVersion`](../namespaces/types.md#cairoversion) | `'0'` | #### Overrides [Provider](Provider.md).[constructor](Provider.md#constructor) #### Defined in [src/account/default.ts:70]( ## Properties ### signer \u2022 **signer**: [`SignerInterface`](SignerInterface.md) #### Implementation of [AccountInterface](AccountInterface.md).[signer](AccountInterface.md#signer) #### Defined in [src/account/default.ts:64]( --- ### address \u2022 **address**: `string` #### Implementation of [AccountInterface](AccountInterface.md).[address](AccountInterface.md#address) #### Defined in [src/account/default.ts:66]( --- ### cairoVersion \u2022 **cairoVersion**: [`CairoVersion`](../namespaces/types.md#cairoversion) #### Implementation of [AccountInterface](AccountInterface.md).[cairoVersion](AccountInterface.md#cairoversion) #### Defined in [src/account/default.ts:68]( --- ### deploySelf \u2022 **deploySelf**: (`__namedParameters`: [`DeployAccountContractPayload`](../namespaces/types.md#deployaccountcontractpayload), `transactionsDetail`: [`InvocationsDetails`](../namespaces/types.md#invocationsdetails)) => `Promise` #### Type declaration \u25b8 (`\u00abdestructured\u00bb`, `transactionsDetail?`): `Promise` ##### Parameters | Name | Type | | :------------------- | :------------------------------------------------------------------------------------ | | `\u00abdestructured\u00bb` | [`DeployAccountContractPayload`](../namespaces/types.md#deployaccountcontractpayload) | | `transactionsDetail` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | ##### Returns `Promise` #### Defined in [src/account/default.ts:427]( ## Methods ### getNonce \u25b8 **getNonce**(`blockIdentifier?`): `Promise` Gets the nonce of the account with respect to a specific block #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :---------------------------------------------- | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | optional blockIdentifier. Defaults to 'pending' | #### Returns `Promise` nonce of the account #### Implementation of [AccountInterface](AccountInterface.md).[getNonce](AccountInterface.md#getnonce) #### Defined in [src/account/default.ts:86]( --- ### getNonceSafe \u25b8 `Private` **getNonceSafe**(`nonce?`): `Promise` #### Parameters | Name | Type | | :------- | :---------------------------------------------------- | | `nonce?` | [`BigNumberish`](../namespaces/types.md#bignumberish) | #### Returns `Promise` #### Defined in [src/account/default.ts:90]( --- ### estimateFee \u25b8 **estimateFee**(`calls`, `estimateFeeDetails?`): `Promise` #### Parameters | Name | Type | | :-------------------- | :---------------------------------------------------------------------------------------- | | `calls` | [`AllowArray`](../namespaces/types.md#allowarray) | | `estimateFeeDetails?` | [`EstimateFeeDetails`](../interfaces/types.EstimateFeeDetails.md) | #### Returns `Promise` #### Defined in [src/account/default.ts:99]( --- ### estimateInvokeFee \u25b8 **estimateInvokeFee**(`calls`, `\u00abdestructured\u00bb?`): `Promise` Estimate Fee for executing an INVOKE transaction on starknet #### Parameters | Name | Type | Description | | :--------------- | :---------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `calls` | [`AllowArray`](../namespaces/types.md#allowarray) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata | | `\u00abdestructured\u00bb` | [`EstimateFeeDetails`](../interfaces/types.EstimateFeeDetails.md) | - | #### Returns `Promise` response from estimate_fee #### Implementation of [AccountInterface](AccountInterface.md).[estimateInvokeFee](AccountInterface.md#estimateinvokefee) #### Defined in [src/account/default.ts:106]( --- ### estimateDeclareFee \u25b8 **estimateDeclareFee**(`\u00abdestructured\u00bb`, `\u00abdestructured\u00bb?`): `Promise` Estimate Fee for executing a DECLARE transaction on starknet #### Parameters | Name | Type | Description | | :--------------- | :------------------------------------------------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `\u00abdestructured\u00bb` | [`DeclareContractPayload`](../namespaces/types.md#declarecontractpayload) | the payload object containing: - contract - the compiled contract to be declared - classHash - the class hash of the compiled contract. This can be obtained by using starknet-cli. | | `\u00abdestructured\u00bb` | [`EstimateFeeDetails`](../interfaces/types.EstimateFeeDetails.md) | - | #### Returns `Promise` response from estimate_fee #### Implementation of [AccountInterface](AccountInterface.md).[estimateDeclareFee](AccountInterface.md#estimatedeclarefee) #### Defined in [src/account/default.ts:140]( --- ### estimateAccountDeployFee \u25b8 **estimateAccountDeployFee**(`\u00abdestructured\u00bb`, `\u00abdestructured\u00bb?`): `Promise` Estimate Fee for executing a DEPLOY_ACCOUNT transaction on starknet #### Parameters | Name | Type | Description | | :--------------- | :------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------- | | `\u00abdestructured\u00bb` | [`DeployAccountContractPayload`](../namespaces/types.md#deployaccountcontractpayload) | contract - the compiled contract to be deployed - classHash - the class hash of the compiled contract. This can be obtained by using starknet-cli. | | `\u00abdestructured\u00bb` | [`EstimateFeeDetails`](../interfaces/types.EstimateFeeDetails.md) | optional blockIdentifier - constant nonce = 0 | #### Returns `Promise` response from estimate_fee #### Implementation of [AccountInterface](AccountInterface.md).[estimateAccountDeployFee](AccountInterface.md#estimateaccountdeployfee) #### Defined in [src/account/default.ts:174]( --- ### estimateDeployFee \u25b8 **estimateDeployFee**(`payload`, `transactionsDetail?`): `Promise` Estimate Fee for executing a UDC DEPLOY transaction on starknet This is different from the normal DEPLOY transaction as it goes through the Universal Deployer Contract (UDC) #### Parameters | Name | Type | Description | | :-------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `payload` | [`UniversalDeployerContractPayload`](../namespaces/types.md#universaldeployercontractpayload) \\| [`UniversalDeployerContractPayload`](../namespaces/types.md#universaldeployercontractpayload)[] | containing - classHash: computed class hash of compiled contract - salt: address salt - unique: bool if true ensure unique salt - calldata: constructor calldata | | `transactionsDetail?` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | Invocation Details containing: - optional nonce - optional version - optional maxFee | #### Returns `Promise` #### Implementation of [AccountInterface](AccountInterface.md).[estimateDeployFee](AccountInterface.md#estimatedeployfee) #### Defined in [src/account/default.ts:213]( --- ### estimateFeeBulk \u25b8 **estimateFeeBulk**(`invocations`, `\u00abdestructured\u00bb?`): `Promise` Estimate Fee for executing a list of transactions on starknet Contract must be deployed for fee estimation to be possible #### Parameters | Name | Type | | :--------------- | :---------------------------------------------------------------- | | `invocations` | [`Invocations`](../namespaces/types.md#invocations) | | `\u00abdestructured\u00bb` | [`EstimateFeeDetails`](../interfaces/types.EstimateFeeDetails.md) | #### Returns `Promise` response from estimate_fee #### Implementation of [AccountInterface](AccountInterface.md).[estimateFeeBulk](AccountInterface.md#estimatefeebulk) #### Defined in [src/account/default.ts:221]( --- ### buildInvocation \u25b8 **buildInvocation**(`call`, `signerDetails`): `Promise` #### Parameters | Name | Type | | :-------------- | :---------------------------------------------------------------------------- | | `call` | [`Call`](../namespaces/types.md#call)[] | | `signerDetails` | [`InvocationsSignerDetails`](../interfaces/types.InvocationsSignerDetails.md) | #### Returns `Promise` #### Defined in [src/account/default.ts:245]( --- ### execute \u25b8 **execute**(`calls`, `abis?`, `transactionsDetail?`): `Promise` Invoke execute function in account contract #### Parameters | Name | Type | Default value | Description | | :------------------- | :---------------------------------------------------------------------------------------- | :------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `calls` | [`AllowArray`](../namespaces/types.md#allowarray) | `undefined` | the invocation object or an array of them, containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `abis` | `undefined` \\| [`Abi`](../namespaces/types.md#abi)[] | `undefined` | - | | `transactionsDetail` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | `{}` | - | #### Returns `Promise` response from addTransaction #### Implementation of [AccountInterface](AccountInterface.md).[execute](AccountInterface.md#execute) #### Defined in [src/account/default.ts:259]( --- ### declareIfNot \u25b8 **declareIfNot**(`payload`, `transactionsDetail?`): `Promise` First check if contract is already declared, if not declare it If contract already declared returned transaction_hash is ''. Method will pass even if contract is already declared #### Parameters | Name | Type | Description | | :------------------- | :------------------------------------------------------------------------ | :--------------------------------- | | `payload` | [`DeclareContractPayload`](../namespaces/types.md#declarecontractpayload) | DeclareContractPayload | | `transactionsDetail` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | (optional) InvocationsDetails = {} | #### Returns `Promise` DeclareContractResponse #### Defined in [src/account/default.ts:306]( --- ### declare \u25b8 **declare**(`payload`, `transactionsDetail?`): `Promise` Declares a given compiled contract (json) to starknet #### Parameters | Name | Type | Description | | :------------------- | :------------------------------------------------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `payload` | [`DeclareContractPayload`](../namespaces/types.md#declarecontractpayload) | transaction payload to be deployed containing: - contract: compiled contract code - (optional) classHash: computed class hash of compiled contract. Pre-compute it for faster execution. - (required for Cairo1 without compiledClassHash) casm: CompiledContract \\| string; - (optional for Cairo1 with casm) compiledClassHash: compiled class hash from casm. Pre-compute it for faster execution. | | `transactionsDetail` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | Invocation Details containing: - optional nonce - optional version - optional maxFee | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Implementation of [AccountInterface](AccountInterface.md).[declare](AccountInterface.md#declare) #### Defined in [src/account/default.ts:322]( --- ### deploy \u25b8 **deploy**(`payload`, `details?`): `Promise` Deploys a declared contract to starknet - using Universal Deployer Contract (UDC) support multicall #### Parameters | Name | Type | Description | | :--------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `payload` | [`UniversalDeployerContractPayload`](../namespaces/types.md#universaldeployercontractpayload) \\| [`UniversalDeployerContractPayload`](../namespaces/types.md#universaldeployercontractpayload)[] | classHash: computed class hash of compiled contract - [constructorCalldata] contract constructor calldata - [salt=pseudorandom] deploy address salt - [unique=true] ensure unique salt | | `details?` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | [nonce=getNonce] - [version=transactionVersion] - [maxFee=getSuggestedMaxFee] | #### Returns `Promise` - contract_address[] - transaction_hash #### Implementation of [AccountInterface](AccountInterface.md).[deploy](AccountInterface.md#deploy) #### Defined in [src/account/default.ts:351]( --- ### deployContract \u25b8 **deployContract**(`payload`, `details?`): `Promise` Simplify deploy simulating old DeployContract with same response + UDC specific response Internal wait for L2 transaction, support multicall #### Parameters | Name | Type | Description | | :--------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `payload` | [`UniversalDeployerContractPayload`](../namespaces/types.md#universaldeployercontractpayload) \\| [`UniversalDeployerContractPayload`](../namespaces/types.md#universaldeployercontractpayload)[] | classHash: computed class hash of compiled contract - [constructorCalldata] contract constructor calldata - [salt=pseudorandom] deploy address salt - [unique=true] ensure unique salt | | `details?` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | [nonce=getNonce] - [version=transactionVersion] - [maxFee=getSuggestedMaxFee] | #### Returns `Promise` - contract_address - transaction_hash - address - deployer - unique - classHash - calldata_len - calldata - salt #### Implementation of [AccountInterface](AccountInterface.md).[deployContract](AccountInterface.md#deploycontract) #### Defined in [src/account/default.ts:397]( --- ### declareAndDeploy \u25b8 **declareAndDeploy**(`payload`, `details?`): `Promise` Declares and Deploy a given compiled contract (json) to starknet using UDC Internal wait for L2 transaction, do not support multicall Method will pass even if contract is already declared (internal using DeclareIfNot) #### Parameters | Name | Type | Description | | :--------- | :------------------------------------------------------------------------------------------ | :---------------------------------------------------------------------------- | | `payload` | [`DeclareAndDeployContractPayload`](../namespaces/types.md#declareanddeploycontractpayload) | - | | `details?` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | [nonce=getNonce] - [version=transactionVersion] - [maxFee=getSuggestedMaxFee] | #### Returns `Promise` - declare - transaction_hash - deploy - contract_address - transaction_hash - address - deployer - unique - classHash - calldata_len - calldata - salt #### Implementation of [AccountInterface](AccountInterface.md).[declareAndDeploy](AccountInterface.md#declareanddeploy) #### Defined in [src/account/default.ts:408]( --- ### deployAccount \u25b8 **deployAccount**(`\u00abdestructured\u00bb`, `transactionsDetail?`): `Promise` Deploy the account on Starknet #### Parameters | Name | Type | Description | | :------------------- | :------------------------------------------------------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `\u00abdestructured\u00bb` | [`DeployAccountContractPayload`](../namespaces/types.md#deployaccountcontractpayload) | transaction payload to be deployed containing: - classHash: computed class hash of compiled contract - optional constructor calldata - optional address salt - optional contractAddress | | `transactionsDetail` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | Invocation Details containing: - constant nonce = 0 - optional version - optional maxFee | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Implementation of [AccountInterface](AccountInterface.md).[deployAccount](AccountInterface.md#deployaccount) #### Defined in [src/account/default.ts:429]( --- ### signMessage \u25b8 **signMessage**(`typedData`): `Promise` Sign an JSON object for off-chain usage with the starknet private key and return the signature This adds a message prefix so it cant be interchanged with transactions **`Throws`** if the JSON object is not a valid JSON #### Parameters | Name | Type | | :---------- | :---------------------------------------------- | | `typedData` | [`TypedData`](../interfaces/types.TypedData.md) | #### Returns `Promise` the signature of the JSON object #### Implementation of [AccountInterface](AccountInterface.md).[signMessage](AccountInterface.md#signmessage) #### Defined in [src/account/default.ts:483]( --- ### hashMessage \u25b8 **hashMessage**(`typedData`): `Promise` Hash a JSON object with pederson hash and return the hash This adds a message prefix so it cant be interchanged with transactions **`Throws`** if the JSON object is not a valid JSON #### Parameters | Name | Type | | :---------- | :---------------------------------------------- | | `typedData` | [`TypedData`](../interfaces/types.TypedData.md) | #### Returns `Promise` the hash of the JSON object #### Implementation of [AccountInterface](AccountInterface.md).[hashMessage](AccountInterface.md#hashmessage) #### Defined in [src/account/default.ts:487]( --- ### verifyMessageHash \u25b8 **verifyMessageHash**(`hash`, `signature`): `Promise` Verify a signature of a given hash **`Warning`** This method is not recommended, use verifyMessage instead **`Throws`** if the signature is not a valid signature #### Parameters | Name | Type | Description | | :---------- | :---------------------------------------------------- | :-------------------- | | `hash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | hash to be verified | | `signature` | [`Signature`](../namespaces/types.md#signature) | signature of the hash | #### Returns `Promise` true if the signature is valid, false otherwise #### Implementation of [AccountInterface](AccountInterface.md).[verifyMessageHash](AccountInterface.md#verifymessagehash) #### Defined in [src/account/default.ts:491]( --- ### verifyMessage \u25b8 **verifyMessage**(`typedData`, `signature`): `Promise` Verify a signature of a JSON object **`Throws`** if the JSON object is not a valid JSON or the signature is not a valid signature #### Parameters | Name | Type | Description | | :---------- | :---------------------------------------------- | :--------------------------- | | `typedData` | [`TypedData`](../interfaces/types.TypedData.md) | JSON object to be verified | | `signature` | [`Signature`](../namespaces/types.md#signature) | signature of the JSON object | #### Returns `Promise` true if the signature is valid, false otherwise #### Implementation of [AccountInterface](AccountInterface.md).[verifyMessage](AccountInterface.md#verifymessage) #### Defined in [src/account/default.ts:507]( --- ### getSuggestedMaxFee \u25b8 **getSuggestedMaxFee**(`\u00abdestructured\u00bb`, `details`): `Promise` Gets Suggested Max Fee based on the transaction type #### Parameters | Name | Type | | :--------------- | :---------------------------------------------------------------- | | `\u00abdestructured\u00bb` | [`EstimateFeeAction`](../namespaces/types.md#estimatefeeaction) | | `details` | [`EstimateFeeDetails`](../interfaces/types.EstimateFeeDetails.md) | #### Returns `Promise` suggestedMaxFee #### Implementation of [AccountInterface](AccountInterface.md).[getSuggestedMaxFee](AccountInterface.md#getsuggestedmaxfee) #### Defined in [src/account/default.ts:512]( --- ### buildDeclarePayload \u25b8 **buildDeclarePayload**(`payload`, `\u00abdestructured\u00bb`): `Promise` will be renamed to buildDeclareContractTransaction #### Parameters | Name | Type | | :--------------- | :---------------------------------------------------------------------------- | | `payload` | [`DeclareContractPayload`](../namespaces/types.md#declarecontractpayload) | | `\u00abdestructured\u00bb` | [`InvocationsSignerDetails`](../interfaces/types.InvocationsSignerDetails.md) | #### Returns `Promise` #### Defined in [src/account/default.ts:546]( --- ### buildAccountDeployPayload \u25b8 **buildAccountDeployPayload**(`\u00abdestructured\u00bb`, `\u00abdestructured\u00bb`): `Promise` #### Parameters | Name | Type | | :--------------- | :------------------------------------------------------------------------------------ | | `\u00abdestructured\u00bb` | [`DeployAccountContractPayload`](../namespaces/types.md#deployaccountcontractpayload) | | `\u00abdestructured\u00bb` | [`InvocationsSignerDetails`](../interfaces/types.InvocationsSignerDetails.md) | #### Returns `Promise` #### Defined in [src/account/default.ts:570]( --- ### buildUDCContractPayload \u25b8 **buildUDCContractPayload**(`payload`): [`Call`](../namespaces/types.md#call)[] #### Parameters | Name | Type | | :-------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `payload` | [`UniversalDeployerContractPayload`](../namespaces/types.md#universaldeployercontractpayload) \\| [`UniversalDeployerContractPayload`](../namespaces/types.md#universaldeployercontractpayload)[] | #### Returns [`Call`](../namespaces/types.md#call)[] #### Defined in [src/account/default.ts:603]( --- ### simulateTransaction \u25b8 **simulateTransaction**(`invocations`, `\u00abdestructured\u00bb?`): `Promise` Simulates an array of transaction and returns an array of transaction trace and estimated fee. #### Parameters | Name | Type | Description | | :--------------- | :-------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------- | | `invocations` | [`Invocations`](../namespaces/types.md#invocations) | Invocations containing: - type - transaction type: DECLARE, (multi)DEPLOY, DEPLOY_ACCOUNT, (multi)INVOKE_FUNCTION | | `\u00abdestructured\u00bb` | [`SimulateTransactionDetails`](../namespaces/types.md#simulatetransactiondetails) | SimulateTransactionDetails | #### Returns `Promise` response from simulate_transaction #### Implementation of [AccountInterface](AccountInterface.md).[simulateTransaction](AccountInterface.md#simulatetransaction) #### Defined in [src/account/default.ts:630]( --- ### accountInvocationsFactory \u25b8 **accountInvocationsFactory**(`invocations`, `\u00abdestructured\u00bb`): `Promise` #### Parameters | Name | Type | | :--------------- | :-------------------------------------------------------------------------------------------- | | `invocations` | [`Invocations`](../namespaces/types.md#invocations) | | `\u00abdestructured\u00bb` | [`AccountInvocationsFactoryDetails`](../namespaces/types.md#accountinvocationsfactorydetails) | #### Returns `Promise` #### Defined in [src/account/default.ts:647]( --- ### getStarkName \u25b8 **getStarkName**(`address?`, `StarknetIdContract?`): `Promise` #### Parameters | Name | Type | | :-------------------- | :---------------------------------------------------- | | `address` | [`BigNumberish`](../namespaces/types.md#bignumberish) | | `StarknetIdContract?` | `string` | #### Returns `Promise` #### Overrides [Provider](Provider.md).[getStarkName](Provider.md#getstarkname) #### Defined in [src/account/default.ts:715]( --- ### getChainId \u25b8 **getChainId**(): `Promise` Gets the Starknet chain Id #### Returns `Promise` the chain Id #### Implementation of [AccountInterface](AccountInterface.md).[getChainId](AccountInterface.md#getchainid) #### Inherited from [Provider](Provider.md).[getChainId](Provider.md#getchainid) #### Defined in [src/provider/default.ts:63]( --- ### getBlock \u25b8 **getBlock**(`blockIdentifier`): `Promise` Gets the block information #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------- | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the block object #### Implementation of [AccountInterface](AccountInterface.md).[getBlock](AccountInterface.md#getblock) #### Inherited from [Provider](Provider.md).[getBlock](Provider.md#getblock) #### Defined in [src/provider/default.ts:67]( --- ### getClassAt \u25b8 **getClassAt**(`contractAddress`, `blockIdentifier?`): `Promise` Gets the contract class of the deployed contract. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` Contract class of compiled contract #### Implementation of [AccountInterface](AccountInterface.md).[getClassAt](AccountInterface.md#getclassat) #### Inherited from [Provider](Provider.md).[getClassAt](Provider.md#getclassat) #### Defined in [src/provider/default.ts:71]( --- ### getClassHashAt \u25b8 **getClassHashAt**(`contractAddress`, `blockIdentifier?`): `Promise` Returns the class hash deployed under the given address. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` Class hash #### Implementation of [AccountInterface](AccountInterface.md).[getClassHashAt](AccountInterface.md#getclasshashat) #### Inherited from [Provider](Provider.md).[getClassHashAt](Provider.md#getclasshashat) #### Defined in [src/provider/default.ts:78]( --- ### getClassByHash \u25b8 **getClassByHash**(`classHash`): `Promise` Returns the contract class deployed under the given class hash. #### Parameters | Name | Type | Description | | :---------- | :------- | :---------- | | `classHash` | `string` | class hash | #### Returns `Promise` Contract class of compiled contract #### Implementation of [AccountInterface](AccountInterface.md).[getClassByHash](AccountInterface.md#getclassbyhash) #### Inherited from [Provider](Provider.md).[getClassByHash](Provider.md#getclassbyhash) #### Defined in [src/provider/default.ts:85]( --- ### getEstimateFee \u25b8 **getEstimateFee**(`invocationWithTxType`, `invocationDetails`, `blockIdentifier`): `Promise` Estimates the fee for a given INVOKE transaction **`Deprecated`** Please use getInvokeEstimateFee or getDeclareEstimateFee instead. Should not be used outside of Account class #### Parameters | Name | Type | Description | | :--------------------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `invocationWithTxType` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `invocationDetails` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | #### Returns `Promise` the estimated fee #### Implementation of [AccountInterface](AccountInterface.md).[getEstimateFee](AccountInterface.md#getestimatefee) #### Inherited from [Provider](Provider.md).[getEstimateFee](Provider.md#getestimatefee) #### Defined in [src/provider/default.ts:89]( --- ### getInvokeEstimateFee \u25b8 **getInvokeEstimateFee**(`invocationWithTxType`, `invocationDetails`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given INVOKE transaction #### Parameters | Name | Type | Description | | :--------------------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `invocationWithTxType` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `invocationDetails` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | | `skipValidate?` | `boolean` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Implementation of [AccountInterface](AccountInterface.md).[getInvokeEstimateFee](AccountInterface.md#getinvokeestimatefee) #### Inherited from [Provider](Provider.md).[getInvokeEstimateFee](Provider.md#getinvokeestimatefee) #### Defined in [src/provider/default.ts:97]( --- ### getEstimateFeeBulk \u25b8 **getEstimateFeeBulk**(`invocations`, `options`): `Promise` Estimates the fee for a list of INVOKE transaction #### Parameters | Name | Type | Description | | :------------ | :------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------- | | `invocations` | [`AccountInvocations`](../namespaces/types.md#accountinvocations) | AccountInvocations - Complete invocations array with account details | | `options` | [`getEstimateFeeBulkOptions`](../namespaces/types.md#getestimatefeebulkoptions) | getEstimateFeeBulkOptions - (optional) blockIdentifier - BlockIdentifier - (optional) skipValidate - boolean (default false) | #### Returns `Promise` the estimated fee #### Implementation of [AccountInterface](AccountInterface.md).[getEstimateFeeBulk](AccountInterface.md#getestimatefeebulk) #### Inherited from [Provider](Provider.md).[getEstimateFeeBulk](Provider.md#getestimatefeebulk) #### Defined in [src/provider/default.ts:111]( --- ### getNonceForAddress \u25b8 **getNonceForAddress**(`contractAddress`, `blockIdentifier?`): `Promise` Gets the nonce of a contract with respect to a specific block #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | - | #### Returns `Promise` the hex nonce #### Implementation of [AccountInterface](AccountInterface.md).[getNonceForAddress](AccountInterface.md#getnonceforaddress) #### Inherited from [Provider](Provider.md).[getNonceForAddress](Provider.md#getnonceforaddress) #### Defined in [src/provider/default.ts:118]( --- ### getStorageAt \u25b8 **getStorageAt**(`contractAddress`, `key`, `blockIdentifier?`): `Promise` Gets the contract's storage variable at a specific key. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------------------------------------------------- | | `contractAddress` | `string` | | | `key` | [`BigNumberish`](../namespaces/types.md#bignumberish) | from getStorageVarAddress('') (WIP) | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the value of the storage variable #### Implementation of [AccountInterface](AccountInterface.md).[getStorageAt](AccountInterface.md#getstorageat) #### Inherited from [Provider](Provider.md).[getStorageAt](Provider.md#getstorageat) #### Defined in [src/provider/default.ts:125]( --- ### getTransaction \u25b8 **getTransaction**(`txHash`): `Promise` Gets the transaction information from a tx id. #### Parameters | Name | Type | | :------- | :---------------------------------------------------- | | `txHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | #### Returns `Promise` the transaction object { transaction_id, status, transaction, block_number?, block_number?, transaction_index?, transaction_failure_reason? } #### Implementation of [AccountInterface](AccountInterface.md).[getTransaction](AccountInterface.md#gettransaction) #### Inherited from [Provider](Provider.md).[getTransaction](Provider.md#gettransaction) #### Defined in [src/provider/default.ts:133]( --- ### getTransactionReceipt \u25b8 **getTransactionReceipt**(`txHash`): `Promise` Gets the transaction receipt from a tx hash. #### Parameters | Name | Type | | :------- | :---------------------------------------------------- | | `txHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | #### Returns `Promise` the transaction receipt object #### Implementation of [AccountInterface](AccountInterface.md).[getTransactionReceipt](AccountInterface.md#gettransactionreceipt) #### Inherited from [Provider](Provider.md).[getTransactionReceipt](Provider.md#gettransactionreceipt) #### Defined in [src/provider/default.ts:137]( --- ### callContract \u25b8 **callContract**(`request`, `blockIdentifier?`): `Promise` Calls a function on the Starknet contract. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :----------------------- | | `request` | [`Call`](../namespaces/types.md#call) | transaction to be called | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the result of the function on the smart contract. #### Implementation of [AccountInterface](AccountInterface.md).[callContract](AccountInterface.md#callcontract) #### Inherited from [Provider](Provider.md).[callContract](Provider.md#callcontract) #### Defined in [src/provider/default.ts:141]( --- ### invokeFunction \u25b8 **invokeFunction**(`functionInvocation`, `details`): `Promise` Invokes a function on starknet **`Deprecated`** This method wont be supported as soon as fees are mandatory. Should not be used outside of Account class #### Parameters | Name | Type | Description | | :------------------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `functionInvocation` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version - maxFee - optional maxFee | #### Returns `Promise` response from addTransaction #### Implementation of [AccountInterface](AccountInterface.md).[invokeFunction](AccountInterface.md#invokefunction) #### Inherited from [Provider](Provider.md).[invokeFunction](Provider.md#invokefunction) #### Defined in [src/provider/default.ts:148]( --- ### deployAccountContract \u25b8 **deployAccountContract**(`payload`, `details`): `Promise` Deploys a given compiled Account contract (json) to starknet #### Parameters | Name | Type | Description | | :-------- | :-------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------ | | `payload` | [`DeployAccountContractTransaction`](../namespaces/types.md#deployaccountcontracttransaction) | payload to be deployed containing: - compiled contract code - constructor calldata - address salt | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | - | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Implementation of [AccountInterface](AccountInterface.md).[deployAccountContract](AccountInterface.md#deployaccountcontract) #### Inherited from [Provider](Provider.md).[deployAccountContract](Provider.md#deployaccountcontract) #### Defined in [src/provider/default.ts:155]( --- ### declareContract \u25b8 **declareContract**(`transaction`, `details`): `Promise` Declares a given compiled contract (json) to starknet #### Parameters | Name | Type | Description | | :------------ | :---------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------- | | `transaction` | [`DeclareContractTransaction`](../namespaces/types.md#declarecontracttransaction) | transaction payload to be deployed containing: - compiled contract code - sender address - signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | Invocation Details containing: - nonce - optional version - optional maxFee | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Implementation of [AccountInterface](AccountInterface.md).[declareContract](AccountInterface.md#declarecontract) #### Inherited from [Provider](Provider.md).[declareContract](Provider.md#declarecontract) #### Defined in [src/provider/default.ts:162]( --- ### getDeclareEstimateFee \u25b8 **getDeclareEstimateFee**(`transaction`, `details`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given DECLARE transaction #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ | | `transaction` | [`DeclareContractTransaction`](../namespaces/types.md#declarecontracttransaction) | transaction payload to be declared containing: - compiled contract code - sender address - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - version - optional version - optional maxFee | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | | `skipValidate?` | `boolean` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Implementation of [AccountInterface](AccountInterface.md).[getDeclareEstimateFee](AccountInterface.md#getdeclareestimatefee) #### Inherited from [Provider](Provider.md).[getDeclareEstimateFee](Provider.md#getdeclareestimatefee) #### Defined in [src/provider/default.ts:169]( --- ### getDeployAccountEstimateFee \u25b8 **getDeployAccountEstimateFee**(`transaction`, `details`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given DEPLOY_ACCOUNT transaction #### Parameters | Name | Type | Description | | :----------------- | :-------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------ | | `transaction` | [`DeployAccountContractTransaction`](../namespaces/types.md#deployaccountcontracttransaction) | transaction payload to be deployed containing: - classHash - constructorCalldata - addressSalt - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - version - optional version - optional maxFee | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | | `skipValidate?` | `boolean` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Implementation of [AccountInterface](AccountInterface.md).[getDeployAccountEstimateFee](AccountInterface.md#getdeployaccountestimatefee) #### Inherited from [Provider](Provider.md).[getDeployAccountEstimateFee](Provider.md#getdeployaccountestimatefee) #### Defined in [src/provider/default.ts:178]( --- ### getCode \u25b8 **getCode**(`contractAddress`, `blockIdentifier?`): `Promise` **`Deprecated`** The method should not be used #### Parameters | Name | Type | | :----------------- | :---------------------------------------------------------- | | `contractAddress` | `string` | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | #### Returns `Promise` #### Implementation of [AccountInterface](AccountInterface.md).[getCode](AccountInterface.md#getcode) #### Inherited from [Provider](Provider.md).[getCode](Provider.md#getcode) #### Defined in [src/provider/default.ts:192]( --- ### waitForTransaction \u25b8 **waitForTransaction**(`txHash`, `options?`): `Promise` Wait for the transaction to be accepted #### Parameters | Name | Type | Description | | :--------- | :------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------- | | `txHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | transaction hash | | `options?` | [`waitForTransactionOptions`](../namespaces/types.md#waitfortransactionoptions) | waitForTransactionOptions - (optional) retryInterval: number \\| undefined; - (optional) successStates: TransactionStatus[] \\| undefined; | #### Returns `Promise` GetTransactionReceiptResponse #### Implementation of [AccountInterface](AccountInterface.md).[waitForTransaction](AccountInterface.md#waitfortransaction) #### Inherited from [Provider](Provider.md).[waitForTransaction](Provider.md#waitfortransaction) #### Defined in [src/provider/default.ts:199]( --- ### getSimulateTransaction \u25b8 **getSimulateTransaction**(`invocations`, `options?`): `Promise` Simulates the transaction and returns the transaction trace and estimated fee. #### Parameters | Name | Type | Description | | :------------ | :-------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | `invocations` | [`AccountInvocations`](../namespaces/types.md#accountinvocations) | AccountInvocations - Complete invocations array with account details | | `options?` | [`getSimulateTransactionOptions`](../namespaces/types.md#getsimulatetransactionoptions) | getSimulateTransactionOptions - (optional) blockIdentifier - block identifier - (optional) skipValidate - skip cairo **validate** method - (optional) skipExecute - skip cairo **execute** method | #### Returns `Promise` an array of transaction trace and estimated fee #### Implementation of [AccountInterface](AccountInterface.md).[getSimulateTransaction](AccountInterface.md#getsimulatetransaction) #### Inherited from [Provider](Provider.md).[getSimulateTransaction](Provider.md#getsimulatetransaction) #### Defined in [src/provider/default.ts:206]( --- ### getStateUpdate \u25b8 **getStateUpdate**(`blockIdentifier?`): `Promise` Gets the state changes in a specific block #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` StateUpdateResponse #### Implementation of [AccountInterface](AccountInterface.md).[getStateUpdate](AccountInterface.md#getstateupdate) #### Inherited from [Provider](Provider.md).[getStateUpdate](Provider.md#getstateupdate) #### Defined in [src/provider/default.ts:213]( --- ### getAddressFromStarkName \u25b8 **getAddressFromStarkName**(`name`, `StarknetIdContract?`): `Promise` #### Parameters | Name | Type | | :-------------------- | :------- | | `name` | `string` | | `StarknetIdContract?` | `string` | #### Returns `Promise` #### Inherited from [Provider](Provider.md).[getAddressFromStarkName](Provider.md#getaddressfromstarkname) #### Defined in [src/provider/default.ts:221]("}
{"title": "AccountInterface.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'AccountInterface' title: 'Class: AccountInterface' sidebar_label: 'AccountInterface' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - [`ProviderInterface`](ProviderInterface.md) \u21b3 **`AccountInterface`** ## Implemented by - [`Account`](Account.md) ## Constructors ### constructor \u2022 **new AccountInterface**() #### Inherited from [ProviderInterface](ProviderInterface.md).[constructor](ProviderInterface.md#constructor) ## Properties ### address \u2022 `Abstract` **address**: `string` #### Defined in [src/account/interface.ts:34]( --- ### signer \u2022 `Abstract` **signer**: [`SignerInterface`](SignerInterface.md) #### Defined in [src/account/interface.ts:36]( --- ### cairoVersion \u2022 `Abstract` **cairoVersion**: [`CairoVersion`](../namespaces/types.md#cairoversion) #### Defined in [src/account/interface.ts:38]( ## Methods ### estimateInvokeFee \u25b8 `Abstract` **estimateInvokeFee**(`calls`, `estimateFeeDetails?`): `Promise` Estimate Fee for executing an INVOKE transaction on starknet #### Parameters | Name | Type | Description | | :-------------------- | :---------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `calls` | [`AllowArray`](../namespaces/types.md#allowarray) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata | | `estimateFeeDetails?` | [`EstimateFeeDetails`](../interfaces/types.EstimateFeeDetails.md) | - | #### Returns `Promise` response from estimate_fee #### Defined in [src/account/interface.ts:50]( --- ### estimateDeclareFee \u25b8 `Abstract` **estimateDeclareFee**(`contractPayload`, `estimateFeeDetails?`): `Promise` Estimate Fee for executing a DECLARE transaction on starknet #### Parameters | Name | Type | Description | | :-------------------- | :------------------------------------------------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `contractPayload` | [`DeclareContractPayload`](../namespaces/types.md#declarecontractpayload) | the payload object containing: - contract - the compiled contract to be declared - classHash - the class hash of the compiled contract. This can be obtained by using starknet-cli. | | `estimateFeeDetails?` | [`EstimateFeeDetails`](../interfaces/types.EstimateFeeDetails.md) | - | #### Returns `Promise` response from estimate_fee #### Defined in [src/account/interface.ts:64]( --- ### estimateAccountDeployFee \u25b8 `Abstract` **estimateAccountDeployFee**(`contractPayload`, `estimateFeeDetails?`): `Promise` Estimate Fee for executing a DEPLOY_ACCOUNT transaction on starknet #### Parameters | Name | Type | Description | | :-------------------- | :------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------- | | `contractPayload` | [`DeployAccountContractPayload`](../namespaces/types.md#deployaccountcontractpayload) | contract - the compiled contract to be deployed - classHash - the class hash of the compiled contract. This can be obtained by using starknet-cli. | | `estimateFeeDetails?` | [`EstimateFeeDetails`](../interfaces/types.EstimateFeeDetails.md) | optional blockIdentifier - constant nonce = 0 | #### Returns `Promise` response from estimate_fee #### Defined in [src/account/interface.ts:80]( --- ### estimateDeployFee \u25b8 `Abstract` **estimateDeployFee**(`deployContractPayload`, `transactionsDetail?`): `Promise` Estimate Fee for executing a UDC DEPLOY transaction on starknet This is different from the normal DEPLOY transaction as it goes through the Universal Deployer Contract (UDC) #### Parameters | Name | Type | Description | | :---------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `deployContractPayload` | [`UniversalDeployerContractPayload`](../namespaces/types.md#universaldeployercontractpayload) \\| [`UniversalDeployerContractPayload`](../namespaces/types.md#universaldeployercontractpayload)[] | containing - classHash: computed class hash of compiled contract - salt: address salt - unique: bool if true ensure unique salt - calldata: constructor calldata | | `transactionsDetail?` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | Invocation Details containing: - optional nonce - optional version - optional maxFee | #### Returns `Promise` #### Defined in [src/account/interface.ts:100]( --- ### estimateFeeBulk \u25b8 `Abstract` **estimateFeeBulk**(`invocations`, `details?`): `Promise` Estimate Fee for executing a list of transactions on starknet Contract must be deployed for fee estimation to be possible #### Parameters | Name | Type | | :------------ | :---------------------------------------------------------------- | | `invocations` | [`Invocations`](../namespaces/types.md#invocations) | | `details?` | [`EstimateFeeDetails`](../interfaces/types.EstimateFeeDetails.md) | #### Returns `Promise` response from estimate_fee #### Defined in [src/account/interface.ts:115]( --- ### execute \u25b8 `Abstract` **execute**(`transactions`, `abis?`, `transactionsDetail?`): `Promise` Invoke execute function in account contract #### Parameters | Name | Type | Description | | :-------------------- | :---------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `transactions` | [`AllowArray`](../namespaces/types.md#allowarray) | the invocation object or an array of them, containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `abis?` | [`Abi`](../namespaces/types.md#abi)[] | - | | `transactionsDetail?` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | - | #### Returns `Promise` response from addTransaction #### Defined in [src/account/interface.ts:132]( --- ### declare \u25b8 `Abstract` **declare**(`contractPayload`, `transactionsDetail?`): `Promise` Declares a given compiled contract (json) to starknet #### Parameters | Name | Type | Description | | :-------------------- | :------------------------------------------------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `contractPayload` | [`DeclareContractPayload`](../namespaces/types.md#declarecontractpayload) | transaction payload to be deployed containing: - contract: compiled contract code - (optional) classHash: computed class hash of compiled contract. Pre-compute it for faster execution. - (required for Cairo1 without compiledClassHash) casm: CompiledContract \\| string; - (optional for Cairo1 with casm) compiledClassHash: compiled class hash from casm. Pre-compute it for faster execution. | | `transactionsDetail?` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | Invocation Details containing: - optional nonce - optional version - optional maxFee | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Defined in [src/account/interface.ts:152]( --- ### deploy \u25b8 `Abstract` **deploy**(`payload`, `details?`): `Promise` Deploys a declared contract to starknet - using Universal Deployer Contract (UDC) support multicall #### Parameters | Name | Type | Description | | :--------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `payload` | [`UniversalDeployerContractPayload`](../namespaces/types.md#universaldeployercontractpayload) \\| [`UniversalDeployerContractPayload`](../namespaces/types.md#universaldeployercontractpayload)[] | classHash: computed class hash of compiled contract - [constructorCalldata] contract constructor calldata - [salt=pseudorandom] deploy address salt - [unique=true] ensure unique salt | | `details?` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | [nonce=getNonce] - [version=transactionVersion] - [maxFee=getSuggestedMaxFee] | #### Returns `Promise` - contract_address[] - transaction_hash #### Defined in [src/account/interface.ts:174]( --- ### deployContract \u25b8 `Abstract` **deployContract**(`payload`, `details?`): `Promise` Simplify deploy simulating old DeployContract with same response + UDC specific response Internal wait for L2 transaction, support multicall #### Parameters | Name | Type | Description | | :--------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `payload` | [`UniversalDeployerContractPayload`](../namespaces/types.md#universaldeployercontractpayload) \\| [`UniversalDeployerContractPayload`](../namespaces/types.md#universaldeployercontractpayload)[] | classHash: computed class hash of compiled contract - [constructorCalldata] contract constructor calldata - [salt=pseudorandom] deploy address salt - [unique=true] ensure unique salt | | `details?` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | [nonce=getNonce] - [version=transactionVersion] - [maxFee=getSuggestedMaxFee] | #### Returns `Promise` - contract_address - transaction_hash - address - deployer - unique - classHash - calldata_len - calldata - salt #### Defined in [src/account/interface.ts:203]( --- ### declareAndDeploy \u25b8 `Abstract` **declareAndDeploy**(`payload`, `details?`): `Promise` Declares and Deploy a given compiled contract (json) to starknet using UDC Internal wait for L2 transaction, do not support multicall Method will pass even if contract is already declared (internal using DeclareIfNot) #### Parameters | Name | Type | Description | | :--------- | :------------------------------------------------------------------------------------------ | :---------------------------------------------------------------------------- | | `payload` | [`DeclareAndDeployContractPayload`](../namespaces/types.md#declareanddeploycontractpayload) | - | | `details?` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | [nonce=getNonce] - [version=transactionVersion] - [maxFee=getSuggestedMaxFee] | #### Returns `Promise` - declare - transaction_hash - deploy - contract_address - transaction_hash - address - deployer - unique - classHash - calldata_len - calldata - salt #### Defined in [src/account/interface.ts:237]( --- ### deployAccount \u25b8 `Abstract` **deployAccount**(`contractPayload`, `transactionsDetail?`): `Promise` Deploy the account on Starknet #### Parameters | Name | Type | Description | | :-------------------- | :------------------------------------------------------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `contractPayload` | [`DeployAccountContractPayload`](../namespaces/types.md#deployaccountcontractpayload) | transaction payload to be deployed containing: - classHash: computed class hash of compiled contract - optional constructor calldata - optional address salt - optional contractAddress | | `transactionsDetail?` | [`InvocationsDetails`](../namespaces/types.md#invocationsdetails) | Invocation Details containing: - constant nonce = 0 - optional version - optional maxFee | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Defined in [src/account/interface.ts:256]( --- ### signMessage \u25b8 `Abstract` **signMessage**(`typedData`): `Promise` Sign an JSON object for off-chain usage with the starknet private key and return the signature This adds a message prefix so it cant be interchanged with transactions **`Throws`** if the JSON object is not a valid JSON #### Parameters | Name | Type | | :---------- | :---------------------------------------------- | | `typedData` | [`TypedData`](../interfaces/types.TypedData.md) | #### Returns `Promise` the signature of the JSON object #### Defined in [src/account/interface.ts:269]( --- ### hashMessage \u25b8 `Abstract` **hashMessage**(`typedData`): `Promise` Hash a JSON object with pederson hash and return the hash This adds a message prefix so it cant be interchanged with transactions **`Throws`** if the JSON object is not a valid JSON #### Parameters | Name | Type | | :---------- | :---------------------------------------------- | | `typedData` | [`TypedData`](../interfaces/types.TypedData.md) | #### Returns `Promise` the hash of the JSON object #### Defined in [src/account/interface.ts:279]( --- ### verifyMessage \u25b8 `Abstract` **verifyMessage**(`typedData`, `signature`): `Promise` Verify a signature of a JSON object **`Throws`** if the JSON object is not a valid JSON or the signature is not a valid signature #### Parameters | Name | Type | Description | | :---------- | :---------------------------------------------- | :--------------------------- | | `typedData` | [`TypedData`](../interfaces/types.TypedData.md) | JSON object to be verified | | `signature` | [`Signature`](../namespaces/types.md#signature) | signature of the JSON object | #### Returns `Promise` true if the signature is valid, false otherwise #### Defined in [src/account/interface.ts:289]( --- ### verifyMessageHash \u25b8 `Abstract` **verifyMessageHash**(`hash`, `signature`): `Promise` Verify a signature of a given hash **`Warning`** This method is not recommended, use verifyMessage instead **`Throws`** if the signature is not a valid signature #### Parameters | Name | Type | Description | | :---------- | :---------------------------------------------------- | :-------------------- | | `hash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | hash to be verified | | `signature` | [`Signature`](../namespaces/types.md#signature) | signature of the hash | #### Returns `Promise` true if the signature is valid, false otherwise #### Defined in [src/account/interface.ts:300]( --- ### getNonce \u25b8 `Abstract` **getNonce**(`blockIdentifier?`): `Promise` Gets the nonce of the account with respect to a specific block #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :---------------------------------------------- | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | optional blockIdentifier. Defaults to 'pending' | #### Returns `Promise` nonce of the account #### Defined in [src/account/interface.ts:308]( --- ### getSuggestedMaxFee \u25b8 `Abstract` **getSuggestedMaxFee**(`estimateFeeAction`, `details`): `Promise` Gets Suggested Max Fee based on the transaction type #### Parameters | Name | Type | | :------------------ | :---------------------------------------------------------------- | | `estimateFeeAction` | [`EstimateFeeAction`](../namespaces/types.md#estimatefeeaction) | | `details` | [`EstimateFeeDetails`](../interfaces/types.EstimateFeeDetails.md) | #### Returns `Promise` suggestedMaxFee #### Defined in [src/account/interface.ts:317]( --- ### simulateTransaction \u25b8 `Abstract` **simulateTransaction**(`invocations`, `details?`): `Promise` Simulates an array of transaction and returns an array of transaction trace and estimated fee. #### Parameters | Name | Type | Description | | :------------ | :-------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------- | | `invocations` | [`Invocations`](../namespaces/types.md#invocations) | Invocations containing: - type - transaction type: DECLARE, (multi)DEPLOY, DEPLOY_ACCOUNT, (multi)INVOKE_FUNCTION | | `details?` | [`SimulateTransactionDetails`](../namespaces/types.md#simulatetransactiondetails) | SimulateTransactionDetails | #### Returns `Promise` response from simulate_transaction #### Defined in [src/account/interface.ts:331]( --- ### getChainId \u25b8 `Abstract` **getChainId**(): `Promise` Gets the Starknet chain Id #### Returns `Promise` the chain Id #### Inherited from [ProviderInterface](ProviderInterface.md).[getChainId](ProviderInterface.md#getchainid) #### Defined in [src/provider/interface.ts:38]( --- ### callContract \u25b8 `Abstract` **callContract**(`call`, `blockIdentifier?`): `Promise` Calls a function on the Starknet contract. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :----------------------- | | `call` | [`Call`](../namespaces/types.md#call) | transaction to be called | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the result of the function on the smart contract. #### Inherited from [ProviderInterface](ProviderInterface.md).[callContract](ProviderInterface.md#callcontract) #### Defined in [src/provider/interface.ts:47]( --- ### getBlock \u25b8 `Abstract` **getBlock**(`blockIdentifier`): `Promise` Gets the block information #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------- | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the block object #### Inherited from [ProviderInterface](ProviderInterface.md).[getBlock](ProviderInterface.md#getblock) #### Defined in [src/provider/interface.ts:58]( --- ### getCode \u25b8 `Abstract` **getCode**(`contractAddress`, `blockIdentifier?`): `Promise` **`Deprecated`** The method should not be used #### Parameters | Name | Type | | :----------------- | :---------------------------------------------------------- | | `contractAddress` | `string` | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | #### Returns `Promise` #### Inherited from [ProviderInterface](ProviderInterface.md).[getCode](ProviderInterface.md#getcode) #### Defined in [src/provider/interface.ts:63]( --- ### getClassAt \u25b8 `Abstract` **getClassAt**(`contractAddress`, `blockIdentifier?`): `Promise` Gets the contract class of the deployed contract. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` Contract class of compiled contract #### Inherited from [ProviderInterface](ProviderInterface.md).[getClassAt](ProviderInterface.md#getclassat) #### Defined in [src/provider/interface.ts:75]( --- ### getClassHashAt \u25b8 `Abstract` **getClassHashAt**(`contractAddress`, `blockIdentifier?`): `Promise` Returns the class hash deployed under the given address. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` Class hash #### Inherited from [ProviderInterface](ProviderInterface.md).[getClassHashAt](ProviderInterface.md#getclasshashat) #### Defined in [src/provider/interface.ts:87]( --- ### getClassByHash \u25b8 `Abstract` **getClassByHash**(`classHash`): `Promise` Returns the contract class deployed under the given class hash. #### Parameters | Name | Type | Description | | :---------- | :------- | :---------- | | `classHash` | `string` | class hash | #### Returns `Promise` Contract class of compiled contract #### Inherited from [ProviderInterface](ProviderInterface.md).[getClassByHash](ProviderInterface.md#getclassbyhash) #### Defined in [src/provider/interface.ts:98]( --- ### getNonceForAddress \u25b8 `Abstract` **getNonceForAddress**(`contractAddress`, `blockIdentifier?`): `Promise` Gets the nonce of a contract with respect to a specific block #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | - | #### Returns `Promise` the hex nonce #### Inherited from [ProviderInterface](ProviderInterface.md).[getNonceForAddress](ProviderInterface.md#getnonceforaddress) #### Defined in [src/provider/interface.ts:106]( --- ### getStorageAt \u25b8 `Abstract` **getStorageAt**(`contractAddress`, `key`, `blockIdentifier?`): `Promise` Gets the contract's storage variable at a specific key. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------------------------------------------------- | | `contractAddress` | `string` | | | `key` | [`BigNumberish`](../namespaces/types.md#bignumberish) | from getStorageVarAddress('') (WIP) | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the value of the storage variable #### Inherited from [ProviderInterface](ProviderInterface.md).[getStorageAt](ProviderInterface.md#getstorageat) #### Defined in [src/provider/interface.ts:119]( --- ### getTransaction \u25b8 `Abstract` **getTransaction**(`transactionHash`): `Promise` Gets the transaction information from a tx id. #### Parameters | Name | Type | | :---------------- | :---------------------------------------------------- | | `transactionHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | #### Returns `Promise` the transaction object { transaction_id, status, transaction, block_number?, block_number?, transaction_index?, transaction_failure_reason? } #### Inherited from [ProviderInterface](ProviderInterface.md).[getTransaction](ProviderInterface.md#gettransaction) #### Defined in [src/provider/interface.ts:131]( --- ### getTransactionReceipt \u25b8 `Abstract` **getTransactionReceipt**(`transactionHash`): `Promise` Gets the transaction receipt from a tx hash. #### Parameters | Name | Type | | :---------------- | :---------------------------------------------------- | | `transactionHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | #### Returns `Promise` the transaction receipt object #### Inherited from [ProviderInterface](ProviderInterface.md).[getTransactionReceipt](ProviderInterface.md#gettransactionreceipt) #### Defined in [src/provider/interface.ts:139]( --- ### deployAccountContract \u25b8 `Abstract` **deployAccountContract**(`payload`, `details`): `Promise` Deploys a given compiled Account contract (json) to starknet #### Parameters | Name | Type | Description | | :-------- | :------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------ | | `payload` | [`DeployAccountContractPayload`](../namespaces/types.md#deployaccountcontractpayload) | payload to be deployed containing: - compiled contract code - constructor calldata - address salt | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | - | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Inherited from [ProviderInterface](ProviderInterface.md).[deployAccountContract](ProviderInterface.md#deployaccountcontract) #### Defined in [src/provider/interface.ts:152]( --- ### invokeFunction \u25b8 `Abstract` **invokeFunction**(`invocation`, `details`): `Promise` Invokes a function on starknet **`Deprecated`** This method wont be supported as soon as fees are mandatory. Should not be used outside of Account class #### Parameters | Name | Type | Description | | :----------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `invocation` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version - maxFee - optional maxFee | #### Returns `Promise` response from addTransaction #### Inherited from [ProviderInterface](ProviderInterface.md).[invokeFunction](ProviderInterface.md#invokefunction) #### Defined in [src/provider/interface.ts:172]( --- ### declareContract \u25b8 `Abstract` **declareContract**(`transaction`, `details`): `Promise` Declares a given compiled contract (json) to starknet #### Parameters | Name | Type | Description | | :------------ | :---------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------- | | `transaction` | [`DeclareContractTransaction`](../namespaces/types.md#declarecontracttransaction) | transaction payload to be deployed containing: - compiled contract code - sender address - signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | Invocation Details containing: - nonce - optional version - optional maxFee | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Inherited from [ProviderInterface](ProviderInterface.md).[declareContract](ProviderInterface.md#declarecontract) #### Defined in [src/provider/interface.ts:189]( --- ### getEstimateFee \u25b8 `Abstract` **getEstimateFee**(`invocation`, `details`, `blockIdentifier`, `skipValidate?`): `Promise` Estimates the fee for a given INVOKE transaction **`Deprecated`** Please use getInvokeEstimateFee or getDeclareEstimateFee instead. Should not be used outside of Account class #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `invocation` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | | `skipValidate?` | `boolean` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Inherited from [ProviderInterface](ProviderInterface.md).[getEstimateFee](ProviderInterface.md#getestimatefee) #### Defined in [src/provider/interface.ts:210]( --- ### getInvokeEstimateFee \u25b8 `Abstract` **getInvokeEstimateFee**(`invocation`, `details`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given INVOKE transaction #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `invocation` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | | `skipValidate?` | `boolean` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Inherited from [ProviderInterface](ProviderInterface.md).[getInvokeEstimateFee](ProviderInterface.md#getinvokeestimatefee) #### Defined in [src/provider/interface.ts:232]( --- ### getDeclareEstimateFee \u25b8 `Abstract` **getDeclareEstimateFee**(`transaction`, `details`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given DECLARE transaction #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ | | `transaction` | [`DeclareContractTransaction`](../namespaces/types.md#declarecontracttransaction) | transaction payload to be declared containing: - compiled contract code - sender address - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - version - optional version - optional maxFee | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | | `skipValidate?` | `boolean` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Inherited from [ProviderInterface](ProviderInterface.md).[getDeclareEstimateFee](ProviderInterface.md#getdeclareestimatefee) #### Defined in [src/provider/interface.ts:254]( --- ### getDeployAccountEstimateFee \u25b8 `Abstract` **getDeployAccountEstimateFee**(`transaction`, `details`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given DEPLOY_ACCOUNT transaction #### Parameters | Name | Type | Description | | :----------------- | :-------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------ | | `transaction` | [`DeployAccountContractTransaction`](../namespaces/types.md#deployaccountcontracttransaction) | transaction payload to be deployed containing: - classHash - constructorCalldata - addressSalt - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - version - optional version - optional maxFee | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | | `skipValidate?` | `boolean` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Inherited from [ProviderInterface](ProviderInterface.md).[getDeployAccountEstimateFee](ProviderInterface.md#getdeployaccountestimatefee) #### Defined in [src/provider/interface.ts:277]( --- ### getEstimateFeeBulk \u25b8 `Abstract` **getEstimateFeeBulk**(`invocations`, `options?`): `Promise` Estimates the fee for a list of INVOKE transaction #### Parameters | Name | Type | Description | | :------------ | :------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------- | | `invocations` | [`AccountInvocations`](../namespaces/types.md#accountinvocations) | AccountInvocations - Complete invocations array with account details | | `options?` | [`getEstimateFeeBulkOptions`](../namespaces/types.md#getestimatefeebulkoptions) | getEstimateFeeBulkOptions - (optional) blockIdentifier - BlockIdentifier - (optional) skipValidate - boolean (default false) | #### Returns `Promise` the estimated fee #### Inherited from [ProviderInterface](ProviderInterface.md).[getEstimateFeeBulk](ProviderInterface.md#getestimatefeebulk) #### Defined in [src/provider/interface.ts:293]( --- ### waitForTransaction \u25b8 `Abstract` **waitForTransaction**(`txHash`, `options?`): `Promise` Wait for the transaction to be accepted #### Parameters | Name | Type | Description | | :--------- | :------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------- | | `txHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | transaction hash | | `options?` | [`waitForTransactionOptions`](../namespaces/types.md#waitfortransactionoptions) | waitForTransactionOptions - (optional) retryInterval: number \\| undefined; - (optional) successStates: TransactionStatus[] \\| undefined; | #### Returns `Promise` GetTransactionReceiptResponse #### Inherited from [ProviderInterface](ProviderInterface.md).[waitForTransaction](ProviderInterface.md#waitfortransaction) #### Defined in [src/provider/interface.ts:306]( --- ### getSimulateTransaction \u25b8 `Abstract` **getSimulateTransaction**(`invocations`, `options?`): `Promise` Simulates the transaction and returns the transaction trace and estimated fee. #### Parameters | Name | Type | Description | | :------------ | :-------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | `invocations` | [`AccountInvocations`](../namespaces/types.md#accountinvocations) | AccountInvocations - Complete invocations array with account details | | `options?` | [`getSimulateTransactionOptions`](../namespaces/types.md#getsimulatetransactionoptions) | getSimulateTransactionOptions - (optional) blockIdentifier - block identifier - (optional) skipValidate - skip cairo **validate** method - (optional) skipExecute - skip cairo **execute** method | #### Returns `Promise` an array of transaction trace and estimated fee #### Inherited from [ProviderInterface](ProviderInterface.md).[getSimulateTransaction](ProviderInterface.md#getsimulatetransaction) #### Defined in [src/provider/interface.ts:321]( --- ### getStateUpdate \u25b8 `Abstract` **getStateUpdate**(`blockIdentifier?`): `Promise` Gets the state changes in a specific block #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` StateUpdateResponse #### Inherited from [ProviderInterface](ProviderInterface.md).[getStateUpdate](ProviderInterface.md#getstateupdate) #### Defined in [src/provider/interface.ts:332]("}
{"title": "CallData.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'CallData' title: 'Class: CallData' sidebar_label: 'CallData' sidebar_position: 0 custom_edit_url: null --- ## Constructors ### constructor \u2022 **new CallData**(`abi`) #### Parameters | Name | Type | | :---- | :---------------------------------- | | `abi` | [`Abi`](../namespaces/types.md#abi) | #### Defined in [src/utils/calldata/index.ts:37]( ## Properties ### abi \u2022 **abi**: [`Abi`](../namespaces/types.md#abi) #### Defined in [src/utils/calldata/index.ts:31]( --- ### parser \u2022 **parser**: `AbiParserInterface` #### Defined in [src/utils/calldata/index.ts:33]( --- ### structs \u2022 `Protected` `Readonly` **structs**: [`AbiStructs`](../namespaces/types.md#abistructs) #### Defined in [src/utils/calldata/index.ts:35]( ## Methods ### compile \u25b8 `Static` **compile**(`rawArgs`): [`Calldata`](../namespaces/types.md#calldata) Compile contract callData without abi #### Parameters | Name | Type | Description | | :-------- | :------------------------------------------ | :--------------------------------------------------------------------------- | | `rawArgs` | [`RawArgs`](../namespaces/types.md#rawargs) | RawArgs representing cairo method arguments or string array of compiled data | #### Returns [`Calldata`](../namespaces/types.md#calldata) Calldata #### Defined in [src/utils/calldata/index.ts:125]( --- ### getAbiStruct \u25b8 `Static` **getAbiStruct**(`abi`): [`AbiStructs`](../namespaces/types.md#abistructs) Helper to extract structs from abi #### Parameters | Name | Type | Description | | :---- | :---------------------------------- | :---------- | | `abi` | [`Abi`](../namespaces/types.md#abi) | Abi | #### Returns [`AbiStructs`](../namespaces/types.md#abistructs) AbiStructs - structs from abi #### Defined in [src/utils/calldata/index.ts:206]( --- ### toCalldata \u25b8 `Static` **toCalldata**(`rawCalldata?`): [`Calldata`](../namespaces/types.md#calldata) Helper: Compile HexCalldata | RawCalldata | RawArgs #### Parameters | Name | Type | Default value | Description | | :------------ | :------------------------------------------ | :------------ | :------------------------------------ | | `rawCalldata` | [`RawArgs`](../namespaces/types.md#rawargs) | `[]` | HexCalldata \\| RawCalldata \\| RawArgs | #### Returns [`Calldata`](../namespaces/types.md#calldata) Calldata #### Defined in [src/utils/calldata/index.ts:223]( --- ### toHex \u25b8 `Static` **toHex**(`raw?`): [`HexCalldata`](../namespaces/types.md#hexcalldata) Helper: Convert raw to HexCalldata #### Parameters | Name | Type | Default value | Description | | :---- | :------------------------------------------ | :------------ | :------------------------------------ | | `raw` | [`RawArgs`](../namespaces/types.md#rawargs) | `[]` | HexCalldata \\| RawCalldata \\| RawArgs | #### Returns [`HexCalldata`](../namespaces/types.md#hexcalldata) HexCalldata #### Defined in [src/utils/calldata/index.ts:232]( --- ### validate \u25b8 **validate**(`type`, `method`, `args?`): `void` Validate arguments passed to the method as corresponding to the ones in the abi #### Parameters | Name | Type | Default value | Description | | :------- | :-------------------------------------------------------- | :------------ | :------------------------------------------------------- | | `type` | [`ValidateType`](../enums/types.ValidateType.md) | `undefined` | ValidateType - type of the method | | `method` | `string` | `undefined` | string - name of the method | | `args` | [`ArgsOrCalldata`](../namespaces/types.md#argsorcalldata) | `[]` | ArgsOrCalldata - arguments that are passed to the method | #### Returns `void` #### Defined in [src/utils/calldata/index.ts:49]( --- ### compile \u25b8 **compile**(`method`, `argsCalldata`): [`Calldata`](../namespaces/types.md#calldata) Compile contract callData with abi Parse the calldata by using input fields from the abi for that method **`Example`** ```typescript const calldata = myCallData.compile(\"constructor\",[\"0x34a\",[1,3n]]); ``` ```typescript const calldata2 = myCallData.compile(\"constructor\",{list:[1,3n],balance:\"0x34\"}); // wrong order is valid ``` #### Parameters | Name | Type | Description | | :------------- | :------------------------------------------ | :------------------- | | `method` | `string` | string - method name | | `argsCalldata` | [`RawArgs`](../namespaces/types.md#rawargs) | - | #### Returns [`Calldata`](../namespaces/types.md#calldata) Calldata - parsed arguments in format that contract is expecting #### Defined in [src/utils/calldata/index.ts:98]( --- ### parse \u25b8 **parse**(`method`, `response`): [`Result`](../namespaces/types.md#result) Parse elements of the response array and structuring them into response object #### Parameters | Name | Type | Description | | :--------- | :--------- | :---------------------------------- | | `method` | `string` | string - method name | | `response` | `string`[] | string[] - response from the method | #### Returns [`Result`](../namespaces/types.md#result) Result - parsed response corresponding to the abi #### Defined in [src/utils/calldata/index.ts:172]( --- ### format \u25b8 **format**(`method`, `response`, `format`): [`Result`](../namespaces/types.md#result) Format cairo method response data to native js values based on provided format schema #### Parameters | Name | Type | Description | | :--------- | :--------- | :------------------------------- | | `method` | `string` | string - cairo method name | | `response` | `string`[] | string[] - cairo method response | | `format` | `object` | object - formatter object schema | #### Returns [`Result`](../namespaces/types.md#result) Result - parsed and formatted response object #### Defined in [src/utils/calldata/index.ts:196]("}
{"title": "Contract.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'Contract' title: 'Class: Contract' sidebar_label: 'Contract' sidebar_position: 0 custom_edit_url: null --- Not used at the moment ## Implements - [`ContractInterface`](ContractInterface.md) ## Indexable [key: `string`]: [`AsyncContractFunction`](../namespaces/types.md#asynccontractfunction) \\| `any` ## Constructors ### constructor \u2022 **new Contract**(`abi`, `address`, `providerOrAccount?`) Contract class to handle contract methods #### Parameters | Name | Type | Default value | Description | | :------------------ | :--------------------------------------------------------------------------------------- | :---------------- | :-------------------------------------------- | | `abi` | [`Abi`](../namespaces/types.md#abi) | `undefined` | Abi of the contract object | | `address` | `string` | `undefined` | (optional) - address to connect to | | `providerOrAccount` | [`ProviderInterface`](ProviderInterface.md) \\| [`AccountInterface`](AccountInterface.md) | `defaultProvider` | (optional) - Provider or Account to attach to | #### Defined in [src/contract/default.ts:146]( ## Properties ### abi \u2022 **abi**: [`Abi`](../namespaces/types.md#abi) #### Implementation of [ContractInterface](ContractInterface.md).[abi](ContractInterface.md#abi) #### Defined in [src/contract/default.ts:117]( --- ### address \u2022 **address**: `string` #### Implementation of [ContractInterface](ContractInterface.md).[address](ContractInterface.md#address) #### Defined in [src/contract/default.ts:119]( --- ### providerOrAccount \u2022 **providerOrAccount**: [`ProviderInterface`](ProviderInterface.md) \\| [`AccountInterface`](AccountInterface.md) #### Implementation of [ContractInterface](ContractInterface.md).[providerOrAccount](ContractInterface.md#provideroraccount) #### Defined in [src/contract/default.ts:121]( --- ### deployTransactionHash \u2022 `Optional` **deployTransactionHash**: `string` #### Implementation of [ContractInterface](ContractInterface.md).[deployTransactionHash](ContractInterface.md#deploytransactionhash) #### Defined in [src/contract/default.ts:123]( --- ### structs \u2022 `Protected` `Readonly` **structs**: `Object` #### Index signature [name: `string`]: [`StructAbi`](../namespaces/types.md#structabi) #### Defined in [src/contract/default.ts:125]( --- ### functions \u2022 `Readonly` **functions**: `Object` #### Index signature [name: `string`]: [`AsyncContractFunction`](../namespaces/types.md#asynccontractfunction) #### Implementation of [ContractInterface](ContractInterface.md).[functions](ContractInterface.md#functions) #### Defined in [src/contract/default.ts:127]( --- ### callStatic \u2022 `Readonly` **callStatic**: `Object` #### Index signature [name: `string`]: [`AsyncContractFunction`](../namespaces/types.md#asynccontractfunction) #### Implementation of [ContractInterface](ContractInterface.md).[callStatic](ContractInterface.md#callstatic) #### Defined in [src/contract/default.ts:129]( --- ### populateTransaction \u2022 `Readonly` **populateTransaction**: `Object` #### Index signature [name: `string`]: [`ContractFunction`](../namespaces/types.md#contractfunction) #### Implementation of [ContractInterface](ContractInterface.md).[populateTransaction](ContractInterface.md#populatetransaction) #### Defined in [src/contract/default.ts:131]( --- ### estimateFee \u2022 `Readonly` **estimateFee**: `Object` #### Index signature [name: `string`]: [`ContractFunction`](../namespaces/types.md#contractfunction) #### Implementation of [ContractInterface](ContractInterface.md).[estimateFee](ContractInterface.md#estimatefee) #### Defined in [src/contract/default.ts:133]( --- ### callData \u2022 `Private` **callData**: [`CallData`](CallData.md) #### Defined in [src/contract/default.ts:137]( ## Methods ### attach \u25b8 **attach**(`address`): `void` Saves the address of the contract deployed on network that will be used for interaction #### Parameters | Name | Type | Description | | :-------- | :------- | :---------------------- | | `address` | `string` | address of the contract | #### Returns `void` #### Implementation of [ContractInterface](ContractInterface.md).[attach](ContractInterface.md#attach) #### Defined in [src/contract/default.ts:201]( --- ### connect \u25b8 **connect**(`providerOrAccount`): `void` Attaches to new Provider or Account #### Parameters | Name | Type | Description | | :------------------ | :--------------------------------------------------------------------------------------- | :----------------------------------- | | `providerOrAccount` | [`ProviderInterface`](ProviderInterface.md) \\| [`AccountInterface`](AccountInterface.md) | new Provider or Account to attach to | #### Returns `void` #### Implementation of [ContractInterface](ContractInterface.md).[connect](ContractInterface.md#connect) #### Defined in [src/contract/default.ts:205]( --- ### deployed \u25b8 **deployed**(): `Promise` Resolves when contract is deployed on the network or when no deployment transaction is found **`Throws`** When deployment fails #### Returns `Promise` Promise that resolves when contract is deployed on the network or when no deployment transaction is found #### Implementation of [ContractInterface](ContractInterface.md).[deployed](ContractInterface.md#deployed) #### Defined in [src/contract/default.ts:209]( --- ### call \u25b8 **call**(`method`, `args?`, `\u00abdestructured\u00bb?`): `Promise` Calls a method on a contract #### Parameters | Name | Type | Default value | Description | | :--------------- | :-------------------------------------------------------- | :------------ | :---------------------------------- | | `method` | `string` | `undefined` | name of the method | | `args` | [`ArgsOrCalldata`](../namespaces/types.md#argsorcalldata) | `[]` | Array of the arguments for the call | | `\u00abdestructured\u00bb` | [`CallOptions`](../namespaces/types.md#calloptions) | `{}` | optional blockIdentifier | #### Returns `Promise` Result of the call as an array with key value pars #### Implementation of [ContractInterface](ContractInterface.md).[call](ContractInterface.md#call) #### Defined in [src/contract/default.ts:217]( --- ### invoke \u25b8 **invoke**(`method`, `args?`, `\u00abdestructured\u00bb?`): `Promise` Invokes a method on a contract #### Parameters | Name | Type | Default value | Description | | :--------------- | :-------------------------------------------------------- | :------------ | :------------------------------------------------ | | `method` | `string` | `undefined` | name of the method | | `args` | [`ArgsOrCalldata`](../namespaces/types.md#argsorcalldata) | `[]` | Array of the arguments for the invoke or Calldata | | `\u00abdestructured\u00bb` | [`InvokeOptions`](../namespaces/types.md#invokeoptions) | `{}` | | #### Returns `Promise` Add Transaction Response #### Implementation of [ContractInterface](ContractInterface.md).[invoke](ContractInterface.md#invoke) #### Defined in [src/contract/default.ts:259]( --- ### estimate \u25b8 **estimate**(`method`, `args?`): `Promise` Estimates a method on a contract #### Parameters | Name | Type | Default value | Description | | :------- | :-------------------------------------------------------- | :------------ | :---------------------------------------------- | | `method` | `string` | `undefined` | name of the method | | `args` | [`ArgsOrCalldata`](../namespaces/types.md#argsorcalldata) | `[]` | Array of the arguments for the call or Calldata | #### Returns `Promise` #### Implementation of [ContractInterface](ContractInterface.md).[estimate](ContractInterface.md#estimate) #### Defined in [src/contract/default.ts:303]( --- ### populate \u25b8 **populate**(`method`, `args?`): [`Call`](../namespaces/types.md#call) Calls a method on a contract #### Parameters | Name | Type | Default value | Description | | :------- | :------------------------------------------ | :------------ | :---------------------------------------------- | | `method` | `string` | `undefined` | name of the method | | `args` | [`RawArgs`](../namespaces/types.md#rawargs) | `[]` | Array of the arguments for the call or Calldata | #### Returns [`Call`](../namespaces/types.md#call) Invocation object #### Implementation of [ContractInterface](ContractInterface.md).[populate](ContractInterface.md#populate) #### Defined in [src/contract/default.ts:317]( --- ### isCairo1 \u25b8 **isCairo1**(): `boolean` tells if the contract comes from a Cairo 1 contract **`Example`** ```typescript const isCairo1: boolean = myContract.isCairo1(); ``` #### Returns `boolean` TRUE if the contract comes from a Cairo1 contract #### Implementation of [ContractInterface](ContractInterface.md).[isCairo1](ContractInterface.md#iscairo1) #### Defined in [src/contract/default.ts:327]("}
{"title": "ContractFactory.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'ContractFactory' title: 'Class: ContractFactory' sidebar_label: 'ContractFactory' sidebar_position: 0 custom_edit_url: null --- ## Constructors ### constructor \u2022 **new ContractFactory**(`compiledContract`, `classHash`, `account`, `abi?`) #### Parameters | Name | Type | Default value | | :----------------- | :------------------------------------------------------------ | :--------------------- | | `compiledContract` | [`CompiledContract`](../namespaces/types.md#compiledcontract) | `undefined` | | `classHash` | `string` | `undefined` | | `account` | [`AccountInterface`](AccountInterface.md) | `undefined` | | `abi` | [`Abi`](../namespaces/types.md#abi) | `compiledContract.abi` | #### Defined in [src/contract/contractFactory.ts:18]( ## Properties ### abi \u2022 **abi**: [`Abi`](../namespaces/types.md#abi) #### Defined in [src/contract/contractFactory.ts:8]( --- ### compiledContract \u2022 **compiledContract**: [`CompiledContract`](../namespaces/types.md#compiledcontract) #### Defined in [src/contract/contractFactory.ts:10]( --- ### classHash \u2022 **classHash**: `string` #### Defined in [src/contract/contractFactory.ts:12]( --- ### account \u2022 **account**: [`AccountInterface`](AccountInterface.md) #### Defined in [src/contract/contractFactory.ts:14]( --- ### CallData \u2022 `Private` **CallData**: [`CallData`](CallData.md) #### Defined in [src/contract/contractFactory.ts:16]( ## Methods ### deploy \u25b8 **deploy**(`...args`): `Promise` Deploys contract and returns new instance of the Contract #### Parameters | Name | Type | Description | | :-------- | :------------------------------------------------------------------------------ | :------------------------------------------------ | | `...args` | [`ArgsOrCalldataWithOptions`](../namespaces/types.md#argsorcalldatawithoptions) | Array of the constructor arguments for deployment | #### Returns `Promise` deployed Contract #### Defined in [src/contract/contractFactory.ts:38]( --- ### connect \u25b8 **connect**(`account`): [`ContractFactory`](ContractFactory.md) Attaches to new Account #### Parameters | Name | Type | Description | | :-------- | :---------------------------------------- | :----------------------------------- | | `account` | [`AccountInterface`](AccountInterface.md) | new Provider or Account to attach to | #### Returns [`ContractFactory`](ContractFactory.md) ContractFactory #### Defined in [src/contract/contractFactory.ts:76]( --- ### attach \u25b8 **attach**(`address`): [`Contract`](Contract.md) Attaches current abi and account to the new address #### Parameters | Name | Type | Description | | :-------- | :------- | :--------------- | | `address` | `string` | Contract address | #### Returns [`Contract`](Contract.md) Contract #### Defined in [src/contract/contractFactory.ts:87]("}
{"title": "ContractInterface.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'ContractInterface' title: 'Class: ContractInterface' sidebar_label: 'ContractInterface' sidebar_position: 0 custom_edit_url: null --- ## Implemented by - [`Contract`](Contract.md) ## Indexable [key: `string`]: [`AsyncContractFunction`](../namespaces/types.md#asynccontractfunction) \\| `any` ## Constructors ### constructor \u2022 **new ContractInterface**() ## Properties ### abi \u2022 `Abstract` **abi**: [`Abi`](../namespaces/types.md#abi) #### Defined in [src/contract/interface.ts:18]( --- ### address \u2022 `Abstract` **address**: `string` #### Defined in [src/contract/interface.ts:20]( --- ### providerOrAccount \u2022 `Abstract` **providerOrAccount**: [`ProviderInterface`](ProviderInterface.md) \\| [`AccountInterface`](AccountInterface.md) #### Defined in [src/contract/interface.ts:22]( --- ### deployTransactionHash \u2022 `Optional` `Abstract` **deployTransactionHash**: `string` #### Defined in [src/contract/interface.ts:24]( --- ### functions \u2022 `Readonly` **functions**: `Object` #### Index signature [name: `string`]: [`AsyncContractFunction`](../namespaces/types.md#asynccontractfunction) #### Defined in [src/contract/interface.ts:26]( --- ### callStatic \u2022 `Readonly` **callStatic**: `Object` #### Index signature [name: `string`]: [`AsyncContractFunction`](../namespaces/types.md#asynccontractfunction) #### Defined in [src/contract/interface.ts:28]( --- ### populateTransaction \u2022 `Readonly` **populateTransaction**: `Object` #### Index signature [name: `string`]: [`ContractFunction`](../namespaces/types.md#contractfunction) #### Defined in [src/contract/interface.ts:30]( --- ### estimateFee \u2022 `Readonly` **estimateFee**: `Object` #### Index signature [name: `string`]: [`ContractFunction`](../namespaces/types.md#contractfunction) #### Defined in [src/contract/interface.ts:32]( ## Methods ### attach \u25b8 `Abstract` **attach**(`address`): `void` Saves the address of the contract deployed on network that will be used for interaction #### Parameters | Name | Type | Description | | :-------- | :------- | :---------------------- | | `address` | `string` | address of the contract | #### Returns `void` #### Defined in [src/contract/interface.ts:41]( --- ### connect \u25b8 `Abstract` **connect**(`providerOrAccount`): `void` Attaches to new Provider or Account #### Parameters | Name | Type | Description | | :------------------ | :--------------------------------------------------------------------------------------- | :----------------------------------- | | `providerOrAccount` | [`ProviderInterface`](ProviderInterface.md) \\| [`AccountInterface`](AccountInterface.md) | new Provider or Account to attach to | #### Returns `void` #### Defined in [src/contract/interface.ts:48]( --- ### deployed \u25b8 `Abstract` **deployed**(): `Promise` Resolves when contract is deployed on the network or when no deployment transaction is found **`Throws`** When deployment fails #### Returns `Promise` Promise that resolves when contract is deployed on the network or when no deployment transaction is found #### Defined in [src/contract/interface.ts:56]( --- ### call \u25b8 `Abstract` **call**(`method`, `args?`, `options?`): `Promise` Calls a method on a contract #### Parameters | Name | Type | Description | | :--------- | :-------------------------------------------------------- | :---------------------------------- | | `method` | `string` | name of the method | | `args?` | [`ArgsOrCalldata`](../namespaces/types.md#argsorcalldata) | Array of the arguments for the call | | `options?` | [`CallOptions`](../namespaces/types.md#calloptions) | optional blockIdentifier | #### Returns `Promise` Result of the call as an array with key value pars #### Defined in [src/contract/interface.ts:66]( --- ### invoke \u25b8 `Abstract` **invoke**(`method`, `args?`, `options?`): `Promise` Invokes a method on a contract #### Parameters | Name | Type | Description | | :--------- | :-------------------------------------------------------- | :------------------------------------------------ | | `method` | `string` | name of the method | | `args?` | [`ArgsOrCalldata`](../namespaces/types.md#argsorcalldata) | Array of the arguments for the invoke or Calldata | | `options?` | [`InvokeOptions`](../namespaces/types.md#invokeoptions) | | #### Returns `Promise` Add Transaction Response #### Defined in [src/contract/interface.ts:80]( --- ### estimate \u25b8 `Abstract` **estimate**(`method`, `args?`, `options?`): `Promise` Estimates a method on a contract #### Parameters | Name | Type | Description | | :------------------------- | :---------------------------------------------------------- | :---------------------------------------------- | | `method` | `string` | name of the method | | `args?` | [`ArgsOrCalldata`](../namespaces/types.md#argsorcalldata) | Array of the arguments for the call or Calldata | | `options?` | `Object` | optional blockIdentifier | | `options.blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | - | #### Returns `Promise` #### Defined in [src/contract/interface.ts:93]( --- ### populate \u25b8 `Abstract` **populate**(`method`, `args?`): [`Invocation`](../namespaces/types.md#invocation) Calls a method on a contract #### Parameters | Name | Type | Description | | :------- | :-------------------------------------------------------- | :---------------------------------------------- | | `method` | `string` | name of the method | | `args?` | [`ArgsOrCalldata`](../namespaces/types.md#argsorcalldata) | Array of the arguments for the call or Calldata | #### Returns [`Invocation`](../namespaces/types.md#invocation) Invocation object #### Defined in [src/contract/interface.ts:108]( --- ### isCairo1 \u25b8 `Abstract` **isCairo1**(): `boolean` tells if the contract comes from a Cairo 1 contract **`Example`** ```typescript const isCairo1: boolean = myContract.isCairo1(); ``` #### Returns `boolean` TRUE if the contract comes from a Cairo1 contract #### Defined in [src/contract/interface.ts:119]("}
{"title": "CustomError.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'CustomError' title: 'Class: CustomError' sidebar_label: 'CustomError' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - `Error` \u21b3 **`CustomError`** \u21b3\u21b3 [`LibraryError`](LibraryError.md) ## Constructors ### constructor \u2022 **new CustomError**(`message?`) #### Parameters | Name | Type | | :--------- | :------- | | `message?` | `string` | #### Overrides Error.constructor #### Defined in [src/provider/errors.ts:18]( ## Properties ### prepareStackTrace `Static` `Optional` **prepareStackTrace**: (`err`: `Error`, `stackTraces`: `CallSite`[]) => `any` #### Type declaration \u25b8 (`err`, `stackTraces`): `any` Optional override for formatting stack traces **`See`** ##### Parameters | Name | Type | | :------------ | :----------- | | `err` | `Error` | | `stackTraces` | `CallSite`[] | ##### Returns `any` #### Inherited from Error.prepareStackTrace #### Defined in node_modules/@types/node/globals.d.ts:11 --- ### stackTraceLimit `Static` **stackTraceLimit**: `number` #### Inherited from Error.stackTraceLimit #### Defined in node_modules/@types/node/globals.d.ts:13 --- ### name \u2022 **name**: `string` #### Overrides Error.name #### Defined in [src/provider/errors.ts:16]( --- ### message \u2022 **message**: `string` #### Inherited from Error.message #### Defined in --- ### stack \u2022 `Optional` **stack**: `string` #### Inherited from Error.stack #### Defined in ## Methods ### captureStackTrace \u25b8 `Static` **captureStackTrace**(`targetObject`, `constructorOpt?`): `void` Create .stack property on a target object #### Parameters | Name | Type | | :---------------- | :--------- | | `targetObject` | `object` | | `constructorOpt?` | `Function` | #### Returns `void` #### Inherited from Error.captureStackTrace #### Defined in node_modules/@types/node/globals.d.ts:4"}
{"title": "GatewayError.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'GatewayError' title: 'Class: GatewayError' sidebar_label: 'GatewayError' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - [`LibraryError`](LibraryError.md) \u21b3 **`GatewayError`** ## Constructors ### constructor \u2022 **new GatewayError**(`message`, `errorCode`) #### Parameters | Name | Type | | :---------- | :------- | | `message` | `string` | | `errorCode` | `string` | #### Overrides [LibraryError](LibraryError.md).[constructor](LibraryError.md#constructor) #### Defined in [src/provider/errors.ts:40]( ## Properties ### prepareStackTrace `Static` `Optional` **prepareStackTrace**: (`err`: `Error`, `stackTraces`: `CallSite`[]) => `any` #### Type declaration \u25b8 (`err`, `stackTraces`): `any` Optional override for formatting stack traces **`See`** ##### Parameters | Name | Type | | :------------ | :----------- | | `err` | `Error` | | `stackTraces` | `CallSite`[] | ##### Returns `any` #### Inherited from [LibraryError](LibraryError.md).[prepareStackTrace](LibraryError.md#preparestacktrace) #### Defined in node_modules/@types/node/globals.d.ts:11 --- ### stackTraceLimit `Static` **stackTraceLimit**: `number` #### Inherited from [LibraryError](LibraryError.md).[stackTraceLimit](LibraryError.md#stacktracelimit) #### Defined in node_modules/@types/node/globals.d.ts:13 --- ### errorCode \u2022 **errorCode**: `string` #### Defined in [src/provider/errors.ts:40]( --- ### name \u2022 **name**: `string` #### Inherited from [LibraryError](LibraryError.md).[name](LibraryError.md#name) #### Defined in [src/provider/errors.ts:16]( --- ### message \u2022 **message**: `string` #### Inherited from [LibraryError](LibraryError.md).[message](LibraryError.md#message) #### Defined in --- ### stack \u2022 `Optional` **stack**: `string` #### Inherited from [LibraryError](LibraryError.md).[stack](LibraryError.md#stack) #### Defined in ## Methods ### captureStackTrace \u25b8 `Static` **captureStackTrace**(`targetObject`, `constructorOpt?`): `void` Create .stack property on a target object #### Parameters | Name | Type | | :---------------- | :--------- | | `targetObject` | `object` | | `constructorOpt?` | `Function` | #### Returns `void` #### Inherited from [LibraryError](LibraryError.md).[captureStackTrace](LibraryError.md#capturestacktrace) #### Defined in node_modules/@types/node/globals.d.ts:4"}
{"title": "HttpError.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'HttpError' title: 'Class: HttpError' sidebar_label: 'HttpError' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - [`LibraryError`](LibraryError.md) \u21b3 **`HttpError`** ## Constructors ### constructor \u2022 **new HttpError**(`message`, `errorCode`) #### Parameters | Name | Type | | :---------- | :------- | | `message` | `string` | | `errorCode` | `number` | #### Overrides [LibraryError](LibraryError.md).[constructor](LibraryError.md#constructor) #### Defined in [src/provider/errors.ts:46]( ## Properties ### prepareStackTrace `Static` `Optional` **prepareStackTrace**: (`err`: `Error`, `stackTraces`: `CallSite`[]) => `any` #### Type declaration \u25b8 (`err`, `stackTraces`): `any` Optional override for formatting stack traces **`See`** ##### Parameters | Name | Type | | :------------ | :----------- | | `err` | `Error` | | `stackTraces` | `CallSite`[] | ##### Returns `any` #### Inherited from [LibraryError](LibraryError.md).[prepareStackTrace](LibraryError.md#preparestacktrace) #### Defined in node_modules/@types/node/globals.d.ts:11 --- ### stackTraceLimit `Static` **stackTraceLimit**: `number` #### Inherited from [LibraryError](LibraryError.md).[stackTraceLimit](LibraryError.md#stacktracelimit) #### Defined in node_modules/@types/node/globals.d.ts:13 --- ### errorCode \u2022 **errorCode**: `number` #### Defined in [src/provider/errors.ts:46]( --- ### name \u2022 **name**: `string` #### Inherited from [LibraryError](LibraryError.md).[name](LibraryError.md#name) #### Defined in [src/provider/errors.ts:16]( --- ### message \u2022 **message**: `string` #### Inherited from [LibraryError](LibraryError.md).[message](LibraryError.md#message) #### Defined in --- ### stack \u2022 `Optional` **stack**: `string` #### Inherited from [LibraryError](LibraryError.md).[stack](LibraryError.md#stack) #### Defined in ## Methods ### captureStackTrace \u25b8 `Static` **captureStackTrace**(`targetObject`, `constructorOpt?`): `void` Create .stack property on a target object #### Parameters | Name | Type | | :---------------- | :--------- | | `targetObject` | `object` | | `constructorOpt?` | `Function` | #### Returns `void` #### Inherited from [LibraryError](LibraryError.md).[captureStackTrace](LibraryError.md#capturestacktrace) #### Defined in node_modules/@types/node/globals.d.ts:4"}
{"title": "LibraryError.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'LibraryError' title: 'Class: LibraryError' sidebar_label: 'LibraryError' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - [`CustomError`](CustomError.md) \u21b3 **`LibraryError`** \u21b3\u21b3 [`GatewayError`](GatewayError.md) \u21b3\u21b3 [`HttpError`](HttpError.md) ## Constructors ### constructor \u2022 **new LibraryError**(`message?`) #### Parameters | Name | Type | | :--------- | :------- | | `message?` | `string` | #### Inherited from [CustomError](CustomError.md).[constructor](CustomError.md#constructor) #### Defined in [src/provider/errors.ts:18]( ## Properties ### prepareStackTrace `Static` `Optional` **prepareStackTrace**: (`err`: `Error`, `stackTraces`: `CallSite`[]) => `any` #### Type declaration \u25b8 (`err`, `stackTraces`): `any` Optional override for formatting stack traces **`See`** ##### Parameters | Name | Type | | :------------ | :----------- | | `err` | `Error` | | `stackTraces` | `CallSite`[] | ##### Returns `any` #### Inherited from [CustomError](CustomError.md).[prepareStackTrace](CustomError.md#preparestacktrace) #### Defined in node_modules/@types/node/globals.d.ts:11 --- ### stackTraceLimit `Static` **stackTraceLimit**: `number` #### Inherited from [CustomError](CustomError.md).[stackTraceLimit](CustomError.md#stacktracelimit) #### Defined in node_modules/@types/node/globals.d.ts:13 --- ### name \u2022 **name**: `string` #### Inherited from [CustomError](CustomError.md).[name](CustomError.md#name) #### Defined in [src/provider/errors.ts:16]( --- ### message \u2022 **message**: `string` #### Inherited from [CustomError](CustomError.md).[message](CustomError.md#message) #### Defined in --- ### stack \u2022 `Optional` **stack**: `string` #### Inherited from [CustomError](CustomError.md).[stack](CustomError.md#stack) #### Defined in ## Methods ### captureStackTrace \u25b8 `Static` **captureStackTrace**(`targetObject`, `constructorOpt?`): `void` Create .stack property on a target object #### Parameters | Name | Type | | :---------------- | :--------- | | `targetObject` | `object` | | `constructorOpt?` | `Function` | #### Returns `void` #### Inherited from [CustomError](CustomError.md).[captureStackTrace](CustomError.md#capturestacktrace) #### Defined in node_modules/@types/node/globals.d.ts:4"}
{"title": "Provider.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'Provider' title: 'Class: Provider' sidebar_label: 'Provider' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - **`Provider`** \u21b3 [`Account`](Account.md) ## Implements - [`ProviderInterface`](ProviderInterface.md) ## Constructors ### constructor \u2022 **new Provider**(`providerOrOptions?`) #### Parameters | Name | Type | | :------------------- | :--------------------------------------------------------------------------------------------------------- | | `providerOrOptions?` | [`ProviderOptions`](../interfaces/types.ProviderOptions.md) \\| [`ProviderInterface`](ProviderInterface.md) | #### Defined in [src/provider/default.ts:41]( ## Properties ### provider \u2022 `Private` **provider**: [`ProviderInterface`](ProviderInterface.md) #### Defined in [src/provider/default.ts:39]( ## Methods ### getChainId \u25b8 **getChainId**(): `Promise` Gets the Starknet chain Id #### Returns `Promise` the chain Id #### Implementation of [ProviderInterface](ProviderInterface.md).[getChainId](ProviderInterface.md#getchainid) #### Defined in [src/provider/default.ts:63]( --- ### getBlock \u25b8 **getBlock**(`blockIdentifier`): `Promise` Gets the block information #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------- | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the block object #### Implementation of [ProviderInterface](ProviderInterface.md).[getBlock](ProviderInterface.md#getblock) #### Defined in [src/provider/default.ts:67]( --- ### getClassAt \u25b8 **getClassAt**(`contractAddress`, `blockIdentifier?`): `Promise` Gets the contract class of the deployed contract. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` Contract class of compiled contract #### Implementation of [ProviderInterface](ProviderInterface.md).[getClassAt](ProviderInterface.md#getclassat) #### Defined in [src/provider/default.ts:71]( --- ### getClassHashAt \u25b8 **getClassHashAt**(`contractAddress`, `blockIdentifier?`): `Promise` Returns the class hash deployed under the given address. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` Class hash #### Implementation of [ProviderInterface](ProviderInterface.md).[getClassHashAt](ProviderInterface.md#getclasshashat) #### Defined in [src/provider/default.ts:78]( --- ### getClassByHash \u25b8 **getClassByHash**(`classHash`): `Promise` Returns the contract class deployed under the given class hash. #### Parameters | Name | Type | Description | | :---------- | :------- | :---------- | | `classHash` | `string` | class hash | #### Returns `Promise` Contract class of compiled contract #### Implementation of [ProviderInterface](ProviderInterface.md).[getClassByHash](ProviderInterface.md#getclassbyhash) #### Defined in [src/provider/default.ts:85]( --- ### getEstimateFee \u25b8 **getEstimateFee**(`invocationWithTxType`, `invocationDetails`, `blockIdentifier`): `Promise` Estimates the fee for a given INVOKE transaction **`Deprecated`** Please use getInvokeEstimateFee or getDeclareEstimateFee instead. Should not be used outside of Account class #### Parameters | Name | Type | Description | | :--------------------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `invocationWithTxType` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `invocationDetails` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getEstimateFee](ProviderInterface.md#getestimatefee) #### Defined in [src/provider/default.ts:89]( --- ### getInvokeEstimateFee \u25b8 **getInvokeEstimateFee**(`invocationWithTxType`, `invocationDetails`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given INVOKE transaction #### Parameters | Name | Type | Description | | :--------------------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `invocationWithTxType` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `invocationDetails` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | | `skipValidate?` | `boolean` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getInvokeEstimateFee](ProviderInterface.md#getinvokeestimatefee) #### Defined in [src/provider/default.ts:97]( --- ### getEstimateFeeBulk \u25b8 **getEstimateFeeBulk**(`invocations`, `options`): `Promise` Estimates the fee for a list of INVOKE transaction #### Parameters | Name | Type | Description | | :------------ | :------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------- | | `invocations` | [`AccountInvocations`](../namespaces/types.md#accountinvocations) | AccountInvocations - Complete invocations array with account details | | `options` | [`getEstimateFeeBulkOptions`](../namespaces/types.md#getestimatefeebulkoptions) | getEstimateFeeBulkOptions - (optional) blockIdentifier - BlockIdentifier - (optional) skipValidate - boolean (default false) | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getEstimateFeeBulk](ProviderInterface.md#getestimatefeebulk) #### Defined in [src/provider/default.ts:111]( --- ### getNonceForAddress \u25b8 **getNonceForAddress**(`contractAddress`, `blockIdentifier?`): `Promise` Gets the nonce of a contract with respect to a specific block #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | - | #### Returns `Promise` the hex nonce #### Implementation of [ProviderInterface](ProviderInterface.md).[getNonceForAddress](ProviderInterface.md#getnonceforaddress) #### Defined in [src/provider/default.ts:118]( --- ### getStorageAt \u25b8 **getStorageAt**(`contractAddress`, `key`, `blockIdentifier?`): `Promise` Gets the contract's storage variable at a specific key. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------------------------------------------------- | | `contractAddress` | `string` | | | `key` | [`BigNumberish`](../namespaces/types.md#bignumberish) | from getStorageVarAddress('') (WIP) | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the value of the storage variable #### Implementation of [ProviderInterface](ProviderInterface.md).[getStorageAt](ProviderInterface.md#getstorageat) #### Defined in [src/provider/default.ts:125]( --- ### getTransaction \u25b8 **getTransaction**(`txHash`): `Promise` Gets the transaction information from a tx id. #### Parameters | Name | Type | | :------- | :---------------------------------------------------- | | `txHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | #### Returns `Promise` the transaction object { transaction_id, status, transaction, block_number?, block_number?, transaction_index?, transaction_failure_reason? } #### Implementation of [ProviderInterface](ProviderInterface.md).[getTransaction](ProviderInterface.md#gettransaction) #### Defined in [src/provider/default.ts:133]( --- ### getTransactionReceipt \u25b8 **getTransactionReceipt**(`txHash`): `Promise` Gets the transaction receipt from a tx hash. #### Parameters | Name | Type | | :------- | :---------------------------------------------------- | | `txHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | #### Returns `Promise` the transaction receipt object #### Implementation of [ProviderInterface](ProviderInterface.md).[getTransactionReceipt](ProviderInterface.md#gettransactionreceipt) #### Defined in [src/provider/default.ts:137]( --- ### callContract \u25b8 **callContract**(`request`, `blockIdentifier?`): `Promise` Calls a function on the Starknet contract. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :----------------------- | | `request` | [`Call`](../namespaces/types.md#call) | transaction to be called | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the result of the function on the smart contract. #### Implementation of [ProviderInterface](ProviderInterface.md).[callContract](ProviderInterface.md#callcontract) #### Defined in [src/provider/default.ts:141]( --- ### invokeFunction \u25b8 **invokeFunction**(`functionInvocation`, `details`): `Promise` Invokes a function on starknet **`Deprecated`** This method wont be supported as soon as fees are mandatory. Should not be used outside of Account class #### Parameters | Name | Type | Description | | :------------------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `functionInvocation` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version - maxFee - optional maxFee | #### Returns `Promise` response from addTransaction #### Implementation of [ProviderInterface](ProviderInterface.md).[invokeFunction](ProviderInterface.md#invokefunction) #### Defined in [src/provider/default.ts:148]( --- ### deployAccountContract \u25b8 **deployAccountContract**(`payload`, `details`): `Promise` Deploys a given compiled Account contract (json) to starknet #### Parameters | Name | Type | Description | | :-------- | :-------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------ | | `payload` | [`DeployAccountContractTransaction`](../namespaces/types.md#deployaccountcontracttransaction) | payload to be deployed containing: - compiled contract code - constructor calldata - address salt | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | - | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Implementation of [ProviderInterface](ProviderInterface.md).[deployAccountContract](ProviderInterface.md#deployaccountcontract) #### Defined in [src/provider/default.ts:155]( --- ### declareContract \u25b8 **declareContract**(`transaction`, `details`): `Promise` Declares a given compiled contract (json) to starknet #### Parameters | Name | Type | Description | | :------------ | :---------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------- | | `transaction` | [`DeclareContractTransaction`](../namespaces/types.md#declarecontracttransaction) | transaction payload to be deployed containing: - compiled contract code - sender address - signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | Invocation Details containing: - nonce - optional version - optional maxFee | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Implementation of [ProviderInterface](ProviderInterface.md).[declareContract](ProviderInterface.md#declarecontract) #### Defined in [src/provider/default.ts:162]( --- ### getDeclareEstimateFee \u25b8 **getDeclareEstimateFee**(`transaction`, `details`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given DECLARE transaction #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ | | `transaction` | [`DeclareContractTransaction`](../namespaces/types.md#declarecontracttransaction) | transaction payload to be declared containing: - compiled contract code - sender address - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - version - optional version - optional maxFee | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | | `skipValidate?` | `boolean` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getDeclareEstimateFee](ProviderInterface.md#getdeclareestimatefee) #### Defined in [src/provider/default.ts:169]( --- ### getDeployAccountEstimateFee \u25b8 **getDeployAccountEstimateFee**(`transaction`, `details`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given DEPLOY_ACCOUNT transaction #### Parameters | Name | Type | Description | | :----------------- | :-------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------ | | `transaction` | [`DeployAccountContractTransaction`](../namespaces/types.md#deployaccountcontracttransaction) | transaction payload to be deployed containing: - classHash - constructorCalldata - addressSalt - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - version - optional version - optional maxFee | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | | `skipValidate?` | `boolean` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getDeployAccountEstimateFee](ProviderInterface.md#getdeployaccountestimatefee) #### Defined in [src/provider/default.ts:178]( --- ### getCode \u25b8 **getCode**(`contractAddress`, `blockIdentifier?`): `Promise` **`Deprecated`** The method should not be used #### Parameters | Name | Type | | :----------------- | :---------------------------------------------------------- | | `contractAddress` | `string` | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | #### Returns `Promise` #### Implementation of [ProviderInterface](ProviderInterface.md).[getCode](ProviderInterface.md#getcode) #### Defined in [src/provider/default.ts:192]( --- ### waitForTransaction \u25b8 **waitForTransaction**(`txHash`, `options?`): `Promise` Wait for the transaction to be accepted #### Parameters | Name | Type | Description | | :--------- | :------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------- | | `txHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | transaction hash | | `options?` | [`waitForTransactionOptions`](../namespaces/types.md#waitfortransactionoptions) | waitForTransactionOptions - (optional) retryInterval: number \\| undefined; - (optional) successStates: TransactionStatus[] \\| undefined; | #### Returns `Promise` GetTransactionReceiptResponse #### Implementation of [ProviderInterface](ProviderInterface.md).[waitForTransaction](ProviderInterface.md#waitfortransaction) #### Defined in [src/provider/default.ts:199]( --- ### getSimulateTransaction \u25b8 **getSimulateTransaction**(`invocations`, `options?`): `Promise` Simulates the transaction and returns the transaction trace and estimated fee. #### Parameters | Name | Type | Description | | :------------ | :-------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | `invocations` | [`AccountInvocations`](../namespaces/types.md#accountinvocations) | AccountInvocations - Complete invocations array with account details | | `options?` | [`getSimulateTransactionOptions`](../namespaces/types.md#getsimulatetransactionoptions) | getSimulateTransactionOptions - (optional) blockIdentifier - block identifier - (optional) skipValidate - skip cairo **validate** method - (optional) skipExecute - skip cairo **execute** method | #### Returns `Promise` an array of transaction trace and estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getSimulateTransaction](ProviderInterface.md#getsimulatetransaction) #### Defined in [src/provider/default.ts:206]( --- ### getStateUpdate \u25b8 **getStateUpdate**(`blockIdentifier?`): `Promise` Gets the state changes in a specific block #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` StateUpdateResponse #### Implementation of [ProviderInterface](ProviderInterface.md).[getStateUpdate](ProviderInterface.md#getstateupdate) #### Defined in [src/provider/default.ts:213]( --- ### getStarkName \u25b8 **getStarkName**(`address`, `StarknetIdContract?`): `Promise` #### Parameters | Name | Type | | :-------------------- | :---------------------------------------------------- | | `address` | [`BigNumberish`](../namespaces/types.md#bignumberish) | | `StarknetIdContract?` | `string` | #### Returns `Promise` #### Defined in [src/provider/default.ts:217]( --- ### getAddressFromStarkName \u25b8 **getAddressFromStarkName**(`name`, `StarknetIdContract?`): `Promise` #### Parameters | Name | Type | | :-------------------- | :------- | | `name` | `string` | | `StarknetIdContract?` | `string` | #### Returns `Promise` #### Defined in [src/provider/default.ts:221]("}
{"title": "ProviderInterface.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'ProviderInterface' title: 'Class: ProviderInterface' sidebar_label: 'ProviderInterface' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - **`ProviderInterface`** \u21b3 [`AccountInterface`](AccountInterface.md) ## Implemented by - [`Provider`](Provider.md) - [`RpcProvider`](RpcProvider.md) - [`SequencerProvider`](SequencerProvider.md) ## Constructors ### constructor \u2022 **new ProviderInterface**() ## Methods ### getChainId \u25b8 `Abstract` **getChainId**(): `Promise` Gets the Starknet chain Id #### Returns `Promise` the chain Id #### Defined in [src/provider/interface.ts:38]( --- ### callContract \u25b8 `Abstract` **callContract**(`call`, `blockIdentifier?`): `Promise` Calls a function on the Starknet contract. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :----------------------- | | `call` | [`Call`](../namespaces/types.md#call) | transaction to be called | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the result of the function on the smart contract. #### Defined in [src/provider/interface.ts:47]( --- ### getBlock \u25b8 `Abstract` **getBlock**(`blockIdentifier`): `Promise` Gets the block information #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------- | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the block object #### Defined in [src/provider/interface.ts:58]( --- ### getCode \u25b8 `Abstract` **getCode**(`contractAddress`, `blockIdentifier?`): `Promise` **`Deprecated`** The method should not be used #### Parameters | Name | Type | | :----------------- | :---------------------------------------------------------- | | `contractAddress` | `string` | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | #### Returns `Promise` #### Defined in [src/provider/interface.ts:63]( --- ### getClassAt \u25b8 `Abstract` **getClassAt**(`contractAddress`, `blockIdentifier?`): `Promise` Gets the contract class of the deployed contract. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` Contract class of compiled contract #### Defined in [src/provider/interface.ts:75]( --- ### getClassHashAt \u25b8 `Abstract` **getClassHashAt**(`contractAddress`, `blockIdentifier?`): `Promise` Returns the class hash deployed under the given address. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` Class hash #### Defined in [src/provider/interface.ts:87]( --- ### getClassByHash \u25b8 `Abstract` **getClassByHash**(`classHash`): `Promise` Returns the contract class deployed under the given class hash. #### Parameters | Name | Type | Description | | :---------- | :------- | :---------- | | `classHash` | `string` | class hash | #### Returns `Promise` Contract class of compiled contract #### Defined in [src/provider/interface.ts:98]( --- ### getNonceForAddress \u25b8 `Abstract` **getNonceForAddress**(`contractAddress`, `blockIdentifier?`): `Promise` Gets the nonce of a contract with respect to a specific block #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | - | #### Returns `Promise` the hex nonce #### Defined in [src/provider/interface.ts:106]( --- ### getStorageAt \u25b8 `Abstract` **getStorageAt**(`contractAddress`, `key`, `blockIdentifier?`): `Promise` Gets the contract's storage variable at a specific key. #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------------------------------------------------- | | `contractAddress` | `string` | | | `key` | [`BigNumberish`](../namespaces/types.md#bignumberish) | from getStorageVarAddress('') (WIP) | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the value of the storage variable #### Defined in [src/provider/interface.ts:119]( --- ### getTransaction \u25b8 `Abstract` **getTransaction**(`transactionHash`): `Promise` Gets the transaction information from a tx id. #### Parameters | Name | Type | | :---------------- | :---------------------------------------------------- | | `transactionHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | #### Returns `Promise` the transaction object { transaction_id, status, transaction, block_number?, block_number?, transaction_index?, transaction_failure_reason? } #### Defined in [src/provider/interface.ts:131]( --- ### getTransactionReceipt \u25b8 `Abstract` **getTransactionReceipt**(`transactionHash`): `Promise` Gets the transaction receipt from a tx hash. #### Parameters | Name | Type | | :---------------- | :---------------------------------------------------- | | `transactionHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | #### Returns `Promise` the transaction receipt object #### Defined in [src/provider/interface.ts:139]( --- ### deployAccountContract \u25b8 `Abstract` **deployAccountContract**(`payload`, `details`): `Promise` Deploys a given compiled Account contract (json) to starknet #### Parameters | Name | Type | Description | | :-------- | :------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------ | | `payload` | [`DeployAccountContractPayload`](../namespaces/types.md#deployaccountcontractpayload) | payload to be deployed containing: - compiled contract code - constructor calldata - address salt | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | - | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Defined in [src/provider/interface.ts:152]( --- ### invokeFunction \u25b8 `Abstract` **invokeFunction**(`invocation`, `details`): `Promise` Invokes a function on starknet **`Deprecated`** This method wont be supported as soon as fees are mandatory. Should not be used outside of Account class #### Parameters | Name | Type | Description | | :----------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `invocation` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version - maxFee - optional maxFee | #### Returns `Promise` response from addTransaction #### Defined in [src/provider/interface.ts:172]( --- ### declareContract \u25b8 `Abstract` **declareContract**(`transaction`, `details`): `Promise` Declares a given compiled contract (json) to starknet #### Parameters | Name | Type | Description | | :------------ | :---------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------- | | `transaction` | [`DeclareContractTransaction`](../namespaces/types.md#declarecontracttransaction) | transaction payload to be deployed containing: - compiled contract code - sender address - signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | Invocation Details containing: - nonce - optional version - optional maxFee | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Defined in [src/provider/interface.ts:189]( --- ### getEstimateFee \u25b8 `Abstract` **getEstimateFee**(`invocation`, `details`, `blockIdentifier`, `skipValidate?`): `Promise` Estimates the fee for a given INVOKE transaction **`Deprecated`** Please use getInvokeEstimateFee or getDeclareEstimateFee instead. Should not be used outside of Account class #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `invocation` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | | `skipValidate?` | `boolean` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Defined in [src/provider/interface.ts:210]( --- ### getInvokeEstimateFee \u25b8 `Abstract` **getInvokeEstimateFee**(`invocation`, `details`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given INVOKE transaction #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `invocation` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | | `skipValidate?` | `boolean` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Defined in [src/provider/interface.ts:232]( --- ### getDeclareEstimateFee \u25b8 `Abstract` **getDeclareEstimateFee**(`transaction`, `details`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given DECLARE transaction #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ | | `transaction` | [`DeclareContractTransaction`](../namespaces/types.md#declarecontracttransaction) | transaction payload to be declared containing: - compiled contract code - sender address - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - version - optional version - optional maxFee | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | | `skipValidate?` | `boolean` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Defined in [src/provider/interface.ts:254]( --- ### getDeployAccountEstimateFee \u25b8 `Abstract` **getDeployAccountEstimateFee**(`transaction`, `details`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given DEPLOY_ACCOUNT transaction #### Parameters | Name | Type | Description | | :----------------- | :-------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------ | | `transaction` | [`DeployAccountContractTransaction`](../namespaces/types.md#deployaccountcontracttransaction) | transaction payload to be deployed containing: - classHash - constructorCalldata - addressSalt - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - version - optional version - optional maxFee | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | | `skipValidate?` | `boolean` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Defined in [src/provider/interface.ts:277]( --- ### getEstimateFeeBulk \u25b8 `Abstract` **getEstimateFeeBulk**(`invocations`, `options?`): `Promise` Estimates the fee for a list of INVOKE transaction #### Parameters | Name | Type | Description | | :------------ | :------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------- | | `invocations` | [`AccountInvocations`](../namespaces/types.md#accountinvocations) | AccountInvocations - Complete invocations array with account details | | `options?` | [`getEstimateFeeBulkOptions`](../namespaces/types.md#getestimatefeebulkoptions) | getEstimateFeeBulkOptions - (optional) blockIdentifier - BlockIdentifier - (optional) skipValidate - boolean (default false) | #### Returns `Promise` the estimated fee #### Defined in [src/provider/interface.ts:293]( --- ### waitForTransaction \u25b8 `Abstract` **waitForTransaction**(`txHash`, `options?`): `Promise` Wait for the transaction to be accepted #### Parameters | Name | Type | Description | | :--------- | :------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------- | | `txHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | transaction hash | | `options?` | [`waitForTransactionOptions`](../namespaces/types.md#waitfortransactionoptions) | waitForTransactionOptions - (optional) retryInterval: number \\| undefined; - (optional) successStates: TransactionStatus[] \\| undefined; | #### Returns `Promise` GetTransactionReceiptResponse #### Defined in [src/provider/interface.ts:306]( --- ### getSimulateTransaction \u25b8 `Abstract` **getSimulateTransaction**(`invocations`, `options?`): `Promise` Simulates the transaction and returns the transaction trace and estimated fee. #### Parameters | Name | Type | Description | | :------------ | :-------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | `invocations` | [`AccountInvocations`](../namespaces/types.md#accountinvocations) | AccountInvocations - Complete invocations array with account details | | `options?` | [`getSimulateTransactionOptions`](../namespaces/types.md#getsimulatetransactionoptions) | getSimulateTransactionOptions - (optional) blockIdentifier - block identifier - (optional) skipValidate - skip cairo **validate** method - (optional) skipExecute - skip cairo **execute** method | #### Returns `Promise` an array of transaction trace and estimated fee #### Defined in [src/provider/interface.ts:321]( --- ### getStateUpdate \u25b8 `Abstract` **getStateUpdate**(`blockIdentifier?`): `Promise` Gets the state changes in a specific block #### Parameters | Name | Type | Description | | :----------------- | :---------------------------------------------------------- | :--------------- | | `blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` StateUpdateResponse #### Defined in [src/provider/interface.ts:332]("}
{"title": "RpcProvider.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'RpcProvider' title: 'Class: RpcProvider' sidebar_label: 'RpcProvider' sidebar_position: 0 custom_edit_url: null --- ## Implements - [`ProviderInterface`](ProviderInterface.md) ## Constructors ### constructor \u2022 **new RpcProvider**(`optionsOrProvider`) #### Parameters | Name | Type | | :------------------ | :---------------------------------------------------------------- | | `optionsOrProvider` | [`RpcProviderOptions`](../namespaces/types.md#rpcprovideroptions) | #### Defined in [src/provider/rpc.ts:74]( ## Properties ### nodeUrl \u2022 **nodeUrl**: `string` #### Defined in [src/provider/rpc.ts:62]( --- ### headers \u2022 **headers**: `object` #### Defined in [src/provider/rpc.ts:64]( --- ### responseParser \u2022 `Private` **responseParser**: `RPCResponseParser` #### Defined in [src/provider/rpc.ts:66]( --- ### retries \u2022 `Private` **retries**: `number` #### Defined in [src/provider/rpc.ts:68]( --- ### blockIdentifier \u2022 `Private` **blockIdentifier**: [`BlockIdentifier`](../namespaces/types.md#blockidentifier) #### Defined in [src/provider/rpc.ts:70]( --- ### chainId \u2022 `Private` `Optional` **chainId**: [`StarknetChainId`](../enums/constants.StarknetChainId.md) #### Defined in [src/provider/rpc.ts:72]( ## Methods ### fetch \u25b8 **fetch**(`method`, `params`): `Promise` #### Parameters | Name | Type | | :------- | :---- | | `method` | `any` | | `params` | `any` | #### Returns `Promise` #### Defined in [src/provider/rpc.ts:84]( --- ### errorHandler \u25b8 `Protected` **errorHandler**(`error`): `void` #### Parameters | Name | Type | | :------ | :---- | | `error` | `any` | #### Returns `void` #### Defined in [src/provider/rpc.ts:93]( --- ### fetchEndpoint \u25b8 `Protected` **fetchEndpoint**(`method`, `params?`): `Promise` #### Type parameters | Name | Type | | :--- | :---------------------- | | `T` | extends keyof `Methods` | #### Parameters | Name | Type | | :-------- | :--------------------------- | | `method` | `T` | | `params?` | `Methods`[`T`][``\"params\"``] | #### Returns `Promise` #### Defined in [src/provider/rpc.ts:100]( --- ### getChainId \u25b8 **getChainId**(): `Promise` Gets the Starknet chain Id #### Returns `Promise` the chain Id #### Implementation of [ProviderInterface](ProviderInterface.md).[getChainId](ProviderInterface.md#getchainid) #### Defined in [src/provider/rpc.ts:116]( --- ### getBlock \u25b8 **getBlock**(`blockIdentifier?`): `Promise` Gets the block information #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------- | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the block object #### Implementation of [ProviderInterface](ProviderInterface.md).[getBlock](ProviderInterface.md#getblock) #### Defined in [src/provider/rpc.ts:121]( --- ### getBlockHashAndNumber \u25b8 **getBlockHashAndNumber**(): `Promise` #### Returns `Promise` #### Defined in [src/provider/rpc.ts:129]( --- ### getBlockWithTxHashes \u25b8 **getBlockWithTxHashes**(`blockIdentifier?`): `Promise` #### Parameters | Name | Type | | :---------------- | :---------------------------------------------------------- | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | #### Returns `Promise` #### Defined in [src/provider/rpc.ts:133]( --- ### getBlockWithTxs \u25b8 **getBlockWithTxs**(`blockIdentifier?`): `Promise` #### Parameters | Name | Type | | :---------------- | :---------------------------------------------------------- | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | #### Returns `Promise` #### Defined in [src/provider/rpc.ts:140]( --- ### getClassHashAt \u25b8 **getClassHashAt**(`contractAddress`, `blockIdentifier?`): `Promise` Returns the class hash deployed under the given address. #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` Class hash #### Implementation of [ProviderInterface](ProviderInterface.md).[getClassHashAt](ProviderInterface.md#getclasshashat) #### Defined in [src/provider/rpc.ts:147]( --- ### getNonceForAddress \u25b8 **getNonceForAddress**(`contractAddress`, `blockIdentifier?`): `Promise` Gets the nonce of a contract with respect to a specific block #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | - | #### Returns `Promise` the hex nonce #### Implementation of [ProviderInterface](ProviderInterface.md).[getNonceForAddress](ProviderInterface.md#getnonceforaddress) #### Defined in [src/provider/rpc.ts:158]( --- ### getPendingTransactions \u25b8 **getPendingTransactions**(): `Promise` #### Returns `Promise` #### Defined in [src/provider/rpc.ts:169]( --- ### getProtocolVersion \u25b8 **getProtocolVersion**(): `Promise` #### Returns `Promise` #### Defined in [src/provider/rpc.ts:173]( --- ### getStateUpdate \u25b8 **getStateUpdate**(`blockIdentifier?`): `Promise` Gets the state changes in a specific block #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------- | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` StateUpdateResponse #### Implementation of [ProviderInterface](ProviderInterface.md).[getStateUpdate](ProviderInterface.md#getstateupdate) #### Defined in [src/provider/rpc.ts:177]( --- ### getStorageAt \u25b8 **getStorageAt**(`contractAddress`, `key`, `blockIdentifier?`): `Promise` Gets the contract's storage variable at a specific key. #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------------------------------------------------- | | `contractAddress` | `string` | | | `key` | [`BigNumberish`](../namespaces/types.md#bignumberish) | from getStorageVarAddress('') (WIP) | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the value of the storage variable #### Implementation of [ProviderInterface](ProviderInterface.md).[getStorageAt](ProviderInterface.md#getstorageat) #### Defined in [src/provider/rpc.ts:184]( --- ### getTransaction \u25b8 **getTransaction**(`txHash`): `Promise` Gets the transaction information from a tx id. #### Parameters | Name | Type | | :------- | :------- | | `txHash` | `string` | #### Returns `Promise` the transaction object { transaction_id, status, transaction, block_number?, block_number?, transaction_index?, transaction_failure_reason? } #### Implementation of [ProviderInterface](ProviderInterface.md).[getTransaction](ProviderInterface.md#gettransaction) #### Defined in [src/provider/rpc.ts:199]( --- ### getTransactionByHash \u25b8 **getTransactionByHash**(`txHash`): `Promise` #### Parameters | Name | Type | | :------- | :------- | | `txHash` | `string` | #### Returns `Promise` #### Defined in [src/provider/rpc.ts:203]( --- ### getTransactionByBlockIdAndIndex \u25b8 **getTransactionByBlockIdAndIndex**(`blockIdentifier`, `index`): `Promise` #### Parameters | Name | Type | | :---------------- | :---------------------------------------------------------- | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | | `index` | `number` | #### Returns `Promise` #### Defined in [src/provider/rpc.ts:207]( --- ### getTransactionReceipt \u25b8 **getTransactionReceipt**(`txHash`): `Promise` Gets the transaction receipt from a tx hash. #### Parameters | Name | Type | | :------- | :------- | | `txHash` | `string` | #### Returns `Promise` the transaction receipt object #### Implementation of [ProviderInterface](ProviderInterface.md).[getTransactionReceipt](ProviderInterface.md#gettransactionreceipt) #### Defined in [src/provider/rpc.ts:215]( --- ### getClassByHash \u25b8 **getClassByHash**(`classHash`): `Promise` Returns the contract class deployed under the given class hash. #### Parameters | Name | Type | Description | | :---------- | :------- | :---------- | | `classHash` | `string` | class hash | #### Returns `Promise` Contract class of compiled contract #### Implementation of [ProviderInterface](ProviderInterface.md).[getClassByHash](ProviderInterface.md#getclassbyhash) #### Defined in [src/provider/rpc.ts:219]( --- ### getClass \u25b8 **getClass**(`classHash`, `blockIdentifier?`): `Promise` #### Parameters | Name | Type | | :---------------- | :---------------------------------------------------------- | | `classHash` | `string` | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | #### Returns `Promise` #### Defined in [src/provider/rpc.ts:223]( --- ### getClassAt \u25b8 **getClassAt**(`contractAddress`, `blockIdentifier?`): `Promise` Gets the contract class of the deployed contract. #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` Contract class of compiled contract #### Implementation of [ProviderInterface](ProviderInterface.md).[getClassAt](ProviderInterface.md#getclassat) #### Defined in [src/provider/rpc.ts:234]( --- ### getCode \u25b8 **getCode**(`_contractAddress`, `_blockIdentifier?`): `Promise` **`Deprecated`** The method should not be used #### Parameters | Name | Type | | :------------------ | :---------------------------------------------------------- | | `_contractAddress` | `string` | | `_blockIdentifier?` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | #### Returns `Promise` #### Implementation of [ProviderInterface](ProviderInterface.md).[getCode](ProviderInterface.md#getcode) #### Defined in [src/provider/rpc.ts:245]( --- ### getEstimateFee \u25b8 **getEstimateFee**(`invocation`, `invocationDetails`, `blockIdentifier?`): `Promise` Estimates the fee for a given INVOKE transaction **`Deprecated`** Please use getInvokeEstimateFee or getDeclareEstimateFee instead. Should not be used outside of Account class #### Parameters | Name | Type | Description | | :------------------ | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `invocation` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `invocationDetails` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getEstimateFee](ProviderInterface.md#getestimatefee) #### Defined in [src/provider/rpc.ts:252]( --- ### getInvokeEstimateFee \u25b8 **getInvokeEstimateFee**(`invocation`, `invocationDetails`, `blockIdentifier?`): `Promise` Estimates the fee for a given INVOKE transaction #### Parameters | Name | Type | Description | | :------------------ | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `invocation` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `invocationDetails` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getInvokeEstimateFee](ProviderInterface.md#getinvokeestimatefee) #### Defined in [src/provider/rpc.ts:260]( --- ### getDeclareEstimateFee \u25b8 **getDeclareEstimateFee**(`invocation`, `details`, `blockIdentifier?`): `Promise` Estimates the fee for a given DECLARE transaction #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ | | `invocation` | [`DeclareContractTransaction`](../namespaces/types.md#declarecontracttransaction) | transaction payload to be declared containing: - compiled contract code - sender address - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - version - optional version - optional maxFee | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getDeclareEstimateFee](ProviderInterface.md#getdeclareestimatefee) #### Defined in [src/provider/rpc.ts:280]( --- ### getDeployAccountEstimateFee \u25b8 **getDeployAccountEstimateFee**(`invocation`, `details`, `blockIdentifier?`): `Promise` Estimates the fee for a given DEPLOY_ACCOUNT transaction #### Parameters | Name | Type | Description | | :---------------- | :-------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------ | | `invocation` | [`DeployAccountContractTransaction`](../namespaces/types.md#deployaccountcontracttransaction) | transaction payload to be deployed containing: - classHash - constructorCalldata - addressSalt - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - version - optional version - optional maxFee | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | (optional) block identifier | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getDeployAccountEstimateFee](ProviderInterface.md#getdeployaccountestimatefee) #### Defined in [src/provider/rpc.ts:300]( --- ### getEstimateFeeBulk \u25b8 **getEstimateFeeBulk**(`invocations`, `\u00abdestructured\u00bb`): `Promise` Estimates the fee for a list of INVOKE transaction #### Parameters | Name | Type | Description | | :--------------- | :------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------- | | `invocations` | [`AccountInvocations`](../namespaces/types.md#accountinvocations) | AccountInvocations - Complete invocations array with account details | | `\u00abdestructured\u00bb` | [`getEstimateFeeBulkOptions`](../namespaces/types.md#getestimatefeebulkoptions) | getEstimateFeeBulkOptions - (optional) blockIdentifier - BlockIdentifier - (optional) skipValidate - boolean (default false) | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getEstimateFeeBulk](ProviderInterface.md#getestimatefeebulk) #### Defined in [src/provider/rpc.ts:320]( --- ### declareContract \u25b8 **declareContract**(`\u00abdestructured\u00bb`, `details`): `Promise` Declares a given compiled contract (json) to starknet #### Parameters | Name | Type | Description | | :--------------- | :---------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------- | | `\u00abdestructured\u00bb` | [`DeclareContractTransaction`](../namespaces/types.md#declarecontracttransaction) | transaction payload to be deployed containing: - compiled contract code - sender address - signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | Invocation Details containing: - nonce - optional version - optional maxFee | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Implementation of [ProviderInterface](ProviderInterface.md).[declareContract](ProviderInterface.md#declarecontract) #### Defined in [src/provider/rpc.ts:335]( --- ### deployAccountContract \u25b8 **deployAccountContract**(`\u00abdestructured\u00bb`, `details`): `Promise` Deploys a given compiled Account contract (json) to starknet #### Parameters | Name | Type | Description | | :--------------- | :-------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------ | | `\u00abdestructured\u00bb` | [`DeployAccountContractTransaction`](../namespaces/types.md#deployaccountcontracttransaction) | payload to be deployed containing: - compiled contract code - constructor calldata - address salt | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | - | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Implementation of [ProviderInterface](ProviderInterface.md).[deployAccountContract](ProviderInterface.md#deployaccountcontract) #### Defined in [src/provider/rpc.ts:375]( --- ### invokeFunction \u25b8 **invokeFunction**(`functionInvocation`, `details`): `Promise` Invokes a function on starknet **`Deprecated`** This method wont be supported as soon as fees are mandatory. Should not be used outside of Account class #### Parameters | Name | Type | Description | | :------------------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `functionInvocation` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version - maxFee - optional maxFee | #### Returns `Promise` response from addTransaction #### Implementation of [ProviderInterface](ProviderInterface.md).[invokeFunction](ProviderInterface.md#invokefunction) #### Defined in [src/provider/rpc.ts:393]( --- ### callContract \u25b8 **callContract**(`call`, `blockIdentifier?`): `Promise` Calls a function on the Starknet contract. #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :----------------------- | | `call` | [`Call`](../namespaces/types.md#call) | transaction to be called | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the result of the function on the smart contract. #### Implementation of [ProviderInterface](ProviderInterface.md).[callContract](ProviderInterface.md#callcontract) #### Defined in [src/provider/rpc.ts:411]( --- ### traceTransaction \u25b8 **traceTransaction**(`transactionHash`): `Promise` #### Parameters | Name | Type | | :---------------- | :------- | | `transactionHash` | `string` | #### Returns `Promise` #### Defined in [src/provider/rpc.ts:428]( --- ### traceBlockTransactions \u25b8 **traceBlockTransactions**(`blockHash`): `Promise` #### Parameters | Name | Type | | :---------- | :------- | | `blockHash` | `string` | #### Returns `Promise` #### Defined in [src/provider/rpc.ts:432]( --- ### waitForTransaction \u25b8 **waitForTransaction**(`txHash`, `options?`): `Promise` Wait for the transaction to be accepted #### Parameters | Name | Type | Description | | :--------- | :------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------- | | `txHash` | `string` | transaction hash | | `options?` | [`waitForTransactionOptions`](../namespaces/types.md#waitfortransactionoptions) | waitForTransactionOptions - (optional) retryInterval: number \\| undefined; - (optional) successStates: TransactionStatus[] \\| undefined; | #### Returns `Promise` GetTransactionReceiptResponse #### Implementation of [ProviderInterface](ProviderInterface.md).[waitForTransaction](ProviderInterface.md#waitfortransaction) #### Defined in [src/provider/rpc.ts:436]( --- ### getTransactionCount \u25b8 **getTransactionCount**(`blockIdentifier?`): `Promise` Gets the transaction count from a block. #### Parameters | Name | Type | | :---------------- | :---------------------------------------------------------- | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | #### Returns `Promise` Number of transactions #### Defined in [src/provider/rpc.ts:492]( --- ### getBlockNumber \u25b8 **getBlockNumber**(): `Promise` Gets the latest block number #### Returns `Promise` Number of the latest block #### Defined in [src/provider/rpc.ts:505]( --- ### getSyncingStats \u25b8 **getSyncingStats**(): `Promise` Gets syncing status of the node #### Returns `Promise` Object with the stats data #### Defined in [src/provider/rpc.ts:515]( --- ### getEvents \u25b8 **getEvents**(`eventFilter`): `Promise` Gets all the events filtered #### Parameters | Name | Type | | :------------ | :------------ | | `eventFilter` | `EventFilter` | #### Returns `Promise` events and the pagination of the events #### Defined in [src/provider/rpc.ts:525]( --- ### getSimulateTransaction \u25b8 **getSimulateTransaction**(`invocations`, `\u00abdestructured\u00bb`): `Promise` Simulates the transaction and returns the transaction trace and estimated fee. #### Parameters | Name | Type | Description | | :--------------- | :-------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | `invocations` | [`AccountInvocations`](../namespaces/types.md#accountinvocations) | AccountInvocations - Complete invocations array with account details | | `\u00abdestructured\u00bb` | [`getSimulateTransactionOptions`](../namespaces/types.md#getsimulatetransactionoptions) | getSimulateTransactionOptions - (optional) blockIdentifier - block identifier - (optional) skipValidate - skip cairo **validate** method - (optional) skipExecute - skip cairo **execute** method | #### Returns `Promise` an array of transaction trace and estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getSimulateTransaction](ProviderInterface.md#getsimulatetransaction) #### Defined in [src/provider/rpc.ts:529]( --- ### getStarkName \u25b8 **getStarkName**(`address`, `StarknetIdContract?`): `Promise` #### Parameters | Name | Type | | :-------------------- | :---------------------------------------------------- | | `address` | [`BigNumberish`](../namespaces/types.md#bignumberish) | | `StarknetIdContract?` | `string` | #### Returns `Promise` #### Defined in [src/provider/rpc.ts:550]( --- ### getAddressFromStarkName \u25b8 **getAddressFromStarkName**(`name`, `StarknetIdContract?`): `Promise` #### Parameters | Name | Type | | :-------------------- | :------- | | `name` | `string` | | `StarknetIdContract?` | `string` | #### Returns `Promise` #### Defined in [src/provider/rpc.ts:554]( --- ### buildTransaction \u25b8 **buildTransaction**(`invocation`, `versionType?`): `BROADCASTED_TXN` #### Parameters | Name | Type | | :------------- | :---------------------------------------------------------------------- | | `invocation` | [`AccountInvocationItem`](../namespaces/types.md#accountinvocationitem) | | `versionType?` | `\"fee\"` \\| `\"transaction\"` | #### Returns `BROADCASTED_TXN` #### Defined in [src/provider/rpc.ts:558]("}
{"title": "SequencerProvider.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'SequencerProvider' title: 'Class: SequencerProvider' sidebar_label: 'SequencerProvider' sidebar_position: 0 custom_edit_url: null --- ## Implements - [`ProviderInterface`](ProviderInterface.md) ## Constructors ### constructor \u2022 **new SequencerProvider**(`optionsOrProvider?`) #### Parameters | Name | Type | Default value | | :------------------ | :---------------------------------------------------------------------------- | :--------------- | | `optionsOrProvider` | [`SequencerProviderOptions`](../namespaces/types.md#sequencerprovideroptions) | `defaultOptions` | #### Defined in [src/provider/sequencer.ts:90]( ## Properties ### baseUrl \u2022 **baseUrl**: `string` #### Defined in [src/provider/sequencer.ts:76]( --- ### feederGatewayUrl \u2022 **feederGatewayUrl**: `string` #### Defined in [src/provider/sequencer.ts:78]( --- ### gatewayUrl \u2022 **gatewayUrl**: `string` #### Defined in [src/provider/sequencer.ts:80]( --- ### headers \u2022 `Optional` **headers**: `Record` #### Defined in [src/provider/sequencer.ts:82]( --- ### blockIdentifier \u2022 `Private` **blockIdentifier**: [`BlockIdentifier`](../namespaces/types.md#blockidentifier) #### Defined in [src/provider/sequencer.ts:84]( --- ### chainId \u2022 `Private` **chainId**: [`StarknetChainId`](../enums/constants.StarknetChainId.md) #### Defined in [src/provider/sequencer.ts:86]( --- ### responseParser \u2022 `Private` **responseParser**: `SequencerAPIResponseParser` #### Defined in [src/provider/sequencer.ts:88]( ## Methods ### getNetworkFromName \u25b8 `Static` `Protected` **getNetworkFromName**(`name`): `BaseUrl` #### Parameters | Name | Type | | :----- | :--------------------------------------------------------------------------------------------------------------- | | `name` | [`StarknetChainId`](../enums/constants.StarknetChainId.md) \\| [`NetworkName`](../enums/constants.NetworkName.md) | #### Returns `BaseUrl` #### Defined in [src/provider/sequencer.ts:110]( --- ### getChainIdFromBaseUrl \u25b8 `Static` `Protected` **getChainIdFromBaseUrl**(`baseUrl`): [`StarknetChainId`](../enums/constants.StarknetChainId.md) #### Parameters | Name | Type | | :-------- | :------- | | `baseUrl` | `string` | #### Returns [`StarknetChainId`](../enums/constants.StarknetChainId.md) #### Defined in [src/provider/sequencer.ts:123]( --- ### getFetchUrl \u25b8 `Private` **getFetchUrl**(`endpoint`): `string` #### Parameters | Name | Type | | :--------- | :-------------------------------------------------------------- | | `endpoint` | keyof [`Endpoints`](../namespaces/types.Sequencer.md#endpoints) | #### Returns `string` #### Defined in [src/provider/sequencer.ts:140]( --- ### getFetchMethod \u25b8 `Private` **getFetchMethod**(`endpoint`): `\"POST\"` \\| `\"GET\"` #### Parameters | Name | Type | | :--------- | :-------------------------------------------------------------- | | `endpoint` | keyof [`Endpoints`](../namespaces/types.Sequencer.md#endpoints) | #### Returns `\"POST\"` \\| `\"GET\"` #### Defined in [src/provider/sequencer.ts:145]( --- ### getQueryString \u25b8 `Private` **getQueryString**(`query?`): `string` #### Parameters | Name | Type | | :------- | :------------------------- | | `query?` | `Record` | #### Returns `string` #### Defined in [src/provider/sequencer.ts:158]( --- ### getHeaders \u25b8 `Private` **getHeaders**(`method`): `undefined` \\| `Record` #### Parameters | Name | Type | | :------- | :------------------------------------------------------------------ | | `method` | [`SequencerHttpMethod`](../namespaces/types.md#sequencer | #### Returns `undefined` \\| `Record` #### Defined in [src/provider/sequencer.ts:175]( --- ### fetchEndpoint \u25b8 `Protected` **fetchEndpoint**(`endpoint`, `...\u00abdestructured\u00bb`): `Promise` #### Type parameters | Name | Type | | :--- | :---------------------------------------------------------------------- | | `T` | extends keyof [`Endpoints`](../namespaces/types.Sequencer.md#endpoints) | #### Parameters | Name | Type | | :------------------ | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `endpoint` | `T` | | `...\u00abdestructured\u00bb` | [`Endpoints`](../namespaces/types.Sequencer.md#endpoints)[`T`][``\"QUERY\"``] extends `never` ? [`Endpoints`](../namespaces/types.Sequencer.md#endpoints)[`T`][``\"REQUEST\"``] extends `never` ? [] : [`undefined`, [`Endpoints`](../namespaces/types.Sequencer.md#endpoints)[`T`][``\"REQUEST\"``]] : [`Endpoints`](../namespaces/types.Sequencer.md#endpoints)[`T`][``\"REQUEST\"``] extends `never` ? [[`Endpoints`](../namespaces/types.Sequencer.md#endpoints)[`T`][``\"QUERY\"``]] : [[`Endpoints`](../namespaces/types.Sequencer.md#endpoints)[`T`][``\"QUERY\"``], [`Endpoints`](../namespaces/types.Sequencer.md#endpoints)[`T`][``\"REQUEST\"``]] | #### Returns `Promise` #### Defined in [src/provider/sequencer.ts:186]( --- ### fetch \u25b8 **fetch**(`endpoint`, `options?`): `Promise` #### Parameters | Name | Type | | :----------------------------- | :------------------------------------------------------------------ | | `endpoint` | `string` | | `options?` | `Object` | | `options.method?` | [`SequencerHttpMethod`](../namespaces/types.md#sequencer | | `options.body?` | `any` | | `options.parseAlwaysAsBigInt?` | `boolean` | #### Returns `Promise` #### Defined in [src/provider/sequencer.ts:208]( --- ### getChainId \u25b8 **getChainId**(): `Promise` Gets the Starknet chain Id #### Returns `Promise` the chain Id #### Implementation of [ProviderInterface](ProviderInterface.md).[getChainId](ProviderInterface.md#getchainid) #### Defined in [src/provider/sequencer.ts:249]( --- ### callContract \u25b8 **callContract**(`\u00abdestructured\u00bb`, `blockIdentifier?`): `Promise` Calls a function on the Starknet contract. #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :----------------------- | | `\u00abdestructured\u00bb` | [`Call`](../namespaces/types.md#call) | transaction to be called | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the result of the function on the smart contract. #### Implementation of [ProviderInterface](ProviderInterface.md).[callContract](ProviderInterface.md#callcontract) #### Defined in [src/provider/sequencer.ts:253]( --- ### getBlock \u25b8 **getBlock**(`blockIdentifier?`): `Promise` Gets the block information #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------- | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the block object #### Implementation of [ProviderInterface](ProviderInterface.md).[getBlock](ProviderInterface.md#getblock) #### Defined in [src/provider/sequencer.ts:271]( --- ### getNonceForAddress \u25b8 **getNonceForAddress**(`contractAddress`, `blockIdentifier?`): `Promise` Gets the nonce of a contract with respect to a specific block #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | - | #### Returns `Promise` the hex nonce #### Implementation of [ProviderInterface](ProviderInterface.md).[getNonceForAddress](ProviderInterface.md#getnonceforaddress) #### Defined in [src/provider/sequencer.ts:279]( --- ### getStorageAt \u25b8 **getStorageAt**(`contractAddress`, `key`, `blockIdentifier?`): `Promise` Gets the contract's storage variable at a specific key. #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------------------------------------------------- | | `contractAddress` | `string` | | | `key` | [`BigNumberish`](../namespaces/types.md#bignumberish) | from getStorageVarAddress('') (WIP) | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` the value of the storage variable #### Implementation of [ProviderInterface](ProviderInterface.md).[getStorageAt](ProviderInterface.md#getstorageat) #### Defined in [src/provider/sequencer.ts:286]( --- ### getTransaction \u25b8 **getTransaction**(`txHash`): `Promise` Gets the transaction information from a tx id. #### Parameters | Name | Type | | :------- | :---------------------------------------------------- | | `txHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | #### Returns `Promise` the transaction object { transaction_id, status, transaction, block_number?, block_number?, transaction_index?, transaction_failure_reason? } #### Implementation of [ProviderInterface](ProviderInterface.md).[getTransaction](ProviderInterface.md#gettransaction) #### Defined in [src/provider/sequencer.ts:299]( --- ### getTransactionReceipt \u25b8 **getTransactionReceipt**(`txHash`): `Promise` Gets the transaction receipt from a tx hash. #### Parameters | Name | Type | | :------- | :---------------------------------------------------- | | `txHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | #### Returns `Promise` the transaction receipt object #### Implementation of [ProviderInterface](ProviderInterface.md).[getTransactionReceipt](ProviderInterface.md#gettransactionreceipt) #### Defined in [src/provider/sequencer.ts:308]( --- ### getClassAt \u25b8 **getClassAt**(`contractAddress`, `blockIdentifier?`): `Promise` Gets the contract class of the deployed contract. #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` Contract class of compiled contract #### Implementation of [ProviderInterface](ProviderInterface.md).[getClassAt](ProviderInterface.md#getclassat) #### Defined in [src/provider/sequencer.ts:315]( --- ### getClassHashAt \u25b8 **getClassHashAt**(`contractAddress`, `blockIdentifier?`): `Promise` Returns the class hash deployed under the given address. #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------- | | `contractAddress` | `string` | contract address | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` Class hash #### Implementation of [ProviderInterface](ProviderInterface.md).[getClassHashAt](ProviderInterface.md#getclasshashat) #### Defined in [src/provider/sequencer.ts:324]( --- ### getClassByHash \u25b8 **getClassByHash**(`classHash`, `blockIdentifier?`): `Promise` Returns the contract class deployed under the given class hash. #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :---------- | | `classHash` | `string` | class hash | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | - | #### Returns `Promise` Contract class of compiled contract #### Implementation of [ProviderInterface](ProviderInterface.md).[getClassByHash](ProviderInterface.md#getclassbyhash) #### Defined in [src/provider/sequencer.ts:331]( --- ### getCompiledClassByClassHash \u25b8 **getCompiledClassByClassHash**(`classHash`, `blockIdentifier?`): `Promise` #### Parameters | Name | Type | | :---------------- | :---------------------------------------------------------- | | `classHash` | `string` | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | #### Returns `Promise` #### Defined in [src/provider/sequencer.ts:340]( --- ### invokeFunction \u25b8 **invokeFunction**(`functionInvocation`, `details`): `Promise` Invokes a function on starknet **`Deprecated`** This method wont be supported as soon as fees are mandatory. Should not be used outside of Account class #### Parameters | Name | Type | Description | | :------------------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `functionInvocation` | [`Invocation`](../namespaces/types.md#invocation) | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | optional details containing: - nonce - optional nonce - version - optional version - maxFee - optional maxFee | #### Returns `Promise` response from addTransaction #### Implementation of [ProviderInterface](ProviderInterface.md).[invokeFunction](ProviderInterface.md#invokefunction) #### Defined in [src/provider/sequencer.ts:347]( --- ### deployAccountContract \u25b8 **deployAccountContract**(`\u00abdestructured\u00bb`, `details`): `Promise` Deploys a given compiled Account contract (json) to starknet #### Parameters | Name | Type | Description | | :--------------- | :-------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------ | | `\u00abdestructured\u00bb` | [`DeployAccountContractTransaction`](../namespaces/types.md#deployaccountcontracttransaction) | payload to be deployed containing: - compiled contract code - constructor calldata - address salt | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | - | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Implementation of [ProviderInterface](ProviderInterface.md).[deployAccountContract](ProviderInterface.md#deployaccountcontract) #### Defined in [src/provider/sequencer.ts:362]( --- ### declareContract \u25b8 **declareContract**(`\u00abdestructured\u00bb`, `details`): `Promise` Declares a given compiled contract (json) to starknet #### Parameters | Name | Type | Description | | :--------------- | :---------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------- | | `\u00abdestructured\u00bb` | [`DeclareContractTransaction`](../namespaces/types.md#declarecontracttransaction) | transaction payload to be deployed containing: - compiled contract code - sender address - signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | Invocation Details containing: - nonce - optional version - optional maxFee | #### Returns `Promise` a confirmation of sending a transaction on the starknet contract #### Implementation of [ProviderInterface](ProviderInterface.md).[declareContract](ProviderInterface.md#declarecontract) #### Defined in [src/provider/sequencer.ts:378]( --- ### getEstimateFee \u25b8 **getEstimateFee**(`invocation`, `invocationDetails`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given INVOKE transaction **`Deprecated`** Please use getInvokeEstimateFee or getDeclareEstimateFee instead. Should not be used outside of Account class #### Parameters | Name | Type | Default value | Description | | :------------------ | :---------------------------------------------------------------------------------- | :------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `invocation` | [`Invocation`](../namespaces/types.md#invocation) | `undefined` | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `invocationDetails` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | `undefined` | optional details containing: - nonce - optional nonce - version - optional version | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | `undefined` | (optional) block identifier | | `skipValidate` | `boolean` | `false` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getEstimateFee](ProviderInterface.md#getestimatefee) #### Defined in [src/provider/sequencer.ts:406]( --- ### getInvokeEstimateFee \u25b8 **getInvokeEstimateFee**(`invocation`, `invocationDetails`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given INVOKE transaction #### Parameters | Name | Type | Default value | Description | | :------------------ | :---------------------------------------------------------------------------------- | :------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `invocation` | [`Invocation`](../namespaces/types.md#invocation) | `undefined` | the invocation object containing: - contractAddress - the address of the contract - entrypoint - the entrypoint of the contract - calldata - (defaults to []) the calldata - signature - (defaults to []) the signature | | `invocationDetails` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | `undefined` | optional details containing: - nonce - optional nonce - version - optional version | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | `undefined` | (optional) block identifier | | `skipValidate` | `boolean` | `false` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getInvokeEstimateFee](ProviderInterface.md#getinvokeestimatefee) #### Defined in [src/provider/sequencer.ts:415]( --- ### getDeclareEstimateFee \u25b8 **getDeclareEstimateFee**(`invocation`, `details`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given DECLARE transaction #### Parameters | Name | Type | Default value | Description | | :---------------- | :---------------------------------------------------------------------------------- | :------------ | :------------------------------------------------------------------------------------------------------------------------------------ | | `invocation` | [`DeclareContractTransaction`](../namespaces/types.md#declarecontracttransaction) | `undefined` | transaction payload to be declared containing: - compiled contract code - sender address - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | `undefined` | optional details containing: - nonce - version - optional version - optional maxFee | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | `undefined` | (optional) block identifier | | `skipValidate` | `boolean` | `false` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getDeclareEstimateFee](ProviderInterface.md#getdeclareestimatefee) #### Defined in [src/provider/sequencer.ts:434]( --- ### getDeployAccountEstimateFee \u25b8 **getDeployAccountEstimateFee**(`invocation`, `details`, `blockIdentifier?`, `skipValidate?`): `Promise` Estimates the fee for a given DEPLOY_ACCOUNT transaction #### Parameters | Name | Type | Default value | Description | | :---------------- | :-------------------------------------------------------------------------------------------- | :------------ | :------------------------------------------------------------------------------------------------------------------------------------------ | | `invocation` | [`DeployAccountContractTransaction`](../namespaces/types.md#deployaccountcontracttransaction) | `undefined` | transaction payload to be deployed containing: - classHash - constructorCalldata - addressSalt - signature - (defaults to []) the signature | | `details` | [`InvocationsDetailsWithNonce`](../namespaces/types.md#invocationsdetailswithnonce) | `undefined` | optional details containing: - nonce - version - optional version - optional maxFee | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | `undefined` | (optional) block identifier | | `skipValidate` | `boolean` | `false` | (optional) skip cairo **validate** method | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getDeployAccountEstimateFee](ProviderInterface.md#getdeployaccountestimatefee) #### Defined in [src/provider/sequencer.ts:453]( --- ### getEstimateFeeBulk \u25b8 **getEstimateFeeBulk**(`invocations`, `\u00abdestructured\u00bb`): `Promise` Estimates the fee for a list of INVOKE transaction #### Parameters | Name | Type | Description | | :--------------- | :------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------- | | `invocations` | [`AccountInvocations`](../namespaces/types.md#accountinvocations) | AccountInvocations - Complete invocations array with account details | | `\u00abdestructured\u00bb` | [`getEstimateFeeBulkOptions`](../namespaces/types.md#getestimatefeebulkoptions) | getEstimateFeeBulkOptions - (optional) blockIdentifier - BlockIdentifier - (optional) skipValidate - boolean (default false) | #### Returns `Promise` the estimated fee #### Implementation of [ProviderInterface](ProviderInterface.md).[getEstimateFeeBulk](ProviderInterface.md#getestimatefeebulk) #### Defined in [src/provider/sequencer.ts:472]( --- ### getCode \u25b8 **getCode**(`contractAddress`, `blockIdentifier?`): `Promise` **`Deprecated`** The method should not be used #### Parameters | Name | Type | | :---------------- | :---------------------------------------------------------- | | `contractAddress` | `string` | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | #### Returns `Promise` #### Implementation of [ProviderInterface](ProviderInterface.md).[getCode](ProviderInterface.md#getcode) #### Defined in [src/provider/sequencer.ts:484]( --- ### waitForTransaction \u25b8 **waitForTransaction**(`txHash`, `options?`): `Promise` Wait for the transaction to be accepted #### Parameters | Name | Type | Description | | :--------- | :------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------- | | `txHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | transaction hash | | `options?` | [`waitForTransactionOptions`](../namespaces/types.md#waitfortransactionoptions) | waitForTransactionOptions - (optional) retryInterval: number \\| undefined; - (optional) successStates: TransactionStatus[] \\| undefined; | #### Returns `Promise` GetTransactionReceiptResponse #### Implementation of [ProviderInterface](ProviderInterface.md).[waitForTransaction](ProviderInterface.md#waitfortransaction) #### Defined in [src/provider/sequencer.ts:491]( --- ### getTransactionStatus \u25b8 **getTransactionStatus**(`txHash`): `Promise` Gets the status of a transaction. #### Parameters | Name | Type | Description | | :------- | :---------------------------------------------------- | :----------- | | `txHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | BigNumberish | #### Returns `Promise` GetTransactionStatusResponse - the transaction status object #### Defined in [src/provider/sequencer.ts:527]( --- ### getContractAddresses \u25b8 **getContractAddresses**(): `Promise` Gets the smart contract address on the goerli testnet. #### Returns `Promise` GetContractAddressesResponse - starknet smart contract addresses #### Defined in [src/provider/sequencer.ts:536]( --- ### getTransactionTrace \u25b8 **getTransactionTrace**(`txHash`): `Promise` Gets the transaction trace from a tx id. #### Parameters | Name | Type | Description | | :------- | :---------------------------------------------------- | :----------- | | `txHash` | [`BigNumberish`](../namespaces/types.md#bignumberish) | BigNumberish | #### Returns `Promise` TransactionTraceResponse - the transaction trace #### Defined in [src/provider/sequencer.ts:545]( --- ### estimateMessageFee \u25b8 **estimateMessageFee**(`\u00abdestructured\u00bb`, `blockIdentifier?`): `Promise` #### Parameters | Name | Type | | :---------------- | :---------------------------------------------------------- | | `\u00abdestructured\u00bb` | [`CallL1Handler`](../namespaces/types.md#calll1handler) | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | #### Returns `Promise` #### Defined in [src/provider/sequencer.ts:552]( --- ### getSimulateTransaction \u25b8 **getSimulateTransaction**(`invocations`, `\u00abdestructured\u00bb`): `Promise` Simulate transaction using Sequencer provider WARNING!: Sequencer will process only first element from invocations array #### Parameters | Name | Type | Description | | :--------------- | :-------------------------------------------------------------------------------------- | :---------------------------------------------------------------- | | `invocations` | [`AccountInvocations`](../namespaces/types.md#accountinvocations) | Array of invocations, but only first invocation will be processed | | `\u00abdestructured\u00bb` | [`getSimulateTransactionOptions`](../namespaces/types.md#getsimulatetransactionoptions) | - | #### Returns `Promise` #### Implementation of [ProviderInterface](ProviderInterface.md).[getSimulateTransaction](ProviderInterface.md#getsimulatetransaction) #### Defined in [src/provider/sequencer.ts:575]( --- ### getStateUpdate \u25b8 **getStateUpdate**(`blockIdentifier?`): `Promise` Gets the state changes in a specific block #### Parameters | Name | Type | Description | | :---------------- | :---------------------------------------------------------- | :--------------- | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | block identifier | #### Returns `Promise` StateUpdateResponse #### Implementation of [ProviderInterface](ProviderInterface.md).[getStateUpdate](ProviderInterface.md#getstateupdate) #### Defined in [src/provider/sequencer.ts:602]( --- ### getBlockTraces \u25b8 **getBlockTraces**(`blockIdentifier?`): `Promise` #### Parameters | Name | Type | | :---------------- | :---------------------------------------------------------- | | `blockIdentifier` | [`BlockIdentifier`](../namespaces/types.md#blockidentifier) | #### Returns `Promise` #### Defined in [src/provider/sequencer.ts:612]( --- ### getStarkName \u25b8 **getStarkName**(`address`, `StarknetIdContract?`): `Promise` #### Parameters | Name | Type | | :-------------------- | :---------------------------------------------------- | | `address` | [`BigNumberish`](../namespaces/types.md#bignumberish) | | `StarknetIdContract?` | `string` | #### Returns `Promise` #### Defined in [src/provider/sequencer.ts:619]( --- ### getAddressFromStarkName \u25b8 **getAddressFromStarkName**(`name`, `StarknetIdContract?`): `Promise` #### Parameters | Name | Type | | :-------------------- | :------- | | `name` | `string` | | `StarknetIdContract?` | `string` | #### Returns `Promise` #### Defined in [src/provider/sequencer.ts:623]( --- ### buildTransaction \u25b8 **buildTransaction**(`invocation`, `versionType?`): [`AccountTransactionItem`](../namespaces/types.Sequencer.md#accounttransactionitem) Build Single AccountTransaction from Single AccountInvocation #### Parameters | Name | Type | Description | | :------------- | :---------------------------------------------------------------------- | :---------------------------------------------------------- | | `invocation` | [`AccountInvocationItem`](../namespaces/types.md#accountinvocationitem) | AccountInvocationItem | | `versionType?` | `\"fee\"` \\| `\"transaction\"` | 'fee' \\| 'transaction' - used to determine default versions | #### Returns [`AccountTransactionItem`](../namespaces/types.Sequencer.md#accounttransactionitem) AccountTransactionItem #### Defined in [src/provider/sequencer.ts:633]("}
{"title": "Signer.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'Signer' title: 'Class: Signer' sidebar_label: 'Signer' sidebar_position: 0 custom_edit_url: null --- ## Implements - [`SignerInterface`](SignerInterface.md) ## Constructors ### constructor \u2022 **new Signer**(`pk?`) #### Parameters | Name | Type | | :--- | :----------------------- | | `pk` | `string` \\| `Uint8Array` | #### Defined in [src/signer/default.ts:26]( ## Properties ### pk \u2022 `Protected` **pk**: `string` \\| `Uint8Array` #### Defined in [src/signer/default.ts:24]( ## Methods ### getPubKey \u25b8 **getPubKey**(): `Promise` Method to get the public key of the signer #### Returns `Promise` public key of signer as hex string with 0x prefix #### Implementation of [SignerInterface](SignerInterface.md).[getPubKey](SignerInterface.md#getpubkey) #### Defined in [src/signer/default.ts:30]( --- ### signMessage \u25b8 **signMessage**(`typedData`, `accountAddress`): `Promise` Sign an JSON object for off-chain usage with the starknet private key and return the signature This adds a message prefix so it cant be interchanged with transactions **`Throws`** if the JSON object is not a valid JSON #### Parameters | Name | Type | Description | | :--------------- | :---------------------------------------------- | :----------------------- | | `typedData` | [`TypedData`](../interfaces/types.TypedData.md) | JSON object to be signed | | `accountAddress` | `string` | account | #### Returns `Promise` the signature of the JSON object #### Implementation of [SignerInterface](SignerInterface.md).[signMessage](SignerInterface.md#signmessage) #### Defined in [src/signer/default.ts:34]( --- ### signTransaction \u25b8 **signTransaction**(`transactions`, `transactionsDetail`, `abis?`): `Promise` Signs a transaction with the starknet private key and returns the signature #### Parameters | Name | Type | | :------------------- | :---------------------------------------------------------------------------- | | `transactions` | [`Call`](../namespaces/types.md#call)[] | | `transactionsDetail` | [`InvocationsSignerDetails`](../interfaces/types.InvocationsSignerDetails.md) | | `abis?` | [`Abi`](../namespaces/types.md#abi)[] | #### Returns `Promise` signature #### Implementation of [SignerInterface](SignerInterface.md).[signTransaction](SignerInterface.md#signtransaction) #### Defined in [src/signer/default.ts:39]( --- ### signDeployAccountTransaction \u25b8 **signDeployAccountTransaction**(`\u00abdestructured\u00bb`): `Promise` Signs a DEPLOY_ACCOUNT transaction with the starknet private key and returns the signature #### Parameters | Name | Type | Description | | :--------------- | :-------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `\u00abdestructured\u00bb` | [`DeployAccountSignerDetails`](../namespaces/types.md#deployaccountsignerdetails) | contractAddress - the computed address of the contract - constructorCalldata - calldata to be passed in deploy constructor - addressSalt - contract address salt - chainId - the chainId to declare contract on - maxFee - maxFee for the declare transaction - version - transaction version - nonce - Nonce of the declare transaction | #### Returns `Promise` signature #### Implementation of [SignerInterface](SignerInterface.md).[signDeployAccountTransaction](SignerInterface.md#signdeployaccounttransaction) #### Defined in [src/signer/default.ts:63]( --- ### signDeclareTransaction \u25b8 **signDeclareTransaction**(`\u00abdestructured\u00bb`): `Promise` Signs a DECLARE transaction with the starknet private key and returns the signature #### Parameters | Name | Type | Description | | :--------------- | :-------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `\u00abdestructured\u00bb` | [`DeclareSignerDetails`](../interfaces/types.DeclareSignerDetails.md) | classHash - computed class hash. Will be replaced by ContractClass in future once class hash is present in CompiledContract - senderAddress - the address of the sender - chainId - the chainId to declare contract on - maxFee - maxFee for the declare transaction - version - transaction version - nonce - Nonce of the declare transaction | #### Returns `Promise` signature #### Implementation of [SignerInterface](SignerInterface.md).[signDeclareTransaction](SignerInterface.md#signdeclaretransaction) #### Defined in [src/signer/default.ts:87]("}
{"title": "SignerInterface.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'SignerInterface' title: 'Class: SignerInterface' sidebar_label: 'SignerInterface' sidebar_position: 0 custom_edit_url: null --- ## Implemented by - [`Signer`](Signer.md) ## Constructors ### constructor \u2022 **new SignerInterface**() ## Methods ### getPubKey \u25b8 `Abstract` **getPubKey**(): `Promise` Method to get the public key of the signer #### Returns `Promise` public key of signer as hex string with 0x prefix #### Defined in [src/signer/interface.ts:17]( --- ### signMessage \u25b8 `Abstract` **signMessage**(`typedData`, `accountAddress`): `Promise` Sign an JSON object for off-chain usage with the starknet private key and return the signature This adds a message prefix so it cant be interchanged with transactions **`Throws`** if the JSON object is not a valid JSON #### Parameters | Name | Type | Description | | :--------------- | :---------------------------------------------- | :----------------------- | | `typedData` | [`TypedData`](../interfaces/types.TypedData.md) | JSON object to be signed | | `accountAddress` | `string` | account | #### Returns `Promise` the signature of the JSON object #### Defined in [src/signer/interface.ts:28]( --- ### signTransaction \u25b8 `Abstract` **signTransaction**(`transactions`, `transactionsDetail`, `abis?`): `Promise` Signs a transaction with the starknet private key and returns the signature #### Parameters | Name | Type | | :------------------- | :---------------------------------------------------------------------------- | | `transactions` | [`Call`](../namespaces/types.md#call)[] | | `transactionsDetail` | [`InvocationsSignerDetails`](../interfaces/types.InvocationsSignerDetails.md) | | `abis?` | [`Abi`](../namespaces/types.md#abi)[] | #### Returns `Promise` signature #### Defined in [src/signer/interface.ts:41]( --- ### signDeployAccountTransaction \u25b8 `Abstract` **signDeployAccountTransaction**(`transaction`): `Promise` Signs a DEPLOY_ACCOUNT transaction with the starknet private key and returns the signature #### Parameters | Name | Type | Description | | :------------ | :-------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `transaction` | [`DeployAccountSignerDetails`](../namespaces/types.md#deployaccountsignerdetails) | contractAddress - the computed address of the contract - constructorCalldata - calldata to be passed in deploy constructor - addressSalt - contract address salt - chainId - the chainId to declare contract on - maxFee - maxFee for the declare transaction - version - transaction version - nonce - Nonce of the declare transaction | #### Returns `Promise` signature #### Defined in [src/signer/interface.ts:60]( --- ### signDeclareTransaction \u25b8 `Abstract` **signDeclareTransaction**(`transaction`): `Promise` Signs a DECLARE transaction with the starknet private key and returns the signature #### Parameters | Name | Type | Description | | :------------ | :-------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `transaction` | [`DeclareSignerDetails`](../interfaces/types.DeclareSignerDetails.md) | classHash - computed class hash. Will be replaced by ContractClass in future once class hash is present in CompiledContract - senderAddress - the address of the sender - chainId - the chainId to declare contract on - maxFee - maxFee for the declare transaction - version - transaction version - nonce - Nonce of the declare transaction | #### Returns `Promise` signature #### Defined in [src/signer/interface.ts:76]("}
{"title": "merkle.MerkleTree.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'merkle.MerkleTree' title: 'Class: MerkleTree' sidebar_label: 'MerkleTree' custom_edit_url: null --- [merkle](../namespaces/merkle.md).MerkleTree ## Constructors ### constructor \u2022 **new MerkleTree**(`leafHashes`) #### Parameters | Name | Type | | :----------- | :--------- | | `leafHashes` | `string`[] | #### Defined in [src/utils/merkle.ts:11]( ## Properties ### leaves \u2022 **leaves**: `string`[] #### Defined in [src/utils/merkle.ts:5]( --- ### branches \u2022 **branches**: `string`[][] = `[]` #### Defined in [src/utils/merkle.ts:7]( --- ### root \u2022 **root**: `string` #### Defined in [src/utils/merkle.ts:9]( ## Methods ### hash \u25b8 `Static` **hash**(`a`, `b`): `string` #### Parameters | Name | Type | | :--- | :------- | | `a` | `string` | | `b` | `string` | #### Returns `string` #### Defined in [src/utils/merkle.ts:34]( --- ### build \u25b8 `Private` **build**(`leaves`): `string` #### Parameters | Name | Type | | :------- | :--------- | | `leaves` | `string`[] | #### Returns `string` #### Defined in [src/utils/merkle.ts:16]( --- ### getProof \u25b8 **getProof**(`leaf`, `branch?`, `hashPath?`): `string`[] #### Parameters | Name | Type | Default value | | :--------- | :--------- | :------------ | | `leaf` | `string` | `undefined` | | `branch` | `string`[] | `undefined` | | `hashPath` | `string`[] | `[]` | #### Returns `string`[] #### Defined in [src/utils/merkle.ts:39]("}
{"title": "EntryPointType.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'EntryPointType' title: 'Enumeration: EntryPointType' sidebar_label: 'EntryPointType' sidebar_position: 0 custom_edit_url: null --- ## Enumeration Members ### EXTERNAL \u2022 **EXTERNAL** = `\"EXTERNAL\"` #### Defined in [src/types/lib/contract/index.ts:11]( --- ### L1_HANDLER \u2022 **L1_HANDLER** = `\"L1_HANDLER\"` #### Defined in [src/types/lib/contract/index.ts:12]( --- ### CONSTRUCTOR \u2022 **CONSTRUCTOR** = `\"CONSTRUCTOR\"` #### Defined in [src/types/lib/contract/index.ts:13]("}
{"title": "RPC.TransactionType.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'RPC.TransactionType' title: 'Enumeration: TransactionType' sidebar_label: 'TransactionType' custom_edit_url: null --- [RPC](../namespaces/RPC.md).TransactionType ## Enumeration Members ### DECLARE \u2022 **DECLARE** = `\"DECLARE\"` #### Defined in [src/types/api/rpc.ts:48]( --- ### DEPLOY \u2022 **DEPLOY** = `\"DEPLOY\"` #### Defined in [src/types/api/rpc.ts:49]( --- ### DEPLOY_ACCOUNT \u2022 **DEPLOY_ACCOUNT** = `\"DEPLOY_ACCOUNT\"` #### Defined in [src/types/api/rpc.ts:50]( --- ### INVOKE \u2022 **INVOKE** = `\"INVOKE\"` #### Defined in [src/types/api/rpc.ts:51]( --- ### L1_HANDLER \u2022 **L1_HANDLER** = `\"L1_HANDLER\"` #### Defined in [src/types/api/rpc.ts:52]("}
{"title": "TransactionStatus.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'TransactionStatus' title: 'Enumeration: TransactionStatus' sidebar_label: 'TransactionStatus' sidebar_position: 0 custom_edit_url: null --- ## Enumeration Members ### NOT_RECEIVED \u2022 **NOT_RECEIVED** = `\"NOT_RECEIVED\"` #### Defined in [src/types/lib/index.ts:120]( --- ### RECEIVED \u2022 **RECEIVED** = `\"RECEIVED\"` #### Defined in [src/types/lib/index.ts:121]( --- ### PENDING \u2022 **PENDING** = `\"PENDING\"` #### Defined in [src/types/lib/index.ts:122]( --- ### ACCEPTED_ON_L2 \u2022 **ACCEPTED_ON_L2** = `\"ACCEPTED_ON_L2\"` #### Defined in [src/types/lib/index.ts:123]( --- ### ACCEPTED_ON_L1 \u2022 **ACCEPTED_ON_L1** = `\"ACCEPTED_ON_L1\"` #### Defined in [src/types/lib/index.ts:124]( --- ### REJECTED \u2022 **REJECTED** = `\"REJECTED\"` #### Defined in [src/types/lib/index.ts:125]("}
{"title": "TransactionType.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'TransactionType' title: 'Enumeration: TransactionType' sidebar_label: 'TransactionType' sidebar_position: 0 custom_edit_url: null --- ## Enumeration Members ### INVOKE \u2022 **INVOKE** = `\"INVOKE_FUNCTION\"` #### Defined in [src/types/lib/index.ts:154]( --- ### DECLARE \u2022 **DECLARE** = `\"DECLARE\"` #### Defined in [src/types/lib/index.ts:155]( --- ### DEPLOY \u2022 **DEPLOY** = `\"DEPLOY\"` #### Defined in [src/types/lib/index.ts:156]( --- ### DEPLOY_ACCOUNT \u2022 **DEPLOY_ACCOUNT** = `\"DEPLOY_ACCOUNT\"` #### Defined in [src/types/lib/index.ts:157]("}
{"title": "cairo.Uint.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'cairo.Uint' title: 'Enumeration: Uint' sidebar_label: 'Uint' custom_edit_url: null --- [cairo](../namespaces/cairo.md).Uint ## Enumeration Members ### u8 \u2022 **u8** = `\"core::u8\"` #### Defined in [src/utils/calldata/cairo.ts:7]( --- ### u16 \u2022 **u16** = `\"core::u16\"` #### Defined in [src/utils/calldata/cairo.ts:8]( --- ### u32 \u2022 **u32** = `\"core::u32\"` #### Defined in [src/utils/calldata/cairo.ts:9]( --- ### u64 \u2022 **u64** = `\"core::u64\"` #### Defined in [src/utils/calldata/cairo.ts:10]( --- ### u128 \u2022 **u128** = `\"core::u128\"` #### Defined in [src/utils/calldata/cairo.ts:11]( --- ### u256 \u2022 **u256** = `\"core::u256\"` #### Defined in [src/utils/calldata/cairo.ts:12]("}
{"title": "constants.BaseUrl.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'constants.BaseUrl' title: 'Enumeration: BaseUrl' sidebar_label: 'BaseUrl' custom_edit_url: null --- [constants](../namespaces/constants.md).BaseUrl ## Enumeration Members ### SN_MAIN \u2022 **SN_MAIN** = `\" #### Defined in [src/constants.ts:9]( --- ### SN_GOERLI \u2022 **SN_GOERLI** = `\" #### Defined in [src/constants.ts:10]( --- ### SN_GOERLI2 \u2022 **SN_GOERLI2** = `\" #### Defined in [src/constants.ts:11]("}
{"title": "constants.NetworkName.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'constants.NetworkName' title: 'Enumeration: NetworkName' sidebar_label: 'NetworkName' custom_edit_url: null --- [constants](../namespaces/constants.md).NetworkName ## Enumeration Members ### SN_MAIN \u2022 **SN_MAIN** = `\"SN_MAIN\"` #### Defined in [src/constants.ts:15]( --- ### SN_GOERLI \u2022 **SN_GOERLI** = `\"SN_GOERLI\"` #### Defined in [src/constants.ts:16]( --- ### SN_GOERLI2 \u2022 **SN_GOERLI2** = `\"SN_GOERLI2\"` #### Defined in [src/constants.ts:17]("}
{"title": "constants.StarknetChainId.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'constants.StarknetChainId' title: 'Enumeration: StarknetChainId' sidebar_label: 'StarknetChainId' custom_edit_url: null --- [constants](../namespaces/constants.md).StarknetChainId ## Enumeration Members ### SN_MAIN \u2022 **SN_MAIN** = `\"0x534e5f4d41494e\"` #### Defined in [src/constants.ts:21]( --- ### SN_GOERLI \u2022 **SN_GOERLI** = `\"0x534e5f474f45524c49\"` #### Defined in [src/constants.ts:22]( --- ### SN_GOERLI2 \u2022 **SN_GOERLI2** = `\"0x534e5f474f45524c4932\"` #### Defined in [src/constants.ts:23]("}
{"title": "constants.TransactionHashPrefix.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'constants.TransactionHashPrefix' title: 'Enumeration: TransactionHashPrefix' sidebar_label: 'TransactionHashPrefix' custom_edit_url: null --- [constants](../namespaces/constants.md).TransactionHashPrefix ## Enumeration Members ### DECLARE \u2022 **DECLARE** = `\"0x6465636c617265\"` #### Defined in [src/constants.ts:27]( --- ### DEPLOY \u2022 **DEPLOY** = `\"0x6465706c6f79\"` #### Defined in [src/constants.ts:28]( --- ### DEPLOY_ACCOUNT \u2022 **DEPLOY_ACCOUNT** = `\"0x6465706c6f795f6163636f756e74\"` #### Defined in [src/constants.ts:29]( --- ### INVOKE \u2022 **INVOKE** = `\"0x696e766f6b65\"` #### Defined in [src/constants.ts:30]( --- ### L1_HANDLER \u2022 **L1_HANDLER** = `\"0x6c315f68616e646c6572\"` #### Defined in [src/constants.ts:31]("}
{"title": "starknetId.StarknetIdContract.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'starknetId.StarknetIdContract' title: 'Enumeration: StarknetIdContract' sidebar_label: 'StarknetIdContract' custom_edit_url: null --- [starknetId](../namespaces/starknetId.md).StarknetIdContract ## Enumeration Members ### MAINNET \u2022 **MAINNET** = `\"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\"` #### Defined in [src/utils/starknetId.ts:104]( --- ### TESTNET \u2022 **TESTNET** = `\"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\"` #### Defined in [src/utils/starknetId.ts:105]("}
{"title": "types.BlockStatus.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.BlockStatus' title: 'Enumeration: BlockStatus' sidebar_label: 'BlockStatus' custom_edit_url: null --- [types](../namespaces/types.md).BlockStatus ## Enumeration Members ### PENDING \u2022 **PENDING** = `\"PENDING\"` #### Defined in [src/types/lib/index.ts:139]( --- ### ACCEPTED_ON_L1 \u2022 **ACCEPTED_ON_L1** = `\"ACCEPTED_ON_L1\"` #### Defined in [src/types/lib/index.ts:140]( --- ### ACCEPTED_ON_L2 \u2022 **ACCEPTED_ON_L2** = `\"ACCEPTED_ON_L2\"` #### Defined in [src/types/lib/index.ts:141]( --- ### REJECTED \u2022 **REJECTED** = `\"REJECTED\"` #### Defined in [src/types/lib/index.ts:142]("}
{"title": "types.BlockTag.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.BlockTag' title: 'Enumeration: BlockTag' sidebar_label: 'BlockTag' custom_edit_url: null --- [types](../namespaces/types.md).BlockTag ## Enumeration Members ### pending \u2022 **pending** = `\"pending\"` #### Defined in [src/types/lib/index.ts:146]( --- ### latest \u2022 **latest** = `\"latest\"` #### Defined in [src/types/lib/index.ts:147]("}
{"title": "types.EntryPointType.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.EntryPointType' title: 'Enumeration: EntryPointType' sidebar_label: 'EntryPointType' custom_edit_url: null --- [types](../namespaces/types.md).EntryPointType ## Enumeration Members ### EXTERNAL \u2022 **EXTERNAL** = `\"EXTERNAL\"` #### Defined in [src/types/lib/contract/index.ts:23]( --- ### L1_HANDLER \u2022 **L1_HANDLER** = `\"L1_HANDLER\"` #### Defined in [src/types/lib/contract/index.ts:24]( --- ### CONSTRUCTOR \u2022 **CONSTRUCTOR** = `\"CONSTRUCTOR\"` #### Defined in [src/types/lib/contract/index.ts:25]("}
{"title": "types.RPC.TransactionType.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.RPC.TransactionType' title: 'Enumeration: TransactionType' sidebar_label: 'TransactionType' custom_edit_url: null --- [types](../namespaces/types.md).[RPC](../namespaces/types.RPC.md).TransactionType ## Enumeration Members ### DECLARE \u2022 **DECLARE** = `\"DECLARE\"` #### Defined in [src/types/api/rpc.ts:51]( --- ### DEPLOY \u2022 **DEPLOY** = `\"DEPLOY\"` #### Defined in [src/types/api/rpc.ts:52]( --- ### DEPLOY_ACCOUNT \u2022 **DEPLOY_ACCOUNT** = `\"DEPLOY_ACCOUNT\"` #### Defined in [src/types/api/rpc.ts:53]( --- ### INVOKE \u2022 **INVOKE** = `\"INVOKE\"` #### Defined in [src/types/api/rpc.ts:54]( --- ### L1_HANDLER \u2022 **L1_HANDLER** = `\"L1_HANDLER\"` #### Defined in [src/types/api/rpc.ts:55]("}
{"title": "types.SIMULATION_FLAG.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.SIMULATION_FLAG' title: 'Enumeration: SIMULATION_FLAG' sidebar_label: 'SIMULATION_FLAG' custom_edit_url: null --- [types](../namespaces/types.md).SIMULATION_FLAG ## Enumeration Members ### SKIP_VALIDATE \u2022 **SKIP_VALIDATE** = `0` #### Defined in [src/types/account.ts:59]( --- ### SKIP_EXECUTE \u2022 **SKIP_EXECUTE** = `1` #### Defined in [src/types/account.ts:60]("}
{"title": "types.TransactionStatus.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.TransactionStatus' title: 'Enumeration: TransactionStatus' sidebar_label: 'TransactionStatus' custom_edit_url: null --- [types](../namespaces/types.md).TransactionStatus ## Enumeration Members ### NOT_RECEIVED \u2022 **NOT_RECEIVED** = `\"NOT_RECEIVED\"` #### Defined in [src/types/lib/index.ts:131]( --- ### RECEIVED \u2022 **RECEIVED** = `\"RECEIVED\"` #### Defined in [src/types/lib/index.ts:132]( --- ### ACCEPTED_ON_L2 \u2022 **ACCEPTED_ON_L2** = `\"ACCEPTED_ON_L2\"` #### Defined in [src/types/lib/index.ts:133]( --- ### ACCEPTED_ON_L1 \u2022 **ACCEPTED_ON_L1** = `\"ACCEPTED_ON_L1\"` #### Defined in [src/types/lib/index.ts:134]( --- ### REJECTED \u2022 **REJECTED** = `\"REJECTED\"` #### Defined in [src/types/lib/index.ts:135]("}
{"title": "types.TransactionType.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.TransactionType' title: 'Enumeration: TransactionType' sidebar_label: 'TransactionType' custom_edit_url: null --- [types](../namespaces/types.md).TransactionType ## Enumeration Members ### DECLARE \u2022 **DECLARE** = `\"DECLARE\"` #### Defined in [src/types/lib/index.ts:124]( --- ### DEPLOY \u2022 **DEPLOY** = `\"DEPLOY\"` #### Defined in [src/types/lib/index.ts:125]( --- ### DEPLOY_ACCOUNT \u2022 **DEPLOY_ACCOUNT** = `\"DEPLOY_ACCOUNT\"` #### Defined in [src/types/lib/index.ts:126]( --- ### INVOKE \u2022 **INVOKE** = `\"INVOKE_FUNCTION\"` #### Defined in [src/types/lib/index.ts:127]("}
{"title": "types.Uint.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.Uint' title: 'Enumeration: Uint' sidebar_label: 'Uint' custom_edit_url: null --- [types](../namespaces/types.md).Uint ## Enumeration Members ### u8 \u2022 **u8** = `\"core::u8\"` #### Defined in [src/types/calldata.ts:8]( --- ### u16 \u2022 **u16** = `\"core::u16\"` #### Defined in [src/types/calldata.ts:9]( --- ### u32 \u2022 **u32** = `\"core::u32\"` #### Defined in [src/types/calldata.ts:10]( --- ### u64 \u2022 **u64** = `\"core::u64\"` #### Defined in [src/types/calldata.ts:11]( --- ### u128 \u2022 **u128** = `\"core::u128\"` #### Defined in [src/types/calldata.ts:12]( --- ### u256 \u2022 **u256** = `\"core::u256\"` #### Defined in [src/types/calldata.ts:13]("}
{"title": "types.ValidateType.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.ValidateType' title: 'Enumeration: ValidateType' sidebar_label: 'ValidateType' custom_edit_url: null --- [types](../namespaces/types.md).ValidateType ## Enumeration Members ### DEPLOY \u2022 **DEPLOY** = `\"DEPLOY\"` #### Defined in [src/types/calldata.ts:2]( --- ### CALL \u2022 **CALL** = `\"CALL\"` #### Defined in [src/types/calldata.ts:3]( --- ### INVOKE \u2022 **INVOKE** = `\"INVOKE\"` #### Defined in [src/types/calldata.ts:4]("}
{"title": "index.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'index' title: 'Starknet.js API' sidebar_label: 'Readme' sidebar_position: 0 custom_edit_url: null --- This API is based on the [Starknet.js V3]( Interface write up by [Janek]( of [Argent]( ## Provider The Provider [**API**](./classes/Provider.md) allows you to interact with the Starknet network, without signing transactions or messages. Typically, these are _read_ calls on the blockchain. Guide is [**here**](../guides/connect_network.md). ## Account An Account extends [`Provider`](/docs/API/provider) and inherits all of its methods. It also introduces new methods that allow Accounts to create and verify signatures with a custom [`Signer`](/docs/API/signer), declare and deploy Contract and deploy new Account This [**API**](./classes/Account.md) is the primary way to interact with an account contract on Starknet. Guide is [**here**](../guides/create_account.md). ## Contract Contracts [**API**](./classes/Contract.md) can do data transformations in JavaScript based on an ABI. They can also call and invoke to Starknet through a provided Signer. Contracts allow you to transform Cairo values, like `Uint256` to `BigNumber`. It could also allow users to pass their own transformers, similar to `JSON.parse`. Guide is [**here**](../guides/create_contract.md). ## Signer The Signer [**API**](./classes/Signer.md) allows you to sign transactions and messages, and also allows you to get the public key. ## Utils Util functions are provided so you can use various low level functions in your application : ### [elliptic curve](./namespaces/ec.md) ### [hash](./namespaces/hash.md) ### [num](./namespaces/num.md) ### [encode](./namespaces/encode.md) ### [merkle](./namespaces/merkle.md) ### [shortString](./namespaces/shortString.md) ### [stark](./namespaces/stark.md) ### [uint256](./namespaces/uint256.md)"}
{"title": "CallStruct.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'CallStruct' title: 'Interface: CallStruct' sidebar_label: 'CallStruct' sidebar_position: 0 custom_edit_url: null --- ## Properties ### to \u2022 **to**: `string` #### Defined in [src/types/lib/index.ts:181]( --- ### selector \u2022 **selector**: `string` #### Defined in [src/types/lib/index.ts:182]( --- ### calldata \u2022 **calldata**: `string`[] #### Defined in [src/types/lib/index.ts:183]("}
{"title": "CommonTransactionReceiptResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'CommonTransactionReceiptResponse' title: 'Interface: CommonTransactionReceiptResponse' sidebar_label: 'CommonTransactionReceiptResponse' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - **`CommonTransactionReceiptResponse`** \u21b3 [`InvokeTransactionReceiptResponse`](InvokeTransactionReceiptResponse.md) ## Properties ### transaction_hash \u2022 **transaction_hash**: `string` #### Defined in [src/types/provider.ts:72]( --- ### status \u2022 `Optional` **status**: [`Status`](../modules.md#status) #### Defined in [src/types/provider.ts:73]( --- ### actual_fee \u2022 `Optional` **actual_fee**: `string` #### Defined in [src/types/provider.ts:74]( --- ### status_data \u2022 `Optional` **status_data**: `string` #### Defined in [src/types/provider.ts:75]("}
{"title": "CommonTransactionResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'CommonTransactionResponse' title: 'Interface: CommonTransactionResponse' sidebar_label: 'CommonTransactionResponse' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - **`CommonTransactionResponse`** \u21b3 [`InvokeTransactionResponse`](InvokeTransactionResponse.md) \u21b3 [`DeclareTransactionResponse`](DeclareTransactionResponse.md) ## Properties ### transaction_hash \u2022 `Optional` **transaction_hash**: `string` #### Defined in [src/types/provider.ts:43]( --- ### version \u2022 `Optional` **version**: `string` #### Defined in [src/types/provider.ts:44]( --- ### signature \u2022 `Optional` **signature**: [`Signature`](../modules.md#signature) #### Defined in [src/types/provider.ts:45]( --- ### max_fee \u2022 `Optional` **max_fee**: `string` #### Defined in [src/types/provider.ts:46]( --- ### nonce \u2022 `Optional` **nonce**: `string` #### Defined in [src/types/provider.ts:47]("}
{"title": "ContractEntryPoint.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'ContractEntryPoint' title: 'Interface: ContractEntryPoint' sidebar_label: 'ContractEntryPoint' sidebar_position: 0 custom_edit_url: null --- ## Properties ### offset \u2022 **offset**: `string` #### Defined in [src/types/provider.ts:58]( --- ### selector \u2022 **selector**: `string` #### Defined in [src/types/provider.ts:59]("}
{"title": "DeclareContractResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'DeclareContractResponse' title: 'Interface: DeclareContractResponse' sidebar_label: 'DeclareContractResponse' sidebar_position: 0 custom_edit_url: null --- ## Properties ### transaction_hash \u2022 **transaction_hash**: `string` #### Defined in [src/types/provider.ts:115]( --- ### class_hash \u2022 **class_hash**: `string` #### Defined in [src/types/provider.ts:116]("}
{"title": "DeclareSignerDetails.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'DeclareSignerDetails' title: 'Interface: DeclareSignerDetails' sidebar_label: 'DeclareSignerDetails' sidebar_position: 0 custom_edit_url: null --- ## Properties ### classHash \u2022 **classHash**: `string` #### Defined in [src/types/signer.ts:12]( --- ### senderAddress \u2022 **senderAddress**: `string` #### Defined in [src/types/signer.ts:13]( --- ### chainId \u2022 **chainId**: [`StarknetChainId`](../enums/constants.StarknetChainId.md) #### Defined in [src/types/signer.ts:14]( --- ### maxFee \u2022 **maxFee**: [`BigNumberish`](../namespaces/num.md#bignumberish) #### Defined in [src/types/signer.ts:15]( --- ### version \u2022 **version**: [`BigNumberish`](../namespaces/num.md#bignumberish) #### Defined in [src/types/signer.ts:16]( --- ### nonce \u2022 **nonce**: [`BigNumberish`](../namespaces/num.md#bignumberish) #### Defined in [src/types/signer.ts:17]( --- ### compiledClassHash \u2022 `Optional` **compiledClassHash**: `string` #### Defined in [src/types/signer.ts:18]("}
{"title": "DeclareTransactionResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'DeclareTransactionResponse' title: 'Interface: DeclareTransactionResponse' sidebar_label: 'DeclareTransactionResponse' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - [`CommonTransactionResponse`](CommonTransactionResponse.md) \u21b3 **`DeclareTransactionResponse`** ## Properties ### contract_class \u2022 `Optional` **contract_class**: `any` #### Defined in [src/types/provider.ts:63]( --- ### sender_address \u2022 `Optional` **sender_address**: `string` #### Defined in [src/types/provider.ts:64]( --- ### transaction_hash \u2022 `Optional` **transaction_hash**: `string` #### Inherited from [CommonTransactionResponse](CommonTransactionResponse.md).[transaction_hash](CommonTransactionResponse.md#transaction_hash) #### Defined in [src/types/provider.ts:43]( --- ### version \u2022 `Optional` **version**: `string` #### Inherited from [CommonTransactionResponse](CommonTransactionResponse.md).[version](CommonTransactionResponse.md#version) #### Defined in [src/types/provider.ts:44]( --- ### signature \u2022 `Optional` **signature**: [`Signature`](../modules.md#signature) #### Inherited from [CommonTransactionResponse](CommonTransactionResponse.md).[signature](CommonTransactionResponse.md#signature) #### Defined in [src/types/provider.ts:45]( --- ### max_fee \u2022 `Optional` **max_fee**: `string` #### Inherited from [CommonTransactionResponse](CommonTransactionResponse.md).[max_fee](CommonTransactionResponse.md#max_fee) #### Defined in [src/types/provider.ts:46]( --- ### nonce \u2022 `Optional` **nonce**: `string` #### Inherited from [CommonTransactionResponse](CommonTransactionResponse.md).[nonce](CommonTransactionResponse.md#nonce) #### Defined in [src/types/provider.ts:47]("}
{"title": "DeployContractResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'DeployContractResponse' title: 'Interface: DeployContractResponse' sidebar_label: 'DeployContractResponse' sidebar_position: 0 custom_edit_url: null --- ## Properties ### contract_address \u2022 **contract_address**: `string` #### Defined in [src/types/account.ts:22]( --- ### transaction_hash \u2022 **transaction_hash**: `string` #### Defined in [src/types/account.ts:23]("}
{"title": "EstimateFee.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'EstimateFee' title: 'Interface: EstimateFee' sidebar_label: 'EstimateFee' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - [`EstimateFeeResponse`](EstimateFeeResponse.md) \u21b3 **`EstimateFee`** ## Properties ### suggestedMaxFee \u2022 **suggestedMaxFee**: `bigint` #### Overrides [EstimateFeeResponse](EstimateFeeResponse.md).[suggestedMaxFee](EstimateFeeResponse.md#suggestedmaxfee) #### Defined in [src/types/account.ts:10]( --- ### overall_fee \u2022 **overall_fee**: `bigint` #### Inherited from [EstimateFeeResponse](EstimateFeeResponse.md).[overall_fee](EstimateFeeResponse.md#overall_fee) #### Defined in [src/types/provider.ts:104]( --- ### gas_consumed \u2022 `Optional` **gas_consumed**: `bigint` #### Inherited from [EstimateFeeResponse](EstimateFeeResponse.md).[gas_consumed](EstimateFeeResponse.md#gas_consumed) #### Defined in [src/types/provider.ts:105]( --- ### gas_price \u2022 `Optional` **gas_price**: `bigint` #### Inherited from [EstimateFeeResponse](EstimateFeeResponse.md).[gas_price](EstimateFeeResponse.md#gas_price) #### Defined in [src/types/provider.ts:106]("}
{"title": "EstimateFeeDetails.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'EstimateFeeDetails' title: 'Interface: EstimateFeeDetails' sidebar_label: 'EstimateFeeDetails' sidebar_position: 0 custom_edit_url: null --- ## Properties ### nonce \u2022 `Optional` **nonce**: [`BigNumberish`](../namespaces/num.md#bignumberish) #### Defined in [src/types/account.ts:16]( --- ### blockIdentifier \u2022 `Optional` **blockIdentifier**: `BlockIdentifier` #### Defined in [src/types/account.ts:17]( --- ### skipValidate \u2022 `Optional` **skipValidate**: `boolean` #### Defined in [src/types/account.ts:18]("}
{"title": "EstimateFeeResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'EstimateFeeResponse' title: 'Interface: EstimateFeeResponse' sidebar_label: 'EstimateFeeResponse' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - **`EstimateFeeResponse`** \u21b3 [`EstimateFee`](EstimateFee.md) ## Properties ### overall_fee \u2022 **overall_fee**: `bigint` #### Defined in [src/types/provider.ts:104]( --- ### gas_consumed \u2022 `Optional` **gas_consumed**: `bigint` #### Defined in [src/types/provider.ts:105]( --- ### gas_price \u2022 `Optional` **gas_price**: `bigint` #### Defined in [src/types/provider.ts:106]( --- ### suggestedMaxFee \u2022 `Optional` **suggestedMaxFee**: `bigint` #### Defined in [src/types/provider.ts:107]("}
{"title": "Event.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'Event' title: 'Interface: Event' sidebar_label: 'Event' sidebar_position: 0 custom_edit_url: null --- ## Properties ### from_address \u2022 **from_address**: `string` #### Defined in [src/types/provider.ts:84]( --- ### keys \u2022 **keys**: `string`[] #### Defined in [src/types/provider.ts:85]( --- ### data \u2022 **data**: `string`[] #### Defined in [src/types/provider.ts:86]("}
{"title": "GetBlockResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'GetBlockResponse' title: 'Interface: GetBlockResponse' sidebar_label: 'GetBlockResponse' sidebar_position: 0 custom_edit_url: null --- ## Properties ### timestamp \u2022 **timestamp**: `number` #### Defined in [src/types/provider.ts:22]( --- ### block_hash \u2022 **block_hash**: `string` #### Defined in [src/types/provider.ts:23]( --- ### block_number \u2022 **block_number**: `number` #### Defined in [src/types/provider.ts:24]( --- ### new_root \u2022 **new_root**: `string` #### Defined in [src/types/provider.ts:25]( --- ### parent_hash \u2022 **parent_hash**: `string` #### Defined in [src/types/provider.ts:26]( --- ### status \u2022 **status**: [`Status`](../modules.md#status) #### Defined in [src/types/provider.ts:27]( --- ### transactions \u2022 **transactions**: `string`[] #### Defined in [src/types/provider.ts:28]( --- ### gas_price \u2022 `Optional` **gas_price**: `string` #### Defined in [src/types/provider.ts:29]( --- ### sequencer_address \u2022 `Optional` **sequencer_address**: `string` #### Defined in [src/types/provider.ts:30]( --- ### starknet_version \u2022 `Optional` **starknet_version**: `string` #### Defined in [src/types/provider.ts:31]( --- ### transaction_receipts \u2022 `Optional` **transaction_receipts**: `any` #### Defined in [src/types/provider.ts:32]("}
{"title": "GetCodeResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'GetCodeResponse' title: 'Interface: GetCodeResponse' sidebar_label: 'GetCodeResponse' sidebar_position: 0 custom_edit_url: null --- ## Properties ### bytecode \u2022 **bytecode**: [`ByteCode`](../modules.md#bytecode) #### Defined in [src/types/provider.ts:36]("}
{"title": "InvocationsSignerDetails.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'InvocationsSignerDetails' title: 'Interface: InvocationsSignerDetails' sidebar_label: 'InvocationsSignerDetails' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - `Required` \u21b3 **`InvocationsSignerDetails`** ## Properties ### walletAddress \u2022 **walletAddress**: `string` #### Defined in [src/types/signer.ts:6]( --- ### chainId \u2022 **chainId**: [`StarknetChainId`](../enums/constants.StarknetChainId.md) #### Defined in [src/types/signer.ts:7]( --- ### cairoVersion \u2022 **cairoVersion**: [`CairoVersion`](../modules.md#cairoversion) #### Defined in [src/types/signer.ts:8]( --- ### nonce \u2022 **nonce**: [`BigNumberish`](../namespaces/num.md#bignumberish) #### Inherited from Required.nonce #### Defined in [src/types/lib/index.ts:100]( --- ### maxFee \u2022 **maxFee**: [`BigNumberish`](../namespaces/num.md#bignumberish) #### Inherited from Required.maxFee #### Defined in [src/types/lib/index.ts:101]( --- ### version \u2022 **version**: [`BigNumberish`](../namespaces/num.md#bignumberish) #### Inherited from Required.version #### Defined in [src/types/lib/index.ts:102]("}
{"title": "InvokeFunctionResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'InvokeFunctionResponse' title: 'Interface: InvokeFunctionResponse' sidebar_label: 'InvokeFunctionResponse' sidebar_position: 0 custom_edit_url: null --- ## Properties ### transaction_hash \u2022 **transaction_hash**: `string` #### Defined in [src/types/provider.ts:111]("}
{"title": "InvokeTransactionReceiptResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'InvokeTransactionReceiptResponse' title: 'Interface: InvokeTransactionReceiptResponse' sidebar_label: 'InvokeTransactionReceiptResponse' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - [`CommonTransactionReceiptResponse`](CommonTransactionReceiptResponse.md) \u21b3 **`InvokeTransactionReceiptResponse`** ## Properties ### messages_sent \u2022 `Optional` **messages_sent**: [`MessageToL1`](MessageToL1.md)[] **`Deprecated`** Use l2_to_l1_messages #### Defined in [src/types/provider.ts:96]( --- ### events \u2022 `Optional` **events**: [`Event`](Event.md)[] #### Defined in [src/types/provider.ts:97]( --- ### l1_origin_message \u2022 `Optional` **l1_origin_message**: [`MessageToL2`](MessageToL2.md) #### Defined in [src/types/provider.ts:98]( --- ### transaction_hash \u2022 **transaction_hash**: `string` #### Inherited from [CommonTransactionReceiptResponse](CommonTransactionReceiptResponse.md).[transaction_hash](CommonTransactionReceiptResponse.md#transaction_hash) #### Defined in [src/types/provider.ts:72]( --- ### status \u2022 `Optional` **status**: [`Status`](../modules.md#status) #### Inherited from [CommonTransactionReceiptResponse](CommonTransactionReceiptResponse.md).[status](CommonTransactionReceiptResponse.md#status) #### Defined in [src/types/provider.ts:73]( --- ### actual_fee \u2022 `Optional` **actual_fee**: `string` #### Inherited from [CommonTransactionReceiptResponse](CommonTransactionReceiptResponse.md).[actual_fee](CommonTransactionReceiptResponse.md#actual_fee) #### Defined in [src/types/provider.ts:74]( --- ### status_data \u2022 `Optional` **status_data**: `string` #### Inherited from [CommonTransactionReceiptResponse](CommonTransactionReceiptResponse.md).[status_data](CommonTransactionReceiptResponse.md#status_data) #### Defined in [src/types/provider.ts:75]("}
{"title": "InvokeTransactionResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'InvokeTransactionResponse' title: 'Interface: InvokeTransactionResponse' sidebar_label: 'InvokeTransactionResponse' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - [`CommonTransactionResponse`](CommonTransactionResponse.md) \u21b3 **`InvokeTransactionResponse`** ## Properties ### contract_address \u2022 `Optional` **contract_address**: `string` #### Defined in [src/types/provider.ts:51]( --- ### sender_address \u2022 `Optional` **sender_address**: `string` #### Defined in [src/types/provider.ts:52]( --- ### entry_point_selector \u2022 `Optional` **entry_point_selector**: `string` #### Defined in [src/types/provider.ts:53]( --- ### calldata \u2022 **calldata**: [`RawCalldata`](../modules.md#rawcalldata) #### Defined in [src/types/provider.ts:54]( --- ### transaction_hash \u2022 `Optional` **transaction_hash**: `string` #### Inherited from [CommonTransactionResponse](CommonTransactionResponse.md).[transaction_hash](CommonTransactionResponse.md#transaction_hash) #### Defined in [src/types/provider.ts:43]( --- ### version \u2022 `Optional` **version**: `string` #### Inherited from [CommonTransactionResponse](CommonTransactionResponse.md).[version](CommonTransactionResponse.md#version) #### Defined in [src/types/provider.ts:44]( --- ### signature \u2022 `Optional` **signature**: [`Signature`](../modules.md#signature) #### Inherited from [CommonTransactionResponse](CommonTransactionResponse.md).[signature](CommonTransactionResponse.md#signature) #### Defined in [src/types/provider.ts:45]( --- ### max_fee \u2022 `Optional` **max_fee**: `string` #### Inherited from [CommonTransactionResponse](CommonTransactionResponse.md).[max_fee](CommonTransactionResponse.md#max_fee) #### Defined in [src/types/provider.ts:46]( --- ### nonce \u2022 `Optional` **nonce**: `string` #### Inherited from [CommonTransactionResponse](CommonTransactionResponse.md).[nonce](CommonTransactionResponse.md#nonce) #### Defined in [src/types/provider.ts:47]("}
{"title": "MessageToL1.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'MessageToL1' title: 'Interface: MessageToL1' sidebar_label: 'MessageToL1' sidebar_position: 0 custom_edit_url: null --- ## Properties ### to_address \u2022 **to_address**: `string` #### Defined in [src/types/provider.ts:79]( --- ### payload \u2022 **payload**: `string`[] #### Defined in [src/types/provider.ts:80]("}
{"title": "MessageToL2.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'MessageToL2' title: 'Interface: MessageToL2' sidebar_label: 'MessageToL2' sidebar_position: 0 custom_edit_url: null --- ## Properties ### from_address \u2022 **from_address**: `string` #### Defined in [src/types/provider.ts:90]( --- ### payload \u2022 **payload**: `string`[] #### Defined in [src/types/provider.ts:91]("}
{"title": "Program.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'Program' title: 'Interface: Program' sidebar_label: 'Program' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - `Record` \u21b3 **`Program`** ## Properties ### builtins \u2022 **builtins**: `string`[] #### Defined in [src/types/lib/contract/legacy.ts:31]( --- ### data \u2022 **data**: `string`[] #### Defined in [src/types/lib/contract/legacy.ts:32]("}
{"title": "ProviderOptions.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'ProviderOptions' title: 'Interface: ProviderOptions' sidebar_label: 'ProviderOptions' sidebar_position: 0 custom_edit_url: null --- ## Properties ### sequencer \u2022 `Optional` **sequencer**: [`SequencerProviderOptions`](../modules.md#sequencerprovideroptions) #### Defined in [src/provider/default.ts:35]( --- ### rpc \u2022 `Optional` **rpc**: [`RpcProviderOptions`](../modules.md#rpcprovideroptions) #### Defined in [src/provider/default.ts:36]("}
{"title": "Sequencer.InvokeFunctionTransactionResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'Sequencer.InvokeFunctionTransactionResponse' title: 'Interface: InvokeFunctionTransactionResponse' sidebar_label: 'InvokeFunctionTransactionResponse' custom_edit_url: null --- [Sequencer](../namespaces/Sequencer.md).InvokeFunctionTransactionResponse ## Hierarchy - [`InvokeFunctionTransaction`](../namespaces/Sequencer.md#invokefunctiontransaction) \u21b3 **`InvokeFunctionTransactionResponse`** ## Properties ### transaction_hash \u2022 **transaction_hash**: `string` #### Defined in [src/types/api/sequencer.ts:141]( --- ### entry_point_selector \u2022 **entry_point_selector**: `string` #### Defined in [src/types/api/sequencer.ts:142]( --- ### type \u2022 **type**: `\"INVOKE_FUNCTION\"` #### Inherited from InvokeFunctionTransaction.type #### Defined in [src/types/api/sequencer.ts:112]( --- ### sender_address \u2022 **sender_address**: `string` #### Inherited from InvokeFunctionTransaction.sender_address #### Defined in [src/types/api/sequencer.ts:113]( --- ### signature \u2022 `Optional` **signature**: `string`[] #### Inherited from InvokeFunctionTransaction.signature #### Defined in [src/types/api/sequencer.ts:114]( --- ### entry_point_type \u2022 `Optional` **entry_point_type**: [`EXTERNAL`](../enums/EntryPointType.md#external) #### Inherited from InvokeFunctionTransaction.entry_point_type #### Defined in [src/types/api/sequencer.ts:115]( --- ### calldata \u2022 `Optional` **calldata**: [`RawCalldata`](../modules.md#rawcalldata) #### Inherited from InvokeFunctionTransaction.calldata #### Defined in [src/types/api/sequencer.ts:116]( --- ### nonce \u2022 **nonce**: [`BigNumberish`](../namespaces/num.md#bignumberish) #### Inherited from InvokeFunctionTransaction.nonce #### Defined in [src/types/api/sequencer.ts:117]( --- ### max_fee \u2022 `Optional` **max_fee**: [`BigNumberish`](../namespaces/num.md#bignumberish) #### Inherited from InvokeFunctionTransaction.max_fee #### Defined in [src/types/api/sequencer.ts:118]( --- ### version \u2022 `Optional` **version**: [`BigNumberish`](../namespaces/num.md#bignumberish) #### Inherited from InvokeFunctionTransaction.version #### Defined in [src/types/api/sequencer.ts:119]("}
{"title": "StateUpdateResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'StateUpdateResponse' title: 'Interface: StateUpdateResponse' sidebar_label: 'StateUpdateResponse' sidebar_position: 0 custom_edit_url: null --- ## Properties ### block_hash \u2022 **block_hash**: `string` #### Defined in [src/types/provider.ts:154]( --- ### new_root \u2022 **new_root**: `string` #### Defined in [src/types/provider.ts:155]( --- ### old_root \u2022 **old_root**: `string` #### Defined in [src/types/provider.ts:156]( --- ### state_diff \u2022 **state_diff**: `Object` #### Type declaration | Name | Type | | :-------------------------- | :------------------------------------------------------------------------ | | `storage_diffs` | [`StorageDiffs`](../namespaces/RPC.md#storagediffs) | | `declared_contract_hashes?` | [`DeclaredContractHashes`](../namespaces/RPC.md#declaredcontracthashes) | | `deployed_contracts` | [`DeployedContracts`](../namespaces/Sequencer.md#deployedcontracts) | | `nonces` | [`Nonces`](../namespaces/RPC.md#nonces) | | `old_declared_contracts?` | [`OldDeclaredContracts`](../namespaces/Sequencer.md#olddeclaredcontracts) | | `declared_classes?` | [`DeclaredClasses`](../namespaces/Sequencer.md#declaredclasses) | | `replaced_classes?` | [`ReplacedClasses`](../namespaces/Sequencer.md#replacedclasses) | #### Defined in [src/types/provider.ts:157]("}
{"title": "TransactionSimulation.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'TransactionSimulation' title: 'Interface: TransactionSimulation' sidebar_label: 'TransactionSimulation' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - [`TransactionSimulationResponse`](TransactionSimulationResponse.md) \u21b3 **`TransactionSimulation`** ## Properties ### fee_estimation \u2022 **fee_estimation**: [`EstimateFee`](EstimateFee.md) #### Overrides [TransactionSimulationResponse](TransactionSimulationResponse.md).[fee_estimation](TransactionSimulationResponse.md#fee_estimation) #### Defined in [src/types/account.ts:51]( --- ### trace \u2022 **trace**: [`TransactionTraceResponse`](../modules.md#transactiontraceresponse) #### Inherited from [TransactionSimulationResponse](TransactionSimulationResponse.md).[trace](TransactionSimulationResponse.md#trace) #### Defined in [src/types/provider.ts:148]("}
{"title": "TransactionSimulationResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'TransactionSimulationResponse' title: 'Interface: TransactionSimulationResponse' sidebar_label: 'TransactionSimulationResponse' sidebar_position: 0 custom_edit_url: null --- ## Hierarchy - **`TransactionSimulationResponse`** \u21b3 [`TransactionSimulation`](TransactionSimulation.md) ## Properties ### trace \u2022 **trace**: [`TransactionTraceResponse`](../modules.md#transactiontraceresponse) #### Defined in [src/types/provider.ts:148]( --- ### fee_estimation \u2022 **fee_estimation**: [`EstimateFeeResponse`](EstimateFeeResponse.md) #### Defined in [src/types/provider.ts:149]("}
{"title": "ec.weierstrass.ProjConstructor.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'ec.weierstrass.ProjConstructor' title: 'Interface: ProjConstructor' sidebar_label: 'ProjConstructor' custom_edit_url: null --- [ec](../namespaces/ec.md).[weierstrass](../namespaces/ec.weierstrass.md).ProjConstructor ## Type parameters | Name | | :--- | | `T` | ## Hierarchy - `GroupConstructor`\\> \u21b3 **`ProjConstructor`** ## Constructors ### constructor \u2022 **new ProjConstructor**(`x`, `y`, `z`) #### Parameters | Name | Type | | :--- | :--- | | `x` | `T` | | `y` | `T` | | `z` | `T` | #### Inherited from GroupConstructor\\>.constructor #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:76 ## Properties ### BASE \u2022 **BASE**: [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Inherited from GroupConstructor.BASE #### Defined in node_modules/@noble/curves/abstract/curve.d.ts:19 --- ### ZERO \u2022 **ZERO**: [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Inherited from GroupConstructor.ZERO #### Defined in node_modules/@noble/curves/abstract/curve.d.ts:20 ## Methods ### fromAffine \u25b8 **fromAffine**(`p`): [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Parameters | Name | Type | | :--- | :----------------------------------------------------------------- | | `p` | [`AffinePoint`](../namespaces/ec.weierstrass.md#affinepoint) | #### Returns [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:77 --- ### fromHex \u25b8 **fromHex**(`hex`): [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Parameters | Name | Type | | :---- | :---- | | `hex` | `Hex` | #### Returns [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:78 --- ### fromPrivateKey \u25b8 **fromPrivateKey**(`privateKey`): [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Parameters | Name | Type | | :----------- | :-------- | | `privateKey` | `PrivKey` | #### Returns [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:79 --- ### normalizeZ \u25b8 **normalizeZ**(`points`): [`ProjPointType`](ec.weierstrass.ProjPointType.md)[] #### Parameters | Name | Type | | :------- | :--------------------------------------------------------- | | `points` | [`ProjPointType`](ec.weierstrass.ProjPointType.md)[] | #### Returns [`ProjPointType`](ec.weierstrass.ProjPointType.md)[] #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:80"}
{"title": "ec.weierstrass.ProjPointType.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'ec.weierstrass.ProjPointType' title: 'Interface: ProjPointType' sidebar_label: 'ProjPointType' custom_edit_url: null --- [ec](../namespaces/ec.md).[weierstrass](../namespaces/ec.weierstrass.md).ProjPointType ### Design rationale for types - Interaction between classes from different curves should fail: `k256.Point.BASE.add(p256.Point.BASE)` - For this purpose we want to use `instanceof` operator, which is fast and works during runtime - Different calls of `curve()` would return different classes - `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve, it won't affect others TypeScript can't infer types for classes created inside a function. Classes is one instance of nominative types in TypeScript and interfaces only check for shape, so it's hard to create unique type for every function call. We can use generic types via some param, like curve opts, but that would: 1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params) which is hard to debug. 2. Params can be generic and we can't enforce them to be constant value: if somebody creates curve from non-constant params, it would be allowed to interact with other curves with non-constant params TODO: ## Type parameters | Name | | :--- | | `T` | ## Hierarchy - `Group`\\> \u21b3 **`ProjPointType`** ## Properties ### px \u2022 `Readonly` **px**: `T` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:58 --- ### py \u2022 `Readonly` **py**: `T` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:59 --- ### pz \u2022 `Readonly` **pz**: `T` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:60 ## Accessors ### x \u2022 `get` **x**(): `T` #### Returns `T` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:61 --- ### y \u2022 `get` **y**(): `T` #### Returns `T` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:62 ## Methods ### multiply \u25b8 **multiply**(`scalar`): [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Parameters | Name | Type | | :------- | :------- | | `scalar` | `bigint` | #### Returns [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Overrides Group.multiply #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:63 --- ### toAffine \u25b8 **toAffine**(`iz?`): [`AffinePoint`](../namespaces/ec.weierstrass.md#affinepoint) #### Parameters | Name | Type | | :---- | :--- | | `iz?` | `T` | #### Returns [`AffinePoint`](../namespaces/ec.weierstrass.md#affinepoint) #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:64 --- ### isTorsionFree \u25b8 **isTorsionFree**(): `boolean` #### Returns `boolean` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:65 --- ### clearCofactor \u25b8 **clearCofactor**(): [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Returns [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:66 --- ### assertValidity \u25b8 **assertValidity**(): `void` #### Returns `void` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:67 --- ### hasEvenY \u25b8 **hasEvenY**(): `boolean` #### Returns `boolean` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:68 --- ### toRawBytes \u25b8 **toRawBytes**(`isCompressed?`): `Uint8Array` #### Parameters | Name | Type | | :-------------- | :-------- | | `isCompressed?` | `boolean` | #### Returns `Uint8Array` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:69 --- ### toHex \u25b8 **toHex**(`isCompressed?`): `string` #### Parameters | Name | Type | | :-------------- | :-------- | | `isCompressed?` | `boolean` | #### Returns `string` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:70 --- ### multiplyUnsafe \u25b8 **multiplyUnsafe**(`scalar`): [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Parameters | Name | Type | | :------- | :------- | | `scalar` | `bigint` | #### Returns [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:71 --- ### multiplyAndAddUnsafe \u25b8 **multiplyAndAddUnsafe**(`Q`, `a`, `b`): `undefined` \\| [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Parameters | Name | Type | | :--- | :------------------------------------------------------- | | `Q` | [`ProjPointType`](ec.weierstrass.ProjPointType.md) | | `a` | `bigint` | | `b` | `bigint` | #### Returns `undefined` \\| [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:72 --- ### \\_setWindowSize \u25b8 **\\_setWindowSize**(`windowSize`): `void` #### Parameters | Name | Type | | :----------- | :------- | | `windowSize` | `number` | #### Returns `void` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:73 --- ### double \u25b8 **double**(): [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Returns [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Inherited from Group.double #### Defined in node_modules/@noble/curves/abstract/curve.d.ts:11 --- ### negate \u25b8 **negate**(): [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Returns [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Inherited from Group.negate #### Defined in node_modules/@noble/curves/abstract/curve.d.ts:12 --- ### add \u25b8 **add**(`other`): [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Parameters | Name | Type | | :------ | :------------------------------------------------------- | | `other` | [`ProjPointType`](ec.weierstrass.ProjPointType.md) | #### Returns [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Inherited from Group.add #### Defined in node_modules/@noble/curves/abstract/curve.d.ts:13 --- ### subtract \u25b8 **subtract**(`other`): [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Parameters | Name | Type | | :------ | :------------------------------------------------------- | | `other` | [`ProjPointType`](ec.weierstrass.ProjPointType.md) | #### Returns [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Inherited from Group.subtract #### Defined in node_modules/@noble/curves/abstract/curve.d.ts:14 --- ### equals \u25b8 **equals**(`other`): `boolean` #### Parameters | Name | Type | | :------ | :------------------------------------------------------- | | `other` | [`ProjPointType`](ec.weierstrass.ProjPointType.md) | #### Returns `boolean` #### Inherited from Group.equals #### Defined in node_modules/@noble/curves/abstract/curve.d.ts:15"}
{"title": "ec.weierstrass.SignatureType.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'ec.weierstrass.SignatureType' title: 'Interface: SignatureType' sidebar_label: 'SignatureType' custom_edit_url: null --- [ec](../namespaces/ec.md).[weierstrass](../namespaces/ec.weierstrass.md).SignatureType ## Properties ### r \u2022 `Readonly` **r**: `bigint` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:141 --- ### s \u2022 `Readonly` **s**: `bigint` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:142 --- ### recovery \u2022 `Optional` `Readonly` **recovery**: `number` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:143 ## Methods ### assertValidity \u25b8 **assertValidity**(): `void` #### Returns `void` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:144 --- ### addRecoveryBit \u25b8 **addRecoveryBit**(`recovery`): [`SignatureType`](ec.weierstrass.SignatureType.md) #### Parameters | Name | Type | | :--------- | :------- | | `recovery` | `number` | #### Returns [`SignatureType`](ec.weierstrass.SignatureType.md) #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:145 --- ### hasHighS \u25b8 **hasHighS**(): `boolean` #### Returns `boolean` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:146 --- ### normalizeS \u25b8 **normalizeS**(): [`SignatureType`](ec.weierstrass.SignatureType.md) #### Returns [`SignatureType`](ec.weierstrass.SignatureType.md) #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:147 --- ### recoverPublicKey \u25b8 **recoverPublicKey**(`msgHash`): [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Parameters | Name | Type | | :-------- | :---- | | `msgHash` | `Hex` | #### Returns [`ProjPointType`](ec.weierstrass.ProjPointType.md) #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:148 --- ### toCompactRawBytes \u25b8 **toCompactRawBytes**(): `Uint8Array` #### Returns `Uint8Array` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:149 --- ### toCompactHex \u25b8 **toCompactHex**(): `string` #### Returns `string` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:150 --- ### toDERRawBytes \u25b8 **toDERRawBytes**(`isCompressed?`): `Uint8Array` #### Parameters | Name | Type | | :-------------- | :-------- | | `isCompressed?` | `boolean` | #### Returns `Uint8Array` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:151 --- ### toDERHex \u25b8 **toDERHex**(`isCompressed?`): `string` #### Parameters | Name | Type | | :-------------- | :-------- | | `isCompressed?` | `boolean` | #### Returns `string` #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:152"}
{"title": "typedData.StarkNetDomain.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'typedData.StarkNetDomain' title: 'Interface: StarkNetDomain' sidebar_label: 'StarkNetDomain' custom_edit_url: null --- [typedData](../namespaces/typedData.md).StarkNetDomain The EIP712 domain struct. Any of these fields are optional, but it must contain at least one field. ## Hierarchy - `Record` \u21b3 **`StarkNetDomain`** ## Properties ### name \u2022 `Optional` **name**: `string` #### Defined in [src/utils/typedData/types.ts:24]( --- ### version \u2022 `Optional` **version**: `string` #### Defined in [src/utils/typedData/types.ts:25]( --- ### chainId \u2022 `Optional` **chainId**: `string` \\| `number` #### Defined in [src/utils/typedData/types.ts:26]("}
{"title": "typedData.TypedData.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'typedData.TypedData' title: 'Interface: TypedData' sidebar_label: 'TypedData' custom_edit_url: null --- [typedData](../namespaces/typedData.md).TypedData The complete typed data, with all the structs, domain data, primary type of the message, and the message itself. ## Properties ### types \u2022 **types**: `Record` #### Defined in [src/utils/typedData/types.ts:33]( --- ### primaryType \u2022 **primaryType**: `string` #### Defined in [src/utils/typedData/types.ts:34]( --- ### domain \u2022 **domain**: [`StarkNetDomain`](typedData.StarkNetDomain.md) #### Defined in [src/utils/typedData/types.ts:35]( --- ### message \u2022 **message**: `Record` #### Defined in [src/utils/typedData/types.ts:36]("}
{"title": "types.CallStruct.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.CallStruct' title: 'Interface: CallStruct' sidebar_label: 'CallStruct' custom_edit_url: null --- [types](../namespaces/types.md).CallStruct ## Properties ### to \u2022 **to**: `string` #### Defined in [src/types/lib/index.ts:212]( --- ### selector \u2022 **selector**: `string` #### Defined in [src/types/lib/index.ts:213]( --- ### calldata \u2022 **calldata**: `string`[] #### Defined in [src/types/lib/index.ts:214]("}
{"title": "types.CommonTransactionReceiptResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.CommonTransactionReceiptResponse' title: 'Interface: CommonTransactionReceiptResponse' sidebar_label: 'CommonTransactionReceiptResponse' custom_edit_url: null --- [types](../namespaces/types.md).CommonTransactionReceiptResponse ## Hierarchy - **`CommonTransactionReceiptResponse`** \u21b3 [`InvokeTransactionReceiptResponse`](types.InvokeTransactionReceiptResponse.md) ## Properties ### transaction_hash \u2022 **transaction_hash**: `string` #### Defined in [src/types/provider/response.ts:75]( --- ### status \u2022 `Optional` **status**: `\"NOT_RECEIVED\"` \\| `\"RECEIVED\"` \\| `\"ACCEPTED_ON_L2\"` \\| `\"ACCEPTED_ON_L1\"` \\| `\"REJECTED\"` #### Defined in [src/types/provider/response.ts:76]( --- ### actual_fee \u2022 `Optional` **actual_fee**: `string` #### Defined in [src/types/provider/response.ts:77]( --- ### status_data \u2022 `Optional` **status_data**: `string` #### Defined in [src/types/provider/response.ts:78]("}
{"title": "types.CommonTransactionResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.CommonTransactionResponse' title: 'Interface: CommonTransactionResponse' sidebar_label: 'CommonTransactionResponse' custom_edit_url: null --- [types](../namespaces/types.md).CommonTransactionResponse ## Hierarchy - **`CommonTransactionResponse`** \u21b3 [`InvokeTransactionResponse`](types.InvokeTransactionResponse.md) \u21b3 [`DeclareTransactionResponse`](types.DeclareTransactionResponse.md) ## Properties ### transaction_hash \u2022 `Optional` **transaction_hash**: `string` #### Defined in [src/types/provider/response.ts:46]( --- ### version \u2022 `Optional` **version**: `string` #### Defined in [src/types/provider/response.ts:47]( --- ### signature \u2022 `Optional` **signature**: [`Signature`](../namespaces/types.md#signature) #### Defined in [src/types/provider/response.ts:48]( --- ### max_fee \u2022 `Optional` **max_fee**: `string` #### Defined in [src/types/provider/response.ts:49]( --- ### nonce \u2022 `Optional` **nonce**: `string` #### Defined in [src/types/provider/response.ts:50]("}
{"title": "types.ContractEntryPoint.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.ContractEntryPoint' title: 'Interface: ContractEntryPoint' sidebar_label: 'ContractEntryPoint' custom_edit_url: null --- [types](../namespaces/types.md).ContractEntryPoint ## Properties ### offset \u2022 **offset**: `string` #### Defined in [src/types/provider/response.ts:61]( --- ### selector \u2022 **selector**: `string` #### Defined in [src/types/provider/response.ts:62]("}
{"title": "types.DeclareContractResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.DeclareContractResponse' title: 'Interface: DeclareContractResponse' sidebar_label: 'DeclareContractResponse' custom_edit_url: null --- [types](../namespaces/types.md).DeclareContractResponse ## Properties ### transaction_hash \u2022 **transaction_hash**: `string` #### Defined in [src/types/provider/response.ts:118]( --- ### class_hash \u2022 **class_hash**: `string` #### Defined in [src/types/provider/response.ts:119]("}
{"title": "types.DeclareSignerDetails.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.DeclareSignerDetails' title: 'Interface: DeclareSignerDetails' sidebar_label: 'DeclareSignerDetails' custom_edit_url: null --- [types](../namespaces/types.md).DeclareSignerDetails ## Properties ### classHash \u2022 **classHash**: `string` #### Defined in [src/types/signer.ts:16]( --- ### senderAddress \u2022 **senderAddress**: `string` #### Defined in [src/types/signer.ts:17]( --- ### chainId \u2022 **chainId**: [`StarknetChainId`](../enums/constants.StarknetChainId.md) #### Defined in [src/types/signer.ts:18]( --- ### maxFee \u2022 **maxFee**: [`BigNumberish`](../namespaces/types.md#bignumberish) #### Defined in [src/types/signer.ts:19]( --- ### version \u2022 **version**: [`BigNumberish`](../namespaces/types.md#bignumberish) #### Defined in [src/types/signer.ts:20]( --- ### nonce \u2022 **nonce**: [`BigNumberish`](../namespaces/types.md#bignumberish) #### Defined in [src/types/signer.ts:21]( --- ### compiledClassHash \u2022 `Optional` **compiledClassHash**: `string` #### Defined in [src/types/signer.ts:22]("}
{"title": "types.DeclareTransactionResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.DeclareTransactionResponse' title: 'Interface: DeclareTransactionResponse' sidebar_label: 'DeclareTransactionResponse' custom_edit_url: null --- [types](../namespaces/types.md).DeclareTransactionResponse ## Hierarchy - [`CommonTransactionResponse`](types.CommonTransactionResponse.md) \u21b3 **`DeclareTransactionResponse`** ## Properties ### contract_class \u2022 `Optional` **contract_class**: `any` #### Defined in [src/types/provider/response.ts:66]( --- ### sender_address \u2022 `Optional` **sender_address**: `string` #### Defined in [src/types/provider/response.ts:67]( --- ### transaction_hash \u2022 `Optional` **transaction_hash**: `string` #### Inherited from [CommonTransactionResponse](types.CommonTransactionResponse.md).[transaction_hash](types.CommonTransactionResponse.md#transaction_hash) #### Defined in [src/types/provider/response.ts:46]( --- ### version \u2022 `Optional` **version**: `string` #### Inherited from [CommonTransactionResponse](types.CommonTransactionResponse.md).[version](types.CommonTransactionResponse.md#version) #### Defined in [src/types/provider/response.ts:47]( --- ### signature \u2022 `Optional` **signature**: [`Signature`](../namespaces/types.md#signature) #### Inherited from [CommonTransactionResponse](types.CommonTransactionResponse.md).[signature](types.CommonTransactionResponse.md#signature) #### Defined in [src/types/provider/response.ts:48]( --- ### max_fee \u2022 `Optional` **max_fee**: `string` #### Inherited from [CommonTransactionResponse](types.CommonTransactionResponse.md).[max_fee](types.CommonTransactionResponse.md#max_fee) #### Defined in [src/types/provider/response.ts:49]( --- ### nonce \u2022 `Optional` **nonce**: `string` #### Inherited from [CommonTransactionResponse](types.CommonTransactionResponse.md).[nonce](types.CommonTransactionResponse.md#nonce) #### Defined in [src/types/provider/response.ts:50]("}
{"title": "types.DeployContractResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.DeployContractResponse' title: 'Interface: DeployContractResponse' sidebar_label: 'DeployContractResponse' custom_edit_url: null --- [types](../namespaces/types.md).DeployContractResponse ## Properties ### contract_address \u2022 **contract_address**: `string` #### Defined in [src/types/account.ts:23]( --- ### transaction_hash \u2022 **transaction_hash**: `string` #### Defined in [src/types/account.ts:24]("}
{"title": "types.EstimateFee.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.EstimateFee' title: 'Interface: EstimateFee' sidebar_label: 'EstimateFee' custom_edit_url: null --- [types](../namespaces/types.md).EstimateFee ## Hierarchy - [`EstimateFeeResponse`](types.EstimateFeeResponse.md) \u21b3 **`EstimateFee`** ## Properties ### suggestedMaxFee \u2022 **suggestedMaxFee**: `bigint` #### Overrides [EstimateFeeResponse](types.EstimateFeeResponse.md).[suggestedMaxFee](types.EstimateFeeResponse.md#suggestedmaxfee) #### Defined in [src/types/account.ts:5]( --- ### overall_fee \u2022 **overall_fee**: `bigint` #### Inherited from [EstimateFeeResponse](types.EstimateFeeResponse.md).[overall_fee](types.EstimateFeeResponse.md#overall_fee) #### Defined in [src/types/provider/response.ts:107]( --- ### gas_consumed \u2022 `Optional` **gas_consumed**: `bigint` #### Inherited from [EstimateFeeResponse](types.EstimateFeeResponse.md).[gas_consumed](types.EstimateFeeResponse.md#gas_consumed) #### Defined in [src/types/provider/response.ts:108]( --- ### gas_price \u2022 `Optional` **gas_price**: `bigint` #### Inherited from [EstimateFeeResponse](types.EstimateFeeResponse.md).[gas_price](types.EstimateFeeResponse.md#gas_price) #### Defined in [src/types/provider/response.ts:109]("}
{"title": "types.EstimateFeeDetails.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.EstimateFeeDetails' title: 'Interface: EstimateFeeDetails' sidebar_label: 'EstimateFeeDetails' custom_edit_url: null --- [types](../namespaces/types.md).EstimateFeeDetails ## Properties ### nonce \u2022 `Optional` **nonce**: [`BigNumberish`](../namespaces/types.md#bignumberish) #### Defined in [src/types/account.ts:17]( --- ### blockIdentifier \u2022 `Optional` **blockIdentifier**: [`BlockIdentifier`](../namespaces/types.md#blockidentifier) #### Defined in [src/types/account.ts:18]( --- ### skipValidate \u2022 `Optional` **skipValidate**: `boolean` #### Defined in [src/types/account.ts:19]("}
{"title": "types.EstimateFeeResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.EstimateFeeResponse' title: 'Interface: EstimateFeeResponse' sidebar_label: 'EstimateFeeResponse' custom_edit_url: null --- [types](../namespaces/types.md).EstimateFeeResponse ## Hierarchy - **`EstimateFeeResponse`** \u21b3 [`EstimateFee`](types.EstimateFee.md) ## Properties ### overall_fee \u2022 **overall_fee**: `bigint` #### Defined in [src/types/provider/response.ts:107]( --- ### gas_consumed \u2022 `Optional` **gas_consumed**: `bigint` #### Defined in [src/types/provider/response.ts:108]( --- ### gas_price \u2022 `Optional` **gas_price**: `bigint` #### Defined in [src/types/provider/response.ts:109]( --- ### suggestedMaxFee \u2022 `Optional` **suggestedMaxFee**: `bigint` #### Defined in [src/types/provider/response.ts:110]("}
{"title": "types.Event.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.Event' title: 'Interface: Event' sidebar_label: 'Event' custom_edit_url: null --- [types](../namespaces/types.md).Event ## Properties ### from_address \u2022 **from_address**: `string` #### Defined in [src/types/provider/response.ts:87]( --- ### keys \u2022 **keys**: `string`[] #### Defined in [src/types/provider/response.ts:88]( --- ### data \u2022 **data**: `string`[] #### Defined in [src/types/provider/response.ts:89]("}
{"title": "types.GetBlockResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.GetBlockResponse' title: 'Interface: GetBlockResponse' sidebar_label: 'GetBlockResponse' custom_edit_url: null --- [types](../namespaces/types.md).GetBlockResponse ## Properties ### timestamp \u2022 **timestamp**: `number` #### Defined in [src/types/provider/response.ts:25]( --- ### block_hash \u2022 **block_hash**: `string` #### Defined in [src/types/provider/response.ts:26]( --- ### block_number \u2022 **block_number**: `number` #### Defined in [src/types/provider/response.ts:27]( --- ### new_root \u2022 **new_root**: `string` #### Defined in [src/types/provider/response.ts:28]( --- ### parent_hash \u2022 **parent_hash**: `string` #### Defined in [src/types/provider/response.ts:29]( --- ### status \u2022 **status**: [`BlockStatus`](../enums/types.BlockStatus.md) #### Defined in [src/types/provider/response.ts:30]( --- ### transactions \u2022 **transactions**: `string`[] #### Defined in [src/types/provider/response.ts:31]( --- ### gas_price \u2022 `Optional` **gas_price**: `string` #### Defined in [src/types/provider/response.ts:32]( --- ### sequencer_address \u2022 `Optional` **sequencer_address**: `string` #### Defined in [src/types/provider/response.ts:33]( --- ### starknet_version \u2022 `Optional` **starknet_version**: `string` #### Defined in [src/types/provider/response.ts:34]( --- ### transaction_receipts \u2022 `Optional` **transaction_receipts**: `any` #### Defined in [src/types/provider/response.ts:35]("}
{"title": "types.GetCodeResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.GetCodeResponse' title: 'Interface: GetCodeResponse' sidebar_label: 'GetCodeResponse' custom_edit_url: null --- [types](../namespaces/types.md).GetCodeResponse ## Properties ### bytecode \u2022 **bytecode**: [`ByteCode`](../namespaces/types.md#bytecode) #### Defined in [src/types/provider/response.ts:39]("}
{"title": "types.InvocationsSignerDetails.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.InvocationsSignerDetails' title: 'Interface: InvocationsSignerDetails' sidebar_label: 'InvocationsSignerDetails' custom_edit_url: null --- [types](../namespaces/types.md).InvocationsSignerDetails ## Hierarchy - `Required` \u21b3 **`InvocationsSignerDetails`** ## Properties ### walletAddress \u2022 **walletAddress**: `string` #### Defined in [src/types/signer.ts:10]( --- ### chainId \u2022 **chainId**: [`StarknetChainId`](../enums/constants.StarknetChainId.md) #### Defined in [src/types/signer.ts:11]( --- ### cairoVersion \u2022 **cairoVersion**: [`CairoVersion`](../namespaces/types.md#cairoversion) #### Defined in [src/types/signer.ts:12]( --- ### nonce \u2022 **nonce**: [`BigNumberish`](../namespaces/types.md#bignumberish) #### Inherited from Required.nonce #### Defined in [src/types/lib/index.ts:104]( --- ### maxFee \u2022 **maxFee**: [`BigNumberish`](../namespaces/types.md#bignumberish) #### Inherited from Required.maxFee #### Defined in [src/types/lib/index.ts:105]( --- ### version \u2022 **version**: [`BigNumberish`](../namespaces/types.md#bignumberish) #### Inherited from Required.version #### Defined in [src/types/lib/index.ts:106]("}
{"title": "types.InvokeFunctionResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.InvokeFunctionResponse' title: 'Interface: InvokeFunctionResponse' sidebar_label: 'InvokeFunctionResponse' custom_edit_url: null --- [types](../namespaces/types.md).InvokeFunctionResponse ## Properties ### transaction_hash \u2022 **transaction_hash**: `string` #### Defined in [src/types/provider/response.ts:114]("}
{"title": "types.InvokeTransactionReceiptResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.InvokeTransactionReceiptResponse' title: 'Interface: InvokeTransactionReceiptResponse' sidebar_label: 'InvokeTransactionReceiptResponse' custom_edit_url: null --- [types](../namespaces/types.md).InvokeTransactionReceiptResponse ## Hierarchy - [`CommonTransactionReceiptResponse`](types.CommonTransactionReceiptResponse.md) \u21b3 **`InvokeTransactionReceiptResponse`** ## Properties ### messages_sent \u2022 `Optional` **messages_sent**: [`MessageToL1`](types.MessageToL1.md)[] **`Deprecated`** Use l2_to_l1_messages #### Defined in [src/types/provider/response.ts:99]( --- ### events \u2022 `Optional` **events**: [`Event`](types.Event.md)[] #### Defined in [src/types/provider/response.ts:100]( --- ### l1_origin_message \u2022 `Optional` **l1_origin_message**: [`MessageToL2`](types.MessageToL2.md) #### Defined in [src/types/provider/response.ts:101]( --- ### transaction_hash \u2022 **transaction_hash**: `string` #### Inherited from [CommonTransactionReceiptResponse](types.CommonTransactionReceiptResponse.md).[transaction_hash](types.CommonTransactionReceiptResponse.md#transaction_hash) #### Defined in [src/types/provider/response.ts:75]( --- ### status \u2022 `Optional` **status**: `\"NOT_RECEIVED\"` \\| `\"RECEIVED\"` \\| `\"ACCEPTED_ON_L2\"` \\| `\"ACCEPTED_ON_L1\"` \\| `\"REJECTED\"` #### Inherited from [CommonTransactionReceiptResponse](types.CommonTransactionReceiptResponse.md).[status](types.CommonTransactionReceiptResponse.md#status) #### Defined in [src/types/provider/response.ts:76]( --- ### actual_fee \u2022 `Optional` **actual_fee**: `string` #### Inherited from [CommonTransactionReceiptResponse](types.CommonTransactionReceiptResponse.md).[actual_fee](types.CommonTransactionReceiptResponse.md#actual_fee) #### Defined in [src/types/provider/response.ts:77]( --- ### status_data \u2022 `Optional` **status_data**: `string` #### Inherited from [CommonTransactionReceiptResponse](types.CommonTransactionReceiptResponse.md).[status_data](types.CommonTransactionReceiptResponse.md#status_data) #### Defined in [src/types/provider/response.ts:78]("}
{"title": "types.InvokeTransactionResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.InvokeTransactionResponse' title: 'Interface: InvokeTransactionResponse' sidebar_label: 'InvokeTransactionResponse' custom_edit_url: null --- [types](../namespaces/types.md).InvokeTransactionResponse ## Hierarchy - [`CommonTransactionResponse`](types.CommonTransactionResponse.md) \u21b3 **`InvokeTransactionResponse`** ## Properties ### contract_address \u2022 `Optional` **contract_address**: `string` #### Defined in [src/types/provider/response.ts:54]( --- ### sender_address \u2022 `Optional` **sender_address**: `string` #### Defined in [src/types/provider/response.ts:55]( --- ### entry_point_selector \u2022 `Optional` **entry_point_selector**: `string` #### Defined in [src/types/provider/response.ts:56]( --- ### calldata \u2022 **calldata**: [`RawCalldata`](../namespaces/types.md#rawcalldata) #### Defined in [src/types/provider/response.ts:57]( --- ### transaction_hash \u2022 `Optional` **transaction_hash**: `string` #### Inherited from [CommonTransactionResponse](types.CommonTransactionResponse.md).[transaction_hash](types.CommonTransactionResponse.md#transaction_hash) #### Defined in [src/types/provider/response.ts:46]( --- ### version \u2022 `Optional` **version**: `string` #### Inherited from [CommonTransactionResponse](types.CommonTransactionResponse.md).[version](types.CommonTransactionResponse.md#version) #### Defined in [src/types/provider/response.ts:47]( --- ### signature \u2022 `Optional` **signature**: [`Signature`](../namespaces/types.md#signature) #### Inherited from [CommonTransactionResponse](types.CommonTransactionResponse.md).[signature](types.CommonTransactionResponse.md#signature) #### Defined in [src/types/provider/response.ts:48]( --- ### max_fee \u2022 `Optional` **max_fee**: `string` #### Inherited from [CommonTransactionResponse](types.CommonTransactionResponse.md).[max_fee](types.CommonTransactionResponse.md#max_fee) #### Defined in [src/types/provider/response.ts:49]( --- ### nonce \u2022 `Optional` **nonce**: `string` #### Inherited from [CommonTransactionResponse](types.CommonTransactionResponse.md).[nonce](types.CommonTransactionResponse.md#nonce) #### Defined in [src/types/provider/response.ts:50]("}
{"title": "types.MessageToL1.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.MessageToL1' title: 'Interface: MessageToL1' sidebar_label: 'MessageToL1' custom_edit_url: null --- [types](../namespaces/types.md).MessageToL1 ## Properties ### to_address \u2022 **to_address**: `string` #### Defined in [src/types/provider/response.ts:82]( --- ### payload \u2022 **payload**: `string`[] #### Defined in [src/types/provider/response.ts:83]("}
{"title": "types.MessageToL2.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.MessageToL2' title: 'Interface: MessageToL2' sidebar_label: 'MessageToL2' custom_edit_url: null --- [types](../namespaces/types.md).MessageToL2 ## Properties ### from_address \u2022 **from_address**: `string` #### Defined in [src/types/provider/response.ts:93]( --- ### payload \u2022 **payload**: `string`[] #### Defined in [src/types/provider/response.ts:94]("}
{"title": "types.Program.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.Program' title: 'Interface: Program' sidebar_label: 'Program' custom_edit_url: null --- [types](../namespaces/types.md).Program ## Hierarchy - `Record` \u21b3 **`Program`** ## Properties ### builtins \u2022 **builtins**: `string`[] #### Defined in [src/types/lib/contract/legacy.ts:37]( --- ### data \u2022 **data**: `string`[] #### Defined in [src/types/lib/contract/legacy.ts:38]("}
{"title": "types.ProviderOptions.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.ProviderOptions' title: 'Interface: ProviderOptions' sidebar_label: 'ProviderOptions' custom_edit_url: null --- [types](../namespaces/types.md).ProviderOptions ## Properties ### sequencer \u2022 `Optional` **sequencer**: [`SequencerProviderOptions`](../namespaces/types.md#sequencerprovideroptions) #### Defined in [src/types/provider/configuration.ts:5]( --- ### rpc \u2022 `Optional` **rpc**: [`RpcProviderOptions`](../namespaces/types.md#rpcprovideroptions) #### Defined in [src/types/provider/configuration.ts:6]("}
{"title": "types.Sequencer.InvokeFunctionTransactionResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.Sequencer.InvokeFunctionTransactionResponse' title: 'Interface: InvokeFunctionTransactionResponse' sidebar_label: 'InvokeFunctionTransactionResponse' custom_edit_url: null --- [types](../namespaces/types.md).[Sequencer](../namespaces/types.Sequencer.md).InvokeFunctionTransactionResponse ## Hierarchy - [`InvokeFunctionTransaction`](../namespaces/types.Sequencer.md#invokefunctiontransaction) \u21b3 **`InvokeFunctionTransactionResponse`** ## Properties ### transaction_hash \u2022 **transaction_hash**: `string` #### Defined in [src/types/api/sequencer.ts:143]( --- ### entry_point_selector \u2022 **entry_point_selector**: `string` #### Defined in [src/types/api/sequencer.ts:144]( --- ### type \u2022 **type**: [`INVOKE`](../enums/types.TransactionType.md#invoke) #### Inherited from InvokeFunctionTransaction.type #### Defined in [src/types/api/sequencer.ts:114]( --- ### sender_address \u2022 **sender_address**: `string` #### Inherited from InvokeFunctionTransaction.sender_address #### Defined in [src/types/api/sequencer.ts:115]( --- ### signature \u2022 `Optional` **signature**: `string`[] #### Inherited from InvokeFunctionTransaction.signature #### Defined in [src/types/api/sequencer.ts:116]( --- ### entry_point_type \u2022 `Optional` **entry_point_type**: [`EXTERNAL`](../enums/types.EntryPointType.md#external) #### Inherited from InvokeFunctionTransaction.entry_point_type #### Defined in [src/types/api/sequencer.ts:117]( --- ### calldata \u2022 `Optional` **calldata**: [`RawCalldata`](../namespaces/types.md#rawcalldata) #### Inherited from InvokeFunctionTransaction.calldata #### Defined in [src/types/api/sequencer.ts:118]( --- ### nonce \u2022 **nonce**: [`BigNumberish`](../namespaces/types.md#bignumberish) #### Inherited from InvokeFunctionTransaction.nonce #### Defined in [src/types/api/sequencer.ts:119]( --- ### max_fee \u2022 `Optional` **max_fee**: [`BigNumberish`](../namespaces/types.md#bignumberish) #### Inherited from InvokeFunctionTransaction.max_fee #### Defined in [src/types/api/sequencer.ts:120]( --- ### version \u2022 `Optional` **version**: [`BigNumberish`](../namespaces/types.md#bignumberish) #### Inherited from InvokeFunctionTransaction.version #### Defined in [src/types/api/sequencer.ts:121]("}
{"title": "types.StarkNetDomain.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.StarkNetDomain' title: 'Interface: StarkNetDomain' sidebar_label: 'StarkNetDomain' custom_edit_url: null --- [types](../namespaces/types.md).StarkNetDomain The EIP712 domain struct. Any of these fields are optional, but it must contain at least one field. ## Hierarchy - `Record` \u21b3 **`StarkNetDomain`** ## Properties ### name \u2022 `Optional` **name**: `string` #### Defined in [src/types/typedData.ts:24]( --- ### version \u2022 `Optional` **version**: `string` #### Defined in [src/types/typedData.ts:25]( --- ### chainId \u2022 `Optional` **chainId**: `string` \\| `number` #### Defined in [src/types/typedData.ts:26]("}
{"title": "types.StateUpdateResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.StateUpdateResponse' title: 'Interface: StateUpdateResponse' sidebar_label: 'StateUpdateResponse' custom_edit_url: null --- [types](../namespaces/types.md).StateUpdateResponse ## Properties ### block_hash \u2022 `Optional` **block_hash**: `string` #### Defined in [src/types/provider/response.ts:162]( --- ### new_root \u2022 `Optional` **new_root**: `string` #### Defined in [src/types/provider/response.ts:163]( --- ### old_root \u2022 **old_root**: `string` #### Defined in [src/types/provider/response.ts:164]( --- ### state_diff \u2022 **state_diff**: `Object` #### Type declaration | Name | Type | | :----------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------- | | `storage_diffs` | [`StorageDiffs`](../namespaces/types.RPC.md#storagediffs) | | `deployed_contracts` | [`DeployedContracts`](../namespaces/types.Sequencer.md#deployedcontracts) | | `nonces` | [`Nonces`](../namespaces/types.RPC.md#nonces) | | `old_declared_contracts?` | [`OldDeclaredContracts`](../namespaces/types.Sequencer.md#olddeclaredcontracts) | | `declared_classes?` | [`DeclaredClasses`](../namespaces/types.Sequencer.md#declaredclasses) | | `replaced_classes?` | [`ReplacedClasses`](../namespaces/types.RPC.md#replacedclasses) \\| [`ReplacedClasses`](../namespaces/types.Sequencer.md#replacedclasses) | | `deprecated_declared_classes?` | [`DeprecatedDeclaredClasses`](../namespaces/types.RPC.md#deprecateddeclaredclasses) | #### Defined in [src/types/provider/response.ts:165]("}
{"title": "types.TransactionSimulation.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.TransactionSimulation' title: 'Interface: TransactionSimulation' sidebar_label: 'TransactionSimulation' custom_edit_url: null --- [types](../namespaces/types.md).TransactionSimulation ## Hierarchy - [`TransactionSimulationResponse`](types.TransactionSimulationResponse.md) \u21b3 **`TransactionSimulation`** ## Properties ### fee_estimation \u2022 **fee_estimation**: [`EstimateFee`](types.EstimateFee.md) #### Overrides [TransactionSimulationResponse](types.TransactionSimulationResponse.md).[fee_estimation](types.TransactionSimulationResponse.md#fee_estimation) #### Defined in [src/types/account.ts:50]( --- ### trace \u2022 **trace**: [`TransactionTraceResponse`](../namespaces/types.md#transactiontraceresponse) #### Inherited from [TransactionSimulationResponse](types.TransactionSimulationResponse.md).[trace](types.TransactionSimulationResponse.md#trace) #### Defined in [src/types/provider/response.ts:148]("}
{"title": "types.TransactionSimulationResponse.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.TransactionSimulationResponse' title: 'Interface: TransactionSimulationResponse' sidebar_label: 'TransactionSimulationResponse' custom_edit_url: null --- [types](../namespaces/types.md).TransactionSimulationResponse ## Hierarchy - **`TransactionSimulationResponse`** \u21b3 [`TransactionSimulation`](types.TransactionSimulation.md) ## Properties ### trace \u2022 **trace**: [`TransactionTraceResponse`](../namespaces/types.md#transactiontraceresponse) #### Defined in [src/types/provider/response.ts:148]( --- ### fee_estimation \u2022 **fee_estimation**: [`EstimateFeeResponse`](types.EstimateFeeResponse.md) #### Defined in [src/types/provider/response.ts:149]("}
{"title": "types.TypedData.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.TypedData' title: 'Interface: TypedData' sidebar_label: 'TypedData' custom_edit_url: null --- [types](../namespaces/types.md).TypedData The complete typed data, with all the structs, domain data, primary type of the message, and the message itself. ## Properties ### types \u2022 **types**: `Record` #### Defined in [src/types/typedData.ts:33]( --- ### primaryType \u2022 **primaryType**: `string` #### Defined in [src/types/typedData.ts:34]( --- ### domain \u2022 **domain**: [`StarkNetDomain`](types.StarkNetDomain.md) #### Defined in [src/types/typedData.ts:35]( --- ### message \u2022 **message**: `Record` #### Defined in [src/types/typedData.ts:36]("}
{"title": "types.Uint256.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.Uint256' title: 'Interface: Uint256' sidebar_label: 'Uint256' custom_edit_url: null --- [types](../namespaces/types.md).Uint256 Represents an integer in the range [0, 2^256) ## Properties ### low \u2022 **low**: [`BigNumberish`](../namespaces/types.md#bignumberish) #### Defined in [src/types/lib/index.ts:16]( --- ### high \u2022 **high**: [`BigNumberish`](../namespaces/types.md#bignumberish) #### Defined in [src/types/lib/index.ts:18]("}
{"title": "uint256.Uint256.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'uint256.Uint256' title: 'Interface: Uint256' sidebar_label: 'Uint256' custom_edit_url: null --- [uint256](../namespaces/uint256.md).Uint256 ## Properties ### low \u2022 **low**: [`BigNumberish`](../namespaces/num.md#bignumberish) #### Defined in [src/utils/uint256.ts:8]( --- ### high \u2022 **high**: [`BigNumberish`](../namespaces/num.md#bignumberish) #### Defined in [src/utils/uint256.ts:10]("}
{"title": "modules.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'modules' title: 'Starknet.js API - v5.16.0' sidebar_label: 'Exports' sidebar_position: 0.5 custom_edit_url: null --- ## Namespaces - [types](namespaces/types.md) - [constants](namespaces/constants.md) - [encode](namespaces/encode.md) - [hash](namespaces/hash.md) - [json](namespaces/json.md) - [num](namespaces/num.md) - [transaction](namespaces/transaction.md) - [stark](namespaces/stark.md) - [merkle](namespaces/merkle.md) - [uint256](namespaces/uint256.md) - [shortString](namespaces/shortString.md) - [typedData](namespaces/typedData.md) - [ec](namespaces/ec.md) - [starknetId](namespaces/starknetId.md) - [provider](namespaces/provider-1.md) - [selector](namespaces/selector.md) - [cairo](namespaces/cairo.md) ## Classes - [Account](classes/Account.md) - [AccountInterface](classes/AccountInterface.md) - [Contract](classes/Contract.md) - [ContractInterface](classes/ContractInterface.md) - [ContractFactory](classes/ContractFactory.md) - [Provider](classes/Provider.md) - [CustomError](classes/CustomError.md) - [LibraryError](classes/LibraryError.md) - [GatewayError](classes/GatewayError.md) - [HttpError](classes/HttpError.md) - [SequencerProvider](classes/SequencerProvider.md) - [ProviderInterface](classes/ProviderInterface.md) - [RpcProvider](classes/RpcProvider.md) - [SignerInterface](classes/SignerInterface.md) - [Signer](classes/Signer.md) - [CallData](classes/CallData.md) ## References ### EstimateFee Re-exports [EstimateFee](interfaces/types.EstimateFee.md) --- ### EstimateFeeBulk Re-exports [EstimateFeeBulk](namespaces/types.md#estimatefeebulk) --- ### AccountInvocationsFactoryDetails Re-exports [AccountInvocationsFactoryDetails](namespaces/types.md#accountinvocationsfactorydetails) --- ### EstimateFeeDetails Re-exports [EstimateFeeDetails](interfaces/types.EstimateFeeDetails.md) --- ### DeployContractResponse Re-exports [DeployContractResponse](interfaces/types.DeployContractResponse.md) --- ### MultiDeployContractResponse Re-exports [MultiDeployContractResponse](namespaces/types.md#multideploycontractresponse) --- ### DeployContractUDCResponse Re-exports [DeployContractUDCResponse](namespaces/types.md#deploycontractudcresponse) --- ### DeclareDeployUDCResponse Re-exports [DeclareDeployUDCResponse](namespaces/types.md#declaredeployudcresponse) --- ### SimulateTransactionDetails Re-exports [SimulateTransactionDetails](namespaces/types.md#simulatetransactiondetails) --- ### SIMULATION_FLAG Re-exports [SIMULATION_FLAG](enums/types.SIMULATION_FLAG.md) --- ### AsyncContractFunction Re-exports [AsyncContractFunction](namespaces/types.md#asynccontractfunction) --- ### ContractFunction Re-exports [ContractFunction](namespaces/types.md#contractfunction) --- ### Result Re-exports [Result](namespaces/types.md#result) --- ### Calldata Re-exports [Calldata](namespaces/types.md#calldata) --- ### ArgsOrCalldata Re-exports [ArgsOrCalldata](namespaces/types.md#argsorcalldata) --- ### ArgsOrCalldataWithOptions Re-exports [ArgsOrCalldataWithOptions](namespaces/types.md#argsorcalldatawithoptions) --- ### ContractOptions Re-exports [ContractOptions](namespaces/types.md#contractoptions) --- ### CallOptions Re-exports [CallOptions](namespaces/types.md#calloptions) --- ### InvokeOptions Re-exports [InvokeOptions](namespaces/types.md#invokeoptions) --- ### WeierstrassSignatureType Re-exports [WeierstrassSignatureType](namespaces/types.md#weierstrasssignaturetype) --- ### ArraySignatureType Re-exports [ArraySignatureType](namespaces/types.md#arraysignaturetype) --- ### Signature Re-exports [Signature](namespaces/types.md#signature) --- ### BigNumberish Re-exports [BigNumberish](namespaces/types.md#bignumberish) --- ### Uint256 Re-exports [Uint256](interfaces/types.Uint256.md) --- ### RawCalldata Re-exports [RawCalldata](namespaces/types.md#rawcalldata) --- ### HexCalldata Re-exports [HexCalldata](namespaces/types.md#hexcalldata) --- ### AllowArray Re-exports [AllowArray](namespaces/types.md#allowarray) --- ### OptionalPayload Re-exports [OptionalPayload](namespaces/types.md#optionalpayload) --- ### RawArgs Re-exports [RawArgs](namespaces/types.md#rawargs) --- ### RawArgsObject Re-exports [RawArgsObject](namespaces/types.md#rawargsobject) --- ### RawArgsArray Re-exports [RawArgsArray](namespaces/types.md#rawargsarray) --- ### MultiType Re-exports [MultiType](namespaces/types.md#multitype) --- ### UniversalDeployerContractPayload Re-exports [UniversalDeployerContractPayload](namespaces/types.md#universaldeployercontractpayload) --- ### DeployAccountContractPayload Re-exports [DeployAccountContractPayload](namespaces/types.md#deployaccountcontractpayload) --- ### DeployAccountContractTransaction Re-exports [DeployAccountContractTransaction](namespaces/types.md#deployaccountcontracttransaction) --- ### DeclareContractPayload Re-exports [DeclareContractPayload](namespaces/types.md#declarecontractpayload) --- ### CompleteDeclareContractPayload Re-exports [CompleteDeclareContractPayload](namespaces/types.md#completedeclarecontractpayload) --- ### DeclareAndDeployContractPayload Re-exports [DeclareAndDeployContractPayload](namespaces/types.md#declareanddeploycontractpayload) --- ### DeclareContractTransaction Re-exports [DeclareContractTransaction](namespaces/types.md#declarecontracttransaction) --- ### CallDetails Re-exports [CallDetails](namespaces/types.md#calldetails) --- ### Invocation Re-exports [Invocation](namespaces/types.md#invocation) --- ### Call Re-exports [Call](namespaces/types.md#call) --- ### CairoVersion Re-exports [CairoVersion](namespaces/types.md#cairoversion) --- ### InvocationsDetails Re-exports [InvocationsDetails](namespaces/types.md#invocationsdetails) --- ### Details Re-exports [Details](namespaces/types.md#details) --- ### InvocationsDetailsWithNonce Re-exports [InvocationsDetailsWithNonce](namespaces/types.md#invocationsdetailswithnonce) --- ### TransactionType Re-exports [TransactionType](enums/types.TransactionType.md) --- ### TransactionStatus Re-exports [TransactionStatus](enums/types.TransactionStatus.md) --- ### BlockStatus Re-exports [BlockStatus](enums/types.BlockStatus.md) --- ### BlockTag Re-exports [BlockTag](enums/types.BlockTag.md) --- ### BlockNumber Re-exports [BlockNumber](namespaces/types.md#blocknumber) --- ### BlockIdentifier Re-exports [BlockIdentifier](namespaces/types.md#blockidentifier) --- ### AccountInvocationItem Re-exports [AccountInvocationItem](namespaces/types.md#accountinvocationitem) --- ### AccountInvocations Re-exports [AccountInvocations](namespaces/types.md#accountinvocations) --- ### Invocations Re-exports [Invocations](namespaces/types.md#invocations) --- ### Tupled Re-exports [Tupled](namespaces/types.md#tupled) --- ### Args Re-exports [Args](namespaces/types.md#args) --- ### ParsedStruct Re-exports [ParsedStruct](namespaces/types.md#parsedstruct) --- ### waitForTransactionOptions Re-exports [waitForTransactionOptions](namespaces/types.md#waitfortransactionoptions) --- ### getSimulateTransactionOptions Re-exports [getSimulateTransactionOptions](namespaces/types.md#getsimulatetransactionoptions) --- ### getEstimateFeeBulkOptions Re-exports [getEstimateFeeBulkOptions](namespaces/types.md#getestimatefeebulkoptions) --- ### CallStruct Re-exports [CallStruct](interfaces/types.CallStruct.md) --- ### ContractClass Re-exports [ContractClass](namespaces/types.md#contractclass) --- ### CompiledContract Re-exports [CompiledContract](namespaces/types.md#compiledcontract) --- ### CairoContract Re-exports [CairoContract](namespaces/types.md#cairocontract) --- ### EntryPointType Re-exports [EntryPointType](enums/types.EntryPointType.md) --- ### Abi Re-exports [Abi](namespaces/types.md#abi) --- ### AbiEntry Re-exports [AbiEntry](namespaces/types.md#abientry) --- ### FunctionAbi Re-exports [FunctionAbi](namespaces/types.md#functionabi) --- ### AbiStructs Re-exports [AbiStructs](namespaces/types.md#abistructs) --- ### StructAbi Re-exports [StructAbi](namespaces/types.md#structabi) --- ### LegacyContractClass Re-exports [LegacyContractClass](namespaces/types.md#legacycontractclass) --- ### LegacyCompiledContract Re-exports [LegacyCompiledContract](namespaces/types.md#legacycompiledcontract) --- ### Builtins Re-exports [Builtins](namespaces/types.md#builtins) --- ### CompressedProgram Re-exports [CompressedProgram](namespaces/types.md#compressedprogram) --- ### EntryPointsByType Re-exports [EntryPointsByType](namespaces/types.md#entrypointsbytype) --- ### ContractEntryPointFields Re-exports [ContractEntryPointFields](namespaces/types.md#contractentrypointfields) --- ### Program Re-exports [Program](interfaces/types.Program.md) --- ### CairoAssembly Re-exports [CairoAssembly](namespaces/types.md#cairoassembly) --- ### CompiledSierra Re-exports [CompiledSierra](namespaces/types.md#compiledsierra) --- ### SierraContractClass Re-exports [SierraContractClass](namespaces/types.md#sierracontractclass) --- ### CompiledSierraCasm Re-exports [CompiledSierraCasm](namespaces/types.md#compiledsierracasm) --- ### ByteCode Re-exports [ByteCode](namespaces/types.md#bytecode) --- ### PythonicHints Re-exports [PythonicHints](namespaces/types.md#pythonichints) --- ### SierraProgramDebugInfo Re-exports [SierraProgramDebugInfo](namespaces/types.md#sierraprogramdebuginfo) --- ### SierraEntryPointsByType Re-exports [SierraEntryPointsByType](namespaces/types.md#sierraentrypointsbytype) --- ### SierraContractEntryPointFields Re-exports [SierraContractEntryPointFields](namespaces/types.md#sierracontractentrypointfields) --- ### ProviderOptions Re-exports [ProviderOptions](interfaces/types.ProviderOptions.md) --- ### RpcProviderOptions Re-exports [RpcProviderOptions](namespaces/types.md#rpcprovideroptions) --- ### SequencerHttpMethod Re-exports [SequencerHttpMethod](namespaces/types.md#sequencer --- ### SequencerProviderOptions Re-exports [SequencerProviderOptions](namespaces/types.md#sequencerprovideroptions) --- ### GetBlockResponse Re-exports [GetBlockResponse](interfaces/types.GetBlockResponse.md) --- ### GetCodeResponse Re-exports [GetCodeResponse](interfaces/types.GetCodeResponse.md) --- ### GetTransactionResponse Re-exports [GetTransactionResponse](namespaces/types.md#gettransactionresponse) --- ### CommonTransactionResponse Re-exports [CommonTransactionResponse](interfaces/types.CommonTransactionResponse.md) --- ### InvokeTransactionResponse Re-exports [InvokeTransactionResponse](interfaces/types.InvokeTransactionResponse.md) --- ### ContractEntryPoint Re-exports [ContractEntryPoint](interfaces/types.ContractEntryPoint.md) --- ### DeclareTransactionResponse Re-exports [DeclareTransactionResponse](interfaces/types.DeclareTransactionResponse.md) --- ### GetTransactionReceiptResponse Re-exports [GetTransactionReceiptResponse](namespaces/types.md#gettransactionreceiptresponse) --- ### CommonTransactionReceiptResponse Re-exports [CommonTransactionReceiptResponse](interfaces/types.CommonTransactionReceiptResponse.md) --- ### MessageToL1 Re-exports [MessageToL1](interfaces/types.MessageToL1.md) --- ### Event Re-exports [Event](interfaces/types.Event.md) --- ### MessageToL2 Re-exports [MessageToL2](interfaces/types.MessageToL2.md) --- ### InvokeTransactionReceiptResponse Re-exports [InvokeTransactionReceiptResponse](interfaces/types.InvokeTransactionReceiptResponse.md) --- ### DeclareTransactionReceiptResponse Re-exports [DeclareTransactionReceiptResponse](namespaces/types.md#declaretransactionreceiptresponse) --- ### EstimateFeeResponse Re-exports [EstimateFeeResponse](interfaces/types.EstimateFeeResponse.md) --- ### InvokeFunctionResponse Re-exports [InvokeFunctionResponse](interfaces/types.InvokeFunctionResponse.md) --- ### DeclareContractResponse Re-exports [DeclareContractResponse](interfaces/types.DeclareContractResponse.md) --- ### CallContractResponse Re-exports [CallContractResponse](namespaces/types.md#callcontractresponse) --- ### EstimateFeeAction Re-exports [EstimateFeeAction](namespaces/types.md#estimatefeeaction) --- ### EstimateFeeResponseBulk Re-exports [EstimateFeeResponseBulk](namespaces/types.md#estimatefeeresponsebulk) --- ### Storage Re-exports [Storage](namespaces/types.md#storage) --- ### Nonce Re-exports [Nonce](namespaces/types.md#nonce) --- ### SimulationFlags Re-exports [SimulationFlags](namespaces/types.md#simulationflags) --- ### SimulatedTransaction Re-exports [SimulatedTransaction](namespaces/types.md#simulatedtransaction) --- ### SimulateTransactionResponse Re-exports [SimulateTransactionResponse](namespaces/types.md#simulatetransactionresponse) --- ### StateUpdateResponse Re-exports [StateUpdateResponse](interfaces/types.StateUpdateResponse.md) --- ### ContractClassResponse Re-exports [ContractClassResponse](namespaces/types.md#contractclassresponse) --- ### InvocationsSignerDetails Re-exports [InvocationsSignerDetails](interfaces/types.InvocationsSignerDetails.md) --- ### DeclareSignerDetails Re-exports [DeclareSignerDetails](interfaces/types.DeclareSignerDetails.md) --- ### DeployAccountSignerDetails Re-exports [DeployAccountSignerDetails](namespaces/types.md#deployaccountsignerdetails) --- ### StarkNetMerkleType Re-exports [StarkNetMerkleType](namespaces/types.md#starknetmerkletype) --- ### StarkNetType Re-exports [StarkNetType](namespaces/types.md#starknettype) --- ### StarkNetDomain Re-exports [StarkNetDomain](interfaces/types.StarkNetDomain.md) --- ### TypedData Re-exports [TypedData](interfaces/types.TypedData.md) --- ### GetTransactionStatusResponse Re-exports [GetTransactionStatusResponse](namespaces/types.md#gettransactionstatusresponse) --- ### GetContractAddressesResponse Re-exports [GetContractAddressesResponse](namespaces/types.md#getcontractaddressesresponse) --- ### FunctionInvocation Re-exports [FunctionInvocation](namespaces/types.md#functioninvocation) --- ### ExecutionResources Re-exports [ExecutionResources](namespaces/types.md#executionresources) --- ### CallL1Handler Re-exports [CallL1Handler](namespaces/types.md#calll1handler) --- ### DeployedContractItem Re-exports [DeployedContractItem](namespaces/types.md#deployedcontractitem) --- ### SequencerIdentifier Re-exports [SequencerIdentifier](namespaces/types.md#sequenceridentifier) --- ### Sequencer Re-exports [Sequencer](namespaces/types.Sequencer.md) --- ### RPC Re-exports [RPC](namespaces/types.RPC.md) --- ### ValidateType Re-exports [ValidateType](enums/types.ValidateType.md) --- ### Uint Re-exports [Uint](enums/types.Uint.md) ## Variables ### number \u2022 `Const` **number**: [`num`](namespaces/num.md) = `num` **`Deprecated`** prefer the 'num' naming #### Defined in [src/index.ts:44]( --- ### defaultProvider \u2022 `Const` **defaultProvider**: [`Provider`](classes/Provider.md) #### Defined in [src/provider/index.ts:9]( ## Functions ### getCalldata \u25b8 **getCalldata**(`args`, `callback`): [`Calldata`](namespaces/types.md#calldata) #### Parameters | Name | Type | | :--------- | :--------------------------------------- | | `args` | [`RawArgs`](namespaces/types.md#rawargs) | | `callback` | `Function` | #### Returns [`Calldata`](namespaces/types.md#calldata) #### Defined in [src/contract/default.ts:100]( --- ### splitArgsAndOptions \u25b8 **splitArgsAndOptions**(`args`): { `args`: [`ArgsOrCalldata`](namespaces/types.md#argsorcalldata) ; `options`: [`ContractOptions`](namespaces/types.md#contractoptions) } \\| { `args`: [`ArgsOrCalldata`](namespaces/types.md#argsorcalldata) ; `options?`: `undefined` } #### Parameters | Name | Type | | :----- | :--------------------------------------------------------------------------- | | `args` | [`ArgsOrCalldataWithOptions`](namespaces/types.md#argsorcalldatawithoptions) | #### Returns { `args`: [`ArgsOrCalldata`](namespaces/types.md#argsorcalldata) ; `options`: [`ContractOptions`](namespaces/types.md#contractoptions) } \\| { `args`: [`ArgsOrCalldata`](namespaces/types.md#argsorcalldata) ; `options?`: `undefined` } #### Defined in [src/contract/default.ts:27]( --- ### fixStack \u25b8 **fixStack**(`target`, `fn?`): `void` #### Parameters | Name | Type | Default value | | :------- | :--------- | :------------------- | | `target` | `Error` | `undefined` | | `fn` | `Function` | `target.constructor` | #### Returns `void` #### Defined in [src/provider/errors.ts:2]( --- ### fixProto \u25b8 **fixProto**(`target`, `prototype`): `void` #### Parameters | Name | Type | | :---------- | :------- | | `target` | `Error` | | `prototype` | `Object` | #### Returns `void` #### Defined in [src/provider/errors.ts:8]( --- ### addAddressPadding \u25b8 **addAddressPadding**(`address`): `string` #### Parameters | Name | Type | | :-------- | :------------------------------------------------- | | `address` | [`BigNumberish`](namespaces/types.md#bignumberish) | #### Returns `string` #### Defined in [src/utils/address.ts:10]( --- ### validateAndParseAddress \u25b8 **validateAndParseAddress**(`address`): `string` #### Parameters | Name | Type | | :-------- | :------------------------------------------------- | | `address` | [`BigNumberish`](namespaces/types.md#bignumberish) | #### Returns `string` #### Defined in [src/utils/address.ts:14]( --- ### getChecksumAddress \u25b8 **getChecksumAddress**(`address`): `string` #### Parameters | Name | Type | | :-------- | :------------------------------------------------- | | `address` | [`BigNumberish`](namespaces/types.md#bignumberish) | #### Returns `string` #### Defined in [src/utils/address.ts:27]( --- ### validateChecksumAddress \u25b8 **validateChecksumAddress**(`address`): `boolean` #### Parameters | Name | Type | | :-------- | :------- | | `address` | `string` | #### Returns `boolean` #### Defined in [src/utils/address.ts:44]( --- ### isUrl \u25b8 **isUrl**(`s?`): `boolean` Loosely validate a URL `string`. #### Parameters | Name | Type | | :--- | :------- | | `s?` | `string` | #### Returns `boolean` #### Defined in [src/utils/url.ts:22]( --- ### buildUrl \u25b8 **buildUrl**(`baseUrl`, `defaultPath`, `urlOrPath?`): `string` #### Parameters | Name | Type | | :------------ | :------- | | `baseUrl` | `string` | | `defaultPath` | `string` | | `urlOrPath?` | `string` | #### Returns `string` #### Defined in [src/utils/url.ts:51]( --- ### isSierra \u25b8 **isSierra**(`contract`): contract is CompiledSierra \\| SierraContractClass #### Parameters | Name | Type | | :--------- | :--------------------------------------------------------------- | | `contract` | `string` \\| [`CairoContract`](namespaces/types.md#cairocontract) | #### Returns contract is CompiledSierra \\| SierraContractClass #### Defined in [src/utils/contract.ts:14]( --- ### extractContractHashes \u25b8 **extractContractHashes**(`payload`): [`CompleteDeclareContractPayload`](namespaces/types.md#completedeclarecontractpayload) #### Parameters | Name | Type | | :-------- | :--------------------------------------------------------------------- | | `payload` | [`DeclareContractPayload`](namespaces/types.md#declarecontractpayload) | #### Returns [`CompleteDeclareContractPayload`](namespaces/types.md#completedeclarecontractpayload) #### Defined in [src/utils/contract.ts:21]( --- ### contractClassResponseToLegacyCompiledContract \u25b8 **contractClassResponseToLegacyCompiledContract**(`ccr`): [`LegacyCompiledContract`](namespaces/types.md#legacycompiledcontract) Helper to redeclare response Cairo0 contract #### Parameters | Name | Type | Description | | :---- | :------------------------------------------------------------------- | :-------------------- | | `ccr` | [`ContractClassResponse`](namespaces/types.md#contractclassresponse) | ContractClassResponse | #### Returns [`LegacyCompiledContract`](namespaces/types.md#legacycompiledcontract) LegacyCompiledContract #### Defined in [src/utils/contract.ts:48]( --- ### parseUDCEvent \u25b8 **parseUDCEvent**(`txReceipt`): `Object` Parse Transaction Receipt Event from UDC invoke transaction and create DeployContractResponse compatibile response with adition of UDC Event data #### Parameters | Name | Type | | :---------- | :----------------------------------------------------------------------------------------- | | `txReceipt` | [`InvokeTransactionReceiptResponse`](interfaces/types.InvokeTransactionReceiptResponse.md) | #### Returns `Object` DeployContractResponse | UDC Event Response data | Name | Type | | :----------------- | :--------- | | `transaction_hash` | `string` | | `contract_address` | `string` | | `address` | `string` | | `deployer` | `string` | | `unique` | `string` | | `classHash` | `string` | | `calldata_len` | `string` | | `calldata` | `string`[] | | `salt` | `string` | #### Defined in [src/utils/events.ts:12]("}
{"title": "RPC.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'RPC' title: 'Namespace: RPC' sidebar_label: 'RPC' sidebar_position: 0 custom_edit_url: null --- ## Enumerations - [TransactionType](../enums/RPC.TransactionType.md) ## Type Aliases ### Response \u01ac **Response**: `Object` #### Type declaration | Name | Type | | :-------------- | :----------------------------------------- | | `id` | `number` | | `jsonrpc` | `string` | | `result?` | `any` | | `error?` | { `code`: `string` ; `message`: `string` } | | `error.code` | `string` | | `error.message` | `string` | #### Defined in [src/types/api/rpc.ts:4]( --- ### ChainId \u01ac **ChainId**: `OPENRPC.CHAIN_ID` #### Defined in [src/types/api/rpc.ts:14]( --- ### CallResponse \u01ac **CallResponse**: `OPENRPC.CallResponse` #### Defined in [src/types/api/rpc.ts:15]( --- ### ContractAddress \u01ac **ContractAddress**: `ADDRESS` #### Defined in [src/types/api/rpc.ts:16]( --- ### Felt \u01ac **Felt**: `FELT` #### Defined in [src/types/api/rpc.ts:17]( --- ### Nonce \u01ac **Nonce**: `OPENRPC.Nonce` #### Defined in [src/types/api/rpc.ts:18]( --- ### ContractClass \u01ac **ContractClass**: `OPENRPC.ContractClass` #### Defined in [src/types/api/rpc.ts:19]( --- ### StateUpdate \u01ac **StateUpdate**: `OPENRPC.StateUpdate` #### Defined in [src/types/api/rpc.ts:20]( --- ### Transaction \u01ac **Transaction**: `OPENRPC.Transaction` #### Defined in [src/types/api/rpc.ts:21]( --- ### PendingTransactions \u01ac **PendingTransactions**: `OPENRPC.PendingTransactions` #### Defined in [src/types/api/rpc.ts:22]( --- ### TransactionHash \u01ac **TransactionHash**: `OPENRPC.TransactionHash` #### Defined in [src/types/api/rpc.ts:23]( --- ### Trace \u01ac **Trace**: `OPENRPC.Trace` #### Defined in [src/types/api/rpc.ts:24]( --- ### Traces \u01ac **Traces**: `OPENRPC.Traces` #### Defined in [src/types/api/rpc.ts:25]( --- ### BlockHash \u01ac **BlockHash**: `OPENRPC.BlockHash` #### Defined in [src/types/api/rpc.ts:26]( --- ### BlockHashAndNumber \u01ac **BlockHashAndNumber**: `OPENRPC.BlockHashAndNumber` #### Defined in [src/types/api/rpc.ts:27]( --- ### GetClassResponse \u01ac **GetClassResponse**: `OPENRPC.ContractClass` #### Defined in [src/types/api/rpc.ts:28]( --- ### EstimateFeeResponse \u01ac **EstimateFeeResponse**: `OPENRPC.EstimatedFee` #### Defined in [src/types/api/rpc.ts:29]( --- ### GetBlockWithTxHashesResponse \u01ac **GetBlockWithTxHashesResponse**: `OPENRPC.BlockWithTxHashes` #### Defined in [src/types/api/rpc.ts:30]( --- ### GetBlockWithTxs \u01ac **GetBlockWithTxs**: `OPENRPC.BlockWithTxs` #### Defined in [src/types/api/rpc.ts:31]( --- ### GetStorageAtResponse \u01ac **GetStorageAtResponse**: `OPENRPC.Storage` #### Defined in [src/types/api/rpc.ts:32]( --- ### TransactionReceipt \u01ac **TransactionReceipt**: `OPENRPC.TransactionReceipt` #### Defined in [src/types/api/rpc.ts:33]( --- ### GetTransactionByHashResponse \u01ac **GetTransactionByHashResponse**: `OPENRPC.Transaction` #### Defined in [src/types/api/rpc.ts:34]( --- ### GetTransactionByBlockIdAndIndex \u01ac **GetTransactionByBlockIdAndIndex**: `OPENRPC.Transaction` #### Defined in [src/types/api/rpc.ts:35]( --- ### GetTransactionCountResponse \u01ac **GetTransactionCountResponse**: `number` #### Defined in [src/types/api/rpc.ts:36]( --- ### GetBlockNumberResponse \u01ac **GetBlockNumberResponse**: `OPENRPC.BlockNumber` #### Defined in [src/types/api/rpc.ts:37]( --- ### GetSyncingStatsResponse \u01ac **GetSyncingStatsResponse**: `OPENRPC.SyncingStatus` #### Defined in [src/types/api/rpc.ts:38]( --- ### EventFilter \u01ac **EventFilter**: `OPENRPC.EventFilter` #### Defined in [src/types/api/rpc.ts:39]( --- ### GetEventsResponse \u01ac **GetEventsResponse**: `OPENRPC.Events` #### Defined in [src/types/api/rpc.ts:40]( --- ### InvokedTransaction \u01ac **InvokedTransaction**: `OPENRPC.InvokedTransaction` #### Defined in [src/types/api/rpc.ts:41]( --- ### DeclaredTransaction \u01ac **DeclaredTransaction**: `OPENRPC.DeclaredTransaction` #### Defined in [src/types/api/rpc.ts:42]( --- ### DeployedTransaction \u01ac **DeployedTransaction**: `OPENRPC.DeployedTransaction` #### Defined in [src/types/api/rpc.ts:43]( --- ### Methods \u01ac **Methods**: `OPENRPC.Methods` #### Defined in [src/types/api/rpc.ts:44]( --- ### Storage \u01ac **Storage**: `OPENRPC.Storage` #### Defined in [src/types/api/rpc.ts:45]( --- ### StorageDiffs \u01ac **StorageDiffs**: `CONTRACT_STORAGE_DIFF_ITEM`[] #### Defined in [src/types/api/rpc.ts:56]( --- ### DeclaredContractHashes \u01ac **DeclaredContractHashes**: `FELT`[] #### Defined in [src/types/api/rpc.ts:57]( --- ### Nonces \u01ac **Nonces**: { `contract_address`: `ADDRESS` ; `nonce`: `FELT` }[] #### Defined in [src/types/api/rpc.ts:58]("}
{"title": "Sequencer.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'Sequencer' title: 'Namespace: Sequencer' sidebar_label: 'Sequencer' sidebar_position: 0 custom_edit_url: null --- ## Interfaces - [InvokeFunctionTransactionResponse](../interfaces/Sequencer.InvokeFunctionTransactionResponse.md) ## Type Aliases ### DeclareTransaction \u01ac **DeclareTransaction**: `Object` #### Type declaration | Name | Type | | :--------------------- | :--------------------------------------------- | | `type` | `\"DECLARE\"` | | `sender_address` | `string` | | `contract_class` | [`ContractClass`](../modules.md#contractclass) | | `signature?` | `string`[] | | `nonce` | [`BigNumberish`](num.md#bignumberish) | | `max_fee?` | [`BigNumberish`](num.md#bignumberish) | | `version?` | [`BigNumberish`](num.md#bignumberish) | | `compiled_class_hash?` | `string` | #### Defined in [src/types/api/sequencer.ts:81]( --- ### DeployTransaction \u01ac **DeployTransaction**: `Object` #### Type declaration | Name | Type | | :---------------------- | :--------------------------------------------- | | `type` | `\"DEPLOY\"` | | `contract_definition` | [`ContractClass`](../modules.md#contractclass) | | `contract_address_salt` | [`BigNumberish`](num.md#bignumberish) | | `constructor_calldata` | `string`[] | | `nonce?` | [`BigNumberish`](num.md#bignumberish) | #### Defined in [src/types/api/sequencer.ts:92]( --- ### DeployAccountTransaction \u01ac **DeployAccountTransaction**: `Object` #### Type declaration | Name | Type | | :---------------------- | :------------------------------------ | | `type` | `\"DEPLOY_ACCOUNT\"` | | `class_hash` | `string` | | `contract_address_salt` | [`BigNumberish`](num.md#bignumberish) | | `constructor_calldata` | `string`[] | | `signature?` | `string`[] | | `max_fee?` | [`BigNumberish`](num.md#bignumberish) | | `version?` | [`BigNumberish`](num.md#bignumberish) | | `nonce?` | [`BigNumberish`](num.md#bignumberish) | #### Defined in [src/types/api/sequencer.ts:100]( --- ### InvokeFunctionTransaction \u01ac **InvokeFunctionTransaction**: `Object` #### Type declaration | Name | Type | | :------------------ | :------------------------------------------------ | | `type` | `\"INVOKE_FUNCTION\"` | | `sender_address` | `string` | | `signature?` | `string`[] | | `entry_point_type?` | [`EXTERNAL`](../enums/EntryPointType.md#external) | | `calldata?` | [`RawCalldata`](../modules.md#rawcalldata) | | `nonce` | [`BigNumberish`](num.md#bignumberish) | | `max_fee?` | [`BigNumberish`](num.md#bignumberish) | | `version?` | [`BigNumberish`](num.md#bignumberish) | #### Defined in [src/types/api/sequencer.ts:111]( --- ### Transaction \u01ac **Transaction**: [`DeclareTransaction`](Sequencer.md#declaretransaction) \\| [`DeployTransaction`](Sequencer.md#deploytransaction) \\| [`InvokeFunctionTransaction`](Sequencer.md#invokefunctiontransaction) \\| [`DeployAccountTransaction`](Sequencer.md#deployaccounttransaction) #### Defined in [src/types/api/sequencer.ts:122]( --- ### AddTransactionResponse \u01ac **AddTransactionResponse**: `Object` #### Type declaration | Name | Type | | :----------------- | :----------------------- | | `transaction_hash` | `string` | | `code?` | `\"TRANSACTION_RECEIVED\"` | | `address?` | `string` | | `class_hash?` | `string` | #### Defined in [src/types/api/sequencer.ts:128]( --- ### GetCodeResponse \u01ac **GetCodeResponse**: `Object` #### Type declaration | Name | Type | | :--------- | :----------------------------------- | | `bytecode` | [`ByteCode`](../modules.md#bytecode) | | `abi` | [`Abi`](../modules.md#abi) | #### Defined in [src/types/api/sequencer.ts:135]( --- ### TransactionResponse \u01ac **TransactionResponse**: [`DeclareTransaction`](Sequencer.md#declaretransaction) \\| [`DeployTransaction`](Sequencer.md#deploytransaction) \\| [`InvokeFunctionTransactionResponse`](../interfaces/Sequencer.InvokeFunctionTransactionResponse.md) #### Defined in [src/types/api/sequencer.ts:145]( --- ### SuccessfulTransactionResponse \u01ac **SuccessfulTransactionResponse**: `Object` #### Type declaration | Name | Type | | :------------------ | :-------------------------------------------------------- | | `status` | [`Status`](../modules.md#status) | | `transaction` | [`TransactionResponse`](Sequencer.md#transactionresponse) | | `block_hash` | `string` | | `block_number` | [`BlockNumber`](../modules.md#blocknumber) | | `transaction_index` | `number` | #### Defined in [src/types/api/sequencer.ts:150]( --- ### FailedTransactionResponse \u01ac **FailedTransactionResponse**: `Object` #### Type declaration | Name | Type | | :----------------------------------------- | :-------------------------------------------------------- | | `status` | `\"REJECTED\"` | | `transaction_failure_reason` | { `code`: `string` ; `error_message`: `string` } | | `transaction_failure_reason.code` | `string` | | `transaction_failure_reason.error_message` | `string` | | `transaction` | [`TransactionResponse`](Sequencer.md#transactionresponse) | #### Defined in [src/types/api/sequencer.ts:158]( --- ### GetTransactionResponse \u01ac **GetTransactionResponse**: [`SuccessfulTransactionResponse`](Sequencer.md#successfultransactionresponse) \\| [`FailedTransactionResponse`](Sequencer.md#failedtransactionresponse) #### Defined in [src/types/api/sequencer.ts:167]( --- ### TransactionReceiptResponse \u01ac **TransactionReceiptResponse**: [`SuccessfulTransactionReceiptResponse`](Sequencer.md#successfultransactionreceiptresponse) \\| [`FailedTransactionReceiptResponse`](Sequencer.md#failedtransactionreceiptresponse) #### Defined in [src/types/api/sequencer.ts:169]( --- ### SuccessfulTransactionReceiptResponse \u01ac **SuccessfulTransactionReceiptResponse**: `Object` #### Type declaration | Name | Type | | :-------------------- | :------------------------------------------------------- | | `status` | [`Status`](../modules.md#status) | | `transaction_hash` | `string` | | `transaction_index` | `number` | | `block_hash` | `string` | | `block_number` | [`BlockNumber`](../modules.md#blocknumber) | | `l2_to_l1_messages` | `string`[] | | `events` | `string`[] | | `actual_fee` | `string` | | `execution_resources` | [`ExecutionResources`](../modules.md#executionresources) | #### Defined in [src/types/api/sequencer.ts:173]( --- ### FailedTransactionReceiptResponse \u01ac **FailedTransactionReceiptResponse**: `Object` #### Type declaration | Name | Type | | :----------------------------------------- | :----------------------------------------------- | | `status` | `\"REJECTED\"` | | `transaction_failure_reason` | { `code`: `string` ; `error_message`: `string` } | | `transaction_failure_reason.code` | `string` | | `transaction_failure_reason.error_message` | `string` | | `transaction_hash` | `string` | | `l2_to_l1_messages` | `string`[] | | `events` | `string`[] | #### Defined in [src/types/api/sequencer.ts:185]( --- ### GetBlockResponse \u01ac **GetBlockResponse**: `Object` #### Type declaration | Name | Type | | :--------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `block_number` | `number` | | `state_root` | `string` | | `block_hash` | `string` | | `transactions` | { `[txHash: string]`: [`TransactionResponse`](Sequencer.md#transactionresponse); } | | `timestamp` | `number` | | `transaction_receipts` | { `[txHash: string]`: { `block_hash`: `string` ; `transaction_hash`: `string` ; `l2_to_l1_messages`: { `to_address`: `string` ; `payload`: `string`[] ; `from_address`: `string` }[] ; `block_number`: [`BlockNumber`](../modules.md#blocknumber) ; `status`: [`Status`](../modules.md#status) ; `transaction_index`: `number` }; } | | `parent_block_hash` | `string` | | `status` | [`Status`](../modules.md#status) | | `gas_price` | `string` | | `sequencer_address` | `string` | | `starknet_version` | `string` | #### Defined in [src/types/api/sequencer.ts:196]( --- ### CallContractTransaction \u01ac **CallContractTransaction**: { `calldata?`: [`RawCalldata`](../modules.md#rawcalldata) ; `max_fee?`: [`BigNumberish`](num.md#bignumberish) ; `version?`: [`BigNumberish`](num.md#bignumberish) ; `entry_point_selector`: `string` } & { `sender_address`: `string` ; `signature`: `string`[] } \\| { `contract_address`: `string` ; `signature?`: `never` } #### Defined in [src/types/api/sequencer.ts:225]( --- ### CallContractResponse \u01ac **CallContractResponse**: `Object` #### Type declaration | Name | Type | | :------- | :--------- | | `result` | `string`[] | #### Defined in [src/types/api/sequencer.ts:241]( --- ### InvokeEstimateFee \u01ac **InvokeEstimateFee**: `Omit` #### Defined in [src/types/api/sequencer.ts:245]( --- ### DeclareEstimateFee \u01ac **DeclareEstimateFee**: `Omit` #### Defined in [src/types/api/sequencer.ts:246]( --- ### DeployAccountEstimateFee \u01ac **DeployAccountEstimateFee**: `Omit` #### Defined in [src/types/api/sequencer.ts:247]( --- ### DeployEstimateFee \u01ac **DeployEstimateFee**: [`DeployTransaction`](Sequencer.md#deploytransaction) #### Defined in [src/types/api/sequencer.ts:248]( --- ### EstimateFeeRequest \u01ac **EstimateFeeRequest**: [`InvokeEstimateFee`](Sequencer.md#invokeestimatefee) \\| [`DeclareEstimateFee`](Sequencer.md#declareestimatefee) \\| [`DeployEstimateFee`](Sequencer.md#deployestimatefee) \\| [`DeployAccountEstimateFee`](Sequencer.md#deployaccountestimatefee) #### Defined in [src/types/api/sequencer.ts:250]( --- ### TransactionSimulationResponse \u01ac **TransactionSimulationResponse**: `Object` #### Type declaration | Name | Type | | :--------------- | :------------------------------------------------------------------- | | `trace` | [`TransactionTraceResponse`](../modules.md#transactiontraceresponse) | | `fee_estimation` | [`EstimateFeeResponse`](Sequencer.md#estimatefeeresponse) | #### Defined in [src/types/api/sequencer.ts:256]( --- ### SimulateTransaction \u01ac **SimulateTransaction**: `Omit` #### Defined in [src/types/api/sequencer.ts:261]( --- ### EstimateFeeRequestBulk \u01ac **EstimateFeeRequestBulk**: [`AllowArray`](../modules.md#allowarray) #### Defined in [src/types/api/sequencer.ts:263]( --- ### EstimateFeeResponse \u01ac **EstimateFeeResponse**: { `overall_fee`: `number` ; `gas_price`: `number` ; `gas_usage`: `number` ; `uint`: `string` } \\| { `amount`: `bigint` ; `unit`: `string` } #### Defined in [src/types/api/sequencer.ts:268]( --- ### EstimateFeeResponseBulk \u01ac **EstimateFeeResponseBulk**: [`AllowArray`](../modules.md#allowarray) #### Defined in [src/types/api/sequencer.ts:280]( --- ### BlockTransactionTracesResponse \u01ac **BlockTransactionTracesResponse**: `Object` #### Type declaration | Name | Type | | :------- | :-------------------------------------------------------------------------------------------------------- | | `traces` | [`TransactionTraceResponse`](../modules.md#transactiontraceresponse) & { `transaction_hash`: `string` }[] | #### Defined in [src/types/api/sequencer.ts:282]( --- ### Storage \u01ac **Storage**: `string` #### Defined in [src/types/api/sequencer.ts:286]( --- ### StateUpdateResponse \u01ac **StateUpdateResponse**: `Object` #### Type declaration | Name | Type | | :---------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | `block_hash` | `string` | | `new_root` | `string` | | `old_root` | `string` | | `state_diff` | { `storage_diffs`: [`StorageDiffs`](Sequencer.md#storagediffs) ; `nonces`: [`Nonces`](Sequencer.md#nonces) ; `deployed_contracts`: [`DeployedContractItem`](../modules.md#deployedcontractitem)[] ; `old_declared_contracts`: [`OldDeclaredContracts`](Sequencer.md#olddeclaredcontracts) ; `declared_classes`: [`DeclaredClasses`](Sequencer.md#declaredclasses) ; `replaced_classes`: [`ReplacedClasses`](Sequencer.md#replacedclasses) } | | `state_diff.storage_diffs` | [`StorageDiffs`](Sequencer.md#storagediffs) | | `state_diff.nonces` | [`Nonces`](Sequencer.md#nonces) | | `state_diff.deployed_contracts` | [`DeployedContractItem`](../modules.md#deployedcontractitem)[] | | `state_diff.old_declared_contracts` | [`OldDeclaredContracts`](Sequencer.md#olddeclaredcontracts) | | `state_diff.declared_classes` | [`DeclaredClasses`](Sequencer.md#declaredclasses) | | `state_diff.replaced_classes` | [`ReplacedClasses`](Sequencer.md#replacedclasses) | #### Defined in [src/types/api/sequencer.ts:288]( --- ### StorageDiffs \u01ac **StorageDiffs**: `Object` #### Index signature [address: `string`]: [`StateDiffItem`](Sequencer.md#statediffitem)[] #### Defined in [src/types/api/sequencer.ts:302]( --- ### StateDiffItem \u01ac **StateDiffItem**: `Object` #### Type declaration | Name | Type | | :------ | :------- | | `key` | `string` | | `value` | `string` | #### Defined in [src/types/api/sequencer.ts:304]( --- ### Nonces \u01ac **Nonces**: `Object` #### Index signature [address: `string`]: [`Nonce`](Sequencer.md#nonce) #### Defined in [src/types/api/sequencer.ts:306]( --- ### Nonce \u01ac **Nonce**: `string` #### Defined in [src/types/api/sequencer.ts:308]( --- ### DeployedContracts \u01ac **DeployedContracts**: [`DeployedContractItem`](../modules.md#deployedcontractitem)[] #### Defined in [src/types/api/sequencer.ts:310]( --- ### OldDeclaredContracts \u01ac **OldDeclaredContracts**: `string`[] #### Defined in [src/types/api/sequencer.ts:312]( --- ### DeclaredClasses \u01ac **DeclaredClasses**: [`DeclaredClass`](Sequencer.md#declaredclass)[] #### Defined in [src/types/api/sequencer.ts:314]( --- ### DeclaredClass \u01ac **DeclaredClass**: `Object` #### Type declaration | Name | Type | | :-------------------- | :------- | | `class_hash` | `string` | | `compiled_class_hash` | `string` | #### Defined in [src/types/api/sequencer.ts:316]( --- ### ReplacedClasses \u01ac **ReplacedClasses**: `string`[] #### Defined in [src/types/api/sequencer.ts:318]( --- ### Endpoints \u01ac **Endpoints**: `Object` #### Type declaration | Name | Type | | :-------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `get_contract_addresses` | { `QUERY`: `never` ; `REQUEST`: `never` ; `RESPONSE`: [`GetContractAddressesResponse`](../modules.md#getcontractaddressesresponse) } | | `get_contract_addresses.QUERY` | `never` | | `get_contract_addresses.REQUEST` | `never` | | `get_contract_addresses.RESPONSE` | [`GetContractAddressesResponse`](../modules.md#getcontractaddressesresponse) | | `add_transaction` | { `QUERY`: `never` ; `REQUEST`: [`Transaction`](Sequencer.md#transaction) ; `RESPONSE`: [`AddTransactionResponse`](Sequencer.md#addtransactionresponse) } | | `add_transaction.QUERY` | `never` | | `add_transaction.REQUEST` | [`Transaction`](Sequencer.md#transaction) | | `add_transaction.RESPONSE` | [`AddTransactionResponse`](Sequencer.md#addtransactionresponse) | | `get_transaction` | { `QUERY`: { `transactionHash`: `string` } ; `REQUEST`: `never` ; `RESPONSE`: [`GetTransactionResponse`](Sequencer.md#gettransactionresponse) } | | `get_transaction.QUERY` | { `transactionHash`: `string` } | | `get_transaction.QUERY.transactionHash` | `string` | | `get_transaction.REQUEST` | `never` | | `get_transaction.RESPONSE` | [`GetTransactionResponse`](Sequencer.md#gettransactionresponse) | | `get_transaction_status` | { `QUERY`: { `transactionHash`: `string` } ; `REQUEST`: `never` ; `RESPONSE`: [`GetTransactionStatusResponse`](../modules.md#gettransactionstatusresponse) } | | `get_transaction_status.QUERY` | { `transactionHash`: `string` } | | `get_transaction_status.QUERY.transactionHash` | `string` | | `get_transaction_status.REQUEST` | `never` | | `get_transaction_status.RESPONSE` | [`GetTransactionStatusResponse`](../modules.md#gettransactionstatusresponse) | | `get_transaction_trace` | { `QUERY`: { `transactionHash`: `string` } ; `REQUEST`: `never` ; `RESPONSE`: [`TransactionTraceResponse`](../modules.md#transactiontraceresponse) } | | `get_transaction_trace.QUERY` | { `transactionHash`: `string` } | | `get_transaction_trace.QUERY.transactionHash` | `string` | | `get_transaction_trace.REQUEST` | `never` | | `get_transaction_trace.RESPONSE` | [`TransactionTraceResponse`](../modules.md#transactiontraceresponse) | | `get_transaction_receipt` | { `QUERY`: { `transactionHash`: `string` } ; `REQUEST`: `never` ; `RESPONSE`: [`TransactionReceiptResponse`](Sequencer.md#transactionreceiptresponse) } | | `get_transaction_receipt.QUERY` | { `transactionHash`: `string` } | | `get_transaction_receipt.QUERY.transactionHash` | `string` | | `get_transaction_receipt.REQUEST` | `never` | | `get_transaction_receipt.RESPONSE` | [`TransactionReceiptResponse`](Sequencer.md#transactionreceiptresponse) | | `get_nonce` | { `QUERY`: { `contractAddress`: `string` ; `blockIdentifier`: `BlockIdentifier` } ; `REQUEST`: `never` ; `RESPONSE`: [`Nonce`](Sequencer.md#nonce) } | | `get_nonce.QUERY` | { `contractAddress`: `string` ; `blockIdentifier`: `BlockIdentifier` } | | `get_nonce.QUERY.contractAddress` | `string` | | `get_nonce.QUERY.blockIdentifier` | `BlockIdentifier` | | `get_nonce.REQUEST` | `never` | | `get_nonce.RESPONSE` | [`Nonce`](Sequencer.md#nonce) | | `get_storage_at` | { `QUERY`: { `contractAddress`: `string` ; `key`: [`BigNumberish`](num.md#bignumberish) ; `blockIdentifier`: `BlockIdentifier` } ; `REQUEST`: `never` ; `RESPONSE`: [`Storage`](Sequencer.md#storage) } | | `get_storage_at.QUERY` | { `contractAddress`: `string` ; `key`: [`BigNumberish`](num.md#bignumberish) ; `blockIdentifier`: `BlockIdentifier` } | | `get_storage_at.QUERY.contractAddress` | `string` | | `get_storage_at.QUERY.key` | [`BigNumberish`](num.md#bignumberish) | | `get_storage_at.QUERY.blockIdentifier` | `BlockIdentifier` | | `get_storage_at.REQUEST` | `never` | | `get_storage_at.RESPONSE` | [`Storage`](Sequencer.md#storage) | | `get_code` | { `QUERY`: { `contractAddress`: `string` ; `blockIdentifier`: `BlockIdentifier` } ; `REQUEST`: `never` ; `RESPONSE`: [`GetCodeResponse`](Sequencer.md#getcoderesponse) } | | `get_code.QUERY` | { `contractAddress`: `string` ; `blockIdentifier`: `BlockIdentifier` } | | `get_code.QUERY.contractAddress` | `string` | | `get_code.QUERY.blockIdentifier` | `BlockIdentifier` | | `get_code.REQUEST` | `never` | | `get_code.RESPONSE` | [`GetCodeResponse`](Sequencer.md#getcoderesponse) | | `get_block` | { `QUERY`: { `blockIdentifier`: `BlockIdentifier` } ; `REQUEST`: `never` ; `RESPONSE`: [`GetBlockResponse`](Sequencer.md#getblockresponse) } | | `get_block.QUERY` | { `blockIdentifier`: `BlockIdentifier` } | | `get_block.QUERY.blockIdentifier` | `BlockIdentifier` | | `get_block.REQUEST` | `never` | | `get_block.RESPONSE` | [`GetBlockResponse`](Sequencer.md#getblockresponse) | | `call_contract` | { `QUERY`: { `blockIdentifier`: `BlockIdentifier` } ; `REQUEST`: [`CallContractTransaction`](Sequencer.md#callcontracttransaction) ; `RESPONSE`: [`CallContractResponse`](Sequencer.md#callcontractresponse) } | | `call_contract.QUERY` | { `blockIdentifier`: `BlockIdentifier` } | | `call_contract.QUERY.blockIdentifier` | `BlockIdentifier` | | `call_contract.REQUEST` | [`CallContractTransaction`](Sequencer.md#callcontracttransaction) | | `call_contract.RESPONSE` | [`CallContractResponse`](Sequencer.md#callcontractresponse) | | `estimate_fee` | { `QUERY`: { `blockIdentifier`: `BlockIdentifier` ; `skipValidate`: `boolean` } ; `REQUEST`: [`EstimateFeeRequest`](Sequencer.md#estimatefeerequest) ; `RESPONSE`: [`EstimateFeeResponse`](Sequencer.md#estimatefeeresponse) } | | `estimate_fee.QUERY` | { `blockIdentifier`: `BlockIdentifier` ; `skipValidate`: `boolean` } | | `estimate_fee.QUERY.blockIdentifier` | `BlockIdentifier` | | `estimate_fee.QUERY.skipValidate` | `boolean` | | `estimate_fee.REQUEST` | [`EstimateFeeRequest`](Sequencer.md#estimatefeerequest) | | `estimate_fee.RESPONSE` | [`EstimateFeeResponse`](Sequencer.md#estimatefeeresponse) | | `get_class_by_hash` | { `QUERY`: { `classHash`: `string` ; `blockIdentifier?`: `BlockIdentifier` } ; `REQUEST`: `never` ; `RESPONSE`: [`CompiledContract`](../modules.md#compiledcontract) } | | `get_class_by_hash.QUERY` | { `classHash`: `string` ; `blockIdentifier?`: `BlockIdentifier` } | | `get_class_by_hash.QUERY.classHash` | `string` | | `get_class_by_hash.QUERY.blockIdentifier?` | `BlockIdentifier` | | `get_class_by_hash.REQUEST` | `never` | | `get_class_by_hash.RESPONSE` | [`CompiledContract`](../modules.md#compiledcontract) | | `get_class_hash_at` | { `QUERY`: { `contractAddress`: `string` ; `blockIdentifier?`: `BlockIdentifier` } ; `REQUEST`: `never` ; `RESPONSE`: `string` } | | `get_class_hash_at.QUERY` | { `contractAddress`: `string` ; `blockIdentifier?`: `BlockIdentifier` } | | `get_class_hash_at.QUERY.contractAddress` | `string` | | `get_class_hash_at.QUERY.blockIdentifier?` | `BlockIdentifier` | | `get_class_hash_at.REQUEST` | `never` | | `get_class_hash_at.RESPONSE` | `string` | | `get_state_update` | { `QUERY`: { `blockHash?`: `string` ; `blockNumber?`: [`BlockNumber`](../modules.md#blocknumber) } ; `REQUEST`: `never` ; `RESPONSE`: [`StateUpdateResponse`](Sequencer.md#stateupdateresponse) } | | `get_state_update.QUERY` | { `blockHash?`: `string` ; `blockNumber?`: [`BlockNumber`](../modules.md#blocknumber) } | | `get_state_update.QUERY.blockHash?` | `string` | | `get_state_update.QUERY.blockNumber?` | [`BlockNumber`](../modules.md#blocknumber) | | `get_state_update.REQUEST` | `never` | | `get_state_update.RESPONSE` | [`StateUpdateResponse`](Sequencer.md#stateupdateresponse) | | `get_full_contract` | { `QUERY`: { `contractAddress`: `string` ; `blockIdentifier?`: `BlockIdentifier` } ; `REQUEST`: `never` ; `RESPONSE`: [`CompiledContract`](../modules.md#compiledcontract) } | | `get_full_contract.QUERY` | { `contractAddress`: `string` ; `blockIdentifier?`: `BlockIdentifier` } | | `get_full_contract.QUERY.contractAddress` | `string` | | `get_full_contract.QUERY.blockIdentifier?` | `BlockIdentifier` | | `get_full_contract.REQUEST` | `never` | | `get_full_contract.RESPONSE` | [`CompiledContract`](../modules.md#compiledcontract) | | `estimate_message_fee` | { `QUERY`: `any` ; `REQUEST`: `any` ; `RESPONSE`: [`EstimateFeeResponse`](Sequencer.md#estimatefeeresponse) } | | `estimate_message_fee.QUERY` | `any` | | `estimate_message_fee.REQUEST` | `any` | | `estimate_message_fee.RESPONSE` | [`EstimateFeeResponse`](Sequencer.md#estimatefeeresponse) | | `simulate_transaction` | { `QUERY`: { `blockIdentifier`: `BlockIdentifier` ; `skipValidate`: `boolean` } ; `REQUEST`: [`SimulateTransaction`](Sequencer.md#simulatetransaction) ; `RESPONSE`: [`TransactionSimulationResponse`](Sequencer.md#transactionsimulationresponse) } | | `simulate_transaction.QUERY` | { `blockIdentifier`: `BlockIdentifier` ; `skipValidate`: `boolean` } | | `simulate_transaction.QUERY.blockIdentifier` | `BlockIdentifier` | | `simulate_transaction.QUERY.skipValidate` | `boolean` | | `simulate_transaction.REQUEST` | [`SimulateTransaction`](Sequencer.md#simulatetransaction) | | `simulate_transaction.RESPONSE` | [`TransactionSimulationResponse`](Sequencer.md#transactionsimulationresponse) | | `estimate_fee_bulk` | { `QUERY`: { `blockIdentifier`: `BlockIdentifier` } ; `REQUEST`: [`EstimateFeeRequestBulk`](Sequencer.md#estimatefeerequestbulk) ; `RESPONSE`: [`EstimateFeeResponseBulk`](Sequencer.md#estimatefeeresponsebulk) } | | `estimate_fee_bulk.QUERY` | { `blockIdentifier`: `BlockIdentifier` } | | `estimate_fee_bulk.QUERY.blockIdentifier` | `BlockIdentifier` | | `estimate_fee_bulk.REQUEST` | [`EstimateFeeRequestBulk`](Sequencer.md#estimatefeerequestbulk) | | `estimate_fee_bulk.RESPONSE` | [`EstimateFeeResponseBulk`](Sequencer.md#estimatefeeresponsebulk) | | `get_block_traces` | { `QUERY`: { `blockHash?`: `string` ; `blockNumber?`: [`BlockNumber`](../modules.md#blocknumber) } ; `REQUEST`: `never` ; `RESPONSE`: [`BlockTransactionTracesResponse`](Sequencer.md#blocktransactiontracesresponse) } | | `get_block_traces.QUERY` | { `blockHash?`: `string` ; `blockNumber?`: [`BlockNumber`](../modules.md#blocknumber) } | | `get_block_traces.QUERY.blockHash?` | `string` | | `get_block_traces.QUERY.blockNumber?` | [`BlockNumber`](../modules.md#blocknumber) | | `get_block_traces.REQUEST` | `never` | | `get_block_traces.RESPONSE` | [`BlockTransactionTracesResponse`](Sequencer.md#blocktransactiontracesresponse) | | `get_compiled_class_by_class_hash` | { `QUERY`: { `classHash`: `string` ; `blockIdentifier?`: `BlockIdentifier` } ; `REQUEST`: `any` ; `RESPONSE`: [`CairoAssembly`](../modules.md#cairoassembly) } | | `get_compiled_class_by_class_hash.QUERY` | { `classHash`: `string` ; `blockIdentifier?`: `BlockIdentifier` } | | `get_compiled_class_by_class_hash.QUERY.classHash` | `string` | | `get_compiled_class_by_class_hash.QUERY.blockIdentifier?` | `BlockIdentifier` | | `get_compiled_class_by_class_hash.REQUEST` | `any` | | `get_compiled_class_by_class_hash.RESPONSE` | [`CairoAssembly`](../modules.md#cairoassembly) | #### Defined in [src/types/api/sequencer.ts:320]("}
{"title": "cairo.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'cairo' title: 'Namespace: cairo' sidebar_label: 'cairo' sidebar_position: 0 custom_edit_url: null --- ## Functions ### isCairo1Abi \u25b8 **isCairo1Abi**(`abi`): `boolean` tells if an ABI comes from a Cairo 1 contract **`Example`** ```typescript const isCairo1: boolean = isCairo1Abi(myAbi: Abi); ``` #### Parameters | Name | Type | Description | | :---- | :-------------------- | :--------------------------------------------- | | `abi` | [`Abi`](types.md#abi) | representing the interface of a Cairo contract | #### Returns `boolean` TRUE if it is an ABI from a Cairo1 contract #### Defined in [src/utils/calldata/cairo.ts:37]( --- ### felt \u25b8 **felt**(`it`): `string` felt cairo type #### Parameters | Name | Type | | :--- | :-------------------------------------- | | `it` | [`BigNumberish`](types.md#bignumberish) | #### Returns `string` #### Defined in [src/utils/calldata/cairo.ts:85]( --- ### isLen \u25b8 **isLen**(`name`): `boolean` #### Parameters | Name | Type | | :----- | :------- | | `name` | `string` | #### Returns `boolean` #### Defined in [src/utils/calldata/cairo.ts:6]( --- ### isTypeFelt \u25b8 **isTypeFelt**(`type`): `boolean` #### Parameters | Name | Type | | :----- | :------- | | `type` | `string` | #### Returns `boolean` #### Defined in [src/utils/calldata/cairo.ts:7]( --- ### isTypeArray \u25b8 **isTypeArray**(`type`): `boolean` #### Parameters | Name | Type | | :----- | :------- | | `type` | `string` | #### Returns `boolean` #### Defined in [src/utils/calldata/cairo.ts:8]( --- ### isTypeTuple \u25b8 **isTypeTuple**(`type`): `boolean` #### Parameters | Name | Type | | :----- | :------- | | `type` | `string` | #### Returns `boolean` #### Defined in [src/utils/calldata/cairo.ts:10]( --- ### isTypeNamedTuple \u25b8 **isTypeNamedTuple**(`type`): `boolean` #### Parameters | Name | Type | | :----- | :------- | | `type` | `string` | #### Returns `boolean` #### Defined in [src/utils/calldata/cairo.ts:11]( --- ### isTypeStruct \u25b8 **isTypeStruct**(`type`, `structs`): `boolean` #### Parameters | Name | Type | | :-------- | :---------------------------------- | | `type` | `string` | | `structs` | [`AbiStructs`](types.md#abistructs) | #### Returns `boolean` #### Defined in [src/utils/calldata/cairo.ts:12]( --- ### isTypeUint \u25b8 **isTypeUint**(`type`): `boolean` #### Parameters | Name | Type | | :----- | :------- | | `type` | `string` | #### Returns `boolean` #### Defined in [src/utils/calldata/cairo.ts:13]( --- ### isTypeUint256 \u25b8 **isTypeUint256**(`type`): `boolean` #### Parameters | Name | Type | | :----- | :------- | | `type` | `string` | #### Returns `boolean` #### Defined in [src/utils/calldata/cairo.ts:14]( --- ### isTypeBool \u25b8 **isTypeBool**(`type`): `boolean` #### Parameters | Name | Type | | :----- | :------- | | `type` | `string` | #### Returns `boolean` #### Defined in [src/utils/calldata/cairo.ts:15]( --- ### isTypeContractAddress \u25b8 **isTypeContractAddress**(`type`): `boolean` #### Parameters | Name | Type | | :----- | :------- | | `type` | `string` | #### Returns `boolean` #### Defined in [src/utils/calldata/cairo.ts:16]( --- ### isCairo1Type \u25b8 **isCairo1Type**(`type`): `boolean` #### Parameters | Name | Type | | :----- | :------- | | `type` | `string` | #### Returns `boolean` #### Defined in [src/utils/calldata/cairo.ts:18]( --- ### getArrayType \u25b8 **getArrayType**(`type`): `string` #### Parameters | Name | Type | | :----- | :------- | | `type` | `string` | #### Returns `string` #### Defined in [src/utils/calldata/cairo.ts:20]( --- ### uint256 \u25b8 **uint256**(`it`): [`Uint256`](../interfaces/types.Uint256.md) Uint256 cairo type (helper for common struct type) #### Parameters | Name | Type | | :--- | :-------------------------------------- | | `it` | [`BigNumberish`](types.md#bignumberish) | #### Returns [`Uint256`](../interfaces/types.Uint256.md) #### Defined in [src/utils/calldata/cairo.ts:64]( --- ### tuple \u25b8 **tuple**(`...args`): `Record` unnamed tuple cairo type (helper same as common struct type) #### Parameters | Name | Type | | :-------- | :------------------------------------------------------------------- | | `...args` | (`boolean` \\| `object` \\| [`BigNumberish`](types.md#bignumberish))[] | #### Returns `Record` #### Defined in [src/utils/calldata/cairo.ts:78]("}
{"title": "constants.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'constants' title: 'Namespace: constants' sidebar_label: 'constants' sidebar_position: 0 custom_edit_url: null --- Utils ## Enumerations - [BaseUrl](../enums/constants.BaseUrl.md) - [NetworkName](../enums/constants.NetworkName.md) - [StarknetChainId](../enums/constants.StarknetChainId.md) - [TransactionHashPrefix](../enums/constants.TransactionHashPrefix.md) ## Variables ### IS_BROWSER \u2022 `Const` **IS_BROWSER**: `boolean` #### Defined in [src/utils/encode.ts:2]( --- ### ZERO \u2022 `Const` **ZERO**: `0n` #### Defined in [src/constants.ts:3]( --- ### MASK_250 \u2022 `Const` **MASK_250**: `bigint` #### Defined in [src/constants.ts:4]( --- ### MASK_251 \u2022 `Const` **MASK_251**: `bigint` #### Defined in [src/constants.ts:5]( --- ### API_VERSION \u2022 `Const` **API_VERSION**: `0n` #### Defined in [src/constants.ts:6]( --- ### UDC \u2022 `Const` **UDC**: `Object` #### Type declaration | Name | Type | | :----------- | :------- | | `ADDRESS` | `string` | | `ENTRYPOINT` | `string` | #### Defined in [src/constants.ts:34]( --- ### FIELD_PRIME \u2022 `Const` **FIELD_PRIME**: `\"800000000000011000000000000000000000000000000000000000000000001\"` The following is taken from but converted to hex, because JS is very bad handling big integers by default Please do not edit until the JSON changes. #### Defined in [src/constants.ts:43]( --- ### FIELD_GEN \u2022 `Const` **FIELD_GEN**: `\"3\"` #### Defined in [src/constants.ts:44]( --- ### FIELD_SIZE \u2022 `Const` **FIELD_SIZE**: `251` #### Defined in [src/constants.ts:45]( --- ### EC_ORDER \u2022 `Const` **EC_ORDER**: `\"800000000000010FFFFFFFFFFFFFFFFB781126DCAE7B2321E66A241ADC64D2F\"` #### Defined in [src/constants.ts:46]( --- ### ALPHA \u2022 `Const` **ALPHA**: `\"1\"` #### Defined in [src/constants.ts:47]( --- ### BETA \u2022 `Const` **BETA**: `\"6F21413EFBE40DE150E596D72F7A8C5609AD26C15C915C1F4CDFCB99CEE9E89\"` #### Defined in [src/constants.ts:48]( --- ### MAX_ECDSA_VAL \u2022 `Const` **MAX_ECDSA_VAL**: `\"800000000000000000000000000000000000000000000000000000000000000\"` #### Defined in [src/constants.ts:49]( --- ### CONSTANT_POINTS \u2022 `Const` **CONSTANT_POINTS**: `string`[][] #### Defined in [src/constants.ts:50]("}
{"title": "ec.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'ec' title: 'Namespace: ec' sidebar_label: 'ec' sidebar_position: 0 custom_edit_url: null --- ## Namespaces - [starkCurve](ec.starkCurve.md) - [weierstrass](ec.weierstrass.md)"}
{"title": "ec.starkCurve.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'ec.starkCurve' title: 'Namespace: starkCurve' sidebar_label: 'starkCurve' custom_edit_url: null --- [ec](ec.md).starkCurve ## Type Aliases ### ProjectivePoint \u01ac **ProjectivePoint**: [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md) #### Defined in node_modules/micro-starknet/lib/index.d.ts:6 node_modules/micro-starknet/lib/index.d.ts:44 --- ### PoseidonOpts \u01ac **PoseidonOpts**: `Object` #### Type declaration | Name | Type | | :-------------- | :------------------ | | `Fp` | `IField` | | `rate` | `number` | | `capacity` | `number` | | `roundsFull` | `number` | | `roundsPartial` | `number` | #### Defined in node_modules/micro-starknet/lib/index.d.ts:63 --- ### PoseidonFn \u01ac **PoseidonFn**: `ReturnType` & { `m`: `number` ; `rate`: `number` ; `capacity`: `number` } #### Defined in node_modules/micro-starknet/lib/index.d.ts:70 ## Variables ### \\_starkCurve \u2022 `Const` **\\_starkCurve**: [`weierstrass`](ec.weierstrass.md) #### Defined in node_modules/micro-starknet/lib/index.d.ts:7 --- ### CURVE \u2022 `Const` **CURVE**: `Readonly` ; `n`: `bigint` ; `h`: `bigint` ; `hEff?`: `bigint` ; `Gx`: `bigint` ; `Gy`: `bigint` ; `allowInfinityPoint?`: `boolean` ; `a`: `bigint` ; `b`: `bigint` ; `allowedPrivateKeyLengths?`: readonly `number`[] ; `wrapPrivateKey?`: `boolean` ; `endo?`: { `beta`: `bigint` ; `splitScalar`: (`k`: `bigint`) => { `k1neg`: `boolean` ; `k1`: `bigint` ; `k2neg`: `boolean` ; `k2`: `bigint` } } ; `isTorsionFree?`: (`c`: [`weierstrass`](ec.weierstrass.md), `point`: [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md)) => `boolean` ; `clearCofactor?`: (`c`: [`weierstrass`](ec.weierstrass.md), `point`: [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md)) => [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md) ; `hash`: `u.CHash` ; `hmac`: (`key`: `Uint8Array`, ...`messages`: `Uint8Array`[]) => `Uint8Array` ; `randomBytes`: (`bytesLength?`: `number`) => `Uint8Array` ; `lowS`: `boolean` ; `bits2int?`: (`bytes`: `Uint8Array`) => `bigint` ; `bits2int_modN?`: (`bytes`: `Uint8Array`) => `bigint` ; `p`: `bigint` }\\> #### Defined in node_modules/micro-starknet/lib/index.d.ts:12 --- ### ProjectivePoint \u2022 **ProjectivePoint**: [`ProjConstructor`](../interfaces/ec.weierstrass.ProjConstructor.md) #### Defined in node_modules/micro-starknet/lib/index.d.ts:6 node_modules/micro-starknet/lib/index.d.ts:44 --- ### Signature \u2022 `Const` **Signature**: [`weierstrass`](ec.weierstrass.md) #### Defined in node_modules/micro-starknet/lib/index.d.ts:44 --- ### utils \u2022 `Const` **utils**: `Object` #### Type declaration | Name | Type | | :----------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `normPrivateKeyToScalar` | (`key`: `u.PrivKey`) => `bigint` | | `randomPrivateKey` | () => `Uint8Array` | | `precompute` | (`windowSize?`: `number`, `point?`: [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md)) => [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md) | | `isValidPrivateKey` | (`privateKey`: `PrivKey`) => `boolean` | #### Defined in node_modules/micro-starknet/lib/index.d.ts:44 --- ### Fp253 \u2022 `Const` **Fp253**: `Readonly` & `Required`, `\"isOdd\"`\\>\\>\\> #### Defined in node_modules/micro-starknet/lib/index.d.ts:60 --- ### Fp251 \u2022 `Const` **Fp251**: `Readonly` & `Required`, `\"isOdd\"`\\>\\>\\> #### Defined in node_modules/micro-starknet/lib/index.d.ts:61 ## Functions ### getPublicKey \u25b8 **getPublicKey**(`privKey`, `isCompressed?`): `Uint8Array` #### Parameters | Name | Type | | :-------------- | :-------- | | `privKey` | `Hex` | | `isCompressed?` | `boolean` | #### Returns `Uint8Array` #### Defined in node_modules/micro-starknet/lib/index.d.ts:8 --- ### getSharedSecret \u25b8 **getSharedSecret**(`privKeyA`, `pubKeyB`): `Uint8Array` #### Parameters | Name | Type | | :--------- | :---- | | `privKeyA` | `Hex` | | `pubKeyB` | `Hex` | #### Returns `Uint8Array` #### Defined in node_modules/micro-starknet/lib/index.d.ts:9 --- ### sign \u25b8 **sign**(`msgHash`, `privKey`, `opts?`): [`SignatureType`](../interfaces/ec.weierstrass.SignatureType.md) #### Parameters | Name | Type | | :-------- | :---- | | `msgHash` | `Hex` | | `privKey` | `Hex` | | `opts?` | `any` | #### Returns [`SignatureType`](../interfaces/ec.weierstrass.SignatureType.md) #### Defined in node_modules/micro-starknet/lib/index.d.ts:10 --- ### verify \u25b8 **verify**(`signature`, `msgHash`, `pubKey`): `boolean` #### Parameters | Name | Type | | :---------- | :------------------------------------------------------------------------ | | `signature` | [`SignatureType`](../interfaces/ec.weierstrass.SignatureType.md) \\| `Hex` | | `msgHash` | `Hex` | | `pubKey` | `Hex` | #### Returns `boolean` #### Defined in node_modules/micro-starknet/lib/index.d.ts:11 --- ### grindKey \u25b8 **grindKey**(`seed`): `string` #### Parameters | Name | Type | | :----- | :---- | | `seed` | `Hex` | #### Returns `string` #### Defined in node_modules/micro-starknet/lib/index.d.ts:51 --- ### getStarkKey \u25b8 **getStarkKey**(`privateKey`): `string` #### Parameters | Name | Type | | :----------- | :---- | | `privateKey` | `Hex` | #### Returns `string` #### Defined in node_modules/micro-starknet/lib/index.d.ts:52 --- ### ethSigToPrivate \u25b8 **ethSigToPrivate**(`signature`): `string` #### Parameters | Name | Type | | :---------- | :------- | | `signature` | `string` | #### Returns `string` #### Defined in node_modules/micro-starknet/lib/index.d.ts:53 --- ### getAccountPath \u25b8 **getAccountPath**(`layer`, `application`, `ethereumAddress`, `index`): `string` #### Parameters | Name | Type | | :---------------- | :------- | | `layer` | `string` | | `application` | `string` | | `ethereumAddress` | `string` | | `index` | `number` | #### Returns `string` #### Defined in node_modules/micro-starknet/lib/index.d.ts:54 --- ### pedersen \u25b8 **pedersen**(`x`, `y`): `string` #### Parameters | Name | Type | | :--- | :------------ | | `x` | `PedersenArg` | | `y` | `PedersenArg` | #### Returns `string` #### Defined in node_modules/micro-starknet/lib/index.d.ts:56 --- ### hashChain \u25b8 **hashChain**(`data`, `fn?`): `PedersenArg` #### Parameters | Name | Type | | :----- | :--------------------------------------------------- | | `data` | `PedersenArg`[] | | `fn?` | (`x`: `PedersenArg`, `y`: `PedersenArg`) => `string` | #### Returns `PedersenArg` #### Defined in node_modules/micro-starknet/lib/index.d.ts:57 --- ### \\_poseidonMDS \u25b8 **\\_poseidonMDS**(`Fp`, `name`, `m`, `attempt?`): `bigint`[][] #### Parameters | Name | Type | | :--------- | :------------------ | | `Fp` | `IField` | | `name` | `string` | | `m` | `number` | | `attempt?` | `number` | #### Returns `bigint`[][] #### Defined in node_modules/micro-starknet/lib/index.d.ts:62 --- ### poseidonBasic \u25b8 **poseidonBasic**(`opts`, `mds`): [`PoseidonFn`](ec.starkCurve.md#poseidonfn) #### Parameters | Name | Type | | :----- | :---------------------------------------------- | | `opts` | [`PoseidonOpts`](ec.starkCurve.md#poseidonopts) | | `mds` | `bigint`[][] | #### Returns [`PoseidonFn`](ec.starkCurve.md#poseidonfn) #### Defined in node_modules/micro-starknet/lib/index.d.ts:75 --- ### poseidonCreate \u25b8 **poseidonCreate**(`opts`, `mdsAttempt?`): [`PoseidonFn`](ec.starkCurve.md#poseidonfn) #### Parameters | Name | Type | | :------------ | :---------------------------------------------- | | `opts` | [`PoseidonOpts`](ec.starkCurve.md#poseidonopts) | | `mdsAttempt?` | `number` | #### Returns [`PoseidonFn`](ec.starkCurve.md#poseidonfn) #### Defined in node_modules/micro-starknet/lib/index.d.ts:76 --- ### poseidonHash \u25b8 **poseidonHash**(`x`, `y`, `fn?`): `bigint` #### Parameters | Name | Type | | :---- | :------------------------------------------ | | `x` | `bigint` | | `y` | `bigint` | | `fn?` | [`PoseidonFn`](ec.starkCurve.md#poseidonfn) | #### Returns `bigint` #### Defined in node_modules/micro-starknet/lib/index.d.ts:78 --- ### poseidonHashFunc \u25b8 **poseidonHashFunc**(`x`, `y`, `fn?`): `Uint8Array` #### Parameters | Name | Type | | :---- | :------------------------------------------ | | `x` | `Uint8Array` | | `y` | `Uint8Array` | | `fn?` | [`PoseidonFn`](ec.starkCurve.md#poseidonfn) | #### Returns `Uint8Array` #### Defined in node_modules/micro-starknet/lib/index.d.ts:79 --- ### poseidonHashSingle \u25b8 **poseidonHashSingle**(`x`, `fn?`): `bigint` #### Parameters | Name | Type | | :---- | :------------------------------------------ | | `x` | `bigint` | | `fn?` | [`PoseidonFn`](ec.starkCurve.md#poseidonfn) | #### Returns `bigint` #### Defined in node_modules/micro-starknet/lib/index.d.ts:80 --- ### poseidonHashMany \u25b8 **poseidonHashMany**(`values`, `fn?`): `bigint` #### Parameters | Name | Type | | :------- | :------------------------------------------ | | `values` | `bigint`[] | | `fn?` | [`PoseidonFn`](ec.starkCurve.md#poseidonfn) | #### Returns `bigint` #### Defined in node_modules/micro-starknet/lib/index.d.ts:81 --- ### computeHashOnElements \u25b8 **computeHashOnElements**(`data`, `fn?`): `PedersenArg` #### Parameters | Name | Type | | :----- | :--------------------------------------------------- | | `data` | `PedersenArg`[] | | `fn?` | (`x`: `PedersenArg`, `y`: `PedersenArg`) => `string` | #### Returns `PedersenArg` #### Defined in node_modules/micro-starknet/lib/index.d.ts:58 --- ### keccak \u25b8 **keccak**(`data`): `bigint` #### Parameters | Name | Type | | :----- | :----------- | | `data` | `Uint8Array` | #### Returns `bigint` #### Defined in node_modules/micro-starknet/lib/index.d.ts:59 --- ### poseidonSmall \u25b8 **poseidonSmall**(`values`): `bigint`[] #### Parameters | Name | Type | | :------- | :--------- | | `values` | `bigint`[] | #### Returns `bigint`[] #### Defined in node_modules/@noble/curves/abstract/poseidon.d.ts:27"}
{"title": "ec.weierstrass.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'ec.weierstrass' title: 'Namespace: weierstrass' sidebar_label: 'weierstrass' custom_edit_url: null --- [ec](ec.md).weierstrass ## Interfaces - [ProjPointType](../interfaces/ec.weierstrass.ProjPointType.md) - [ProjConstructor](../interfaces/ec.weierstrass.ProjConstructor.md) - [SignatureType](../interfaces/ec.weierstrass.SignatureType.md) ## Type Aliases ### AffinePoint \u01ac **AffinePoint**: { `x`: `T` ; `y`: `T` } & { `z?`: `never` ; `t?`: `never` } #### Type parameters | Name | | :--- | | `T` | #### Defined in node_modules/@noble/curves/abstract/curve.d.ts:3 --- ### BasicWCurve \u01ac **BasicWCurve**: `BasicCurve` & { `a`: `T` ; `b`: `T` ; `allowedPrivateKeyLengths?`: readonly `number`[] ; `wrapPrivateKey?`: `boolean` ; `endo?`: `EndomorphismOpts` ; `isTorsionFree?`: (`c`: [`ProjConstructor`](../interfaces/ec.weierstrass.ProjConstructor.md), `point`: [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md)) => `boolean` ; `clearCofactor?`: (`c`: [`ProjConstructor`](../interfaces/ec.weierstrass.ProjConstructor.md), `point`: [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md)) => [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md) } #### Type parameters | Name | | :--- | | `T` | #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:17 --- ### SignOpts \u01ac **SignOpts**: `Object` #### Type declaration | Name | Type | | :-------------- | :-------- | | `lowS?` | `boolean` | | `extraEntropy?` | `Entropy` | | `prehash?` | `boolean` | #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:27 --- ### VerOpts \u01ac **VerOpts**: `Object` #### Type declaration | Name | Type | | :--------- | :-------- | | `lowS?` | `boolean` | | `prehash?` | `boolean` | #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:32 --- ### CurvePointsType \u01ac **CurvePointsType**: [`BasicWCurve`](ec.weierstrass.md#basicwcurve) & { `fromBytes?`: (`bytes`: `Uint8Array`) => [`AffinePoint`](ec.weierstrass.md#affinepoint) ; `toBytes?`: (`c`: [`ProjConstructor`](../interfaces/ec.weierstrass.ProjConstructor.md), `point`: [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md), `isCompressed`: `boolean`) => `Uint8Array` } #### Type parameters | Name | | :--- | | `T` | #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:82 --- ### CurvePointsRes \u01ac **CurvePointsRes**: `Object` #### Type parameters | Name | | :--- | | `T` | #### Type declaration | Name | Type | | :----------------------- | :------------------------------------------------------------------------- | | `ProjectivePoint` | [`ProjConstructor`](../interfaces/ec.weierstrass.ProjConstructor.md) | | `normPrivateKeyToScalar` | (`key`: `PrivKey`) => `bigint` | | `weierstrassEquation` | (`x`: `T`) => `T` | | `isWithinCurveOrder` | (`num`: `bigint`) => `boolean` | #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:86 --- ### SignatureConstructor \u01ac **SignatureConstructor**: `Object` #### Call signature \u2022 **new SignatureConstructor**(`r`, `s`): [`SignatureType`](../interfaces/ec.weierstrass.SignatureType.md) ##### Parameters | Name | Type | | :--- | :------- | | `r` | `bigint` | | `s` | `bigint` | ##### Returns [`SignatureType`](../interfaces/ec.weierstrass.SignatureType.md) #### Type declaration | Name | Type | | :------------ | :--------------------------------------------------------------------------------- | | `fromCompact` | (`hex`: `Hex`) => [`SignatureType`](../interfaces/ec.weierstrass.SignatureType.md) | | `fromDER` | (`hex`: `Hex`) => [`SignatureType`](../interfaces/ec.weierstrass.SignatureType.md) | #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:154 --- ### PubKey \u01ac **PubKey**: `Hex` \\| [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md) #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:163 --- ### CurveType \u01ac **CurveType**: [`BasicWCurve`](ec.weierstrass.md#basicwcurve) & { `hash`: `CHash` ; `hmac`: `HmacFnSync` ; `randomBytes`: (`bytesLength?`: `number`) => `Uint8Array` ; `lowS?`: `boolean` ; `bits2int?`: (`bytes`: `Uint8Array`) => `bigint` ; `bits2int_modN?`: (`bytes`: `Uint8Array`) => `bigint` } #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:164 --- ### CurveFn \u01ac **CurveFn**: `Object` #### Type declaration | Name | Type | | :----------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `CURVE` | `ReturnType` | | `getPublicKey` | (`privateKey`: `PrivKey`, `isCompressed?`: `boolean`) => `Uint8Array` | | `getSharedSecret` | (`privateA`: `PrivKey`, `publicB`: `Hex`, `isCompressed?`: `boolean`) => `Uint8Array` | | `sign` | (`msgHash`: `Hex`, `privKey`: `PrivKey`, `opts?`: [`SignOpts`](ec.weierstrass.md#signopts)) => [`SignatureType`](../interfaces/ec.weierstrass.SignatureType.md) | | `verify` | (`signature`: `Hex` \\| `SignatureLike`, `msgHash`: `Hex`, `publicKey`: `Hex`, `opts?`: [`VerOpts`](ec.weierstrass.md#veropts)) => `boolean` | | `ProjectivePoint` | [`ProjConstructor`](../interfaces/ec.weierstrass.ProjConstructor.md) | | `Signature` | [`SignatureConstructor`](ec.weierstrass.md#signatureconstructor) | | `utils` | { `normPrivateKeyToScalar`: (`key`: `PrivKey`) => `bigint` ; `randomPrivateKey`: () => `Uint8Array` ; `precompute`: (`windowSize?`: `number`, `point?`: [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md)) => [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md) ; `isValidPrivateKey`: (`privateKey`: `PrivKey`) => `boolean` } | | `utils.normPrivateKeyToScalar` | (`key`: `PrivKey`) => `bigint` | | `utils.randomPrivateKey` | () => `Uint8Array` | | `utils.precompute` | (`windowSize?`: `number`, `point?`: [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md)) => [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md) | | `utils.isValidPrivateKey` | [object Object] | #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:197 ## Variables ### DER \u2022 `Const` **DER**: `Object` #### Type declaration | Name | Type | | :----------- | :---------------------------------------------------------------------------------- | | `Err` | (`m?`: `string`) => { `name`: `string` ; `message`: `string` ; `stack?`: `string` } | | `_parseInt` | (`data`: `Uint8Array`) => { `d`: `bigint` ; `l`: `Uint8Array` } | | `toSig` | (`hex`: `string` \\| `Uint8Array`) => { `r`: `bigint` ; `s`: `bigint` } | | `hexFromSig` | (`sig`: { `r`: `bigint` ; `s`: `bigint` }) => `string` | #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:92 ## Functions ### weierstrassPoints \u25b8 **weierstrassPoints**(`opts`): `Object` #### Type parameters | Name | | :--- | | `T` | #### Parameters | Name | Type | | :----- | :----------------------------------------------------------- | | `opts` | [`CurvePointsType`](ec.weierstrass.md#curvepointstype) | #### Returns `Object` | Name | Type | | :----------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `CURVE` | `Readonly` ; `n`: `bigint` ; `h`: `bigint` ; `hEff?`: `bigint` ; `Gx`: `T` ; `Gy`: `T` ; `allowInfinityPoint?`: `boolean` ; `a`: `T` ; `b`: `T` ; `allowedPrivateKeyLengths?`: readonly `number`[] ; `wrapPrivateKey?`: `boolean` ; `endo?`: `EndomorphismOpts` ; `isTorsionFree?`: (`c`: [`ProjConstructor`](../interfaces/ec.weierstrass.ProjConstructor.md), `point`: [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md)) => `boolean` ; `clearCofactor?`: (`c`: [`ProjConstructor`](../interfaces/ec.weierstrass.ProjConstructor.md), `point`: [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md)) => [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md) ; `fromBytes?`: (`bytes`: `Uint8Array`) => [`AffinePoint`](ec.weierstrass.md#affinepoint) ; `toBytes?`: (`c`: [`ProjConstructor`](../interfaces/ec.weierstrass.ProjConstructor.md), `point`: [`ProjPointType`](../interfaces/ec.weierstrass.ProjPointType.md), `isCompressed`: `boolean`) => `Uint8Array` ; `p`: `bigint` }\\> | | `ProjectivePoint` | [`ProjConstructor`](../interfaces/ec.weierstrass.ProjConstructor.md) | | `normPrivateKeyToScalar` | (`key`: `PrivKey`) => `bigint` | | `weierstrassEquation` | (`x`: `T`) => `T` | | `isWithinCurveOrder` | (`num`: `bigint`) => `boolean` | #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:113 --- ### weierstrass \u25b8 **weierstrass**(`curveDef`): [`CurveFn`](ec.weierstrass.md#curvefn) #### Parameters | Name | Type | | :--------- | :----------------------------------------- | | `curveDef` | [`CurveType`](ec.weierstrass.md#curvetype) | #### Returns [`CurveFn`](ec.weierstrass.md#curvefn) #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:212 --- ### SWUFpSqrtRatio \u25b8 **SWUFpSqrtRatio**(`Fp`, `Z`): (`u`: `T`, `v`: `T`) => { `isValid`: `boolean` ; `value`: `T` } #### Type parameters | Name | | :--- | | `T` | #### Parameters | Name | Type | | :--- | :------------- | | `Fp` | `IField` | | `Z` | `T` | #### Returns `fn` \u25b8 (`u`, `v`): `Object` ##### Parameters | Name | Type | | :--- | :--- | | `u` | `T` | | `v` | `T` | ##### Returns `Object` | Name | Type | | :-------- | :-------- | | `isValid` | `boolean` | | `value` | `T` | #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:213 --- ### mapToCurveSimpleSWU \u25b8 **mapToCurveSimpleSWU**(`Fp`, `opts`): (`u`: `T`) => { `x`: `T` ; `y`: `T` } #### Type parameters | Name | | :--- | | `T` | #### Parameters | Name | Type | | :------- | :------------- | | `Fp` | `IField` | | `opts` | `Object` | | `opts.A` | `T` | | `opts.B` | `T` | | `opts.Z` | `T` | #### Returns `fn` \u25b8 (`u`): `Object` ##### Parameters | Name | Type | | :--- | :--- | | `u` | `T` | ##### Returns `Object` | Name | Type | | :--- | :--- | | `x` | `T` | | `y` | `T` | #### Defined in node_modules/@noble/curves/abstract/weierstrass.d.ts:217"}
{"title": "encode.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'encode' title: 'Namespace: encode' sidebar_label: 'encode' sidebar_position: 0 custom_edit_url: null --- ## References ### IS_BROWSER Re-exports [IS_BROWSER](constants.md#is_browser) ## Functions ### arrayBufferToString \u25b8 **arrayBufferToString**(`array`): `string` #### Parameters | Name | Type | | :------ | :------------ | | `array` | `ArrayBuffer` | #### Returns `string` #### Defined in [src/utils/encode.ts:6]( --- ### stringToArrayBuffer \u25b8 **stringToArrayBuffer**(`s`): `Uint8Array` #### Parameters | Name | Type | | :--- | :------- | | `s` | `string` | #### Returns `Uint8Array` #### Defined in [src/utils/encode.ts:10]( --- ### atobUniversal \u25b8 **atobUniversal**(`a`): `Uint8Array` #### Parameters | Name | Type | | :--- | :------- | | `a` | `string` | #### Returns `Uint8Array` #### Defined in [src/utils/encode.ts:14]( --- ### btoaUniversal \u25b8 **btoaUniversal**(`b`): `string` #### Parameters | Name | Type | | :--- | :------------ | | `b` | `ArrayBuffer` | #### Returns `string` #### Defined in [src/utils/encode.ts:18]( --- ### buf2hex \u25b8 **buf2hex**(`buffer`): `string` #### Parameters | Name | Type | | :------- | :----------- | | `buffer` | `Uint8Array` | #### Returns `string` #### Defined in [src/utils/encode.ts:22]( --- ### removeHexPrefix \u25b8 **removeHexPrefix**(`hex`): `string` Some function imported from enc-utils is no dependency to avoid using `Buffer` which just works in node and no browsers #### Parameters | Name | Type | | :---- | :------- | | `hex` | `string` | #### Returns `string` #### Defined in [src/utils/encode.ts:31]( --- ### addHexPrefix \u25b8 **addHexPrefix**(`hex`): `string` #### Parameters | Name | Type | | :---- | :------- | | `hex` | `string` | #### Returns `string` #### Defined in [src/utils/encode.ts:35]( --- ### padLeft \u25b8 **padLeft**(`str`, `length`, `padding?`): `string` #### Parameters | Name | Type | Default value | | :-------- | :------- | :------------ | | `str` | `string` | `undefined` | | `length` | `number` | `undefined` | | `padding` | `string` | `STRING_ZERO` | #### Returns `string` #### Defined in [src/utils/encode.ts:49]( --- ### calcByteLength \u25b8 **calcByteLength**(`length`, `byteSize?`): `number` #### Parameters | Name | Type | Default value | | :--------- | :------- | :------------ | | `length` | `number` | `undefined` | | `byteSize` | `number` | `8` | #### Returns `number` #### Defined in [src/utils/encode.ts:53]( --- ### sanitizeBytes \u25b8 **sanitizeBytes**(`str`, `byteSize?`, `padding?`): `string` #### Parameters | Name | Type | Default value | | :--------- | :------- | :------------ | | `str` | `string` | `undefined` | | `byteSize` | `number` | `8` | | `padding` | `string` | `STRING_ZERO` | #### Returns `string` #### Defined in [src/utils/encode.ts:58]( --- ### sanitizeHex \u25b8 **sanitizeHex**(`hex`): `string` #### Parameters | Name | Type | | :---- | :------- | | `hex` | `string` | #### Returns `string` #### Defined in [src/utils/encode.ts:62]( --- ### utf8ToArray \u25b8 **utf8ToArray**(`str`): `Uint8Array` #### Parameters | Name | Type | | :---- | :------- | | `str` | `string` | #### Returns `Uint8Array` #### Defined in [src/utils/encode.ts:72]("}
{"title": "hash.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'hash' title: 'Namespace: hash' sidebar_label: 'hash' sidebar_position: 0 custom_edit_url: null --- ## Namespaces - [poseidon](hash.poseidon.md) ## Variables ### transactionVersion \u2022 `Const` **transactionVersion**: `1n` #### Defined in [src/utils/hash.ts:30]( --- ### transactionVersion_2 \u2022 `Const` **transactionVersion_2**: `2n` #### Defined in [src/utils/hash.ts:31]( --- ### feeTransactionVersion \u2022 `Const` **feeTransactionVersion**: `bigint` #### Defined in [src/utils/hash.ts:33]( --- ### feeTransactionVersion_2 \u2022 `Const` **feeTransactionVersion_2**: `bigint` #### Defined in [src/utils/hash.ts:34]( ## Functions ### getVersionsByType \u25b8 **getVersionsByType**(`versionType?`): `Object` Return versions based on version type, default transaction versions #### Parameters | Name | Type | Description | | :------------- | :------------------------- | :--------------------- | | `versionType?` | `\"fee\"` \\| `\"transaction\"` | 'fee' \\| 'transaction' | #### Returns `Object` versions { v1: bigint; v2: bigint; } | Name | Type | | :--- | :------- | | `v1` | `bigint` | | `v2` | `bigint` | #### Defined in [src/utils/hash.ts:41]( --- ### computeHashOnElements \u25b8 **computeHashOnElements**(`data`): `string` #### Parameters | Name | Type | | :----- | :---------------------------------------- | | `data` | [`BigNumberish`](types.md#bignumberish)[] | #### Returns `string` #### Defined in [src/utils/hash.ts:47]( --- ### calculateTransactionHashCommon \u25b8 **calculateTransactionHashCommon**(`txHashPrefix`, `version`, `contractAddress`, `entryPointSelector`, `calldata`, `maxFee`, `chainId`, `additionalData?`): `string` #### Parameters | Name | Type | Default value | | :------------------- | :--------------------------------------------------------------------- | :------------ | | `txHashPrefix` | [`TransactionHashPrefix`](../enums/constants.TransactionHashPrefix.md) | `undefined` | | `version` | [`BigNumberish`](types.md#bignumberish) | `undefined` | | `contractAddress` | [`BigNumberish`](types.md#bignumberish) | `undefined` | | `entryPointSelector` | [`BigNumberish`](types.md#bignumberish) | `undefined` | | `calldata` | [`RawCalldata`](types.md#rawcalldata) | `undefined` | | `maxFee` | [`BigNumberish`](types.md#bignumberish) | `undefined` | | `chainId` | [`StarknetChainId`](../enums/constants.StarknetChainId.md) | `undefined` | | `additionalData` | [`BigNumberish`](types.md#bignumberish)[] | `[]` | #### Returns `string` #### Defined in [src/utils/hash.ts:56]( --- ### calculateDeployTransactionHash \u25b8 **calculateDeployTransactionHash**(`contractAddress`, `constructorCalldata`, `version`, `chainId`, `constructorName?`): `string` #### Parameters | Name | Type | Default value | | :-------------------- | :--------------------------------------------------------- | :-------------- | | `contractAddress` | [`BigNumberish`](types.md#bignumberish) | `undefined` | | `constructorCalldata` | [`RawCalldata`](types.md#rawcalldata) | `undefined` | | `version` | [`BigNumberish`](types.md#bignumberish) | `undefined` | | `chainId` | [`StarknetChainId`](../enums/constants.StarknetChainId.md) | `undefined` | | `constructorName` | `string` | `'constructor'` | #### Returns `string` #### Defined in [src/utils/hash.ts:80]( --- ### calculateDeclareTransactionHash \u25b8 **calculateDeclareTransactionHash**(`classHash`, `senderAddress`, `version`, `maxFee`, `chainId`, `nonce`, `compiledClassHash?`): `string` #### Parameters | Name | Type | | :------------------- | :--------------------------------------------------------- | | `classHash` | `string` | | `senderAddress` | [`BigNumberish`](types.md#bignumberish) | | `version` | [`BigNumberish`](types.md#bignumberish) | | `maxFee` | [`BigNumberish`](types.md#bignumberish) | | `chainId` | [`StarknetChainId`](../enums/constants.StarknetChainId.md) | | `nonce` | [`BigNumberish`](types.md#bignumberish) | | `compiledClassHash?` | `string` | #### Returns `string` #### Defined in [src/utils/hash.ts:98]( --- ### calculateDeployAccountTransactionHash \u25b8 **calculateDeployAccountTransactionHash**(`contractAddress`, `classHash`, `constructorCalldata`, `salt`, `version`, `maxFee`, `chainId`, `nonce`): `string` #### Parameters | Name | Type | | :-------------------- | :--------------------------------------------------------- | | `contractAddress` | [`BigNumberish`](types.md#bignumberish) | | `classHash` | [`BigNumberish`](types.md#bignumberish) | | `constructorCalldata` | [`RawCalldata`](types.md#rawcalldata) | | `salt` | [`BigNumberish`](types.md#bignumberish) | | `version` | [`BigNumberish`](types.md#bignumberish) | | `maxFee` | [`BigNumberish`](types.md#bignumberish) | | `chainId` | [`StarknetChainId`](../enums/constants.StarknetChainId.md) | | `nonce` | [`BigNumberish`](types.md#bignumberish) | #### Returns `string` #### Defined in [src/utils/hash.ts:119]( --- ### calculateTransactionHash \u25b8 **calculateTransactionHash**(`contractAddress`, `version`, `calldata`, `maxFee`, `chainId`, `nonce`): `string` #### Parameters | Name | Type | | :---------------- | :--------------------------------------------------------- | | `contractAddress` | [`BigNumberish`](types.md#bignumberish) | | `version` | [`BigNumberish`](types.md#bignumberish) | | `calldata` | [`RawCalldata`](types.md#rawcalldata) | | `maxFee` | [`BigNumberish`](types.md#bignumberish) | | `chainId` | [`StarknetChainId`](../enums/constants.StarknetChainId.md) | | `nonce` | [`BigNumberish`](types.md#bignumberish) | #### Returns `string` #### Defined in [src/utils/hash.ts:143]( --- ### calculateContractAddressFromHash \u25b8 **calculateContractAddressFromHash**(`salt`, `classHash`, `constructorCalldata`, `deployerAddress`): `string` #### Parameters | Name | Type | | :-------------------- | :-------------------------------------- | | `salt` | [`BigNumberish`](types.md#bignumberish) | | `classHash` | [`BigNumberish`](types.md#bignumberish) | | `constructorCalldata` | [`RawArgs`](types.md#rawargs) | | `deployerAddress` | [`BigNumberish`](types.md#bignumberish) | #### Returns `string` #### Defined in [src/utils/hash.ts:163]( --- ### formatSpaces \u25b8 **formatSpaces**(`json`): `string` #### Parameters | Name | Type | | :----- | :------- | | `json` | `string` | #### Returns `string` #### Defined in [src/utils/hash.ts:196]( --- ### default \u25b8 **default**(`compiledContract`): `string` #### Parameters | Name | Type | | :----------------- | :---------------------------------------------------------- | | `compiledContract` | [`LegacyCompiledContract`](types.md#legacycompiledcontract) | #### Returns `string` #### Defined in [src/utils/hash.ts:214]( --- ### computeLegacyContractClassHash \u25b8 **computeLegacyContractClassHash**(`contract`): `string` #### Parameters | Name | Type | | :--------- | :---------------------------------------------------------------------- | | `contract` | `string` \\| [`LegacyCompiledContract`](types.md#legacycompiledcontract) | #### Returns `string` #### Defined in [src/utils/hash.ts:223]( --- ### computeCompiledClassHash \u25b8 **computeCompiledClassHash**(`casm`): `string` #### Parameters | Name | Type | | :----- | :---------------------------------------- | | `casm` | [`CairoAssembly`](types.md#cairoassembly) | #### Returns `string` #### Defined in [src/utils/hash.ts:276]( --- ### computeSierraContractClassHash \u25b8 **computeSierraContractClassHash**(`sierra`): `string` #### Parameters | Name | Type | | :------- | :------------------------------------------ | | `sierra` | [`CompiledSierra`](types.md#compiledsierra) | #### Returns `string` #### Defined in [src/utils/hash.ts:317]( --- ### computeContractClassHash \u25b8 **computeContractClassHash**(`contract`): `string` Compute ClassHash (sierra or legacy) based on provided contract #### Parameters | Name | Type | Description | | :--------- | :---------------------------------------------------------- | :------------------------------------------- | | `contract` | `string` \\| [`CompiledContract`](types.md#compiledcontract) | CompiledContract \\| CompiledSierra \\| string | #### Returns `string` HexString ClassHash #### Defined in [src/utils/hash.ts:355]( --- ### keccakBn \u25b8 **keccakBn**(`value`): `string` Keccak hash BigNumberish value #### Parameters | Name | Type | Description | | :------ | :-------------------------------------- | :----------- | | `value` | [`BigNumberish`](types.md#bignumberish) | BigNumberish | #### Returns `string` string - hexadecimal string #### Defined in [src/utils/selector.ts:13]( --- ### starknetKeccak \u25b8 **starknetKeccak**(`value`): `bigint` Function to get the starknet keccak hash from a string [Reference]( #### Parameters | Name | Type | Description | | :------ | :------- | :-------------------------------------------------- | | `value` | `string` | string you want to get the starknetKeccak hash from | #### Returns `bigint` starknet keccak hash as BigNumber #### Defined in [src/utils/selector.ts:35]( --- ### getSelectorFromName \u25b8 **getSelectorFromName**(`funcName`): `string` Function to get the hex selector from a given function name [Reference]( #### Parameters | Name | Type | Description | | :--------- | :------- | :-------------------------- | | `funcName` | `string` | selectors abi function name | #### Returns `string` hex selector of given abi function name #### Defined in [src/utils/selector.ts:48]( --- ### getSelector \u25b8 **getSelector**(`value`): `string` Function to get hex selector from function name, decimal string or hex string #### Parameters | Name | Type | Description | | :------ | :------- | :------------------------------------- | | `value` | `string` | hex string \\| decimal string \\| string | #### Returns `string` Hex selector #### Defined in [src/utils/selector.ts:58]("}
{"title": "hash.poseidon.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'hash.poseidon' title: 'Namespace: poseidon' sidebar_label: 'poseidon' custom_edit_url: null --- [hash](hash.md).poseidon ## Type Aliases ### PoseidonOpts \u01ac **PoseidonOpts**: `Object` #### Type declaration | Name | Type | | :---------------------- | :------------------ | | `Fp` | `IField` | | `t` | `number` | | `roundsFull` | `number` | | `roundsPartial` | `number` | | `sboxPower?` | `number` | | `reversePartialPowIdx?` | `boolean` | | `mds` | `bigint`[][] | | `roundConstants` | `bigint`[][] | #### Defined in node_modules/@noble/curves/abstract/poseidon.d.ts:3 ## Functions ### validateOpts \u25b8 **validateOpts**(`opts`): `Readonly` `bigint` ; `roundConstants`: `bigint`[][] ; `mds`: `bigint`[][] ; `Fp`: `IField` ; `t`: `number` ; `roundsFull`: `number` ; `roundsPartial`: `number` ; `sboxPower?`: `number` ; `reversePartialPowIdx?`: `boolean` }\\> #### Parameters | Name | Type | | :----- | :---------------------------------------------- | | `opts` | [`PoseidonOpts`](hash.poseidon.md#poseidonopts) | #### Returns `Readonly` `bigint` ; `roundConstants`: `bigint`[][] ; `mds`: `bigint`[][] ; `Fp`: `IField` ; `t`: `number` ; `roundsFull`: `number` ; `roundsPartial`: `number` ; `sboxPower?`: `number` ; `reversePartialPowIdx?`: `boolean` }\\> #### Defined in node_modules/@noble/curves/abstract/poseidon.d.ts:13 --- ### splitConstants \u25b8 **splitConstants**(`rc`, `t`): `bigint`[][] #### Parameters | Name | Type | | :--- | :--------- | | `rc` | `bigint`[] | | `t` | `number` | #### Returns `bigint`[][] #### Defined in node_modules/@noble/curves/abstract/poseidon.d.ts:25 --- ### poseidon \u25b8 **poseidon**(`opts`): (`values`: `bigint`[]) => `bigint`[] #### Parameters | Name | Type | | :----- | :---------------------------------------------- | | `opts` | [`PoseidonOpts`](hash.poseidon.md#poseidonopts) | #### Returns `fn` \u25b8 (`values`): `bigint`[] ##### Parameters | Name | Type | | :------- | :--------- | | `values` | `bigint`[] | ##### Returns `bigint`[] | Name | Type | | :--------------- | :----------- | | `roundConstants` | `bigint`[][] | #### Defined in node_modules/@noble/curves/abstract/poseidon.d.ts:26"}
{"title": "json.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'json' title: 'Namespace: json' sidebar_label: 'json' sidebar_position: 0 custom_edit_url: null --- ## Functions ### parse \u25b8 **parse**(`x`): `any` #### Parameters | Name | Type | | :--- | :------- | | `x` | `string` | #### Returns `any` #### Defined in [src/utils/json.ts:12]( --- ### parseAlwaysAsBig \u25b8 **parseAlwaysAsBig**(`x`): `any` #### Parameters | Name | Type | | :--- | :------- | | `x` | `string` | #### Returns `any` #### Defined in [src/utils/json.ts:13]( --- ### stringify \u25b8 **stringify**(`...p`): `string` #### Parameters | Name | Type | | :----- | :----------------------------------------------------------------------------------------------------------- | | `...p` | [value: JavaScriptValue, replacer?: any, space?: string \\| number, numberStringifiers?: NumberStringifier[]] | #### Returns `string` #### Defined in [src/utils/json.ts:18]( --- ### stringifyAlwaysAsBig \u25b8 **stringifyAlwaysAsBig**(`...p`): `string` **`Deprecated`** equivalent to 'stringify', alias will be removed #### Parameters | Name | Type | | :----- | :----------------------------------------------------------------------------------------------------------- | | `...p` | [value: JavaScriptValue, replacer?: any, space?: string \\| number, numberStringifiers?: NumberStringifier[]] | #### Returns `string` #### Defined in [src/utils/json.ts:18]("}
{"title": "merkle.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'merkle' title: 'Namespace: merkle' sidebar_label: 'merkle' sidebar_position: 0 custom_edit_url: null --- ## Classes - [MerkleTree](../classes/merkle.MerkleTree.md) ## Functions ### proofMerklePath \u25b8 **proofMerklePath**(`root`, `leaf`, `path`): `boolean` #### Parameters | Name | Type | | :----- | :--------- | | `root` | `string` | | `leaf` | `string` | | `path` | `string`[] | #### Returns `boolean` #### Defined in [src/utils/merkle.ts:63]("}
{"title": "num.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'num' title: 'Namespace: num' sidebar_label: 'num' sidebar_position: 0 custom_edit_url: null --- ## References ### BigNumberish Re-exports [BigNumberish](types.md#bignumberish) ## Functions ### isHex \u25b8 **isHex**(`hex`): `boolean` #### Parameters | Name | Type | | :---- | :------- | | `hex` | `string` | #### Returns `boolean` #### Defined in [src/utils/num.ts:10]( --- ### toBigInt \u25b8 **toBigInt**(`value`): `bigint` #### Parameters | Name | Type | | :------ | :-------------------------------------- | | `value` | [`BigNumberish`](types.md#bignumberish) | #### Returns `bigint` #### Defined in [src/utils/num.ts:14]( --- ### isBigInt \u25b8 **isBigInt**(`value`): value is bigint #### Parameters | Name | Type | | :------ | :---- | | `value` | `any` | #### Returns value is bigint #### Defined in [src/utils/num.ts:18]( --- ### toHex \u25b8 **toHex**(`number`): `string` #### Parameters | Name | Type | | :------- | :-------------------------------------- | | `number` | [`BigNumberish`](types.md#bignumberish) | #### Returns `string` #### Defined in [src/utils/num.ts:22]( --- ### toStorageKey \u25b8 **toStorageKey**(`number`): `string` Convert BigNumberish to STORAGE_KEY Same as toHex but conforming pattern STORAGE_KEY pattern ^0x0[0-7]{1}[a-fA-F0-9]{0,62}$ A storage key. Represented as up to 62 hex digits, 3 bits, and 5 leading zeroes. 0x0 + [0-7] + 62 hex = 0x + 64 hex #### Parameters | Name | Type | Description | | :------- | :-------------------------------------- | :----------- | | `number` | [`BigNumberish`](types.md#bignumberish) | BigNumberish | #### Returns `string` #### Defined in [src/utils/num.ts:33]( --- ### hexToDecimalString \u25b8 **hexToDecimalString**(`hex`): `string` #### Parameters | Name | Type | | :---- | :------- | | `hex` | `string` | #### Returns `string` #### Defined in [src/utils/num.ts:38]( --- ### assertInRange \u25b8 **assertInRange**(`input`, `lowerBound`, `upperBound`, `inputName?`): `void` #### Parameters | Name | Type | Default value | | :----------- | :-------------------------------------- | :------------ | | `input` | [`BigNumberish`](types.md#bignumberish) | `undefined` | | `lowerBound` | [`BigNumberish`](types.md#bignumberish) | `undefined` | | `upperBound` | [`BigNumberish`](types.md#bignumberish) | `undefined` | | `inputName` | `string` | `''` | #### Returns `void` #### Defined in [src/utils/num.ts:54]( --- ### bigNumberishArrayToDecimalStringArray \u25b8 **bigNumberishArrayToDecimalStringArray**(`rawCalldata`): `string`[] #### Parameters | Name | Type | | :------------ | :---------------------------------------- | | `rawCalldata` | [`BigNumberish`](types.md#bignumberish)[] | #### Returns `string`[] #### Defined in [src/utils/num.ts:71]( --- ### bigNumberishArrayToHexadecimalStringArray \u25b8 **bigNumberishArrayToHexadecimalStringArray**(`rawCalldata`): `string`[] #### Parameters | Name | Type | | :------------ | :---------------------------------------- | | `rawCalldata` | [`BigNumberish`](types.md#bignumberish)[] | #### Returns `string`[] #### Defined in [src/utils/num.ts:75]( --- ### getDecimalString \u25b8 **getDecimalString**(`value`): `string` #### Parameters | Name | Type | | :------ | :------- | | `value` | `string` | #### Returns `string` #### Defined in [src/utils/num.ts:82]( --- ### getHexString \u25b8 **getHexString**(`value`): `string` #### Parameters | Name | Type | | :------ | :------- | | `value` | `string` | #### Returns `string` #### Defined in [src/utils/num.ts:92]( --- ### getHexStringArray \u25b8 **getHexStringArray**(`value`): `string`[] #### Parameters | Name | Type | | :------ | :--------- | | `value` | `string`[] | #### Returns `string`[] #### Defined in [src/utils/num.ts:102]( --- ### hexToBytes \u25b8 **hexToBytes**(`value`): `Uint8Array` Convert a hex string to an array of Bytes (Uint8Array) #### Parameters | Name | Type | Description | | :------ | :------- | :---------- | | `value` | `string` | hex string | #### Returns `Uint8Array` an array of Bytes #### Defined in [src/utils/num.ts:113]( --- ### cleanHex \u25b8 **cleanHex**(`hex`): `string` Remove hex string leading zero and lower case '0x01A'.. -> '0x1a..' #### Parameters | Name | Type | Description | | :---- | :------- | :---------- | | `hex` | `string` | string | #### Returns `string` #### Defined in [src/utils/num.ts:46]( --- ### isStringWholeNumber \u25b8 **isStringWholeNumber**(`value`): `boolean` #### Parameters | Name | Type | | :------ | :------- | | `value` | `string` | #### Returns `boolean` #### Defined in [src/utils/num.ts:79]( --- ### toHexString \u25b8 **toHexString**(`value`): `string` #### Parameters | Name | Type | | :------ | :------- | | `value` | `string` | #### Returns `string` #### Defined in [src/utils/num.ts:80]( --- ### toCairoBool \u25b8 **toCairoBool**(`value`): `string` #### Parameters | Name | Type | | :------ | :-------- | | `value` | `boolean` | #### Returns `string` #### Defined in [src/utils/num.ts:106]("}
{"title": "provider-1.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'provider-1' title: 'Namespace: provider' sidebar_label: 'provider' sidebar_position: 0 custom_edit_url: null --- ## Functions ### wait \u25b8 **wait**(`delay`): `Promise` #### Parameters | Name | Type | | :------ | :------- | | `delay` | `number` | #### Returns `Promise` #### Defined in [src/utils/provider.ts:13]( --- ### createSierraContractClass \u25b8 **createSierraContractClass**(`contract`): [`SierraContractClass`](types.md#sierracontractclass) #### Parameters | Name | Type | | :--------- | :------------------------------------------ | | `contract` | [`CompiledSierra`](types.md#compiledsierra) | #### Returns [`SierraContractClass`](types.md#sierracontractclass) #### Defined in [src/utils/provider.ts:19]( --- ### parseContract \u25b8 **parseContract**(`contract`): [`ContractClass`](types.md#contractclass) #### Parameters | Name | Type | | :--------- | :---------------------------------------------------------- | | `contract` | `string` \\| [`CompiledContract`](types.md#compiledcontract) | #### Returns [`ContractClass`](types.md#contractclass) #### Defined in [src/utils/provider.ts:29]("}
{"title": "selector.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'selector' title: 'Namespace: selector' sidebar_label: 'selector' sidebar_position: 0 custom_edit_url: null --- ## References ### keccakBn Re-exports [keccakBn](hash.md#keccakbn) --- ### starknetKeccak Re-exports [starknetKeccak](hash.md#starknetkeccak) --- ### getSelectorFromName Re-exports [getSelectorFromName](hash.md#getselectorfromname) --- ### getSelector Re-exports [getSelector](hash.md#getselector)"}
{"title": "shortString.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'shortString' title: 'Namespace: shortString' sidebar_label: 'shortString' sidebar_position: 0 custom_edit_url: null --- ## Functions ### isASCII \u25b8 **isASCII**(`str`): `boolean` #### Parameters | Name | Type | | :---- | :------- | | `str` | `string` | #### Returns `boolean` #### Defined in [src/utils/shortString.ts:6]( --- ### isShortString \u25b8 **isShortString**(`str`): `boolean` #### Parameters | Name | Type | | :---- | :------- | | `str` | `string` | #### Returns `boolean` #### Defined in [src/utils/shortString.ts:12]( --- ### isDecimalString \u25b8 **isDecimalString**(`decim`): `boolean` #### Parameters | Name | Type | | :------ | :------- | | `decim` | `string` | #### Returns `boolean` #### Defined in [src/utils/shortString.ts:17]( --- ### isText \u25b8 **isText**(`val`): `boolean` check if value is string text, and not string-hex, string-number #### Parameters | Name | Type | Description | | :---- | :---- | :---------- | | `val` | `any` | any | #### Returns `boolean` boolean #### Defined in [src/utils/shortString.ts:26]( --- ### splitLongString \u25b8 **splitLongString**(`longStr`): `string`[] #### Parameters | Name | Type | | :-------- | :------- | | `longStr` | `string` | #### Returns `string`[] #### Defined in [src/utils/shortString.ts:33]( --- ### encodeShortString \u25b8 **encodeShortString**(`str`): `string` Convert an ASCII string to an hexadecimal string. **`Example`** ```typescript const myEncodedString: string = encodeShortString(\"uri/pict/t38.jpg\"); ``` returns : string : \"0x7572692f706963742f7433382e6a7067\" #### Parameters | Name | Type | Description | | :---- | :------- | :------------------------------------------------------- | | `str` | `string` | ASCII string - 31 characters maxi. Ex : \"uri/item23.jpg\" | #### Returns `string` a string representing an Hex number 248 bits max. #### Defined in [src/utils/shortString.ts:49]( --- ### decodeShortString \u25b8 **decodeShortString**(`str`): `string` Convert an hexadecimal or decimal string to an ASCII string. **`Example`** ```typescript const myDecodedString: string = decodeShortString(\"0x7572692f706963742f7433382e6a7067\"); ``` return : string : \"uri/pict/t38.jpg\" #### Parameters | Name | Type | Description | | :---- | :------- | :------------------------------------------------------------------------------------------------------- | | `str` | `string` | string - representing a 248 bits max number. Ex : hex : \"0x1A4F64EA56\" or decimal : \"236942575435676423\" | #### Returns `string` a string with 31 characters max. #### Defined in [src/utils/shortString.ts:67]( --- ### isShortText \u25b8 **isShortText**(`val`): `boolean` #### Parameters | Name | Type | | :---- | :---- | | `val` | `any` | #### Returns `boolean` #### Defined in [src/utils/shortString.ts:30]( --- ### isLongText \u25b8 **isLongText**(`val`): `boolean` #### Parameters | Name | Type | | :---- | :---- | | `val` | `any` | #### Returns `boolean` #### Defined in [src/utils/shortString.ts:31]("}
{"title": "stark.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'stark' title: 'Namespace: stark' sidebar_label: 'stark' sidebar_position: 0 custom_edit_url: null --- ## Functions ### compressProgram \u25b8 **compressProgram**(`jsonProgram`): [`CompressedProgram`](types.md#compressedprogram) Function to compress compiled cairo program [Reference]( #### Parameters | Name | Type | Description | | :------------ | :------------------------------------------------------ | :------------------------------------------------ | | `jsonProgram` | `string` \\| [`Program`](../interfaces/types.Program.md) | json file representing the compiled cairo program | #### Returns [`CompressedProgram`](types.md#compressedprogram) Compressed cairo program #### Defined in [src/utils/stark.ts:21]( --- ### decompressProgram \u25b8 **decompressProgram**(`base64`): `any` Function to decompress compressed compiled cairo program #### Parameters | Name | Type | Description | | :------- | :------- | :---------------- | | `base64` | `string` | CompressedProgram | #### Returns `any` parsed decompressed compiled cairo program #### Defined in [src/utils/stark.ts:33]( --- ### randomAddress \u25b8 **randomAddress**(): `string` #### Returns `string` #### Defined in [src/utils/stark.ts:39]( --- ### makeAddress \u25b8 **makeAddress**(`input`): `string` #### Parameters | Name | Type | | :------ | :------- | | `input` | `string` | #### Returns `string` #### Defined in [src/utils/stark.ts:44]( --- ### formatSignature \u25b8 **formatSignature**(`sig?`): [`ArraySignatureType`](types.md#arraysignaturetype) #### Parameters | Name | Type | | :----- | :-------------------------------- | | `sig?` | [`Signature`](types.md#signature) | #### Returns [`ArraySignatureType`](types.md#arraysignaturetype) #### Defined in [src/utils/stark.ts:48]( --- ### signatureToDecimalArray \u25b8 **signatureToDecimalArray**(`sig?`): [`ArraySignatureType`](types.md#arraysignaturetype) #### Parameters | Name | Type | | :----- | :-------------------------------- | | `sig?` | [`Signature`](types.md#signature) | #### Returns [`ArraySignatureType`](types.md#arraysignaturetype) #### Defined in [src/utils/stark.ts:61]( --- ### signatureToHexArray \u25b8 **signatureToHexArray**(`sig?`): [`ArraySignatureType`](types.md#arraysignaturetype) #### Parameters | Name | Type | | :----- | :-------------------------------- | | `sig?` | [`Signature`](types.md#signature) | #### Returns [`ArraySignatureType`](types.md#arraysignaturetype) #### Defined in [src/utils/stark.ts:65]( --- ### estimatedFeeToMaxFee \u25b8 **estimatedFeeToMaxFee**(`estimatedFee`, `overhead?`): `bigint` #### Parameters | Name | Type | Default value | | :------------- | :-------------------------------------- | :------------ | | `estimatedFee` | [`BigNumberish`](types.md#bignumberish) | `undefined` | | `overhead` | `number` | `0.5` | #### Returns `bigint` #### Defined in [src/utils/stark.ts:69]("}
{"title": "starknetId.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'starknetId' title: 'Namespace: starknetId' sidebar_label: 'starknetId' sidebar_position: 0 custom_edit_url: null --- ## Enumerations - [StarknetIdContract](../enums/starknetId.StarknetIdContract.md) ## Functions ### useDecoded \u25b8 **useDecoded**(`encoded`): `string` #### Parameters | Name | Type | | :-------- | :--------- | | `encoded` | `bigint`[] | #### Returns `string` #### Defined in [src/utils/starknetId.ts:20]( --- ### useEncoded \u25b8 **useEncoded**(`decoded`): `bigint` #### Parameters | Name | Type | | :-------- | :------- | | `decoded` | `string` | #### Returns `bigint` #### Defined in [src/utils/starknetId.ts:61]( --- ### getStarknetIdContract \u25b8 **getStarknetIdContract**(`chainId`): `string` #### Parameters | Name | Type | | :-------- | :--------------------------------------------------------- | | `chainId` | [`StarknetChainId`](../enums/constants.StarknetChainId.md) | #### Returns `string` #### Defined in [src/utils/starknetId.ts:108]("}
{"title": "transaction.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'transaction' title: 'Namespace: transaction' sidebar_label: 'transaction' sidebar_position: 0 custom_edit_url: null --- ## Functions ### transformCallsToMulticallArrays \u25b8 **transformCallsToMulticallArrays**(`calls`): `Object` Transforms a list of Calls, each with their own calldata, into two arrays: one with the entrypoints, and one with the concatenated calldata. #### Parameters | Name | Type | | :------ | :------------------------ | | `calls` | [`Call`](types.md#call)[] | #### Returns `Object` | Name | Type | | :---------- | :---------------------------------------- | | `callArray` | [`ParsedStruct`](types.md#parsedstruct)[] | | `calldata` | [`Calldata`](types.md#calldata) | #### Defined in [src/utils/transaction.ts:12]( --- ### fromCallsToExecuteCalldata \u25b8 **fromCallsToExecuteCalldata**(`calls`): [`Calldata`](types.md#calldata) Transforms a list of calls in the full flattened calldata expected by the **execute** protocol. #### Parameters | Name | Type | | :------ | :------------------------ | | `calls` | [`Call`](types.md#call)[] | #### Returns [`Calldata`](types.md#calldata) #### Defined in [src/utils/transaction.ts:37]( --- ### fromCallsToExecuteCalldataWithNonce \u25b8 **fromCallsToExecuteCalldataWithNonce**(`calls`, `nonce`): [`Calldata`](types.md#calldata) #### Parameters | Name | Type | | :------ | :-------------------------------------- | | `calls` | [`Call`](types.md#call)[] | | `nonce` | [`BigNumberish`](types.md#bignumberish) | #### Returns [`Calldata`](types.md#calldata) #### Defined in [src/utils/transaction.ts:43]( --- ### transformCallsToMulticallArrays_cairo1 \u25b8 **transformCallsToMulticallArrays_cairo1**(`calls`): [`CallStruct`](../interfaces/types.CallStruct.md)[] Format Data inside Calls #### Parameters | Name | Type | Description | | :------ | :------------------------ | :---------- | | `calls` | [`Call`](types.md#call)[] | Call[] | #### Returns [`CallStruct`](../interfaces/types.CallStruct.md)[] CallStruct #### Defined in [src/utils/transaction.ts:53]( --- ### fromCallsToExecuteCalldata_cairo1 \u25b8 **fromCallsToExecuteCalldata_cairo1**(`calls`): [`Calldata`](types.md#calldata) Transforms a list of calls in the full flattened calldata expected by the **execute** protocol. #### Parameters | Name | Type | | :------ | :------------------------ | | `calls` | [`Call`](types.md#call)[] | #### Returns [`Calldata`](types.md#calldata) Calldata #### Defined in [src/utils/transaction.ts:68]( --- ### getExecuteCalldata \u25b8 **getExecuteCalldata**(`calls`, `cairoVersion?`): [`Calldata`](types.md#calldata) #### Parameters | Name | Type | Default value | Description | | :------------- | :-------------------------------------- | :------------ | :------------ | | `calls` | [`Call`](types.md#call)[] | `undefined` | Call array | | `cairoVersion` | [`CairoVersion`](types.md#cairoversion) | `'0'` | Defaults to 0 | #### Returns [`Calldata`](types.md#calldata) string[] of calldata #### Defined in [src/utils/transaction.ts:85]("}
{"title": "typedData.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'typedData' title: 'Namespace: typedData' sidebar_label: 'typedData' sidebar_position: 0 custom_edit_url: null --- ## References ### StarkNetMerkleType Re-exports [StarkNetMerkleType](types.md#starknetmerkletype) --- ### StarkNetType Re-exports [StarkNetType](types.md#starknettype) --- ### StarkNetDomain Re-exports [StarkNetDomain](../interfaces/types.StarkNetDomain.md) --- ### TypedData Re-exports [TypedData](../interfaces/types.TypedData.md) ## Functions ### prepareSelector \u25b8 **prepareSelector**(`selector`): `string` #### Parameters | Name | Type | | :--------- | :------- | | `selector` | `string` | #### Returns `string` #### Defined in [src/utils/typedData.ts:36]( --- ### isMerkleTreeType \u25b8 **isMerkleTreeType**(`type`): type is StarkNetMerkleType #### Parameters | Name | Type | | :----- | :-------------------------------------- | | `type` | [`StarkNetType`](types.md#starknettype) | #### Returns type is StarkNetMerkleType #### Defined in [src/utils/typedData.ts:40]( --- ### getDependencies \u25b8 **getDependencies**(`types`, `type`, `dependencies?`): `string`[] Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once in the resulting array. #### Parameters | Name | Type | Default value | | :-------------- | :------------------------------------------------------------- | :------------ | | `types` | `Record` | `undefined` | | `type` | `string` | `undefined` | | `dependencies?` | `string`[] | `[]` | #### Returns `string`[] #### Defined in [src/utils/typedData.ts:58]( --- ### encodeType \u25b8 **encodeType**(`types`, `type`): `string` Encode a type to a string. All dependant types are alphabetically sorted. #### Parameters | Name | Type | | :------ | :------------------------------------------------------------- | | `types` | `Record` | | `type` | `string` | #### Returns `string` #### Defined in [src/utils/typedData.ts:114]( --- ### getTypeHash \u25b8 **getTypeHash**(`types`, `type`): `string` Get a type string as hash. #### Parameters | Name | Type | | :------ | :------------------------------------------------------------- | | `types` | `Record` | | `type` | `string` | #### Returns `string` #### Defined in [src/utils/typedData.ts:132]( --- ### encodeValue \u25b8 **encodeValue**(`types`, `type`, `data`, `ctx?`): [`string`, `string`] Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of an array of ABI compatible types, and an array of corresponding values. #### Parameters | Name | Type | | :------ | :------------------------------------------------------------- | | `types` | `Record` | | `type` | `string` | | `data` | `unknown` | | `ctx` | `Context` | #### Returns [`string`, `string`] #### Defined in [src/utils/typedData.ts:145]( --- ### encodeData \u25b8 **encodeData**(`types`, `type`, `data`): `string`[][] Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All dependant types are automatically encoded. #### Type parameters | Name | Type | | :--- | :------------------------------------------------------ | | `T` | extends [`TypedData`](../interfaces/types.TypedData.md) | #### Parameters | Name | Type | | :------ | :----------------- | | `types` | `T`[``\"types\"``] | | `type` | `string` | | `data` | `T`[``\"message\"``] | #### Returns `string`[][] #### Defined in [src/utils/typedData.ts:197]( --- ### getStructHash \u25b8 **getStructHash**(`types`, `type`, `data`): `string` Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant types are automatically encoded. #### Type parameters | Name | Type | | :--- | :------------------------------------------------------ | | `T` | extends [`TypedData`](../interfaces/types.TypedData.md) | #### Parameters | Name | Type | | :------ | :----------------- | | `types` | `T`[``\"types\"``] | | `type` | `string` | | `data` | `T`[``\"message\"``] | #### Returns `string` #### Defined in [src/utils/typedData.ts:234]( --- ### getMessageHash \u25b8 **getMessageHash**(`typedData`, `account`): `string` Get the EIP-191 encoded message to sign, from the typedData object. #### Parameters | Name | Type | | :---------- | :---------------------------------------------- | | `typedData` | [`TypedData`](../interfaces/types.TypedData.md) | | `account` | [`BigNumberish`](types.md#bignumberish) | #### Returns `string` #### Defined in [src/utils/typedData.ts:249]("}
{"title": "types.RPC.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.RPC' title: 'Namespace: RPC' sidebar_label: 'RPC' custom_edit_url: null --- [types](types.md).RPC ## Enumerations - [TransactionType](../enums/types.RPC.TransactionType.md) ## Type Aliases ### Response \u01ac **Response**: `Object` #### Type declaration | Name | Type | | :-------------- | :----------------------------------------- | | `id` | `number` | | `jsonrpc` | `string` | | `result?` | `any` | | `error?` | { `code`: `string` ; `message`: `string` } | | `error.code` | `string` | | `error.message` | `string` | #### Defined in [src/types/api/rpc.ts:4]( --- ### ChainId \u01ac **ChainId**: `OPENRPC.CHAIN_ID` #### Defined in [src/types/api/rpc.ts:14]( --- ### CallResponse \u01ac **CallResponse**: `OPENRPC.CallResponse` #### Defined in [src/types/api/rpc.ts:15]( --- ### ContractAddress \u01ac **ContractAddress**: `ADDRESS` #### Defined in [src/types/api/rpc.ts:16]( --- ### Felt \u01ac **Felt**: `FELT` #### Defined in [src/types/api/rpc.ts:17]( --- ### Nonce \u01ac **Nonce**: `OPENRPC.Nonce` #### Defined in [src/types/api/rpc.ts:18]( --- ### ContractClass \u01ac **ContractClass**: `OPENRPC.ContractClass` \\| `OPENRPC.DeprecatedContractClass` #### Defined in [src/types/api/rpc.ts:19]( --- ### StateUpdate \u01ac **StateUpdate**: `OPENRPC.StateUpdate` #### Defined in [src/types/api/rpc.ts:20]( --- ### Transaction \u01ac **Transaction**: `OPENRPC.Transaction` #### Defined in [src/types/api/rpc.ts:21]( --- ### PendingTransactions \u01ac **PendingTransactions**: `OPENRPC.PendingTransactions` #### Defined in [src/types/api/rpc.ts:22]( --- ### TransactionHash \u01ac **TransactionHash**: `OPENRPC.TransactionHash` #### Defined in [src/types/api/rpc.ts:23]( --- ### Trace \u01ac **Trace**: `OPENRPC.Trace` #### Defined in [src/types/api/rpc.ts:24]( --- ### Traces \u01ac **Traces**: `OPENRPC.Traces` #### Defined in [src/types/api/rpc.ts:25]( --- ### BlockHash \u01ac **BlockHash**: `OPENRPC.BlockHash` #### Defined in [src/types/api/rpc.ts:26]( --- ### BlockHashAndNumber \u01ac **BlockHashAndNumber**: `OPENRPC.BlockHashAndNumber` #### Defined in [src/types/api/rpc.ts:27]( --- ### EstimateFeeResponse \u01ac **EstimateFeeResponse**: `OPENRPC.EstimatedFee` #### Defined in [src/types/api/rpc.ts:28]( --- ### GetBlockWithTxHashesResponse \u01ac **GetBlockWithTxHashesResponse**: `OPENRPC.BlockWithTxHashes` #### Defined in [src/types/api/rpc.ts:29]( --- ### GetBlockWithTxs \u01ac **GetBlockWithTxs**: `OPENRPC.BlockWithTxs` #### Defined in [src/types/api/rpc.ts:30]( --- ### GetStorageAtResponse \u01ac **GetStorageAtResponse**: `OPENRPC.Storage` #### Defined in [src/types/api/rpc.ts:31]( --- ### TransactionReceipt \u01ac **TransactionReceipt**: `OPENRPC.TransactionReceipt` #### Defined in [src/types/api/rpc.ts:32]( --- ### GetTransactionByHashResponse \u01ac **GetTransactionByHashResponse**: `OPENRPC.Transaction` #### Defined in [src/types/api/rpc.ts:33]( --- ### GetTransactionByBlockIdAndIndex \u01ac **GetTransactionByBlockIdAndIndex**: `OPENRPC.Transaction` #### Defined in [src/types/api/rpc.ts:34]( --- ### GetTransactionCountResponse \u01ac **GetTransactionCountResponse**: `number` #### Defined in [src/types/api/rpc.ts:35]( --- ### GetBlockNumberResponse \u01ac **GetBlockNumberResponse**: `OPENRPC.BlockNumber` #### Defined in [src/types/api/rpc.ts:36]( --- ### GetSyncingStatsResponse \u01ac **GetSyncingStatsResponse**: `OPENRPC.SyncingStatus` #### Defined in [src/types/api/rpc.ts:37]( --- ### EventFilter \u01ac **EventFilter**: `OPENRPC.EventFilter` #### Defined in [src/types/api/rpc.ts:38]( --- ### GetEventsResponse \u01ac **GetEventsResponse**: `OPENRPC.Events` #### Defined in [src/types/api/rpc.ts:39]( --- ### InvokedTransaction \u01ac **InvokedTransaction**: `OPENRPC.InvokedTransaction` #### Defined in [src/types/api/rpc.ts:40]( --- ### DeclaredTransaction \u01ac **DeclaredTransaction**: `OPENRPC.DeclaredTransaction` #### Defined in [src/types/api/rpc.ts:41]( --- ### DeployedTransaction \u01ac **DeployedTransaction**: `OPENRPC.DeployedTransaction` #### Defined in [src/types/api/rpc.ts:42]( --- ### SimulationFlags \u01ac **SimulationFlags**: `OPENRPC.SimulationFlags` #### Defined in [src/types/api/rpc.ts:43]( --- ### BroadcastedTransaction \u01ac **BroadcastedTransaction**: `OPENRPC.BroadcastedTransaction` #### Defined in [src/types/api/rpc.ts:44]( --- ### EstimatedFee \u01ac **EstimatedFee**: `OPENRPC.EstimatedFee` #### Defined in [src/types/api/rpc.ts:45]( --- ### Methods \u01ac **Methods**: `OPENRPC.Methods` #### Defined in [src/types/api/rpc.ts:46]( --- ### Storage \u01ac **Storage**: `OPENRPC.Storage` #### Defined in [src/types/api/rpc.ts:47]( --- ### SimulateTransactionResponse \u01ac **SimulateTransactionResponse**: `OPENRPC.SimulatedTransactions` #### Defined in [src/types/api/rpc.ts:48]( --- ### StorageDiffs \u01ac **StorageDiffs**: `CONTRACT_STORAGE_DIFF_ITEM`[] #### Defined in [src/types/api/rpc.ts:59]( --- ### DeprecatedDeclaredClasses \u01ac **DeprecatedDeclaredClasses**: `FELT`[] #### Defined in [src/types/api/rpc.ts:60]( --- ### Nonces \u01ac **Nonces**: { `contract_address`: `ADDRESS` ; `nonce`: `FELT` }[] #### Defined in [src/types/api/rpc.ts:61]( --- ### ReplacedClasses \u01ac **ReplacedClasses**: { `contract_address`: `ADDRESS` ; `class_hash`: `FELT` }[] #### Defined in [src/types/api/rpc.ts:65]("}
{"title": "types.Sequencer.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types.Sequencer' title: 'Namespace: Sequencer' sidebar_label: 'Sequencer' custom_edit_url: null --- [types](types.md).Sequencer ## Interfaces - [InvokeFunctionTransactionResponse](../interfaces/types.Sequencer.InvokeFunctionTransactionResponse.md) ## Type Aliases ### TransactionTraceResponse \u01ac **TransactionTraceResponse**: `Object` #### Type declaration | Name | Type | | :------------------------- | :-------------------------------------------------- | | `validate_invocation?` | [`FunctionInvocation`](types.md#functioninvocation) | | `function_invocation?` | [`FunctionInvocation`](types.md#functioninvocation) | | `fee_transfer_invocation?` | [`FunctionInvocation`](types.md#functioninvocation) | | `constructor_invocation?` | [`FunctionInvocation`](types.md#functioninvocation) | | `signature` | `string`[] | #### Defined in [src/types/api/sequencer.ts:75]( --- ### DeclareTransaction \u01ac **DeclareTransaction**: `Object` #### Type declaration | Name | Type | | :--------------------- | :----------------------------------------------------- | | `type` | [`DECLARE`](../enums/types.TransactionType.md#declare) | | `sender_address` | `string` | | `contract_class` | [`ContractClass`](types.md#contractclass) | | `signature?` | `string`[] | | `nonce` | [`BigNumberish`](types.md#bignumberish) | | `max_fee?` | [`BigNumberish`](types.md#bignumberish) | | `version?` | [`BigNumberish`](types.md#bignumberish) | | `compiled_class_hash?` | `string` | #### Defined in [src/types/api/sequencer.ts:83]( --- ### DeployTransaction \u01ac **DeployTransaction**: `Object` #### Type declaration | Name | Type | | :---------------------- | :--------------------------------------------------- | | `type` | [`DEPLOY`](../enums/types.TransactionType.md#deploy) | | `contract_definition` | [`ContractClass`](types.md#contractclass) | | `contract_address_salt` | [`BigNumberish`](types.md#bignumberish) | | `constructor_calldata` | `string`[] | | `nonce?` | [`BigNumberish`](types.md#bignumberish) | #### Defined in [src/types/api/sequencer.ts:94]( --- ### DeployAccountTransaction \u01ac **DeployAccountTransaction**: `Object` #### Type declaration | Name | Type | | :---------------------- | :------------------------------------------------------------------- | | `type` | [`DEPLOY_ACCOUNT`](../enums/types.TransactionType.md#deploy_account) | | `class_hash` | `string` | | `contract_address_salt` | [`BigNumberish`](types.md#bignumberish) | | `constructor_calldata` | `string`[] | | `signature?` | `string`[] | | `max_fee?` | [`BigNumberish`](types.md#bignumberish) | | `version?` | [`BigNumberish`](types.md#bignumberish) | | `nonce?` | [`BigNumberish`](types.md#bignumberish) | #### Defined in [src/types/api/sequencer.ts:102]( --- ### InvokeFunctionTransaction \u01ac **InvokeFunctionTransaction**: `Object` #### Type declaration | Name | Type | | :------------------ | :------------------------------------------------------ | | `type` | [`INVOKE`](../enums/types.TransactionType.md#invoke) | | `sender_address` | `string` | | `signature?` | `string`[] | | `entry_point_type?` | [`EXTERNAL`](../enums/types.EntryPointType.md#external) | | `calldata?` | [`RawCalldata`](types.md#rawcalldata) | | `nonce` | [`BigNumberish`](types.md#bignumberish) | | `max_fee?` | [`BigNumberish`](types.md#bignumberish) | | `version?` | [`BigNumberish`](types.md#bignumberish) | #### Defined in [src/types/api/sequencer.ts:113]( --- ### Transaction \u01ac **Transaction**: [`DeclareTransaction`](types.Sequencer.md#declaretransaction) \\| [`DeployTransaction`](types.Sequencer.md#deploytransaction) \\| [`InvokeFunctionTransaction`](types.Sequencer.md#invokefunctiontransaction) \\| [`DeployAccountTransaction`](types.Sequencer.md#deployaccounttransaction) #### Defined in [src/types/api/sequencer.ts:124]( --- ### AddTransactionResponse \u01ac **AddTransactionResponse**: `Object` #### Type declaration | Name | Type | | :----------------- | :----------------------- | | `transaction_hash` | `string` | | `code?` | `\"TRANSACTION_RECEIVED\"` | | `address?` | `string` | | `class_hash?` | `string` | #### Defined in [src/types/api/sequencer.ts:130]( --- ### GetCodeResponse \u01ac **GetCodeResponse**: `Object` #### Type declaration | Name | Type | | :--------- | :------------------------------ | | `bytecode` | [`ByteCode`](types.md#bytecode) | | `abi` | [`Abi`](types.md#abi) | #### Defined in [src/types/api/sequencer.ts:137]( --- ### TransactionResponse \u01ac **TransactionResponse**: [`DeclareTransaction`](types.Sequencer.md#declaretransaction) \\| [`DeployTransaction`](types.Sequencer.md#deploytransaction) \\| [`InvokeFunctionTransactionResponse`](../interfaces/types.Sequencer.InvokeFunctionTransactionResponse.md) #### Defined in [src/types/api/sequencer.ts:147]( --- ### SuccessfulTransactionResponse \u01ac **SuccessfulTransactionResponse**: `Object` #### Type declaration | Name | Type | | :------------------ | :-------------------------------------------------------------- | | `status` | [`TransactionStatus`](../enums/types.TransactionStatus.md) | | `transaction` | [`TransactionResponse`](types.Sequencer.md#transactionresponse) | | `block_hash` | `string` | | `block_number` | [`BlockNumber`](types.md#blocknumber) | | `transaction_index` | `number` | #### Defined in [src/types/api/sequencer.ts:152]( --- ### FailedTransactionResponse \u01ac **FailedTransactionResponse**: `Object` #### Type declaration | Name | Type | | :----------------------------------------- | :-------------------------------------------------------------- | | `status` | [`REJECTED`](../enums/types.TransactionStatus.md#rejected) | | `transaction_failure_reason` | { `code`: `string` ; `error_message`: `string` } | | `transaction_failure_reason.code` | `string` | | `transaction_failure_reason.error_message` | `string` | | `transaction` | [`TransactionResponse`](types.Sequencer.md#transactionresponse) | #### Defined in [src/types/api/sequencer.ts:160]( --- ### GetTransactionResponse \u01ac **GetTransactionResponse**: [`SuccessfulTransactionResponse`](types.Sequencer.md#successfultransactionresponse) \\| [`FailedTransactionResponse`](types.Sequencer.md#failedtransactionresponse) #### Defined in [src/types/api/sequencer.ts:169]( --- ### TransactionReceiptResponse \u01ac **TransactionReceiptResponse**: [`SuccessfulTransactionReceiptResponse`](types.Sequencer.md#successfultransactionreceiptresponse) \\| [`FailedTransactionReceiptResponse`](types.Sequencer.md#failedtransactionreceiptresponse) #### Defined in [src/types/api/sequencer.ts:171]( --- ### SuccessfulTransactionReceiptResponse \u01ac **SuccessfulTransactionReceiptResponse**: `Object` #### Type declaration | Name | Type | | :-------------------- | :--------------------------------------------------------- | | `status` | [`TransactionStatus`](../enums/types.TransactionStatus.md) | | `transaction_hash` | `string` | | `transaction_index` | `number` | | `block_hash` | `string` | | `block_number` | [`BlockNumber`](types.md#blocknumber) | | `l2_to_l1_messages` | `string`[] | | `events` | `string`[] | | `actual_fee` | `string` | | `execution_resources` | [`ExecutionResources`](types.md#executionresources) | #### Defined in [src/types/api/sequencer.ts:175]( --- ### FailedTransactionReceiptResponse \u01ac **FailedTransactionReceiptResponse**: `Object` #### Type declaration | Name | Type | | :----------------------------------------- | :--------------------------------------------------------- | | `status` | [`REJECTED`](../enums/types.TransactionStatus.md#rejected) | | `transaction_failure_reason` | { `code`: `string` ; `error_message`: `string` } | | `transaction_failure_reason.code` | `string` | | `transaction_failure_reason.error_message` | `string` | | `transaction_hash` | `string` | | `l2_to_l1_messages` | `string`[] | | `events` | `string`[] | #### Defined in [src/types/api/sequencer.ts:187]( --- ### GetBlockResponse \u01ac **GetBlockResponse**: `Object` #### Type declaration | Name | Type | | :--------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `block_number` | `number` | | `state_root` | `string` | | `block_hash` | `string` | | `transactions` | { `[txHash: string]`: [`TransactionResponse`](types.Sequencer.md#transactionresponse); } | | `timestamp` | `number` | | `transaction_receipts` | { `[txHash: string]`: { `block_hash`: `string` ; `transaction_hash`: `string` ; `l2_to_l1_messages`: { `to_address`: `string` ; `payload`: `string`[] ; `from_address`: `string` }[] ; `block_number`: [`BlockNumber`](types.md#blocknumber) ; `status`: [`TransactionStatus`](../enums/types.TransactionStatus.md) ; `transaction_index`: `number` }; } | | `parent_block_hash` | `string` | | `status` | [`BlockStatus`](../enums/types.BlockStatus.md) | | `gas_price` | `string` | | `sequencer_address` | `string` | | `starknet_version` | `string` | #### Defined in [src/types/api/sequencer.ts:198]( --- ### CallContractTransaction \u01ac **CallContractTransaction**: { `calldata?`: [`RawCalldata`](types.md#rawcalldata) ; `max_fee?`: [`BigNumberish`](types.md#bignumberish) ; `version?`: [`BigNumberish`](types.md#bignumberish) ; `entry_point_selector`: `string` } & { `sender_address`: `string` ; `signature`: `string`[] } \\| { `contract_address`: `string` ; `signature?`: `never` } #### Defined in [src/types/api/sequencer.ts:227]( --- ### CallContractResponse \u01ac **CallContractResponse**: `Object` #### Type declaration | Name | Type | | :------- | :--------- | | `result` | `string`[] | #### Defined in [src/types/api/sequencer.ts:243]( --- ### InvokeEstimateFee \u01ac **InvokeEstimateFee**: `Omit` #### Defined in [src/types/api/sequencer.ts:247]( --- ### DeclareEstimateFee \u01ac **DeclareEstimateFee**: `Omit` #### Defined in [src/types/api/sequencer.ts:248]( --- ### DeployAccountEstimateFee \u01ac **DeployAccountEstimateFee**: `Omit` #### Defined in [src/types/api/sequencer.ts:249]( --- ### DeployEstimateFee \u01ac **DeployEstimateFee**: [`DeployTransaction`](types.Sequencer.md#deploytransaction) #### Defined in [src/types/api/sequencer.ts:250]( --- ### SimulateTransactionResponse \u01ac **SimulateTransactionResponse**: `Object` #### Type declaration | Name | Type | | :--------------- | :------------------------------------------------------------------------ | | `trace` | [`TransactionTraceResponse`](types.Sequencer.md#transactiontraceresponse) | | `fee_estimation` | [`EstimateFeeResponse`](types.Sequencer.md#estimatefeeresponse) | #### Defined in [src/types/api/sequencer.ts:252]( --- ### AccountTransactionItem \u01ac **AccountTransactionItem**: [`InvokeEstimateFee`](types.Sequencer.md#invokeestimatefee) \\| [`DeclareEstimateFee`](types.Sequencer.md#declareestimatefee) \\| [`DeployEstimateFee`](types.Sequencer.md#deployestimatefee) \\| [`DeployAccountEstimateFee`](types.Sequencer.md#deployaccountestimatefee) #### Defined in [src/types/api/sequencer.ts:257]( --- ### AccountTransaction \u01ac **AccountTransaction**: [`AllowArray`](types.md#allowarray) Transaction filled with account data #### Defined in [src/types/api/sequencer.ts:266]( --- ### EstimateFeeResponse \u01ac **EstimateFeeResponse**: { `overall_fee`: `number` ; `gas_price`: `number` ; `gas_usage`: `number` ; `uint`: `string` } \\| { `amount`: `bigint` ; `unit`: `string` } #### Defined in [src/types/api/sequencer.ts:269]( --- ### EstimateFeeResponseBulk \u01ac **EstimateFeeResponseBulk**: [`AllowArray`](types.md#allowarray) #### Defined in [src/types/api/sequencer.ts:281]( --- ### BlockTransactionTracesResponse \u01ac **BlockTransactionTracesResponse**: `Object` #### Type declaration | Name | Type | | :------- | :------------------------------------------------------------------------------------------------------------- | | `traces` | [`TransactionTraceResponse`](types.Sequencer.md#transactiontraceresponse) & { `transaction_hash`: `string` }[] | #### Defined in [src/types/api/sequencer.ts:283]( --- ### Storage \u01ac **Storage**: `string` #### Defined in [src/types/api/sequencer.ts:287]( --- ### StateUpdateResponse \u01ac **StateUpdateResponse**: `Object` #### Type declaration | Name | Type | | :---------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `block_hash` | `string` | | `new_root` | `string` | | `old_root` | `string` | | `state_diff` | { `storage_diffs`: [`StorageDiffs`](types.Sequencer.md#storagediffs) ; `nonces`: [`Nonces`](types.Sequencer.md#nonces) ; `deployed_contracts`: [`DeployedContractItem`](types.md#deployedcontractitem)[] ; `old_declared_contracts`: [`OldDeclaredContracts`](types.Sequencer.md#olddeclaredcontracts) ; `declared_classes`: [`DeclaredClasses`](types.Sequencer.md#declaredclasses) ; `replaced_classes`: [`ReplacedClasses`](types.Sequencer.md#replacedclasses) } | | `state_diff.storage_diffs` | [`StorageDiffs`](types.Sequencer.md#storagediffs) | | `state_diff.nonces` | [`Nonces`](types.Sequencer.md#nonces) | | `state_diff.deployed_contracts` | [`DeployedContractItem`](types.md#deployedcontractitem)[] | | `state_diff.old_declared_contracts` | [`OldDeclaredContracts`](types.Sequencer.md#olddeclaredcontracts) | | `state_diff.declared_classes` | [`DeclaredClasses`](types.Sequencer.md#declaredclasses) | | `state_diff.replaced_classes` | [`ReplacedClasses`](types.Sequencer.md#replacedclasses) | #### Defined in [src/types/api/sequencer.ts:289]( --- ### StorageDiffs \u01ac **StorageDiffs**: `Object` #### Index signature [address: `string`]: [`StateDiffItem`](types.Sequencer.md#statediffitem)[] #### Defined in [src/types/api/sequencer.ts:303]( --- ### StateDiffItem \u01ac **StateDiffItem**: `Object` #### Type declaration | Name | Type | | :------ | :------- | | `key` | `string` | | `value` | `string` | #### Defined in [src/types/api/sequencer.ts:305]( --- ### Nonces \u01ac **Nonces**: `Object` #### Index signature [address: `string`]: [`Nonce`](types.Sequencer.md#nonce) #### Defined in [src/types/api/sequencer.ts:307]( --- ### Nonce \u01ac **Nonce**: `string` #### Defined in [src/types/api/sequencer.ts:309]( --- ### DeployedContracts \u01ac **DeployedContracts**: [`DeployedContractItem`](types.md#deployedcontractitem)[] #### Defined in [src/types/api/sequencer.ts:311]( --- ### OldDeclaredContracts \u01ac **OldDeclaredContracts**: `string`[] #### Defined in [src/types/api/sequencer.ts:313]( --- ### DeclaredClasses \u01ac **DeclaredClasses**: [`DeclaredClass`](types.Sequencer.md#declaredclass)[] #### Defined in [src/types/api/sequencer.ts:315]( --- ### DeclaredClass \u01ac **DeclaredClass**: `Object` #### Type declaration | Name | Type | | :-------------------- | :------- | | `class_hash` | `string` | | `compiled_class_hash` | `string` | #### Defined in [src/types/api/sequencer.ts:317]( --- ### ReplacedClasses \u01ac **ReplacedClasses**: `string`[] #### Defined in [src/types/api/sequencer.ts:319]( --- ### Endpoints \u01ac **Endpoints**: `Object` #### Type declaration | Name | Type | | :-------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `get_contract_addresses` | { `QUERY`: `never` ; `REQUEST`: `never` ; `RESPONSE`: [`GetContractAddressesResponse`](types.md#getcontractaddressesresponse) } | | `get_contract_addresses.QUERY` | `never` | | `get_contract_addresses.REQUEST` | `never` | | `get_contract_addresses.RESPONSE` | [`GetContractAddressesResponse`](types.md#getcontractaddressesresponse) | | `add_transaction` | { `QUERY`: `never` ; `REQUEST`: [`Transaction`](types.Sequencer.md#transaction) ; `RESPONSE`: [`AddTransactionResponse`](types.Sequencer.md#addtransactionresponse) } | | `add_transaction.QUERY` | `never` | | `add_transaction.REQUEST` | [`Transaction`](types.Sequencer.md#transaction) | | `add_transaction.RESPONSE` | [`AddTransactionResponse`](types.Sequencer.md#addtransactionresponse) | | `get_transaction` | { `QUERY`: { `transactionHash`: `string` } ; `REQUEST`: `never` ; `RESPONSE`: [`GetTransactionResponse`](types.Sequencer.md#gettransactionresponse) } | | `get_transaction.QUERY` | { `transactionHash`: `string` } | | `get_transaction.QUERY.transactionHash` | `string` | | `get_transaction.REQUEST` | `never` | | `get_transaction.RESPONSE` | [`GetTransactionResponse`](types.Sequencer.md#gettransactionresponse) | | `get_transaction_status` | { `QUERY`: { `transactionHash`: `string` } ; `REQUEST`: `never` ; `RESPONSE`: [`GetTransactionStatusResponse`](types.md#gettransactionstatusresponse) } | | `get_transaction_status.QUERY` | { `transactionHash`: `string` } | | `get_transaction_status.QUERY.transactionHash` | `string` | | `get_transaction_status.REQUEST` | `never` | | `get_transaction_status.RESPONSE` | [`GetTransactionStatusResponse`](types.md#gettransactionstatusresponse) | | `get_transaction_trace` | { `QUERY`: { `transactionHash`: `string` } ; `REQUEST`: `never` ; `RESPONSE`: [`TransactionTraceResponse`](types.Sequencer.md#transactiontraceresponse) } | | `get_transaction_trace.QUERY` | { `transactionHash`: `string` } | | `get_transaction_trace.QUERY.transactionHash` | `string` | | `get_transaction_trace.REQUEST` | `never` | | `get_transaction_trace.RESPONSE` | [`TransactionTraceResponse`](types.Sequencer.md#transactiontraceresponse) | | `get_transaction_receipt` | { `QUERY`: { `transactionHash`: `string` } ; `REQUEST`: `never` ; `RESPONSE`: [`TransactionReceiptResponse`](types.Sequencer.md#transactionreceiptresponse) } | | `get_transaction_receipt.QUERY` | { `transactionHash`: `string` } | | `get_transaction_receipt.QUERY.transactionHash` | `string` | | `get_transaction_receipt.REQUEST` | `never` | | `get_transaction_receipt.RESPONSE` | [`TransactionReceiptResponse`](types.Sequencer.md#transactionreceiptresponse) | | `get_nonce` | { `QUERY`: { `contractAddress`: `string` ; `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) } ; `REQUEST`: `never` ; `RESPONSE`: [`Nonce`](types.Sequencer.md#nonce) } | | `get_nonce.QUERY` | { `contractAddress`: `string` ; `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) } | | `get_nonce.QUERY.contractAddress` | `string` | | `get_nonce.QUERY.blockIdentifier` | [`BlockIdentifier`](types.md#blockidentifier) | | `get_nonce.REQUEST` | `never` | | `get_nonce.RESPONSE` | [`Nonce`](types.Sequencer.md#nonce) | | `get_storage_at` | { `QUERY`: { `contractAddress`: `string` ; `key`: [`BigNumberish`](types.md#bignumberish) ; `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) } ; `REQUEST`: `never` ; `RESPONSE`: [`Storage`](types.Sequencer.md#storage) } | | `get_storage_at.QUERY` | { `contractAddress`: `string` ; `key`: [`BigNumberish`](types.md#bignumberish) ; `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) } | | `get_storage_at.QUERY.contractAddress` | `string` | | `get_storage_at.QUERY.key` | [`BigNumberish`](types.md#bignumberish) | | `get_storage_at.QUERY.blockIdentifier` | [`BlockIdentifier`](types.md#blockidentifier) | | `get_storage_at.REQUEST` | `never` | | `get_storage_at.RESPONSE` | [`Storage`](types.Sequencer.md#storage) | | `get_code` | { `QUERY`: { `contractAddress`: `string` ; `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) } ; `REQUEST`: `never` ; `RESPONSE`: [`GetCodeResponse`](types.Sequencer.md#getcoderesponse) } | | `get_code.QUERY` | { `contractAddress`: `string` ; `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) } | | `get_code.QUERY.contractAddress` | `string` | | `get_code.QUERY.blockIdentifier` | [`BlockIdentifier`](types.md#blockidentifier) | | `get_code.REQUEST` | `never` | | `get_code.RESPONSE` | [`GetCodeResponse`](types.Sequencer.md#getcoderesponse) | | `get_block` | { `QUERY`: { `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) } ; `REQUEST`: `never` ; `RESPONSE`: [`GetBlockResponse`](types.Sequencer.md#getblockresponse) } | | `get_block.QUERY` | { `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) } | | `get_block.QUERY.blockIdentifier` | [`BlockIdentifier`](types.md#blockidentifier) | | `get_block.REQUEST` | `never` | | `get_block.RESPONSE` | [`GetBlockResponse`](types.Sequencer.md#getblockresponse) | | `call_contract` | { `QUERY`: { `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) } ; `REQUEST`: [`CallContractTransaction`](types.Sequencer.md#callcontracttransaction) ; `RESPONSE`: [`CallContractResponse`](types.Sequencer.md#callcontractresponse) } | | `call_contract.QUERY` | { `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) } | | `call_contract.QUERY.blockIdentifier` | [`BlockIdentifier`](types.md#blockidentifier) | | `call_contract.REQUEST` | [`CallContractTransaction`](types.Sequencer.md#callcontracttransaction) | | `call_contract.RESPONSE` | [`CallContractResponse`](types.Sequencer.md#callcontractresponse) | | `estimate_fee` | { `QUERY`: { `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) ; `skipValidate`: `boolean` } ; `REQUEST`: [`AccountTransactionItem`](types.Sequencer.md#accounttransactionitem) ; `RESPONSE`: [`EstimateFeeResponse`](types.Sequencer.md#estimatefeeresponse) } | | `estimate_fee.QUERY` | { `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) ; `skipValidate`: `boolean` } | | `estimate_fee.QUERY.blockIdentifier` | [`BlockIdentifier`](types.md#blockidentifier) | | `estimate_fee.QUERY.skipValidate` | `boolean` | | `estimate_fee.REQUEST` | [`AccountTransactionItem`](types.Sequencer.md#accounttransactionitem) | | `estimate_fee.RESPONSE` | [`EstimateFeeResponse`](types.Sequencer.md#estimatefeeresponse) | | `get_class_by_hash` | { `QUERY`: { `classHash`: `string` ; `blockIdentifier?`: [`BlockIdentifier`](types.md#blockidentifier) } ; `REQUEST`: `never` ; `RESPONSE`: [`CompiledContract`](types.md#compiledcontract) } | | `get_class_by_hash.QUERY` | { `classHash`: `string` ; `blockIdentifier?`: [`BlockIdentifier`](types.md#blockidentifier) } | | `get_class_by_hash.QUERY.classHash` | `string` | | `get_class_by_hash.QUERY.blockIdentifier?` | [`BlockIdentifier`](types.md#blockidentifier) | | `get_class_by_hash.REQUEST` | `never` | | `get_class_by_hash.RESPONSE` | [`CompiledContract`](types.md#compiledcontract) | | `get_class_hash_at` | { `QUERY`: { `contractAddress`: `string` ; `blockIdentifier?`: [`BlockIdentifier`](types.md#blockidentifier) } ; `REQUEST`: `never` ; `RESPONSE`: `string` } | | `get_class_hash_at.QUERY` | { `contractAddress`: `string` ; `blockIdentifier?`: [`BlockIdentifier`](types.md#blockidentifier) } | | `get_class_hash_at.QUERY.contractAddress` | `string` | | `get_class_hash_at.QUERY.blockIdentifier?` | [`BlockIdentifier`](types.md#blockidentifier) | | `get_class_hash_at.REQUEST` | `never` | | `get_class_hash_at.RESPONSE` | `string` | | `get_state_update` | { `QUERY`: { `blockHash?`: `string` ; `blockNumber?`: [`BlockNumber`](types.md#blocknumber) } ; `REQUEST`: `never` ; `RESPONSE`: [`StateUpdateResponse`](types.Sequencer.md#stateupdateresponse) } | | `get_state_update.QUERY` | { `blockHash?`: `string` ; `blockNumber?`: [`BlockNumber`](types.md#blocknumber) } | | `get_state_update.QUERY.blockHash?` | `string` | | `get_state_update.QUERY.blockNumber?` | [`BlockNumber`](types.md#blocknumber) | | `get_state_update.REQUEST` | `never` | | `get_state_update.RESPONSE` | [`StateUpdateResponse`](types.Sequencer.md#stateupdateresponse) | | `get_full_contract` | { `QUERY`: { `contractAddress`: `string` ; `blockIdentifier?`: [`BlockIdentifier`](types.md#blockidentifier) } ; `REQUEST`: `never` ; `RESPONSE`: [`CompiledContract`](types.md#compiledcontract) } | | `get_full_contract.QUERY` | { `contractAddress`: `string` ; `blockIdentifier?`: [`BlockIdentifier`](types.md#blockidentifier) } | | `get_full_contract.QUERY.contractAddress` | `string` | | `get_full_contract.QUERY.blockIdentifier?` | [`BlockIdentifier`](types.md#blockidentifier) | | `get_full_contract.REQUEST` | `never` | | `get_full_contract.RESPONSE` | [`CompiledContract`](types.md#compiledcontract) | | `estimate_message_fee` | { `QUERY`: `any` ; `REQUEST`: `any` ; `RESPONSE`: [`EstimateFeeResponse`](types.Sequencer.md#estimatefeeresponse) } | | `estimate_message_fee.QUERY` | `any` | | `estimate_message_fee.REQUEST` | `any` | | `estimate_message_fee.RESPONSE` | [`EstimateFeeResponse`](types.Sequencer.md#estimatefeeresponse) | | `simulate_transaction` | { `QUERY`: { `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) ; `skipValidate`: `boolean` } ; `REQUEST`: [`AccountTransaction`](types.Sequencer.md#accounttransaction) ; `RESPONSE`: [`SimulateTransactionResponse`](types.Sequencer.md#simulatetransactionresponse) } | | `simulate_transaction.QUERY` | { `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) ; `skipValidate`: `boolean` } | | `simulate_transaction.QUERY.blockIdentifier` | [`BlockIdentifier`](types.md#blockidentifier) | | `simulate_transaction.QUERY.skipValidate` | `boolean` | | `simulate_transaction.REQUEST` | [`AccountTransaction`](types.Sequencer.md#accounttransaction) | | `simulate_transaction.RESPONSE` | [`SimulateTransactionResponse`](types.Sequencer.md#simulatetransactionresponse) | | `estimate_fee_bulk` | { `QUERY`: { `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) ; `skipValidate`: `boolean` } ; `REQUEST`: [`AccountTransaction`](types.Sequencer.md#accounttransaction) ; `RESPONSE`: [`EstimateFeeResponseBulk`](types.Sequencer.md#estimatefeeresponsebulk) } | | `estimate_fee_bulk.QUERY` | { `blockIdentifier`: [`BlockIdentifier`](types.md#blockidentifier) ; `skipValidate`: `boolean` } | | `estimate_fee_bulk.QUERY.blockIdentifier` | [`BlockIdentifier`](types.md#blockidentifier) | | `estimate_fee_bulk.QUERY.skipValidate` | `boolean` | | `estimate_fee_bulk.REQUEST` | [`AccountTransaction`](types.Sequencer.md#accounttransaction) | | `estimate_fee_bulk.RESPONSE` | [`EstimateFeeResponseBulk`](types.Sequencer.md#estimatefeeresponsebulk) | | `get_block_traces` | { `QUERY`: { `blockHash?`: `string` ; `blockNumber?`: [`BlockNumber`](types.md#blocknumber) } ; `REQUEST`: `never` ; `RESPONSE`: [`BlockTransactionTracesResponse`](types.Sequencer.md#blocktransactiontracesresponse) } | | `get_block_traces.QUERY` | { `blockHash?`: `string` ; `blockNumber?`: [`BlockNumber`](types.md#blocknumber) } | | `get_block_traces.QUERY.blockHash?` | `string` | | `get_block_traces.QUERY.blockNumber?` | [`BlockNumber`](types.md#blocknumber) | | `get_block_traces.REQUEST` | `never` | | `get_block_traces.RESPONSE` | [`BlockTransactionTracesResponse`](types.Sequencer.md#blocktransactiontracesresponse) | | `get_compiled_class_by_class_hash` | { `QUERY`: { `classHash`: `string` ; `blockIdentifier?`: [`BlockIdentifier`](types.md#blockidentifier) } ; `REQUEST`: `any` ; `RESPONSE`: [`CairoAssembly`](types.md#cairoassembly) } | | `get_compiled_class_by_class_hash.QUERY` | { `classHash`: `string` ; `blockIdentifier?`: [`BlockIdentifier`](types.md#blockidentifier) } | | `get_compiled_class_by_class_hash.QUERY.classHash` | `string` | | `get_compiled_class_by_class_hash.QUERY.blockIdentifier?` | [`BlockIdentifier`](types.md#blockidentifier) | | `get_compiled_class_by_class_hash.REQUEST` | `any` | | `get_compiled_class_by_class_hash.RESPONSE` | [`CairoAssembly`](types.md#cairoassembly) | #### Defined in [src/types/api/sequencer.ts:321]("}
{"title": "types.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'types' title: 'Namespace: types' sidebar_label: 'types' sidebar_position: 0 custom_edit_url: null --- ## Namespaces - [Sequencer](types.Sequencer.md) - [RPC](types.RPC.md) ## Enumerations - [SIMULATION_FLAG](../enums/types.SIMULATION_FLAG.md) - [TransactionType](../enums/types.TransactionType.md) - [TransactionStatus](../enums/types.TransactionStatus.md) - [BlockStatus](../enums/types.BlockStatus.md) - [BlockTag](../enums/types.BlockTag.md) - [EntryPointType](../enums/types.EntryPointType.md) - [ValidateType](../enums/types.ValidateType.md) - [Uint](../enums/types.Uint.md) ## Interfaces - [EstimateFee](../interfaces/types.EstimateFee.md) - [EstimateFeeDetails](../interfaces/types.EstimateFeeDetails.md) - [DeployContractResponse](../interfaces/types.DeployContractResponse.md) - [Uint256](../interfaces/types.Uint256.md) - [CallStruct](../interfaces/types.CallStruct.md) - [Program](../interfaces/types.Program.md) - [ProviderOptions](../interfaces/types.ProviderOptions.md) - [GetBlockResponse](../interfaces/types.GetBlockResponse.md) - [GetCodeResponse](../interfaces/types.GetCodeResponse.md) - [CommonTransactionResponse](../interfaces/types.CommonTransactionResponse.md) - [InvokeTransactionResponse](../interfaces/types.InvokeTransactionResponse.md) - [ContractEntryPoint](../interfaces/types.ContractEntryPoint.md) - [DeclareTransactionResponse](../interfaces/types.DeclareTransactionResponse.md) - [CommonTransactionReceiptResponse](../interfaces/types.CommonTransactionReceiptResponse.md) - [MessageToL1](../interfaces/types.MessageToL1.md) - [Event](../interfaces/types.Event.md) - [MessageToL2](../interfaces/types.MessageToL2.md) - [InvokeTransactionReceiptResponse](../interfaces/types.InvokeTransactionReceiptResponse.md) - [EstimateFeeResponse](../interfaces/types.EstimateFeeResponse.md) - [InvokeFunctionResponse](../interfaces/types.InvokeFunctionResponse.md) - [DeclareContractResponse](../interfaces/types.DeclareContractResponse.md) - [StateUpdateResponse](../interfaces/types.StateUpdateResponse.md) - [InvocationsSignerDetails](../interfaces/types.InvocationsSignerDetails.md) - [DeclareSignerDetails](../interfaces/types.DeclareSignerDetails.md) - [StarkNetDomain](../interfaces/types.StarkNetDomain.md) - [TypedData](../interfaces/types.TypedData.md) ## Type Aliases ### EstimateFeeBulk \u01ac **EstimateFeeBulk**: [`EstimateFee`](../interfaces/types.EstimateFee.md)[] #### Defined in [src/types/account.ts:8]( --- ### AccountInvocationsFactoryDetails \u01ac **AccountInvocationsFactoryDetails**: `Object` #### Type declaration | Name | Type | | :----------------- | :-------------------------------------------- | | `versions` | `bigint`[] | | `nonce?` | [`BigNumberish`](types.md#bignumberish) | | `blockIdentifier?` | [`BlockIdentifier`](types.md#blockidentifier) | #### Defined in [src/types/account.ts:10]( --- ### MultiDeployContractResponse \u01ac **MultiDeployContractResponse**: `Object` #### Type declaration | Name | Type | | :----------------- | :--------- | | `contract_address` | `string`[] | | `transaction_hash` | `string` | #### Defined in [src/types/account.ts:27]( --- ### DeployContractUDCResponse \u01ac **DeployContractUDCResponse**: `Object` #### Type declaration | Name | Type | | :----------------- | :--------- | | `contract_address` | `string` | | `transaction_hash` | `string` | | `address` | `string` | | `deployer` | `string` | | `unique` | `string` | | `classHash` | `string` | | `calldata_len` | `string` | | `calldata` | `string`[] | | `salt` | `string` | #### Defined in [src/types/account.ts:32]( --- ### DeclareDeployUDCResponse \u01ac **DeclareDeployUDCResponse**: `Object` #### Type declaration | Name | Type | | :-------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------- | | `declare` | { `class_hash`: [`BigNumberish`](types.md#bignumberish) } & `Partial` | | `deploy` | [`DeployContractUDCResponse`](types.md#deploycontractudcresponse) | #### Defined in [src/types/account.ts:44]( --- ### SimulateTransactionDetails \u01ac **SimulateTransactionDetails**: `Object` #### Type declaration | Name | Type | | :----------------- | :-------------------------------------------- | | `nonce?` | [`BigNumberish`](types.md#bignumberish) | | `blockIdentifier?` | [`BlockIdentifier`](types.md#blockidentifier) | | `skipValidate?` | `boolean` | | `skipExecute?` | `boolean` | #### Defined in [src/types/account.ts:51]( --- ### AsyncContractFunction \u01ac **AsyncContractFunction**: (...`args`: [`ArgsOrCalldataWithOptions`](types.md#argsorcalldatawithoptions)) => `Promise` #### Type parameters | Name | Type | | :--- | :---- | | `T` | `any` | #### Type declaration \u25b8 (`...args`): `Promise` ##### Parameters | Name | Type | | :-------- | :---------------------------------------------------------------- | | `...args` | [`ArgsOrCalldataWithOptions`](types.md#argsorcalldatawithoptions) | ##### Returns `Promise` #### Defined in [src/types/contract.ts:3]( --- ### ContractFunction \u01ac **ContractFunction**: (...`args`: [`ArgsOrCalldataWithOptions`](types.md#argsorcalldatawithoptions)) => `any` #### Type declaration \u25b8 (`...args`): `any` ##### Parameters | Name | Type | | :-------- | :---------------------------------------------------------------- | | `...args` | [`ArgsOrCalldataWithOptions`](types.md#argsorcalldatawithoptions) | ##### Returns `any` #### Defined in [src/types/contract.ts:4]( --- ### Result \u01ac **Result**: { `[key: string]`: `any`; } \\| [`Result`](types.md#result)[] \\| `bigint` \\| `string` \\| `boolean` #### Defined in [src/types/contract.ts:5]( --- ### Calldata \u01ac **Calldata**: `string`[] & { `__compiled__?`: `boolean` } Compiled calldata ready to be sent decimal-string array #### Defined in [src/types/contract.ts:18]( --- ### ArgsOrCalldata \u01ac **ArgsOrCalldata**: [`RawArgsArray`](types.md#rawargsarray) \\| [[`Calldata`](types.md#calldata)] \\| [`Calldata`](types.md#calldata) #### Defined in [src/types/contract.ts:20]( --- ### ArgsOrCalldataWithOptions \u01ac **ArgsOrCalldataWithOptions**: [`ArgsOrCalldata`](types.md#argsorcalldata) & [`ContractOptions`](types.md#contractoptions) #### Defined in [src/types/contract.ts:21]( --- ### ContractOptions \u01ac **ContractOptions**: `Object` #### Type declaration | Name | Type | | :----------------- | :-------------------------------------------- | | `blockIdentifier?` | [`BlockIdentifier`](types.md#blockidentifier) | | `parseRequest?` | `boolean` | | `parseResponse?` | `boolean` | | `formatResponse?` | { `[key: string]`: `any`; } | | `maxFee?` | [`BigNumberish`](types.md#bignumberish) | | `nonce?` | [`BigNumberish`](types.md#bignumberish) | | `signature?` | [`Signature`](types.md#signature) | | `addressSalt?` | `string` | #### Defined in [src/types/contract.ts:22]( --- ### CallOptions \u01ac **CallOptions**: `Pick` #### Defined in [src/types/contract.ts:33]( --- ### InvokeOptions \u01ac **InvokeOptions**: `Pick` #### Defined in [src/types/contract.ts:38]( --- ### WeierstrassSignatureType \u01ac **WeierstrassSignatureType**: [`SignatureType`](../interfaces/ec.weierstrass.SignatureType.md) #### Defined in [src/types/lib/index.ts:5]( --- ### ArraySignatureType \u01ac **ArraySignatureType**: `string`[] #### Defined in [src/types/lib/index.ts:6]( --- ### Signature \u01ac **Signature**: [`ArraySignatureType`](types.md#arraysignaturetype) \\| [`WeierstrassSignatureType`](types.md#weierstrasssignaturetype) #### Defined in [src/types/lib/index.ts:7]( --- ### BigNumberish \u01ac **BigNumberish**: `string` \\| `number` \\| `bigint` #### Defined in [src/types/lib/index.ts:9]( --- ### RawCalldata \u01ac **RawCalldata**: [`BigNumberish`](types.md#bignumberish)[] BigNumberish array use CallData.compile() to convert to Calldata #### Defined in [src/types/lib/index.ts:25]( --- ### HexCalldata \u01ac **HexCalldata**: `string`[] Hexadecimal-string array #### Defined in [src/types/lib/index.ts:30]( --- ### AllowArray \u01ac **AllowArray**: `T` \\| `T`[] #### Type parameters | Name | | :--- | | `T` | #### Defined in [src/types/lib/index.ts:32]( --- ### OptionalPayload \u01ac **OptionalPayload**: { `payload`: `T` } \\| `T` #### Type parameters | Name | | :--- | | `T` | #### Defined in [src/types/lib/index.ts:34]( --- ### RawArgs \u01ac **RawArgs**: [`RawArgsObject`](types.md#rawargsobject) \\| [`RawArgsArray`](types.md#rawargsarray) #### Defined in [src/types/lib/index.ts:36]( --- ### RawArgsObject \u01ac **RawArgsObject**: `Object` #### Index signature [inputName: `string`]: [`MultiType`](types.md#multitype) \\| [`MultiType`](types.md#multitype)[] \\| [`RawArgs`](types.md#rawargs) #### Defined in [src/types/lib/index.ts:38]( --- ### RawArgsArray \u01ac **RawArgsArray**: ([`MultiType`](types.md#multitype) \\| [`MultiType`](types.md#multitype)[] \\| [`RawArgs`](types.md#rawargs))[] #### Defined in [src/types/lib/index.ts:42]( --- ### MultiType \u01ac **MultiType**: [`BigNumberish`](types.md#bignumberish) \\| [`Uint256`](../interfaces/types.Uint256.md) \\| `object` \\| `boolean` #### Defined in [src/types/lib/index.ts:44]( --- ### UniversalDeployerContractPayload \u01ac **UniversalDeployerContractPayload**: `Object` #### Type declaration | Name | Type | | :--------------------- | :-------------------------------------- | | `classHash` | [`BigNumberish`](types.md#bignumberish) | | `salt?` | `string` | | `unique?` | `boolean` | | `constructorCalldata?` | [`RawArgs`](types.md#rawargs) | #### Defined in [src/types/lib/index.ts:46]( --- ### DeployAccountContractPayload \u01ac **DeployAccountContractPayload**: `Object` #### Type declaration | Name | Type | | :--------------------- | :-------------------------------------- | | `classHash` | `string` | | `constructorCalldata?` | [`RawArgs`](types.md#rawargs) | | `addressSalt?` | [`BigNumberish`](types.md#bignumberish) | | `contractAddress?` | `string` | #### Defined in [src/types/lib/index.ts:53]( --- ### DeployAccountContractTransaction \u01ac **DeployAccountContractTransaction**: `Omit` & { `signature?`: [`Signature`](types.md#signature) } #### Defined in [src/types/lib/index.ts:60]( --- ### DeclareContractPayload \u01ac **DeclareContractPayload**: `Object` #### Type declaration | Name | Type | | :------------------- | :---------------------------------------------------------- | | `contract` | [`CompiledContract`](types.md#compiledcontract) \\| `string` | | `classHash?` | `string` | | `casm?` | [`CompiledSierraCasm`](types.md#compiledsierracasm) | | `compiledClassHash?` | `string` | #### Defined in [src/types/lib/index.ts:67]( --- ### CompleteDeclareContractPayload \u01ac **CompleteDeclareContractPayload**: `Object` #### Type declaration | Name | Type | | :------------------- | :---------------------------------------------------------- | | `contract` | [`CompiledContract`](types.md#compiledcontract) \\| `string` | | `classHash` | `string` | | `casm?` | [`CompiledSierraCasm`](types.md#compiledsierracasm) | | `compiledClassHash?` | `string` | #### Defined in [src/types/lib/index.ts:74]( --- ### DeclareAndDeployContractPayload \u01ac **DeclareAndDeployContractPayload**: `Omit` & [`DeclareContractPayload`](types.md#declarecontractpayload) #### Defined in [src/types/lib/index.ts:81]( --- ### DeclareContractTransaction \u01ac **DeclareContractTransaction**: `Object` #### Type declaration | Name | Type | | :------------------- | :---------------------------------------- | | `contract` | [`ContractClass`](types.md#contractclass) | | `senderAddress` | `string` | | `signature?` | [`Signature`](types.md#signature) | | `compiledClassHash?` | `string` | #### Defined in [src/types/lib/index.ts:84]( --- ### CallDetails \u01ac **CallDetails**: `Object` #### Type declaration | Name | Type | | :---------------- | :---------------------------- | | `contractAddress` | `string` | | `calldata?` | [`RawArgs`](types.md#rawargs) | | `entrypoint?` | `string` | #### Defined in [src/types/lib/index.ts:91]( --- ### Invocation \u01ac **Invocation**: [`CallDetails`](types.md#calldetails) & { `signature?`: [`Signature`](types.md#signature) } #### Defined in [src/types/lib/index.ts:97]( --- ### Call \u01ac **Call**: [`CallDetails`](types.md#calldetails) & { `entrypoint`: `string` } #### Defined in [src/types/lib/index.ts:99]( --- ### CairoVersion \u01ac **CairoVersion**: `\"0\"` \\| `\"1\"` #### Defined in [src/types/lib/index.ts:101]( --- ### InvocationsDetails \u01ac **InvocationsDetails**: `Object` #### Type declaration | Name | Type | | :--------- | :-------------------------------------- | | `nonce?` | [`BigNumberish`](types.md#bignumberish) | | `maxFee?` | [`BigNumberish`](types.md#bignumberish) | | `version?` | [`BigNumberish`](types.md#bignumberish) | #### Defined in [src/types/lib/index.ts:103]( --- ### Details \u01ac **Details**: `Object` Contain all additional details params #### Type declaration | Name | Type | | :-------- | :--------------------------------------------------------- | | `nonce` | [`BigNumberish`](types.md#bignumberish) | | `maxFee` | [`BigNumberish`](types.md#bignumberish) | | `version` | [`BigNumberish`](types.md#bignumberish) | | `chainId` | [`StarknetChainId`](../enums/constants.StarknetChainId.md) | #### Defined in [src/types/lib/index.ts:112]( --- ### InvocationsDetailsWithNonce \u01ac **InvocationsDetailsWithNonce**: [`InvocationsDetails`](types.md#invocationsdetails) & { `nonce`: [`BigNumberish`](types.md#bignumberish) } #### Defined in [src/types/lib/index.ts:119]( --- ### BlockNumber \u01ac **BlockNumber**: [`BlockTag`](../enums/types.BlockTag.md) \\| `null` \\| `number` #### Defined in [src/types/lib/index.ts:150]( --- ### BlockIdentifier \u01ac **BlockIdentifier**: [`BlockNumber`](types.md#blocknumber) \\| [`BigNumberish`](types.md#bignumberish) hex string and BN are detected as block hashes decimal string and number are detected as block numbers null appends nothing to the request url #### Defined in [src/types/lib/index.ts:157]( --- ### AccountInvocationItem \u01ac **AccountInvocationItem**: { `type`: [`DECLARE`](../enums/types.TransactionType.md#declare) } & [`DeclareContractTransaction`](types.md#declarecontracttransaction) \\| { `type`: [`DEPLOY_ACCOUNT`](../enums/types.TransactionType.md#deploy_account) } & [`DeployAccountContractTransaction`](types.md#deployaccountcontracttransaction) \\| { `type`: [`INVOKE`](../enums/types.TransactionType.md#invoke) } & [`Invocation`](types.md#invocation) & [`InvocationsDetailsWithNonce`](types.md#invocationsdetailswithnonce) items used by AccountInvocations #### Defined in [src/types/lib/index.ts:162]( --- ### AccountInvocations \u01ac **AccountInvocations**: [`AccountInvocationItem`](types.md#accountinvocationitem)[] Complete invocations array with account details (internal type from account -> provider) #### Defined in [src/types/lib/index.ts:172]( --- ### Invocations \u01ac **Invocations**: ({ `type`: [`DECLARE`](../enums/types.TransactionType.md#declare) } & [`OptionalPayload`](types.md#optionalpayload) \\| { `type`: [`DEPLOY`](../enums/types.TransactionType.md#deploy) } & [`OptionalPayload`](types.md#optionalpayload)\\> \\| { `type`: [`DEPLOY_ACCOUNT`](../enums/types.TransactionType.md#deploy_account) } & [`OptionalPayload`](types.md#optionalpayload) \\| { `type`: [`INVOKE`](../enums/types.TransactionType.md#invoke) } & [`OptionalPayload`](types.md#optionalpayload)\\>)[] Invocations array user provide to bulk method (simulate) #### Defined in [src/types/lib/index.ts:177]( --- ### Tupled \u01ac **Tupled**: `Object` #### Type declaration | Name | Type | | :-------- | :------- | | `element` | `any` | | `type` | `string` | #### Defined in [src/types/lib/index.ts:186]( --- ### Args \u01ac **Args**: `Object` #### Index signature [inputName: `string`]: [`BigNumberish`](types.md#bignumberish) \\| [`BigNumberish`](types.md#bignumberish)[] \\| [`ParsedStruct`](types.md#parsedstruct) \\| [`ParsedStruct`](types.md#parsedstruct)[] #### Defined in [src/types/lib/index.ts:188]( --- ### ParsedStruct \u01ac **ParsedStruct**: `Object` #### Index signature [key: `string`]: [`BigNumberish`](types.md#bignumberish) \\| [`ParsedStruct`](types.md#parsedstruct) #### Defined in [src/types/lib/index.ts:191]( --- ### waitForTransactionOptions \u01ac **waitForTransactionOptions**: `Object` #### Type declaration | Name | Type | | :--------------- | :----------------------------------------------------------- | | `retryInterval?` | `number` | | `successStates?` | [`TransactionStatus`](../enums/types.TransactionStatus.md)[] | #### Defined in [src/types/lib/index.ts:195]( --- ### getSimulateTransactionOptions \u01ac **getSimulateTransactionOptions**: `Object` #### Type declaration | Name | Type | | :----------------- | :-------------------------------------------- | | `blockIdentifier?` | [`BlockIdentifier`](types.md#blockidentifier) | | `skipValidate?` | `boolean` | | `skipExecute?` | `boolean` | #### Defined in [src/types/lib/index.ts:200]( --- ### getEstimateFeeBulkOptions \u01ac **getEstimateFeeBulkOptions**: `Object` #### Type declaration | Name | Type | | :----------------- | :-------------------------------------------- | | `blockIdentifier?` | [`BlockIdentifier`](types.md#blockidentifier) | | `skipValidate?` | `boolean` | #### Defined in [src/types/lib/index.ts:206]( --- ### ContractClass \u01ac **ContractClass**: [`LegacyContractClass`](types.md#legacycontractclass) \\| [`SierraContractClass`](types.md#sierracontractclass) format produced after compressing compiled contract CompressedCompiledContract #### Defined in [src/types/lib/contract/index.ts:9]( --- ### CompiledContract \u01ac **CompiledContract**: [`LegacyCompiledContract`](types.md#legacycompiledcontract) \\| [`CompiledSierra`](types.md#compiledsierra) format produced after compile .cairo to .json #### Defined in [src/types/lib/contract/index.ts:14]( --- ### CairoContract \u01ac **CairoContract**: [`ContractClass`](types.md#contractclass) \\| [`CompiledContract`](types.md#compiledcontract) Compressed or decompressed Cairo0 or Cairo1 Contract #### Defined in [src/types/lib/contract/index.ts:19]( --- ### Abi \u01ac **Abi**: ([`FunctionAbi`](types.md#functionabi) \\| `EventAbi` \\| [`StructAbi`](types.md#structabi))[] ABI #### Defined in [src/types/lib/contract/abi.ts:2]( --- ### AbiEntry \u01ac **AbiEntry**: `Object` #### Type declaration | Name | Type | | :----- | :-------------------------------- | | `name` | `string` | | `type` | `\"felt\"` \\| `\"felt*\"` \\| `string` | #### Defined in [src/types/lib/contract/abi.ts:5]( --- ### FunctionAbi \u01ac **FunctionAbi**: `Object` #### Type declaration | Name | Type | | :------------------ | :-------------------------------- | | `inputs` | [`AbiEntry`](types.md#abientry)[] | | `name` | `string` | | `outputs` | [`AbiEntry`](types.md#abientry)[] | | `stateMutability?` | `\"view\"` | | `state_mutability?` | `string` | | `type` | `FunctionAbiType` | #### Defined in [src/types/lib/contract/abi.ts:14]( --- ### AbiStructs \u01ac **AbiStructs**: `Object` #### Index signature [name: `string`]: [`StructAbi`](types.md#structabi) #### Defined in [src/types/lib/contract/abi.ts:23]( --- ### StructAbi \u01ac **StructAbi**: `Object` #### Type declaration | Name | Type | | :-------- | :--------------------------------------------------------- | | `members` | [`AbiEntry`](types.md#abientry) & { `offset`: `number` }[] | | `name` | `string` | | `size` | `number` | | `type` | `\"struct\"` | #### Defined in [src/types/lib/contract/abi.ts:25]( --- ### LegacyContractClass \u01ac **LegacyContractClass**: `Object` format produced after compressing 'program' property #### Type declaration | Name | Type | | :--------------------- | :------------------------------------------------ | | `program` | [`CompressedProgram`](types.md#compressedprogram) | | `entry_points_by_type` | [`EntryPointsByType`](types.md#entrypointsbytype) | | `abi` | [`Abi`](types.md#abi) | #### Defined in [src/types/lib/contract/legacy.ts:7]( --- ### LegacyCompiledContract \u01ac **LegacyCompiledContract**: `Omit` & { `program`: [`Program`](../interfaces/types.Program.md) } format produced after compile .cairo to .json #### Defined in [src/types/lib/contract/legacy.ts:16]( --- ### Builtins \u01ac **Builtins**: `string`[] SUBTYPES #### Defined in [src/types/lib/contract/legacy.ts:21]( --- ### CompressedProgram \u01ac **CompressedProgram**: `string` #### Defined in [src/types/lib/contract/legacy.ts:22]( --- ### EntryPointsByType \u01ac **EntryPointsByType**: `Object` #### Type declaration | Name | Type | | :------------ | :---------------------------------------------------------------- | | `CONSTRUCTOR` | [`ContractEntryPointFields`](types.md#contractentrypointfields)[] | | `EXTERNAL` | [`ContractEntryPointFields`](types.md#contractentrypointfields)[] | | `L1_HANDLER` | [`ContractEntryPointFields`](types.md#contractentrypointfields)[] | #### Defined in [src/types/lib/contract/legacy.ts:24]( --- ### ContractEntryPointFields \u01ac **ContractEntryPointFields**: `Object` #### Type declaration | Name | Type | | :---------- | :------------------------------ | | `selector` | `string` | | `offset` | `string` | | `builtins?` | [`Builtins`](types.md#builtins) | #### Defined in [src/types/lib/contract/legacy.ts:30]( --- ### CairoAssembly \u01ac **CairoAssembly**: `Object` SYSTEM TYPES #### Type declaration | Name | Type | | :--------------------- | :------------------------------------------------ | | `prime` | `string` | | `compiler_version` | `string` | | `bytecode` | [`ByteCode`](types.md#bytecode) | | `hints` | `any`[] | | `pythonic_hints` | [`PythonicHints`](types.md#pythonichints) | | `entry_points_by_type` | [`EntryPointsByType`](types.md#entrypointsbytype) | #### Defined in [src/types/lib/contract/sierra.ts:5]( --- ### CompiledSierra \u01ac **CompiledSierra**: `Object` format produced after starknet-compile .cairo to .json sierra_program is hex array #### Type declaration | Name | Type | | :--------------------------- | :------------------------------------------------------------ | | `sierra_program` | [`ByteCode`](types.md#bytecode) | | `sierra_program_debug_info?` | [`SierraProgramDebugInfo`](types.md#sierraprogramdebuginfo) | | `contract_class_version` | `string` | | `entry_points_by_type` | [`SierraEntryPointsByType`](types.md#sierraentrypointsbytype) | | `abi` | [`Abi`](types.md#abi) | #### Defined in [src/types/lib/contract/sierra.ts:19]( --- ### SierraContractClass \u01ac **SierraContractClass**: `Omit` & { `sierra_program`: `string` ; `abi`: `string` } format produced after compressing 'sierra_program', stringifies 'abi' property and omit sierra_program_debug_info CompressedCompiledSierra #### Defined in [src/types/lib/contract/sierra.ts:31]( --- ### CompiledSierraCasm \u01ac **CompiledSierraCasm**: [`CairoAssembly`](types.md#cairoassembly) #### Defined in [src/types/lib/contract/sierra.ts:35]( --- ### ByteCode \u01ac **ByteCode**: `string`[] SUBTYPES #### Defined in [src/types/lib/contract/sierra.ts:38]( --- ### PythonicHints \u01ac **PythonicHints**: [`number`, `string`[]][] #### Defined in [src/types/lib/contract/sierra.ts:39]( --- ### SierraProgramDebugInfo \u01ac **SierraProgramDebugInfo**: `Object` #### Type declaration | Name | Type | | :---------------- | :--------------------- | | `type_names` | [`number`, `string`][] | | `libfunc_names` | [`number`, `string`][] | | `user_func_names` | [`number`, `string`][] | #### Defined in [src/types/lib/contract/sierra.ts:41]( --- ### SierraEntryPointsByType \u01ac **SierraEntryPointsByType**: `Object` #### Type declaration | Name | Type | | :------------ | :---------------------------------------------------------------------------- | | `CONSTRUCTOR` | [`SierraContractEntryPointFields`](types.md#sierracontractentrypointfields)[] | | `EXTERNAL` | [`SierraContractEntryPointFields`](types.md#sierracontractentrypointfields)[] | | `L1_HANDLER` | [`SierraContractEntryPointFields`](types.md#sierracontractentrypointfields)[] | #### Defined in [src/types/lib/contract/sierra.ts:47]( --- ### SierraContractEntryPointFields \u01ac **SierraContractEntryPointFields**: `Object` #### Type declaration | Name | Type | | :------------- | :------- | | `selector` | `string` | | `function_idx` | `number` | #### Defined in [src/types/lib/contract/sierra.ts:53]( --- ### RpcProviderOptions \u01ac **RpcProviderOptions**: `Object` #### Type declaration | Name | Type | | :----------------- | :--------------------------------------------------------- | | `nodeUrl` | `string` | | `retries?` | `number` | | `headers?` | `object` | | `blockIdentifier?` | [`BlockIdentifier`](types.md#blockidentifier) | | `chainId?` | [`StarknetChainId`](../enums/constants.StarknetChainId.md) | #### Defined in [src/types/provider/configuration.ts:9]( --- ### SequencerHttpMethod \u01ac **SequencerHttpMethod**: `\"POST\"` \\| `\"GET\"` #### Defined in [src/types/provider/configuration.ts:17]( --- ### SequencerProviderOptions \u01ac **SequencerProviderOptions**: { `headers?`: `Record` ; `blockIdentifier?`: [`BlockIdentifier`](types.md#blockidentifier) ; `chainId?`: [`StarknetChainId`](../enums/constants.StarknetChainId.md) } & { `network`: [`NetworkName`](../enums/constants.NetworkName.md) \\| [`StarknetChainId`](../enums/constants.StarknetChainId.md) } \\| { `baseUrl`: `string` ; `feederGatewayUrl?`: `string` ; `gatewayUrl?`: `string` } #### Defined in [src/types/provider/configuration.ts:19]( --- ### GetTransactionResponse \u01ac **GetTransactionResponse**: [`InvokeTransactionResponse`](../interfaces/types.InvokeTransactionResponse.md) & [`DeclareTransactionResponse`](../interfaces/types.DeclareTransactionResponse.md) #### Defined in [src/types/provider/response.ts:43]( --- ### GetTransactionReceiptResponse \u01ac **GetTransactionReceiptResponse**: [`InvokeTransactionReceiptResponse`](../interfaces/types.InvokeTransactionReceiptResponse.md) \\| [`DeclareTransactionReceiptResponse`](types.md#declaretransactionreceiptresponse) #### Defined in [src/types/provider/response.ts:70]( --- ### DeclareTransactionReceiptResponse \u01ac **DeclareTransactionReceiptResponse**: [`CommonTransactionReceiptResponse`](../interfaces/types.CommonTransactionReceiptResponse.md) #### Defined in [src/types/provider/response.ts:104]( --- ### CallContractResponse \u01ac **CallContractResponse**: `Object` #### Type declaration | Name | Type | | :------- | :--------- | | `result` | `string`[] | #### Defined in [src/types/provider/response.ts:122]( --- ### EstimateFeeAction \u01ac **EstimateFeeAction**: { `type`: [`INVOKE`](../enums/types.TransactionType.md#invoke) ; `payload`: [`AllowArray`](types.md#allowarray) } \\| { `type`: [`DECLARE`](../enums/types.TransactionType.md#declare) ; `payload`: [`DeclareContractPayload`](types.md#declarecontractpayload) } \\| { `type`: [`DEPLOY_ACCOUNT`](../enums/types.TransactionType.md#deploy_account) ; `payload`: [`DeployAccountContractPayload`](types.md#deployaccountcontractpayload) } \\| { `type`: [`DEPLOY`](../enums/types.TransactionType.md#deploy) ; `payload`: [`UniversalDeployerContractPayload`](types.md#universaldeployercontractpayload) } #### Defined in [src/types/provider/response.ts:126]( --- ### EstimateFeeResponseBulk \u01ac **EstimateFeeResponseBulk**: [`EstimateFeeResponse`](../interfaces/types.EstimateFeeResponse.md)[] #### Defined in [src/types/provider/response.ts:144]( --- ### Storage \u01ac **Storage**: [`Storage`](types.Sequencer.md#storage) #### Defined in [src/types/provider/response.ts:146]( --- ### Nonce \u01ac **Nonce**: [`Nonce`](types.Sequencer.md#nonce) #### Defined in [src/types/provider/response.ts:148]( --- ### SimulationFlags \u01ac **SimulationFlags**: [`SimulationFlags`](types.RPC.md#simulationflags) #### Defined in [src/types/provider/response.ts:150]( --- ### SimulatedTransaction \u01ac **SimulatedTransaction**: `Object` #### Type declaration | Name | Type | | :------------------ | :--------------------------------------------------------------------------------------------------------------------------- | | `transaction_trace` | [`Trace`](types.RPC.md#trace) \\| [`TransactionTraceResponse`](types.Sequencer.md#transactiontraceresponse) | | `fee_estimation` | [`EstimateFeeResponse`](types.RPC.md#estimatefeeresponse) \\| [`EstimateFeeResponse`](types.Sequencer.md#estimatefeeresponse) | | `suggestedMaxFee?` | `string` \\| `bigint` | #### Defined in [src/types/provider/response.ts:152]( --- ### SimulateTransactionResponse \u01ac **SimulateTransactionResponse**: [`SimulatedTransaction`](types.md#simulatedtransaction)[] #### Defined in [src/types/provider/response.ts:158]( --- ### ContractClassResponse \u01ac **ContractClassResponse**: [`LegacyContractClass`](types.md#legacycontractclass) \\| `Omit` Standardized type Cairo0 program compressed and Cairo1 sierra_program decompressed abi Abi CompiledSierra without '.sierra_program_debug_info' #### Defined in [src/types/provider/response.ts:182]( --- ### DeployAccountSignerDetails \u01ac **DeployAccountSignerDetails**: `Required` & `Required` & { `contractAddress`: [`BigNumberish`](types.md#bignumberish) ; `chainId`: [`StarknetChainId`](../enums/constants.StarknetChainId.md) } #### Defined in [src/types/signer.ts:25]( --- ### StarkNetMerkleType \u01ac **StarkNetMerkleType**: `Object` #### Type declaration | Name | Type | | :--------- | :------------- | | `name` | `string` | | `type` | `\"merkletree\"` | | `contains` | `string` | #### Defined in [src/types/typedData.ts:1]( --- ### StarkNetType \u01ac **StarkNetType**: { `name`: `string` ; `type`: `string` } \\| [`StarkNetMerkleType`](types.md#starknetmerkletype) A single type, as part of a struct. The `type` field can be any of the EIP-712 supported types. Note that the `uint` and `int` aliases like in Solidity, and fixed point numbers are not supported by the EIP-712 standard. #### Defined in [src/types/typedData.ts:13]( --- ### GetTransactionStatusResponse \u01ac **GetTransactionStatusResponse**: `Object` #### Type declaration | Name | Type | | :-------------------------------- | :--------------------------------------------------------- | | `tx_status` | [`TransactionStatus`](../enums/types.TransactionStatus.md) | | `block_hash?` | `string` | | `tx_failure_reason?` | { `code`: `string` ; `error_message`: `string` } | | `tx_failure_reason.code` | `string` | | `tx_failure_reason.error_message` | `string` | #### Defined in [src/types/api/sequencer.ts:18]( --- ### GetContractAddressesResponse \u01ac **GetContractAddressesResponse**: `Object` #### Type declaration | Name | Type | | :--------------------- | :------- | | `Starknet` | `string` | | `GpsStatementVerifier` | `string` | #### Defined in [src/types/api/sequencer.ts:27]( --- ### FunctionInvocation \u01ac **FunctionInvocation**: `Object` #### Type declaration | Name | Type | | :-------------------- | :------------------------------------------------------ | | `caller_address` | `string` | | `contract_address` | `string` | | `calldata` | [`RawCalldata`](types.md#rawcalldata) | | `call_type?` | `string` | | `class_hash?` | `string` | | `selector?` | `string` | | `entry_point_type?` | [`EXTERNAL`](../enums/types.EntryPointType.md#external) | | `result` | `any`[] | | `execution_resources` | [`ExecutionResources`](types.md#executionresources) | | `internal_calls` | [`FunctionInvocation`](types.md#functioninvocation)[] | | `events` | `any`[] | | `messages` | `any`[] | #### Defined in [src/types/api/sequencer.ts:32]( --- ### ExecutionResources \u01ac **ExecutionResources**: `Object` #### Type declaration | Name | Type | | :--------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | `n_steps` | `number` | | `builtin_instance_counter` | { `pedersen_builtin`: `number` ; `range_check_builtin`: `number` ; `bitwise_builtin`: `number` ; `output_builtin`: `number` ; `ecdsa_builtin`: `number` ; `ec_op_builtin?`: `number` } | | `builtin_instance_counter.pedersen_builtin` | `number` | | `builtin_instance_counter.range_check_builtin` | `number` | | `builtin_instance_counter.bitwise_builtin` | `number` | | `builtin_instance_counter.output_builtin` | `number` | | `builtin_instance_counter.ecdsa_builtin` | `number` | | `builtin_instance_counter.ec_op_builtin?` | `number` | | `n_memory_holes` | `number` | #### Defined in [src/types/api/sequencer.ts:47]( --- ### CallL1Handler \u01ac **CallL1Handler**: `Object` #### Type declaration | Name | Type | | :--------------------- | :--------- | | `from_address` | `string` | | `to_address` | `string` | | `entry_point_selector` | `string` | | `payload` | `string`[] | #### Defined in [src/types/api/sequencer.ts:60]( --- ### DeployedContractItem \u01ac **DeployedContractItem**: `Object` #### Type declaration | Name | Type | | :----------- | :------- | | `address` | `string` | | `class_hash` | `string` | #### Defined in [src/types/api/sequencer.ts:67]( --- ### SequencerIdentifier \u01ac **SequencerIdentifier**: { `blockHash`: `string` } \\| { `blockNumber`: [`BlockNumber`](types.md#blocknumber) } #### Defined in [src/types/api/sequencer.ts:72]("}
{"title": "uint256.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- id: 'uint256' title: 'Namespace: uint256' sidebar_label: 'uint256' sidebar_position: 0 custom_edit_url: null --- ## References ### Uint256 Re-exports [Uint256](../interfaces/types.Uint256.md) ## Variables ### UINT_128_MAX \u2022 `Const` **UINT_128_MAX**: `bigint` #### Defined in [src/utils/uint256.ts:14]( --- ### UINT_256_MAX \u2022 `Const` **UINT_256_MAX**: `bigint` #### Defined in [src/utils/uint256.ts:15]( ## Functions ### uint256ToBN \u25b8 **uint256ToBN**(`uint256`): `bigint` #### Parameters | Name | Type | | :-------- | :------------------------------------------ | | `uint256` | [`Uint256`](../interfaces/types.Uint256.md) | #### Returns `bigint` #### Defined in [src/utils/uint256.ts:10]( --- ### isUint256 \u25b8 **isUint256**(`bn`): `boolean` #### Parameters | Name | Type | | :--- | :-------------------------------------- | | `bn` | [`BigNumberish`](types.md#bignumberish) | #### Returns `boolean` #### Defined in [src/utils/uint256.ts:17]( --- ### bnToUint256 \u25b8 **bnToUint256**(`bignumber`): [`Uint256`](../interfaces/types.Uint256.md) #### Parameters | Name | Type | | :---------- | :-------------------------------------- | | `bignumber` | [`BigNumberish`](types.md#bignumberish) | #### Returns [`Uint256`](../interfaces/types.Uint256.md) #### Defined in [src/utils/uint256.ts:22]("}
{"title": "L1message.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 13 --- # Messages with L1 network You can exchange messages between L1 & L2 networks: - L2 Starknet mainnet L1 Ethereum. - L2 Starknet testnet 1 & 2 L1 Goerli ETH testnet. - L2 local Starknet devnet L1 local ETH testnet (Ganache, ...). You can find an explanation of the global mechanism [here]( Most of the code for this messaging process will be written in Cairo, but Starknet.js provides some functionalities for this subject. ## L1 L2 messages To send a message from L1 to L2, you need a solidity smart contract in the L1 network, calling the `SendMessageToL2` function of the Starknet core contract. The interface of this function: ```solidity /** Sends a message to an L2 contract. This function is payable, the paid amount is the message fee. Returns the hash of the message and the nonce of the message. */ function sendMessageToL2( uint256 toAddress, uint256 selector, uint256[] calldata payload ) external payable returns (bytes32, uint256); ``` You have to pay in the L1 an extra fee when invoking `sendMessageToL2` (of course paid with the L1 fee TOKEN), to pay the L2 part of the messaging mechanism. You can estimate this fee with this function: ```typescript import { SequencerProvider } from \"starknet\"; const provider = new SequencerProvider({ baseUrl: constants.BaseUrl.SN_GOERLI }); // for testnet 1 const responseEstimateMessageFee = await provider.estimateMessageFee({ from_address: L1address, to_address: L2address, entry_point_selector: \"handle_l1_mess\", payload: [\"1234567890123456789\",\"200\"] }) ``` If the fee is paid in L1, the Cairo contract at `to_Address` is automatically executed, function `entry_point_selector` (the function shall have a decorator `@l1_handler` in the Cairo code), with parameters `payload`. ## L2 L1 messages To send a message to L1, you will just invoke a Cairo contract function, paying a fee that will pay all the processes (in L1 & L2). If necessary you can estimate this fee with the generic `estimateInvokeFee` function: ```typescript const { suggestedMaxFee: estimatedFee1 } = await account0.estimateInvokeFee({ contractAddress: testAddress, entrypoint: \"withdraw_to_L1\", calldata: [\"123456789\", \"30\"] }); ``` The result is in `estimatedFee1`, of type BN."}
{"title": "provider.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 1 title: Provider id: 'provider' --- The **Provider** API allows you to interact with the Starknet network, without signing transactions or messages. Typically, these are _read_ calls on the blockchain. ### Creating an instance `new starknet.Provider(optionsOrProvider)` The options for the provider depend on the network. The structure of the options object is: - options.**sequencer** - Options for sequencer provider - options.**rpc** - Options for RPC provider The easiest way to get started is: ```typescript const provider = new starknet.Provider() ``` The above snippet creates a Starknet Provider instance with testnet `SN_GOERLI2` network. However, if you want to use mainnet `SN_MAIN` or explicitly declare the network, you can use: ```typescript const provider = new starknet.Provider({ sequencer: { network: NetworkName.SN_MAIN // or NetworkName.SN_GOERLI2 } }) ``` If you want more control: ```typescript const provider = new starknet.Provider({ sequencer: { baseUrl: BaseUrl.SN_GOERLI, feederGatewayUrl: 'feeder_gateway', gatewayUrl: 'gateway', } }) ``` These are also the default options for the Provider constructor with `network: 'SN_GOERLI2'`. > **Note** > > `network` argument should work in most cases. If you want to use the `sequencer` argument with `baseUrl`, you will not be able to use the `network` field in the object. ## Methods ### getChainId() provider.**getChainId**() => _Promise _ Returns the chain Id for the current network. --- ### callContract() provider.**callContract**(call [ , blockIdentifier ]) => _Promise _ Calls a function on the Starknet contract. The call object structure: - call.**contractAddress** - Address of the contract - call.**entrypoint** - Entrypoint of the call (method name) - call.**calldata** - Payload for the invoking method ###### _CallContractResponse_ ```typescript { result: string[]; } ``` --- ### getBlock() provider.**getBlock**(blockIdentifier) => _Promise _ Gets the block information. ###### _GetBlockResponse_ ```typescript { accepted_time: number; block_hash: string; block_number: number; gas_price: string; new_root: string; old_root?: string; parent_hash: string; sequencer: string; status: 'NOT_RECEIVED' | 'RECEIVED' | 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED'; transactions: Array; starknet_version?: string; } ``` --- ### getClassAt() provider.**getClassAt**(contractAddress, blockIdentifier) => _Promise _ Gets the contract class of the deployed contract. ###### _ContractClass_ ```typescript { program: CompressedProgram; entry_points_by_type: EntryPointsByType; abi?: Abi; } ``` --- ### getInvokeEstimateFee() provider.**getInvokeEstimateFee**(invocationWithTxType, invocationDetails, blockIdentifier) => _Promise _ Estimate fee for invoke transaction. ###### _EstimateFeeResponse_ ```typescript { overall_fee: BN; gas_consumed?: BN; gas_price?: BN; } ``` --- ### getNonceForAddress() provider.**getNonceForAddress**(contractAddress, blockIdentifier) => _Promise _ Gets the nonce of the provided contractAddress. This was renamed from `getNonce` to `getNonceForAddress` to avoid confusion when inheriting an Account from the Provider class. --- ### getStorageAt() provider.**getStorageAt**(contractAddress, key, blockIdentifier) => _Promise _ Gets the contract's storage variable at a specific key. --- ### getTransactionReceipt() provider.**getTransactionReceipt**(txHash) => _Promise _ Gets the status of a transaction. ###### _GetTransactionReceiptResponse_ ```typescript { transaction_hash: string; status: 'NOT_RECEIVED' | 'RECEIVED' | 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED'; actual_fee?: string; status_data?: string; messages_sent?: Array; events?: Array; l1_origin_message?: MessageToL2; } ``` --- ### getTransaction() provider.**getTransaction**(txHash) => _Promise _ Gets the transaction information from a tx hash. ###### _GetTransactionResponse_ ```typescript { transaction_hash: string; version?: string; signature?: Signature; max_fee?: string; nonce?: string; contract_address?: string; entry_point_selector?: string; calldata?: RawCalldata; contract_class?: ContractClass; sender_address?: string; } ``` --- ### declareContract() provider.**declareContract**(transaction, details) => _Promise _ Declare a contract on Starknet. ###### _DeclareContractResponse_ ```typescript { transaction_hash: string; class_hash: string; }; ``` --- ### getDeclareEstimateFee() provider.**getDeclareEstimateFee**(transaction, details, blockIdentifier) => _Promise _ Estimate fee for declare transaction. ###### _EstimateFeeResponse_ ```typescript { overall_fee: BN; gas_consumed?: BN; gas_price?: BN; }; ``` --- ### waitForTransaction() provider.**waitForTransaction**(txHash [ , options]) => _Promise _ Wait for the transaction to be accepted on L2 or L1. --- ### getStarkName() provider.**getStarkName**(address, StarknetIdContract) => _Promise_ Gets starknet.id stark name with the address provided The _StarknetIdContract_ argument can be undefined, if it is, the function will automatically use official starknet id contracts of your network. Returns directly a string (Example: `vitalik.stark`). --- ### getAddressFromStarkName() provider.**getAddressFromStarkName**(name, StarknetIdContract) => _Promise_ Gets account address with the starknet id stark name. The _StarknetIdContract_ argument can be undefined, if it is, the function will automatically use official starknet id contracts of your network. Returns directly the address in a string (Example: `0xff...34`). --- ### getStateUpdate() provider.**getStateUpdate**(blockIdentifier) => _Promise _ Gets the state changes in a specific block ###### StateUpdateResponse ```typescript { block_hash: string; new_root: string; old_root: string; state_diff: { storage_diffs: Array; declared_contract_hashes: Array; deployed_contracts: Array; nonces: Array; }; }; ```"}
{"title": "rpcProvider.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 1 title: RPC Provider id: 'rpcProvider' --- ## Creating an instance `new starknet.RpcProvider(options)` - options.**nodeUrl** - Starknet RPC node url - options.**headers** - [Optional] custom fetch headers - options.**retries** - [Optional] wait for transaction max retries - options.**blockIdentifier** - [Optional] default value set to 'latest' Example: ```typescript const provider = new starknet.RpcProvider({ nodeUrl: 'URL_TO_STARKNET_RPC_NODE', }) ``` ## Methods --- ### fetch() provider.**fetch**(method: any, params: any) => _Promise _ Generic method for users to be able to experiment with RPC methods. --- ### getChainId() provider.**getChainId**() => _Promise _ --- ### getBlock() provider.**getBlock**(blockIdentifier) => _Promise _ --- ### getBlockHashAndNumber() provider.**getBlockHashAndNumber**() => _Promise _ ###### _BlockHashAndNumber_ ```typescript { block_hash: BLOCK_HASH; block_number: BLOCK_NUMBER; } ``` --- ### getBlockWithTxHashes() provider.**getBlockWithTxHashes**(blockIdentifier) => _Promise _ ###### _GetBlockWithTxHashesResponse_ ```typescript OPENRPC.BlockWithTxHashes ``` --- ### getBlockWithTxs() provider.**getBlockWithTxs**(blockIdentifier) => _Promise _ ###### _GetBlockWithTxs_ ```typescript OPENRPC.BlockWithTxs ``` --- ### getClassHashAt() provider.**getClassHashAt**(blockIdentifier) => _Promise _ --- ### getTransactionCount() provider.**getTransactionCount**(blockIdentifier) => _Promise _ Gets the transaction count from a block. --- ### getBlockNumber() provider.**getBlockNumber**() => _Promise _ Gets the latest block number. --- ### getPendingTransactions() provider.**getPendingTransactions**() => _Promise _ ###### _PendingTransactions_ ```typescript OPENRPC.PendingTransactions; ``` --- ### getStateUpdate() provider.**getStateUpdate**(blockIdentifier) => _Promise _ ###### _StateUpdate_ ```typescript OPENRPC.StateUpdate; ``` --- ### getStorageAt() provider.**getStorageAt**(contractAddress, key, blockIdentifier) => _Promise _ --- ### getTransaction() provider.**getTransaction**(txHash) => _Promise _ --- ### getTransactionByHash() provider.**getTransactionByHash**(txHash) => _Promise _ ###### _GetTransactionByHashResponse_ ```typescript OPENRPC.Transaction; ``` --- ### getTransactionByBlockIdAndIndex() provider.**getTransactionByBlockIdAndIndex**(blockIdentifier, index) => _Promise _ ###### _GetTransactionByBlockIdAndIndex_ ```typescript OPENRPC.Transaction; ``` --- ### getTransactionReceipt() provider.**getTransactionReceipt**(txHash) => _Promise _ --- ### getClass() provider.**getClass**(classHash) => _Promise _ ###### _ContractClass_ ```typescript OPENRPC.ContractClass; ``` --- ### getClassAt() provider.**getClassAt**(contractAddress, blockIdentifier) => _Promise _ ###### _ContractClass_ ```typescript OPENRPC.ContractClass; ``` --- ### getInvokeEstimateFee() provider.**getInvokeEstimateFee**(invocation, invocationDetails, blockIdentifier) => _Promise _ ###### _EstimateFeeResponse_ ```typescript overall_fee: BN; gas_consumed?: BN; gas_price?: BN; ``` --- ### getDeclareEstimateFee() provider.**getDeclareEstimateFee**(DeclareContractTransaction, details, blockIdentifier) => _Promise _ ###### _EstimateFeeResponse_ ```typescript overall_fee: BN; gas_consumed?: BN; gas_price?: BN; ``` --- ### declareContract() provider.**declareContract**(DeclareContractTransaction, details) => _Promise _ ###### _DeclareContractResponse_ ```typescript transaction_hash: string; class_hash: string; ``` --- ### callContract() provider.**callContract**(call, blockIdentifier) => _Promise _ --- ### getContractAddresses() provider.**traceTransaction**(transactionHash) => _Promise _ ###### _Trace_ ```typescript OPENRPC.Trace; ``` --- ### traceBlockTransactions() provider.**traceBlockTransactions**(blockHash) => _Promise _ ###### _Traces_ ```typescript OPENRPC.Traces; ``` --- ### getSyncingStats() provider.**getSyncingStats**() => _Promise _ Gets syncing status of the node. ###### _GetSyncingStatsResponse_ ```typescript boolean | { starting_block_hash: string; starting_block_num: string; current_block_hash: string; current_block_num: string; highest_block_hash: string; highest_block_num: string; } ``` --- ### getEvents() provider.**getEvents**(eventFilter) => _Promise _ Gets all the events filtered ##### _EventFilter_ ```typescript type EventFilter = { fromBlock: string; toBlock: string; address: string; keys: string[]; page_size: number; page_number: number; }; ``` ###### _GetEventsResponse_ ```typescript { events: StarknetEmittedEvent[]; page_number: number; is_last_page: number; } ```"}
{"title": "sequencerProvider.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 1 title: Sequencer Provider id: 'sequencerProvider' --- On top of methods found in the [Provider](/docs/API/provider) section, `SequencerProvider` has some additional ones you can use. ## Creating an instance `new starknet.SequencerProvider(optionsOrProvider)` The options for the provider depend on the network. The structure of the options object is: - options.**baseUrl** - Base URL of the network - options.**feederGatewayUrl** - Feeder Gateway Endpoint of the network - options.**gatewayUrl** - Gateway Endpoint - options.**headers** - [Optional] custom fetch headers or - options.**network** - NetworkName - options.**headers** - [Optional] custom fetch headers Example: ```typescript const provider = new starknet.SequencerProvider({ baseUrl: BaseUrl.SN_GOERLI, feederGatewayUrl: 'feeder_gateway', gatewayUrl: 'gateway', }) ``` ## Methods --- ### getContractAddresses() provider.**getContractAddresses**() => _Promise _ Gets the smart contract address on the network. ###### _GetContractAddressesResponse_ ```typescript { Starknet: string; GpsStatementVerifier: string; } ``` --- ### getCode() provider.**getCode**(contractAddress, blockIdentifier) => _Promise _ Gets the smart contract address on the network. ###### _GetCodeResponse_ ```typescript { bytecode: ByteCode; abi: Abi; } ``` --- ### estimateMessageFee() provider.**estimateMessageFee**(CallL1Handler, blockIdentifier) => _Promise _ Estimate fee for sending a message to L1. ##### _CallL1Handler_ ````typescript type CallL1Handler = { from_address: getDecimalString(from_address), to_address: getHexString(to_address), entry_point_selector: getSelector(entry_point_selector), payload: getHexStringArray(payload), }; ###### _EstimateFeeResponse_ ```typescript { overall_fee: number; gas_price: number; gas_usage: number; unit: string; } ```` --- ### getTransactionStatus() provider.**getTransactionStatus**(txHash) => _Promise _ Gets the status of a transaction. ###### _GetTransactionStatusResponse_ ```typescript { tx_status: 'NOT_RECEIVED' | 'RECEIVED' | 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED'; block_hash: string; tx_failure_reason?: { tx_id: number; code: string; error_message: string; } } ``` --- ### getTransactionTrace() provider.**getTransactionTrace**(txHash) => _Promise _ Gets the transaction trace from a tx hash. ###### _GetTransactionTraceResponse_ ```typescript { validate_invocation?: FunctionInvocation; function_invocation?: FunctionInvocation; fee_transfer_invocation?: FunctionInvocation; signature: Signature; } { FunctionInvocation: { caller_address: string; contract_address: string; calldata: { [inputName: string]: string | string[] | { type: 'struct'; [k: string]: BigNumberish }; }; call_type?: string; class_hash?: string; selector?: string; entry_point_type?: EntryPointType; result: Array; execution_resources: ExecutionResources; internal_calls: Array; events: Array; messages: Array; }; } ``` --- ### getBlockTraces() provider.**getBlockTraces**(blockIdentifier) => _Promise _ Gets the transaction traces of an entire block ###### _BlockTransactionTracesResponse_ ```typescript { traces: Array; } { TransactionTraceResponse: { validate_invocation?: FunctionInvocation; function_invocation?: FunctionInvocation; fee_transfer_invocation?: FunctionInvocation; signature: Signature; }; FunctionInvocation: { caller_address: string; contract_address: string; calldata: { [inputName: string]: string | string[] | { type: 'struct'; [k: string]: BigNumberish }; }; call_type?: string; class_hash?: string; selector?: string; entry_point_type?: EntryPointType; result: Array; execution_resources: ExecutionResources; internal_calls: Array; events: Array; messages: Array; }; } ```"}
{"title": "account.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 2 --- # Account An Account extends [`Provider`](/docs/API/provider) and inherits all of its methods. It also introduces new methods that allow Accounts to create and verify signatures with a custom [`Signer`](/docs/API/signer), declare and deploy Contract and deploy new Account This API is the primary way to interact with an account contract on Starknet. ## Creating an instance To create a new instance of the Account, first an account contract must be deployed. Also there needs to be a Provider instance that will be passed in the constructor and key pair for the account. `new starknet.Account(Provider, address, pk)` ## Properties account.**address** => _string_ The address of the account contract. ## Methods ### getNonce() account.**getNonce(blockIdentifier)** => _Promise _ Gets the nonce of the account with respect to a specific block. _blockIdentifier_ - optional blockIdentifier. Defaults to 'pending'. Returns the nonce of the account. --- ### estimateInvokeFee() account.**estimateInvokeFee**(calls [ , estimateFeeDetails ]) => _Promise _ Estimate Fee for executing an INVOKE transaction on Starknet. The _calls_ object structure: - calls.**contractAddress** - Address of the contract - calls.**entrypoint** - Entrypoint of the call (method name) - calls.**calldata** - Payload for the invoking method The _estimateFeeDetails_ object may include any of: - estimateFeeDetails.**blockIdentifier** - Block Identifier for the transaction - estimateFeeDetails.**nonce** - Nonce for the transaction ###### _EstimateFeeResponse_ ```typescript { overall_fee: BN; gas_consumed?: BN; gas_price?: BN; } ``` --- ### estimateDeclareFee() account.**estimateDeclareFee**(contractPayload [ , estimateFeeDetails ]) => _Promise _ Estimate Fee for executing a DECLARE transaction on Starknet. The _contractPayload_ object structure: - contractPayload.**contract** - The compiled contract - contractPayload.**classHash** - This can be obtained by using starknet-cli. Once the classHash is included in CompiledContract, this can be removed The _estimateFeeDetails_ object may include any of: - estimateFeeDetails.**blockIdentifier** - Block Identifier for the transaction - estimateFeeDetails.**nonce** - Nonce for the transaction ###### _EstimateFeeResponse_ ```typescript { overall_fee: BN; gas_consumed?: BN; gas_price?: BN; } ``` --- ### estimateAccountDeployFee() account.**estimateAccountDeployFee**(contractPayload [ , estimateFeeDetails ]) => _Promise _ Estimate Fee for executing a DEPLOY_ACCOUNT transaction on Starknet The _contractPayload_ object structure: - contractPayload.**contract** - The compiled contract to be declared - contractPayload.**classHash** - This can be obtained by using starknet-cli. Once the classHash is included in CompiledContract, this can be removed The _estimateFeeDetails_ object may include any of: - estimateFeeDetails.**blockIdentifier** - Block Identifier for the transaction - estimateFeeDetails.**nonce** - Nonce for the transaction ###### _EstimateFeeResponse_ ```typescript { overall_fee: BN; gas_consumed?: BN; gas_price?: BN; } ``` --- ### estimateFeeBulk() account.**estimateFeeBulk**(transaction[] [ , estimateFeeDetails ]) => _Promise _ Estimate Fee for executing a list of transactions on starknet. The _transaction_ object structure: - transaction.**type** - the type of transaction : 'DECLARE' | 'DEPLOY' | 'INVOKE_FUNCTION' | 'DEPLOY_ACCOUNT' - transaction payload - the payload for the transaction The _estimateFeeDetails_ object may include any of: - estimateFeeDetails.**blockIdentifier** - Block Identifier for the transaction - estimateFeeDetails.**nonce** - Nonce for the transaction ###### _EstimateFeeResponse_ ```typescript { overall_fee: BN; gas_consumed?: BN; gas_price?: BN; } ``` --- ### execute() account.**execute**(transactions [ , abi , transactionsDetail ]) => _Promise _ Executes one or multiple calls using the account contract. If there is only one call, _transactions_ will be an object that contains parameters below. If there are multiple calls, _transactions_ will be an array that contains several objects mentioned above. The _transactions_ object structure: - contractPayload.**contractAddress** - the address of the contract - contractPayload.**entrypoint** - the entrypoint of the contract - contractPayload.**calldata** - (defaults to []) the calldata - contractPayload.**signature** - (defaults to []) the signature _abi_ - (optional) the abi of the contract for better displaying The _transactionsDetail_ object may include any of: - transactionsDetail.**maxFee** - Max Fee that that will be used to execute the call(s) - transactionsDetail.**nonce** - Nonce for the transaction - transactionsDetail.**version** - Version for the transaction (default is 1) Example: ```typescript // When there is only one call const call = await account.execute( { contractAddress: '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7', // ETH contract address entrypoint: 'approve', calldata: starknet.CallData.compile( { spender: \"0x15e90f807a00a01df845460324fbcd33986f2df3cc9d981e9e8b5005b7f595e\", amount: { type: 'struct', low: '1', // 1 wei high: '0', } } ), }, undefined, { nonce: '10', } ); // When there are multiple calls const multiCall = await account.execute( [ { contractAddress: '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7', // ETH contract address entrypoint: 'approve', calldata: starknet.CallData.compile( { spender: \"0x15e90f807a00a01df845460324fbcd33986f2df3cc9d981e9e8b5005b7f595e\", amount: { type: 'struct', low: '1', // 1 wei high: '0', } } ), }, { contractAddress: '0x15e90f807a00a01df845460324fbcd33986f2df3cc9d981e9e8b5005b7f595e', entrypoint: 'transfer_ether', calldata: ['1', '0'], // 1 wei } ], undefined, { nonce: '10', } ); ``` ###### _InvokeFunctionResponse_ ```typescript { transaction_hash: string; }; ``` --- ### declare() account.**declare**(contractPayload [ , transactionsDetail ]) => _Promise _ Declares a given compiled contract (json) to starknet. The _contractPayload_ object consists of: - contractPayload.**contract** - The compiled contract - contractPayload.**classHash** - Hash of the compiled contract The _transactionsDetail_ object may include any of: - transactionsDetail.**maxFee** - Max Fee that that will be used to execute the call(s) - transactionsDetail.**nonce** - Nonce for the transaction - transactionsDetail.**version** - Version for the transaction (default is 1) > _Note:_ Once the classHash is included in CompiledContract, this parameter can be removed. Currently it can be pre-computed from starknet-cli. Example: ```typescript const declareTx = await account.declare({ contract: compiledErc20, // classHash is pre-computed from starknet-cli classHash: '0x54328a1075b8820eb43caf0caa233923148c983742402dcfc38541dd843d01a', }); ``` ###### _DeclareContractResponse_ ```typescript { transaction_hash: string; class_hash: string; }; ``` --- ### deploy() Deploys a given compiled contract (json) to starknet, wrapper around _execute_ invoke function account.**deploy**(deployContractPayload [ , transactionsDetail ]) => _Promise _ @param object **_deployContractPayload_** - **classHash**: computed class hash of compiled contract - optional constructorCalldata: constructor calldata - optional salt: address salt - default random - optional unique: bool if true ensure unique salt - default true @param object **transactionsDetail** Invocation Details - optional nonce - optional version - optional maxFee @returns **transaction_hash** Example: ```typescript const deployment = await account.deploy({ classHash: erc20ClassHash, constructorCalldata: [ encodeShortString('Token'), encodeShortString('ERC20'), account.address, ], salt: randomAddress(), unique: true, // Using true here so as not to clash with normal erc20 deploy in account and provider test }); await provider.waitForTransaction(deployment.transaction_hash); ``` Example multi-call: ```typescript TODO Example with multi-call ``` --- ### deployContract() NEW High level wrapper for deploy. Doesn't require waitForTransaction. Response similar to deprecated provider deployContract. account.**deployContract**(payload [ , details ]) => _Promise _ @param object **_payload_** UniversalDeployerContractPayload - **classHash**: computed class hash of compiled contract - **constructorCalldata**: constructor calldata - optional salt: address salt - default random - optional unique: bool if true ensure unique salt - default true @param object **details** InvocationsDetails - optional nonce - optional version - optional maxFee @returns Promise DeployContractUDCResponse - contract_address - transaction_hash - address - deployer - unique - classHash - calldata_len - calldata - salt Example: ```typescript const deployResponse = await account.deployContract({ classHash: erc20ClassHash, constructorCalldata: [ encodeShortString('Token'), encodeShortString('ERC20'), account.address, ], }); ``` --- ### declareAndDeploy() NEW High level wrapper for declare & deploy. Doesn't require waitForTransaction. Functionality similar to deprecated provider deployContract. Declare and Deploy contract using single function. account.**declareAndDeploy**(payload [ , details ]) => _Promise _ @param object **_payload_** DeclareDeployContractPayload - **contract**: compiled contract code - optional computed class hash of compiled contract - optional constructorCalldata: constructor calldata - optional salt: address salt - default random - optional unique: bool if true ensure unique salt - default true @param object **details** InvocationsDetails - optional nonce - optional version - optional maxFee @returns Promise DeclareDeployUDCResponse - declare: CommonTransactionReceiptResponse - transaction_hash - class_hash - deploy: DeployContractUDCResponse; - contract_address - transaction_hash - address - deployer - unique - classHash - calldata_len - calldata - salt *** Example: ```typescript const declareDeploy = await account.declareDeploy({ contract: compiledErc20, constructorCalldata: [ encodeShortString('Token'), encodeShortString('ERC20'), account.address, ], }); const declareTransactionHash = declareDeploy.declare.transaction_hash const erc20Address = declareDeploy.deploy.contract_address; ``` --- ### deployAccount() account.**deployAccount**(contractPayload [ , transactionsDetail ]) => _Promise _ Declares a given compiled contract (json) to starknet. The _contractPayload_ object consists of: - contractPayload.**classHash** - Hash of the compiled contract - contractPayload.**constructorCalldata** - optional - contractPayload.**addressSalt** - optional - contractPayload.**contractAddress** - optional The _transactionsDetail_ object may include any of: - transactionsDetail.**maxFee** - Max Fee that that will be used to execute the call(s) - transactionsDetail.**nonce** - Nonce for the transaction - transactionsDetail.**version** - Version for the transaction (default is 1) > _Note:_ Once the classHash is included in CompiledContract, this parameter can be removed. Currently it can be pre-computed from starknet-cli. ###### _DeployContractResponse_ ```typescript { contract_address: string; transaction_hash: string; }; ``` --- ### signMessage() account.**signMessage**(typedData) => _Promise _ Sign an JSON object for off-chain usage with the starknet private key and return the signature. This adds a message prefix so it cant be interchanged with transactions. _typedData_ - JSON object to be signed ###### _Signature_ ```typescript string[]; ``` --- ### hashMessage() account.**hashMessage**(typedData) => _Promise _ Hash a JSON object with pederson hash and return the hash. This adds a message prefix so it cant be interchanged with transactions. _typedData_ - JSON object to be signed Returns the hash of the JSON object. --- ### verifyMessageHash() account.**verifyMessageHash**(hash, signature) => _Promise _ Verify a signature of a given hash. > **WARNING** > > This method is not recommended, use `verifyMessage` instead --- ### verifyMessage() account.**verifyMessage**(typedData, signature) => _Promise _ Verify a signature of a JSON object. _typedData_ - JSON object to be verified _signature_ - signature of the JSON object Returns true if the signature is valid, false otherwise --- ### getSuggestedMaxFee() account.**getSuggestedMaxFee**(estimateFeeAction, details) => _Promise _ Gets Suggested Max Fee based on the transaction type. The _details_ object may include any of: - details.**blockIdentifier** - details.**nonce** --- ### getStarkName() account.**getStarkName**(address, StarknetIdContract) => _Promise_ Gets starknet.id stark name with the address provided, if `undefined` uses the address of the account The _StarknetIdContract_ argument can be undefined, if it is, the function will automatically use official starknet id contracts of your network. Returns directly a string (Example: `vitalik.stark`). --- ### simulateTransaction() account.**simulateTransaction**(calls [ , estimateFeeDetails ]) => _Promise _ Simulates the transaction and returns the transaction trace and estimated fee. ###### _TransactionSimulationResponse_ ```typescript { trace: TransactionTraceResponse; fee_estimation: EstimateFee; } ```"}
{"title": "changelog.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 7 --- # CHANGELOG ### Release 3.10.2 (21.04.2022) - New hash formula for the new account contract version. **NOTE**: Update your accounts, old ones will not be supported anymore. For updating with Argent X extension you can check this [link]( - BUGFIX: [#165]( - BUGFIX: [#151]( - BUGFIX: [#158]("}
{"title": "contract.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 4 --- # Contract Contracts can do data transformations in JavaScript based on an ABI. They can also call and invoke to Starknet through a provided Signer. Contracts allow you to transform Cairo values, like `Uint256` to `BigNumber`. It could also allow users to pass their own transformers, similar to `JSON.parse`. ## Creating an instance `new starknet.Contract(abi, address, providerOrAccount)` `contract.attach(address)` _for changing the address of the connected contract_ `contract.connect(providerOrAccount)` _for changing the provider or account_ ## Properties contract.**abi** => _Abi_ The ABI the contract was constructed with. contract.**address** => _string_ The address the contract was constructed/connected with. contract.**providerOrAccount** => _ProviderInterface | AccountInterface_ Provider or account that are used to interact with the network. contract.**deployTransactionHash** => _string | null_ If the Contract object is the result of a ContractFactory deployment, this is the transaction which was used to deploy the contract. ## Methods ### attach() contract.**attach**(address) => void Saves the address of the contract deployed on network that will be used for interaction. _address_ - address of the contract. --- ### connect() contract.**connect**(providerOrAccount) => void Attaches to new Provider or Account --- ### deployed() contract.**deployed**() => _Promise _ If the Contract object is the result of a ContractFactory deployment, this method will wait for the transaction to be resolved. --- ### call() contract.**call**(method, args, options) => _Promise _ Calls a method on a contract. --- ### invoke() contract.**invoke**(method, args, options) => _Promise _ Invokes a method on a contract. --- ### estimate() contract.**estimate**(method, args, options) => _Promise _ Estimates a method on a contract. --- ### populate() contract.**populate**(method, args, options) => _Invocation_ ## Meta-Class A Meta-Class is a Class which has any of its properties determined at run-time. The Contract object uses a Contract's ABI to determine what methods are available, so the following sections describe the generic ways to interact with the properties added at run-time during the Contract constructor. ### Read-Only Methods(constant) A constant method (denoted view in Cairo) is read-only and evaluates a small amount of Cairo code against the current blockchain state. It is therefore free and does not require any fee, but cannot make changes to the blockchain state... contract.**METHOD_NAME**(...args [ , overrides ]) => _Promise _ The type of the result depends on the ABI. Result object will be returned with each parameter available positionally and if the parameter is named, it will also be available by its name. The _overrides_ object for a read-only method may include: - overrides.**blockIdentifier** ### Write Methods (non-constant) A non-constant method requires a transaction to be signed and requires payment in the form of a fee to be paid. contract.**METHOD_NAME**(...args [ , overrides ]) => _Promise _ Returns a _AddTransactionResponse_ for the transaction after it is sent to the network. This requires that Contract has a signer. The _overrides_ object for write methods may include any of: - overrides.**signature** - Signature that will be used for the transaction - overrides.**maxFee** - Max Fee for the transaction - overrides.**nonce** - Nonce for the transaction ### Write Methods Analysis There are several options to analyze properties and results of a write method without actually executing it. contract.estimateFee.**METHOD_NAME**( ...args ) => _Promise _ Returns the estimate units of gas that would be required to execute the METHOD_NAME with args and overrides. contract.populateTransaction.**METHOD_NAME**( ...args [ , overrides ] ) \u21d2 _Call_ Returns an _Call_ object which represents the transaction that would need to be signed and submitted to the network to execute METHOD_NAME with args and overrides. The overrides are identical to the overrides above for write methods."}
{"title": "contractFactory.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 5 --- # Contract Factory Contract Factory allows you to deploy contracts to Starknet. To deploy a Contract, additional information is needed that is not available on a Contract object itself. ## Creating an instance `new starknet.ContractFactory( compiledContract, classHash, account, [ , abi ] )` Creates a new instance of a ContractFactory for the contract described by the _compiledContract_. `contractFactory.connect(account)` _for changing the provider or account_ `contractFactory.attach(address)` _for changing the address of the connected contract factory_ ## Properties contractFactory.**compiledContract** => _CompiledContract_ (the compiled contract the contractFactory was constructed with) contractFactory.**classHash** => _string_ (contract classHash can be obtained using tool for compiling contract) contractFactory.**account** => _AccountInterface_ (account that are used to interact with the network) contractFactory.**abi** => _Abi_ (the ABI the contractFactory was constructed with) ## Methods ### attach() contractFactory.**attach**( address ) \u21d2 _Contract_ Return an instance of a _Contract_ attached to address. This is the same as using the _Contract_ constructor with address and this _compiledContract_ and _account_ passed in when creating the ContractFactory. --- ### deploy() contractFactory.**deploy**( args, addressSalt ) \u21d2 _Promise _ Uses the provider to deploy the Contract with _args_ passed into the constructor and returns a _Contract_ which is attached to the address where this contract will be deployed. The transaction hash can be found at _contract.deployTransactionHash_, and no interactions should be made until the transaction is resolved."}
{"title": "index.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "# Starknet.js old API doc This API is based on the [Starknet.js V3]( Interface write up by [Janek]( of [Argent]("}
{"title": "signer.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 3 --- # Signer The **Signer** API allows you to sign transactions and messages, and also allows you to get the public key. ## Creating an instance `new starknet.Signer(pk)` ## Methods ### getPubKey() signer.**getPubKey**() => _Promise _ Returns the public key of the signer. --- ### signTransaction() signer.**signTransaction**(transactions, transactionsDetail [ , abi ]) => _Promise _ Signs a transaction with the Starknet private key and returns the signature. The _transactions_ object for write methods may include any of: - transactions.**contractAddress** - the address of the contract - transactions.**entrypoint** - the entrypoint of the contract - transactions.**calldata** - (defaults to []) the calldata _abi_ - (optional) the abi of the contract for better displaying ###### _Signature_ ```typescript string[] ``` --- ### signMessage() signer.**signMessage**(typedData, accountAddress) => _Promise _ Sign an JSON object for off-chain usage with the Starknet private key and return the signature. This adds a message prefix so it can't be interchanged with transactions. _typedData_ - JSON object to be signed _accountAddress_ - calldata to be passed in deploy constructor ###### _Signature_ ```typescript string[] ``` --- ### signDeployAccountTransaction() signer.**signDeployAccountTransaction**(transaction) => _Promise _ Signs a DEPLOY_ACCOUNT transaction with the Starknet private key and returns the signature. The _transactions_ object for write methods may include any of: - transactions.**contractAddress** - the address of the contract - transactions.**constructorCalldata** - calldata to be passed in deploy constructor - transactions.**addressSalt** - contract address salt - transactions.**chainId** - the chainId to declare contract on - transactions.**maxFee** - maxFee for the declare transaction - transactions.**version** - transaction version - transactions.**nonce** - Nonce of the declare transaction ###### _Signature_ ```typescript string[] ``` --- ### signDeclareTransaction() signer.**signDeclareTransaction**(transaction, transactionsDetail [ , abi ]) => _Promise _ Signs a DECLARE transaction with the Starknet private key and returns the signature. The _transaction_ object for write methods may include any of: - transactions.**classHash** - computed class hash. Will be replaced by ContractClass in future once class hash is present in CompiledContract - transactions.**senderAddress** - the address of the sender - transactions.**chainId** - the chainId to declare contract on - transactions.**maxFee** - maxFee for the declare transaction - transactions.**version** - transaction version - transactions.**nonce** - Nonce of the declare transaction ###### _Signature_ ```typescript string[] ```"}
{"title": "utils.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 6 --- # Utils Util functions are provided so you can use various low level functions in your application. ## **address** Helper functions for starknet addresses. ### validateAndParseAddress `validateAndParseAddress(address: BigNumberish): string` Checks if the address is valid and, if it is, parses it to the correct format (0x prefix is added if not provided). ### getChecksumAddress `getChecksumAddress(address: BigNumberish): string` This function accepts an address as a `BigNumberish` and returns the checksummed address as a string. An example: ```js import { address } from 'starknet.js'; const addressToCheck = '0x2fd23d9182193775423497fc0c472e156c57c69e4089a1967fb288a2d84e914'; const checksummedAddress = address.getChecksumAddress(addressToCheck); console.log(checksummedAddress); // 0x02FD23D9182193775423497Fc0c472E156C57C69E4089a1967fb288a2D84e914 ``` ### validateChecksumAddress `validateChecksumAddress(address: string): boolean` This function validates the checksum address. Returns true if the address is valid, false otherwise. --- ## **stark** Functions for stark specific manipulations. ### compressProgram `compressProgram(jsonProgram: Program | string): CompressedProgram` Function to compress compiled cairo program. Accepts a json file representing the compiled cairo program and returns a compressed cairo program. ### randomAddress `randomAddress(): string` Function that generates a random stark address. ### makeAddress `makeAddress(input: string): string` Function that turns an incompatible address string into stark address format. Returns a string. Example: `0xdFD0F27FCe99b50909de0bDD328Aed6eAbe76BC5` -> `0xdfd0f27fce99b50909de0bdd328aed6eabe76bc5` ### formatSignature `formatSignature(sig?: Signature): string[]` Function that formats a Signature to BigNum and then to string array. Returns a string array. ### CallData.compile `CallData.compile(args: RawArgs): Calldata` Function that creates calldata that gets sent to the contract. ```js await this.callContract({ contractAddress: this.address, entrypoint: 'is_valid_signature', calldata: CallData.compile({ hash: toBigInt(hash).toString(), signature: signature.map((x) => toBigInt(x).toString()), }), }); ``` ### estimatedFeeToMaxFee `estimatedFeeToMaxFee(estimatedFee: BigNumberish, overhead: number = 0.5): bigint` Function that calculates and returns maximum fee based on the previously estimated one. Returns a BigInt. --- ## **num** Various number formatting functions. ```js export type BigNumberish = string | number | bigint; ``` ### isHex `isHex(hex: string): boolean` Check if number is in hex format. ### toBigInt `toBigInt(value: BigNumberish): bigint` Converts BigNumberish to BigInt. Returns a BigInt. ### toHex `toHex(number: BigNumberish): string` Converts BigNumberish to hex. Returns a string. ### cleanHex `cleanHex(hex: string): string` Remove leading zeroes and lowercase hex string after '0x' `0x01AFF` -> `0x1aff` ### hexToDecimalString `hexToDecimalString(hex: string): string` Converts hex string to decimal string. ### toFelt `toFelt(num: BigNumberish): string` Converts BigNumberish to Felt. Returns a string. ### assertInRange `assertInRange(input: BigNumberish, lowerBound: BigNumberish, upperBound: BigNumberish, inputName = '')` Asserts input is equal to or greater than `lowerBound` and lower than `upperBound`. Assert message specifies inputName. `input`, `lowerBound`, and `upperBound` should be of type BigNumberish. `inputName` should be a string. ### bigNumberishArrayToDecimalStringArray `bigNumberishArrayToDecimalStringArray(rawCalldata: BigNumberish[]): string[]` Convert BigNumberish array to decimal array. Used for signature conversion. ```js const signature = await this.signer.signTransaction(transactions, signerDetails); { contract_address: this.address, entry_point_selector: getSelectorFromName('__execute__'), calldata, version: toHex(version), signature: bigNumberishArrayToDecimalStringArray(signature), } ``` ### bigNumberishArrayToHexadecimalStringArray `bigNumberishArrayToHexadecimalStringArray(rawCalldata: BigNumberish[]): string[]` Convert BigNumberish array to hexadecimal string array. Used for signature conversion. --- ## **uint256** ```js // Represents an integer in the range [0, 2^256). export interface Uint256 { // The low 128 bits of the value. low: BigNumberish; // The high 128 bits of the value. high: BigNumberish; } ``` ### uint256ToBN `uint256ToBN(uint256: Uint256): bigint` Function to convert `Uint256` to `BigInt`. ### isUint256 `isUint256(bn: BigNumberish): boolean` Function to check if `BigNumberish` is smaller or equal to `2**256-1`. ### bnToUint256 `bnToUint256(bignumber: BigNumberish): Uint256` Function to convert `BigNumberish` to `Uint256`. --- ## **hash** Various hashing helpers. ### starknetKeccak `starknetKeccak(value: string): bigint` Function to get the starknet keccak hash from a string. Returns starknet keccak hash as bigint. Returns starknet keccak hash as bigint. ### getSelectorFromName `getSelectorFromName(funcName: string)` Function to get the hex selector from a given function name. Returns hex selector of given abi function name. ### pedersen `pedersen(input: BigNumberish, BigNumberish)` Function to get the Pedersen hash for two arguments. Returns a string. ### computeHashOnElements `computeHashOnElements(data: BigNumberish[])` Function to compute a Pedersen hash on an array of elements. Returns a string. ### calculateTransactionHashCommon `calculateTransactionHashCommon(txHashPrefix: TransactionHashPrefix, version: BigNumberish,contractAddress: BigNumberish, entryPointSelector: BigNumberish, calldata: BigNumberish[], maxFee: BigNumberish, chainId: StarknetChainId, additionalData: BigNumberish[] = []): string` Calculates the transaction hash in the Starknet network - a unique identifier of the transaction. Called internally in `calculateDeployTransactionHash` and `calculateTransactionHash`. ### calculateDeployTransactionHash `calculateDeployTransactionHash(contractAddress: BigNumberish, constructorCalldata: BigNumberish[], version: BigNumberish, chainId: StarknetChainId): string` Function that calculates the deployment transaction hash in the Starknet network. Internally calls `calculateTransactionHashCommon` with `TransactionHashPrefix.DEPLOY`. ### calculateTransactionHash `calculateTransactionHash(contractAddress: BigNumberish, version: BigNumberish, entryPointSelector: BigNumberish, calldata: BigNumberish[], maxFee: BigNumberish, chainId: StarknetChainId, nonce: BigNumberish): string` Function that internally calls `calculateTransactionHashCommon`, with `TransactionHashPrefix.INVOKE`. ```js const hashMsg = calculateTransactionHash( account, transactionVersion, getSelectorFromName('__execute__'), calldata, maxFee, StarknetChainId.SN_GOERLI ); ``` ### calculateContractAddressFromHash `calculateContractAddressFromHash(salt: BigNumberish, classHash: BigNumberish, constructorCalldata: RawCalldata, deployerAddress: BigNumberish)` Function that calculates contract address from hash. Returns a string. ### computeContractClassHash `computeContractClassHash(contract: CompiledContract | string)` Function that computes Class hash of a compiled contract Returns a string. --- ## **calldata** Functions to compile and validate arguments passed in invoke, call and deploy functions. ### compile `compile(args: Array, inputs: AbiEntry[]): Calldata` Parse the calldata by using input fields from the abi for that method. ### validate `validate(type: 'INVOKE' | 'CALL' | 'DEPLOY', method: string, args: Array = [])` Validates if all arguments that are passed to the method are corresponding to the ones in the abi."}
{"title": "connect_account.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 4 --- # Connect to an existing account Once your provider is initialized, you can connect an existing account. You need 2 pieces of data: - the address of the account - the private key of this account ```typescript import { Account, Provider } from \"starknet\"; ``` ## Connect to a pre-deployed account in Starknet-devnet When you launch starknet-devnet, 10 accounts are pre-deployed with 100 dummy ETH in each. Addresses and private keys are displayed on the console at initialization. > This data will change at each launch, so to freeze them, launch with: `starknet-devnet --seed 0`. The result for `account #0`: ```bash Address: 0x7e00d496e324876bbc8531f2d9a82bf154d1a04a50218ee74cdd372f75a551a Public key: 0x7e52885445756b313ea16849145363ccb73fb4ab0440dbac333cf9d13de82b9 Private key: 0xe3e70682c2094cac629f6fbed82c07cd ``` Then you can use this code: ```typescript // initialize provider const provider = new Provider({ sequencer: { baseUrl:\" } }); // initialize existing pre-deployed account 0 of Devnet const privateKey = \"0xe3e70682c2094cac629f6fbed82c07cd\"; const accountAddress = \"0x7e00d496e324876bbc8531f2d9a82bf154d1a04a50218ee74cdd372f75a551a\"; const account = new Account(provider, accountAddress, privateKey); ``` Your account is now connected, and you can use it. ## Connect to an existing account (in any network) The code is the same, you just have to: - connect to the appropriate network. - use the address of this account (public data). - use the private key of this account (very sensitive data: your code MUST not disclose it). For example, to connect an existing account on testnet, with a private key stored in a .env non-archived file: ```typescript import * as dotenv from \"dotenv\"; dotenv.config(); // initialize provider const provider = new Provider({ sequencer: { network: constants.NetworkName.SN_GOERLI2 } }); // initialize existing account const privateKey = process.env.OZ_NEW_ACCOUNT_PRIVKEY; const accountAddress = \"0x051158d244c7636dde39ec822873b29e6c9a758c6a9812d005b6287564908667\"; const account = new Account(provider, accountAddress, privateKey); ```"}
{"title": "connect_contract.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 5 --- # Connect a deployed contract Once your provider is initialized, you can connect a contract already deployed in the network. You need 2 pieces of data: - the address of the contract - the ABI file of the contract (or the compiled/compressed contract file, that includes the abi) > If you don't have the abi file, the `provider.getClassAt()` and `provider.getClassByHash()` commands will recover the compressed contract file. As these methods generate a significant workload to the sequencer/node, it's recommended to store the result in your computer, to be able to reuse it later without using the provider: ```typescript import fs from \"fs\"; const compressedContract = await provider.getClassAt(addrContract); fs.writeFileSync('./myAbi.json', json.stringify( compressedContract.abi, undefined, 2)); ``` > When possible, prefer to read the compiled contract from a local Json file, as it's much more faster, using the `json.parse` util provided by Starknet.js, as shown below. ## Get the abi from a compiled/compressed file ```typescript import { Provider, Contract, json } from \"starknet\"; ``` If you have the compiled/compressed file of the contract, use this code to recover all data, including the ABI: ```typescript const compiledContract = json.parse(fs.readFileSync(\"./compiledContracts/test.json\").toString(\"ascii\")); ``` > Note the `json.parse` util provided by Starknet.js ## Connect to the contract ```typescript // initialize provider const provider = new Provider({ sequencer: { network: constants.NetworkName.SN_GOERLI } }); // initialize deployed contract const testAddress = \"0x7667469b8e93faa642573078b6bf8c790d3a6184b2a1bb39c5c923a732862e1\"; const compiledTest = json.parse(fs.readFileSync(\"./compiledContracts/test.json\").toString(\"ascii\")); // connect the contract const myTestContract = new Contract(compiledTest.abi, testAddress, provider); ```"}
{"title": "connect_network.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 3 --- # Provider object connect to the network The first thing to do is to define with which network you want to interact. With the Provider object, you define which network to use. ```typescript import {Provider} from 'starknet'; ``` ## Connect your DAPP to Starknet mainnet ```typescript const provider = new Provider({ sequencer: { network: constants.NetworkName.SN_MAIN } }) ``` ## Connect your DAPP to Starknet testnet 1 & 2 ```typescript const provider = new Provider({ sequencer: { network: constants.NetworkName.SN_GOERLI } }) // for testnet 1 const provider = new Provider({ sequencer: { network: constants.NetworkName.SN_GOERLI2 } }) // for testnet 2 ``` ## Connect your DAPP to Starknet-devnet ```typescript const provider = new Provider({ sequencer: { baseUrl:\" }); ``` > If you have customized host and port during starknet-devnet initialization, adapt in accordance to your script. ## Connect your DAPP to a private Starknet network If necessary you can have full control of the network access (for example, for your company's private test network): ```typescript const provider = new Provider({ sequencer: { baseUrl: ' feederGatewayUrl: 'feeder_gateway', gatewayUrl: 'gateway', } }) ``` ## Connect your DAPP to a Starknet node For a local [Pathfinder]( node: ```typescript const provider = new Provider({ rpc: { nodeUrl: '127.0.0.1:9545' } }) ``` Your node can be located in your local network (example: pathfinder node running on a computer on your network, launched with this additional option: `-- 0.0.0.0:9545`). You can connect with: ```typescript const provider = new Provider({ rpc: { nodeUrl: '192.168.1.99:9545' } }) ``` ## Specific methods Some methods are available only if connected to a sequencer, and some others are available only if connected to a node (using RPC). ### Specific sequencer methods For example, if you want to estimate the fee of an L1 L2 message, you need to use a method that is available only in the sequencer. The class `SequencerProvider` is available for this case: ```typescript import { SequencerProvider, constants } from \"starknet\"; const provider = new SequencerProvider({ baseUrl: constants.BaseUrl.SN_GOERLI2 }); // for testnet 2 const responseEstimateMessageFee = await provider.estimateMessageFee(.....) ``` ### Specific RPC methods For example, if you want to read the events recorded in a range of blocks, you need to use a method available from an RPC node. The class `RpcProvider` is available for this case: ```typescript import { RpcProvider } from \"starknet\"; const providerRPC = new RpcProvider({ nodeUrl: \" }); // for a pathfinder node located in a PC in the local network const lastBlock = await providerRPC.getBlock('latest'); let eventsList = await providerRPC.getEvents({ address: myContractAddress, from_block: {block_number: lastBlock.block_number-2}, to_block: {block_number: lastBlock.block_number}, chunk_size: 400 }); ``` RPC providers are for example Infura, Alchemy, Chainstack... Or you can spin up your own Pathfinder node! For example, to connect to Alchemy with your personal API key: ```typescript const providerRPC = new RpcProvider({ nodeUrl: ' + alchemyKey}); ```"}
{"title": "cra.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 16 --- # Usage with Create React App Please refer to this [GitHub issue]("}
{"title": "create_account.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 8 --- # Create an account Since there are no Externally Owned Accounts (EOA) in Starknet, all Accounts in Starknet are contracts. Unlike in Ethereum where a wallet is created with a public and private key pair, Starknet Accounts are the only way to sign transactions and messages and verify signatures. Therefore an Account - Contract interface is needed. Account contracts on Starknet cannot be deployed without paying a fee. Creating an account is a bit tricky; you have several steps: 1. Decide on your account type (OpenZeppelin, ArgentX, Braavos, ...). 2. Compute the address of your future account. 3. Send funds to this pre-computed address. The funds will be used to pay for the account contract deployment and remains will fund the new account. 4. Actual deployment of the Account ## Create an OZ (Open Zeppelin) account > Level: easy. Here, we will create a wallet with the Open Zeppelin smart contract v0.5.1. The contract class is already implemented in both Testnet 1 & 2. This contract is coded in Cairo 0, so it will not survive the upcoming re-genesis of Starknet. ```typescript import { Account, constants, ec, json, stark, Provider, hash, CallData } from \"starknet\"; ``` ### compute address ```typescript // connect provider const provider = new Provider({ sequencer: { network: constants.NetworkName.SN_GOERLI } }); // new Open Zeppelin account v0.5.1 // Generate public and private key pair. const privateKey = stark.randomAddress(); console.log('New OZ account:\\nprivateKey=', privateKey); const starkKeyPub = ec.starkCurve.getStarkKey(privateKey); console.log('publicKey=', starkKeyPub); const OZaccountClassHash = \"0x2794ce20e5f2ff0d40e632cb53845b9f4e526ebd8471983f7dbd355b721d5a\"; // Calculate future address of the account const OZaccountConstructorCallData = CallData.compile({ publicKey: starkKeyPub }); const OZcontractAddress = hash.calculateContractAddressFromHash( starkKeyPub, OZaccountClassHash, OZaccountConstructorCallData, 0 ); console.log('Precalculated account address=', OZcontractAddress); ``` If you want a specific private key, replace `stark.randomAddress`()` with your choice. Then you have to fund this address! How to proceed is out of the scope of this guide, but you can for example: - Transfer ETH from another wallet. - Bridge ETH to this Starknet address. - Use a faucet. ( - Mint ETH on starknet-devnet, like so: ```bash curl -X POST -d '{\"address\":\"0x04a093c37ab61065d001550089b1089922212c60b34e662bb14f2f91faee2979\",\"amount\":50000000000000000000,\"lite\":true}' -H \"Content-Type:application/json\" // {\"new_balance\":50000000000000000000,\"tx_hash\":null,\"unit\":\"wei\"} ``` ### deployment of the new account If you have sent enough funds to this new address, you can go forward to the final step: ```typescript const OZaccount = new Account(provider, OZcontractAddress, privateKey); const { transaction_hash, contract_address } = await OZaccount.deployAccount({ classHash: OZaccountClassHash, constructorCalldata: OZaccountConstructorCallData, addressSalt: starkKeyPub }); await provider.waitForTransaction(transaction_hash); console.log(' New OpenZeppelin account created.\\n address =', contract_address); ``` ## Create an Argent account > Level: medium. Here, we will create a wallet with the Argent smart contract v0.2.3. This case is more complicated because we will have the account behind a proxy contract (this way, the wallet contract can be updated). The contract classes of both contracts are already implemented in both Testnet 1 & 2. > If necessary OZ contracts can also be created with a proxy. ```typescript import { Account, ec, json, stark, Provider, hash, CallData } from \"starknet\"; ``` ### compute address ```typescript // connect provider const provider = new Provider({ sequencer: { network: constants.NetworkName.SN_GOERLI } }); //new Argent X account v0.2.3 const argentXproxyClassHash = \"0x25ec026985a3bf9d0cc1fe17326b245dfdc3ff89b8fde106542a3ea56c5a918\"; const argentXaccountClassHash = \"0x033434ad846cdd5f23eb73ff09fe6fddd568284a0fb7d1be20ee482f044dabe2\"; // Generate public and private key pair. const privateKeyAX = stark.randomAddress(); console.log('AX_ACCOUNT_PRIVATE_KEY=', privateKeyAX); const starkKeyPubAX = ec.starkCurve.getStarkKey(privateKey); console.log('AX_ACCOUNT_PUBLIC_KEY=', starkKeyPubAX); // Calculate future address of the ArgentX account const AXproxyConstructorCallData = CallData.compile({ implementation: argentXaccountClassHash, selector: hash.getSelectorFromName(\"initialize\"), calldata: CallData.compile({ signer: starkKeyPubAX, guardian: \"0\" }), }); const AXcontractAddress = hash.calculateContractAddressFromHash( starkKeyPubAX, argentXproxyClassHash, AXproxyConstructorCallData, 0 ); console.log('Precalculated account address=', AXcontractAddress); ``` If you want a specific private key, replace `stark.randomAddress`()` with your choice. Then you have to fund this address. ### deployment of the new account If you have sent enough funds to this new address, you can go forward to the final step: ```typescript const accountAX = new Account(provider, AXcontractAddress, privateKeyAX); const deployAccountPayload = { classHash: argentXproxyClassHash, constructorCalldata: AXproxyConstructorCallData, contractAddress: AXcontractAddress, addressSalt: starkKeyPubAX }; const { transaction_hash: AXdAth, contract_address: AXcontractFinalAdress } = await accountAX.deployAccount(deployAccountPayload); console.log(' ArgentX wallet deployed at:',AXcontractFinalAdress); ``` ## Create a Braavos account > Level: hard. Even more complicated, a Braavos account needs also a proxy but needs in addition a specific signature. Starknet.js is handling only Starknet standard signatures; so we need extra code to handle this specific signature for account creation. These nearly 200 lines of code are not displayed here but are available in a module [here](./compiled_contracts/deployBraavos.ts). We will deploy hereunder a Braavos account in devnet. So launch starknet-devnet with these parameters: ```bash starknet-devnet --seed 0 --fork-network alpha-goerli ``` Initialization: ```typescript import { Provider, Account, num, stark } from \"starknet\"; import { calculateAddressBraavos, deployBraavosAccount, estimateBraavosAccountDeployFee } from \"./deployBraavos\"; import axios from \"axios\"; ``` If you want to create the private key, for example with a random number: ```typescript const privateKeyBraavos = stark.randomAddress(); ``` If you want to use a private key generated by your browser wallet, create a new account (without deploying it), then copy/paste the account private key (it's useless to copy the public key). ```typescript const privateKeyBraavos = \"0x02e8....e12\"; ``` ### Compute address ```typescript // initialize Provider const providerDevnet = new Provider({ sequencer: { baseUrl: \" } }); // address const BraavosProxyAddress = calculateAddressBraavos(privateKeyBraavos); console.log('Calculated account address=', BraavosProxyAddress); ``` ### Estimate fees ```typescript // estimate fees const estimatedFee = await estimateBraavosAccountDeployFee(privateKeyBraavos, providerDevnet); console.log(\"calculated fee =\", estimatedFee); ``` ### Deploy account ```typescript // fund account address before account creation (easy in devnet) const { data: answer } = await axios.post(' { \"address\": BraavosProxyAddress, \"amount\": 10_000_000_000_000_000_000, \"lite\": true }, { headers: { \"Content-Type\": \"application/json\" } }); console.log('Answer mint =', answer); // 10 ETH // deploy Braavos account const { transaction_hash, contract_address: BraavosAccountFinalAddress } = await deployBraavosAccount(privateKeyBraavos, providerDevnet,estimatedFee); // estimatedFee is optional console.log('Transaction hash =', transaction_hash); await providerDevnet.waitForTransaction(transaction_hash); console.log(' Braavos wallet deployed at', BraavosAccountFinalAddress); ``` The computed address has been funded automatically by minting a new dummy ETH in Starknet devnet! ## Create your account abstraction You are not limited to these 3 contracts. You can create your own contract for the wallet. It's the concept of Account Abstraction. You can customize entirely the wallet - for example: - use a different concept of keys. - add a guardian to save your account. - have the possibility to transfer ownership of the wallet. - add some administrators or a super-administrator. - whitelist of addresses for transfer. - multisig. - delayed withdraw. The only limitation is your imagination... Here is an example of a customized wallet, including super administrator management, on a local starknet-devnet: > launch `starknet-devnet --seed 0` before using this script ```typescript import { Account, ec, json, stark, Provider, hash, CallData } from \"starknet\"; import fs from \"fs\"; import axios from \"axios\"; ``` ```typescript // connect provider const provider = new Provider({ sequencer: { network: \" } }); // initialize existing predeployed account 0 of Devnet const privateKey0 = \"0xe3e70682c2094cac629f6fbed82c07cd\"; const accountAddress0 = \"0x7e00d496e324876bbc8531f2d9a82bf154d1a04a50218ee74cdd372f75a551a\"; const account0 = new Account(provider, accountAddress0, privateKey0); // new account abstraction // Generate public and private key pair. const AAprivateKey = stark.randomAddress(); console.log('New account:\\nprivateKey=', AAprivateKey); const AAstarkKeyPub = ec.starkCurve.getStarkKey(AAprivateKey); console.log('publicKey=', AAstarkKeyPub); // declare the contract const compiledAAaccount = json.parse(fs.readFileSync(\"./compiled_contracts/myAccountAbstraction.json\").toString(\"ascii\")); const { transaction_hash: declTH, class_hash: decCH } = await account0.declare({contract: compiledAAaccount}); console.log('Customized account class hash =', decCH); await provider.waitForTransaction(declTH); // Calculate future address of the account const AAaccountConstructorCallData = CallData.compile({ super_admin_address: account0.address, publicKey: AAstarkKeyPub }); const AAcontractAddress = hash.calculateContractAddressFromHash( AAstarkKeyPub, AAaccountClassHash, AAaccountConstructorCallData, 0 ); console.log('Precalculated account address=', AAcontractAddress); // fund account address before account creation const { data: answer } = await axios.post(' { \"address\": AAcontractAddress, \"amount\": 50_000_000_000_000_000_000, \"lite\": true }, { headers: { \"Content-Type\": \"application/json\" } }); console.log('Answer mint =', answer); // deploy account const AAaccount = new Account(provider, AAcontractAddress, AAprivateKey); const { transaction_hash, contract_address } = await AAaccount.deployAccount({ classHash: AAaccountClassHash, constructorCalldata: AAaccountConstructorCallData, addressSalt: AAstarkKeyPub }); await provider.waitForTransaction(transaction_hash); console.log(' New customized account created.\\n address =', contract_address); ``` ## Account update For ArgentX and Braavos wallets, if you have created the private key inside the browser wallet, necessary upgrades will be automatically managed in the wallet. However, if you have created the private key by yourself, it becomes your responsibility to update the account implementation class when it's necessary. It can be done with the `upgrade` function of the implementation class."}
{"title": "create_contract.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 7 --- # Create a new contract When you have compiled your new Cairo contract, you can deploy it in the network. In Starknet, a new contract has to be added in two phases: 1. Create the contract class. 2. Deploy an instance of the contract. > You must first declare your contract class and only then deploy a new instance of it! ![](./pictures/createContract.png) > Both declaration and deployment will cost fees. That's why these functions are methods of the `Account` object. The account should be funded enough to be able to process everything. - The contract class contains the logic of the contract. A contract class is identified by its Class Hash. - The contract instance contains the memory storage of this instance. A contract instance is identified by its contract address. You will interact with the contract instance by using this address. You will have only one Class Hash for one contract code, but you can have as many contract instances as you need. Other users of the network can use your declared contract. It means that if somebody has already declared a contract class (and paid this declaration), and if you would like to have your own instance of this contract, you have only to deploy (and pay) a new instance. Example: if you want an ERC20 contract, and somebody has already declared an ERC20 contract that conforms to your needs, you have just to deploy a new instance of this contract class. ```typescript import { Provider, Account, Contract, json, stark, uint256, shortString } from \"starknet\"; ``` ## `declareAndDeploy()` your new contract Starknet.js proposes a function to perform both operations in one step: `declareAndDeploy()`. Here, to declare & deploy a `Test.cairo` smart contract, in devnet: ```typescript // connect provider const provider = new Provider({ sequencer: { baseUrl: \" } }); // connect your account. To adapt to your own account: const privateKey0 = process.env.OZ_ACCOUNT_PRIVATE_KEY; const account0Address: string = \"0x123....789\"; const account0 = new Account(provider, account0Address, privateKey0); // Declare & deploy Test contract in devnet const compiledTestSierra = json.parse(fs.readFileSync( \"./compiledContracts/test.sierra\").toString( \"ascii\")); const compiledTestCasm = json.parse(fs.readFileSync( \"./compiledContracts/test.casm\").toString( \"ascii\")); const deployResponse = await account0.declareAndDeploy({ contract: compiledTestSierra, casm: compiledTestCasm }); // Connect the new contract instance: const myTestContract = new Contract(compiledTest.abi, deployResponse.deploy.contract_address, provider); console.log(\"Test Contract Class Hash =\", deployResponse.declare.class_hash); console.log(' Test Contract connected at =', myTestContract.address); ``` ## `deployContract()` for a new instance If the contract class is already declared, it's faster and cheaper: just use `deployContract()`. ```typescript // connect provider const provider = new Provider({ sequencer: { baseUrl: \" } }); // connect your account. To adapt to your own account: const privateKey0 = process.env.OZ_ACCOUNT_PRIVATE_KEY; const account0Address: string = \"0x123....789\"; const account0 = new Account(provider, account0Address, privateKey0); // Deploy Test contract in devnet // ClassHash of the already declared contract const testClassHash = \"0xff0378becffa6ad51c67ac968948dbbd110b8a8550397cf17866afebc6c17d\"; const deployResponse = await account0.deployContract({ classHash: testClassHash }); await provider.waitForTransaction( deployResponse.transaction_hash); // read abi of Test contract const { abi: testAbi } = await provider.getClassByHash( testClassHash); if (testAbi === undefined) { throw new Error(\"no abi.\") }; // Connect the new contract instance: const myTestContract = new Contract(testAbi, deployResponse.contract_address, provider); console.log(' Test Contract connected at =', myTestContract.address); ``` ## Construct the constructor If your contract has a constructor with inputs, you have to provide these inputs in the `deployContract` or `declareAndDeploy` commands. For example, with this contract constructor: ```json \"name\": \"constructor\", \"inputs\": [ { \"name\": \"text\", \"type\": \"core::felt252\" }, { \"name\": \"longText\", \"type\": \"core::Array::\" }, { \"name\": \"array1\", \"type\": \"core::Array::\" } ], ``` You have several ways to define these inputs: ### myCalldata.compile This is the recommended way to proceed: ```typescript const myArray1: RawCalldata = [\"0x0a\", 24, 36n]; const contractCallData: CallData = new CallData(compiledContractSierra.abi); const contractConstructor: Calldata = contractCallData.compile(\"constructor\", { text: 'niceToken', longText: \" array1: myArray1 }); const deployResponse = await account0.deployContract({ classHash: contractClassHash, constructorCalldata: contractConstructor }); ``` Starknet.js will perform a full verification of conformity with the abi. Properties can be unordered. Do not use properties for array_len, it will be handled automatically by Starknet.js. ### CallData.compile For very simple constructors, you can use `CallData.compile`: ```typescript const myArray1: RawCalldata = [\"0x0a\", 24, 36n]; const contractConstructor: Calldata = CallData.compile({ text: 'niceToken', longText: \" array1: myArray1 }); const deployResponse = await account0.deployContract({ classHash: contractClassHash, constructorCalldata: contractConstructor }); ``` Properties have to be ordered in conformity with the abi. Even easier: ```typescript const contractConstructor: Calldata = CallData.compile(['niceToken', \" myArray1]); ``` ## `declare()` for a new class If you want only declare a new Contract Class, use `declare()`. ```typescript // connect provider const provider = new Provider({ sequencer: { baseUrl: \" } }); // connect your account. To adapt to your own account: const privateKey0 = process.env.OZ_ACCOUNT_PRIVATE_KEY; const account0Address: string = \"0x123....789\"; const account0 = new Account(provider, account0Address, starkKeyPair0); // Declare Test contract in devnet const compiledTestSierra = json.parse(fs.readFileSync( \"./compiledContracts/test.sierra\").toString(\"ascii\")); const compiledTestCasm = json.parse(fs.readFileSync( \"./compiledContracts/test.casm\").toString(\"ascii\")); const declareResponse = await account0.declare({ contract: compiledTestSierra, casm: compiledTestCasm }); console.log('Test Contract declared with classHash =', declareResponse.class_hash); await provider.waitForTransaction(declareResponse.transaction_hash); console.log(\" Test Completed.\"); ```"}
{"title": "define_call_message.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 9 --- # Data transformation This guide is the most important of all this documentation. Take your time, and read it carefully... Cairo contracts and Javascript/Typescript languages do not have the same types of data. To exchange data with Starknet, the data have to be transformed and formatted in a list of numbers. So, it's necessary to prepare the data before sending them to a contract. On the other side, when a contract sends data to your DAPP (the result of a call), you also have to transform them before using them in your code. In Starknet.js, you can perform these transformations manually, but you can take advantage of methods that perform these transformations. ## Types of data ### Cairo Cairo has 2 versions, involving 2 types of data: - **Cairo 0**: here, everything is felt, an integer on 251 bits. Available: array, struct, tuple, named tuple, or a mix of these elements. - **Cairo 1**: with plethora of literal types: u8, u16, u32, usize, u64, u128, felt252, u256, bool, address. Available: array, struct, tuple, or a mix of these elements. Starknet.js is compatible with both versions. ### Starknet Starknet is waiting for a list of felts, and answers with the same format. ### Javascript / Typescript These types do not exist in JS/TS - you have Number, bigInt, string, array, objects... and types defined in libraries. In Starknet.js, it's a bit ... complicated: you have the BigNumberish type and it can include: - String (representing a number): \"123\", \"0xabc2\" - Number (max 53 bits): 123 - BigInt (max 255 bits): 12345612345n ```typescript import { BigNumberish } from \"starknet\"; const decimals: BigNumberish = 18; ``` ## Preparation of data before delivery If your Cairo smart contract is waiting for a: ### felt, u8, u16, u32, usize, u64, u128, felt252, address Starknet is waiting for a felt. You can send to Starknet.js methods: bigNumberish. ```typescript await myContract.my_function(12,\"13\",\"0xe\",15n); ``` ### bool Starknet is waiting for a felt, containing 0 or 1. You can send to Starknet.js methods: boolean, bigNumberish. ```typescript await myContract.my_function(true,1); ``` ### u256 Starknet is waiting for 2 felts, the first including the lowest 128 bits, the second including the 128 highest bits. You can send to Starknet.js methods: bigNumberish (Cairo 1 only), Uint256 object (both Cairo 0 & 1). ```typescript await myContract0.my_function({low: 100, high: 0}) // Cairo 0 & 1 contract await myContract1.my_function(cairo.uint256(100)) // Cairo 0 & 1 contract await myContract2.my_function(12345678, \"13456789765\", \"0xe23a40b543f\", 1534566734334n) // Cairo 1 contract ``` In specific cases that we will see hereunder, you can use an object, with the following format: ```typescript const a1: Uint256 = cairo.uint256(\"0x05f7cd1fd465baff2ba9d2d1501ad0a2eb5337d9a885be319366b5205a414fdd\") const a2: Uint256 = {low: \"0xeb5337d9a885be319366b5205a414fdd\", high: \"0x05f7cd1fd465baff2ba9d2d1501ad0a2\"}; const a3: Uint256 = {low: a1.low,high: a1.high}; ``` ### string Starknet is waiting for a felt, including 31 ASCII characters max. You can send to Starknet.js methods: string, bigNumberish. ```typescript await myContract.my_function(\"Token\",\"0x0x534e5f4d41494e\") ``` To encode yourself a string: ```typescript const encStr: string = shortString.encodeShortString(\"Stark\"); ``` To decode yourself a string: ```typescript const decStr: string = shortString.decodeShortString(\"0x7572692f706963742f7433382e6a7067\"); ``` The result is: \"uri/pict/t38.jpg\" ### longString longString is a string that may contain more than 31 characters. Starknet is waiting for an array of felt: string_len, string1, string2, ... You can send to Starknet.js methods: string, bigNumberish[]. ```typescript await myContract.my_function(\" ``` If you want to split yourself your longString in 31 chars substrings: ```typescript const splitted: string[] = shortString.splitLongString(\" ``` If you want to split your longString in an array of felts: ```typescript const longString: string[] = shortString.splitLongString(\" ).map( str => shortString.encodeShortString( str)) ``` ### tuple Starknet is waiting for a list of felts. You can send it to Starknet.js methods: `cairo.tuple()`, object. ```typescript const myTpl = cairo.tuple(\"0x0a\", 200); await myContract.my_function(myTpl); ``` To construct your tuple: ```typescript const myTpl = {\"0\": \"0x0a\", \"1\": 200}; ``` ### named tuple > Only for Cairo 0. Starknet is waiting for a list of felts. You can send to Starknet.js methods: an object, `cairo.tuple()`, list of bigNumberish. From this ABI: ```json { \"name\": \"data2\", \"type\": \"(min: felt, max: felt)\" } ``` You can create this code: ```typescript const namedTup = {min: \"0x4e65ac6\", max: 296735486n}; await myContract.my_function(namedTup); ``` > It's not mandatory to create an object conform to the Cairo 0 named tuple ; you can just use the `cairo.tuple()` function. ### struct Starknet is waiting for a list of felts. You can send to Starknet.js methods: an object. ```typescript const myStruct = {type: \"TR1POST\", tries: 8, isBridged: true}; await myContract.my_function(myStruct); ``` ### array Starknet is waiting for an array of felts: array_len, array1, array2, ... You can send it to Starknet.js methods: bigNumberish[]. ```typescript Const myArray = [10,\"0xaa\",567n]; await myContract.my_function(myArray); ``` > Do not add the `array_len` parameter before your array. Starknet.js will manage this element automatically. ### complex types You can mix and nest literals, arrays, structs, and tuples. Starknet is waiting for a list of felts. All these examples are valid: ```typescript type Order2 = { p1: BigNumberish; p2: BigNumberish[]; }; // struct const myOrder2: Order2 = { p1: 17, p2: [234, 467456745457n, '0x56ec'], }; const param1 = cairo.tuple(cairo.tuple(34, '0x5e'), 234n); const param2 = [[200, 201],[202, 203],[204, 205]]; const param3 = [myOrder2, myOrder2]; const param4 = [cairo.tuple(251, 40000n), cairo.tuple(252, 40001n)]; await myContract.my_function(param1, param2, param3, param4); ``` ## Authorized types for Starknet.js methods There are 12 methods using contract parameters. Some types are authorized for each method: ### list of parameters Only meta-class methods are using a list of parameters (as illustrated in the previous chapter). A Meta-Class is a Class that has any of its properties determined at run-time. The Contract object uses a Contract's ABI to determine what methods are available. ```typescript await myContract.my_function(\"TOKEN\", \"13\", [10, 11, 12], 135438734812n); // or const functionName=\"my_function\"; await myContract[functionName](\"TOKEN\", \"13\", [10, 11, 12], 135438734812n); ``` ### Array of parameters An array of parameters can be used as input: ```typescript const myParams = [ {x: 100, y: 200}, 13, [10, 11, 12], cairo.uint256(\"0x295fa652e32b\")]; const txResp = await account0.execute({ contractAddress:testAddress, entrypoint: \"change_activity\", calldata: myParams}); ``` All Starknet.js methods accept this type of input, except meta-class, which needs 3 dots prefix: ```typescript const myParams = [\"TOKEN\", \"13\", [10, 11, 12], 135438734812n]; await myContract.my_function(...myParams); // or const functionName=\"my_function\"; await myContract[functionName](...myParams); ``` > Objects properties have to be ordered in accordance with the ABI. ### Object (without ABI conformity check) The use of objects allows a clear representation of the list of parameters: ```typescript const myParams = { name: \"TOKEN\", decimals: \"13\", amount: 135438734812n}; const deployResponse = await myAccount.deployContract({ classHash: contractClassHash, constructorCalldata: myParams }); ``` This type is available for: `CallData.compile(), hash.calculateContractAddressFromHash, account.deployContract, account.deployAccount, account.execute` > Objects properties have to be ordered in accordance with the ABI. ### Object (with ABI conformity check) This is the recommended type of input to use, especially for complex ABI. ```typescript const myFalseUint256 = { high: 1, low: 23456 }; // wrong order ; should be low first type Order2 = { p1: BigNumberish, p2: BigNumberish[] } const myOrder2bis: Order2 = {// wrong order ; p1 should be first p2: [234, 467456745457n, \"0x56ec\"], p1: \"17\" } const functionParameters: RawArgsObject = {//wrong order ; all properties are mixed active: true, symbol: \"NIT\", initial_supply: myFalseUint256, recipient: account0.address, decimals: 18, tupOfTup: cairo.tuple(cairo.tuple(34,\"0x5e\") ,myFalseUint256), card: myOrder2bis, longText: \"Zorg is back, for ever, here and everywhere\", array1: [100, 101, 102], array2: [[200, 201], [202, 203], [204, 205]], array3: [myOrder2bis, myOrder2bis], array4: [myFalseUint256,myFalseUint256], tuple1: cairo.tuple(40000n, myOrder2bis, [54,55n,\"0xae\"], \"texte\"), name: \"niceToken\", array5: [cairo.tuple(251,40000n),cairo.tuple(252,40001n)], } const contractCallData: CallData = new CallData(compiledContractSierra.abi); const myCalldata: Calldata = contractCallData.compile(\"constructor\", functionParameters); const deployResponse = await account0.deployContract({ classHash: contractClassHash, constructorCalldata: myCalldata }); // or const myCall: Call = myContract.populate(\"setup_elements\", functionParameters); const tx = await account0.execute(myCall); // or const myCall: Call = myContract.populate(\"get_elements\", functionParameters); const res = await myContract.get_elements(...myCall.calldata); ``` It can be used only with methods that know the abi: `Contract.populate, myCallData.compile`. Starknet.js will perform a full check of conformity with the ABI of the contract, reorder the object's properties if necessary, stop if something is wrong or missing, remove not requested properties, and convert everything to Starknet format. Starknet.js will alert you earlier of errors in your parameters (with human comprehensible words), before the call to Starknet. So, no more incomprehensible Starknet messages due to parameters construction. If a property `array_len` has been added before an array, this property is ignored as it's automatically managed by Starknet.js. ### Call, or Call[] A Call is an object with this format: ```typescript type Call = { contractAddress: string, entrypoint: string, calldata?: RawArgs, } ``` ...and is only authorized with `Account.execute `. It can be generated manually or by `Contract.populate()`: ```typescript const myCall: Call = myContract.populate(\"get_component\", [100, recipient]); // or const myCall: Call = { contractAddress: tokenContract.address, entrypoint: \"get_component\", calldata: CallData.compile( [100, recipient]), } const tx = await account0.execute(myCall); ``` It's particularly interesting when you want to invoke a function several times in the same transaction: ```typescript const myCall1: Call = myContract.populate(\"mint\", {type: 7, qty: 10}); const myCall2: Call = myContract.populate(\"mint\", {type: 21, qty: 3}); const myCall3: Call = myContract.populate(\"mint\", {type: 2, qty: 1}); const tx = await account0.execute([myCall1, myCall2, myCall3]); ``` ### Array of strings (representing numbers) This type is particularly useful when you need the maximum performance and speed in your code; You have no automatic transformation, no checks with ABI, and no parsing. You provide to starknet.js the low-level data expected by Starknet: ```typescript const specialParameters: Calldata = [ '2036735872918048433518', '5130580', '18', '23456', '1', '17', '3', '234', '467456745457', '22252']; const getResponse = await myAccount.get_bal(specialParameters, {parseRequest: false}); ``` To use with `parseRequest: false` (see hereunder). ### summary table for arguments These types of arguments can't be used at your convenience everywhere. Here is a table showing which types can be used in which function : | Function | array of parameters | ordered object | non ordered object | Call & MultiCall | list of parameters | array of strings (\\*) | array of strings (\\*\\*) | | ----------------------------------------------------------: | | | | | | | | | **Typescript type** | [] Calldata | {} RawArgsArray | {} RawArgsObject | Call & Call[] | ...Calldata | string[] | string[] | | contract.metaClass() contract\\[metaclass]() | | | | | | | | | contract.call / contract.invoke | | | | | | | | | account.execute (with 3 params, incl. calldata) | | | | | | | | | account.deployContract / Account | | | | | | | | | account.declareAndDeploy | | | | | | | | | CallData.compile | | | | | | | | | myCallData.compile | | | | | | | | | Contract.populate | | | | | | | | | hash. calculateContract AddressFromHash | | | | | | | | > (\\*) = with `parseRequest: false` > (\\*\\*) = result of `Calldata.compile, myCallData.compile, myContract.populate().calldata` ## Receive data from a Cairo contract When you perform a call, the result depends on the contract language: - In Cairo 0, the answer is an object, with keys using the Cairo variable's names. Example: ```typescript const res=myContract.call(...); const amount = res.amount; ``` - In Cairo 1, the result is a variable: ```typescript const amount = myContract.call(...); ``` | Type in Cairo 1 | Cairo 1 code | Type expected in JS/TS | JS/TS function to recover data | | --------------------------------------------------------- | ---------------------------------- | --------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | u8, u16, u32, usize, u64, u128, felt252, address | `func get_v()->u128` | bigint | `const res: bigint = myContract.call(...` | | | | string representing an hex number | `const res=myContract.call(...` `const address: string = num.toHex(res);` | | u8, u16, u32, usize | `func get_v() -> u16` | number (53 bits max) | `const res=myContract.call(...` `const total: number = Number(res)` | | u256 (255 bits max) | `func get_v() -> u256` | bigint | `const res: bigint = myContract.call(...` | | array of u8, u16, u32, usize, u64, u128, felt252, address | `func get_v() -> Array` | bigint[] | `const res: bigint[] = myContract.call(...` | | shortString (31 ASCII characters max) | `func get_v() -> felt252` | string | `const res=myContract.call(...` `const title:string = shortString.decodeShortstring(res)` | | longString | `func get_v() -> Array` | string | `const res=myContract.call(...` `const longString = res.map( (shortStr: bigint) => { return shortString.decodeShortString( num.toHex( shortStr)) }).join(\"\");` | | Tuple | `func get_v() -> (felt252, u8)` | Object {\"0\": bigint, \"1\": bigint} | `const res = myContract.call(...` `const res0: bigint = res[\"0\"];` `const results: bigint[] = Object.values(res)` | | Struct | ` func get_v() -> MyStruct` | MyStruct = { account: bigint, amount: bigint} | `const res: MyStruct = myContract.call(...` | | complex array | `func get_v() -> Array` | MyStruct[] | `const res: MyStruct[] = myContract.call(...` | If you don't know if your Contract object is interacting with a Cairo 0 or a Cairo 1 contract, you have these methods: ```typescript import { cairo } from \"starknet\"; const isCairo1: boolean = myContract.isCairo1(); const isAbiCairo1: boolean = cairo.isCairo1Abi(myAbi); ``` ## Parse configuration ### parseRequest If for any reason (mainly for speed of processing), you want to define yourself the low-level parameters to send to Starknet, you can use the `parseRequest` option. Parameters are an array of strings (representing numbers). ```typescript const txH = await myContract.send_tk([ '2036735872918048433518', '5130580', '18'], {parseRequest: false} ); ``` ### parseResponse If for any reason, you want to receive a low-level answer from Starknet, you can use the parseResponse option. ```typescript const result = await myContract.call(\"get_bals\",100n, {parseResponse: false}); ``` The answer is an array of strings (representing numbers). ### formatResponse As seen above, the strings returned by Starknet are not automatically parsed, because ABI does not inform when a contract returns a string. But there is a way to have automatic parsing of a string. For example, if a contract returns a struct containing a shortString and a longString: ```typescript { name: felt252, description: Array } ``` You can automate the string parsing with: ```typescript const formatAnswer = { name: 'string', description: 'string' } const result = await myContract.get_text(calldata, { parseRequest: true, parseResponse: true, formatResponse: formatAnswer, }); ``` The result will be an object, with 2 strings: ```typescript { name: \"Organic\", description: \"The best way to read a long string!!!\" } ```"}
{"title": "estimate_fees.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 10 --- # Estimate fees By default, all nonfree Starknet commands (declare, deploy, invoke) work without any limitation of cost. Nevertheless, you might want to inform the DAPP user of the cost of the incoming transaction before proceeding and requesting its validation. Starknet.js proposes several functions to estimate the fees: ## estimateDeclareFee To estimate the cost to declare a contract in the network: ```typescript const { suggestedMaxFee: estimatedFee1 } = await account0.estimateDeclareFee({ contract: compiledTest, classHash: testClassHash }); ``` The result is in `estimatedFee1`, of type BigInt. ## estimateDeployFee To estimate the cost to deploy a contract in the network: ```typescript const { suggestedMaxFee: estimatedFee1 } = await account0.estimateDeployFee({ classHash: testClassHash }); ``` The result is in `estimatedFee1`, of type BigInt. ## estimateAccountDeployFee To estimate the cost to deploy an account in the network: ```typescript const { suggestedMaxFee: estimatedFee1 } = await account0.estimateAccountDeployFee({ classHash: OZaccountClashHass, constructorCalldata: OZaccountConstructorCallData, contractAddress: OZcontractAddress }); ``` The result is in `estimatedFee1`, of type BigInt. ## estimateInvokeFee To estimate the cost to invoke a contract in the network: ```typescript const { suggestedMaxFee: estimatedFee1 } = await account0.estimateInvokeFee({ contractAddress: testAddress, entrypoint: \"increase_balance\", calldata: [\"10\", \"30\"] }); ``` The result is in `estimatedFee1`, of type BigInt. ## Fee limitation In all non-free functions, you can add an optional parameter limiting the fee consumption. If the fee has been previously estimated, you can use this value for this parameter, but sometimes this value is under-evaluated: **don't hesitate to add a margin of approximately 10%**: ```typescript estimatedFee1 * 11n / 10n ``` You can also use the `stark.estimatedFeeToMaxFee` function: ```typescript import { stark } from \"starknet\"; stark.estimatedFeeToMaxFee(estimatedFee1, 0.1); ``` Example for declaring: ```typescript const { suggestedMaxFee: estimatedFee1 } = await account0.estimateDeclareFee({ contract: compiledTest }); const declareResponse = await account0.declare({ contract: compiledTest}, { maxFee: estimatedFee1 * 11n / 10n} ); ```"}
{"title": "events.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 12 --- # Reading emitted events ## Starknet events A contract may emit events throughout its execution. Each event contains the following fields: from_address: address of the contract emitting the events keys: a list of field elements data: a list of field elements The events are stored in a block on the blockchain. ## Events in the Cairo code You have to analyze the Cairo code of your smart contract, to recover the list of data emitted by the event. An example in Cairo 0: ```cairo @event func log_data(d1: felt, d2: felt, d3: felt) { } @external func my_func{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() { ... log_data.emit(start_field, high_range, status_prog); ... return (); } ``` Here, we can see that the event will store 3 felts. Once compiled, this code will generate an abi file containing: ```typescript { \"data\": [ {\"name\": \"d1\", \"type\": \"felt\"}, {\"name\": \"d2\", \"type\": \"felt\"}, {\"name\": \"d3\", \"type\": \"felt\"}, ], \"keys\": [], \"name\": \"log_data\", \"type\": \"event\", } ``` ## Recover the event data Once the `my_func` is invoked, the event is stored in the blockchain and you get in return the transaction hash. ```typescript import { InvokeTransactionReceiptResponse } from \"starknet\"; const resu = await myTestContract.my_func(); const txReceiptDeployTest: InvokeTransactionReceiptResponse = await provider.waitForTransaction(resu.transaction_hash); console.log(\"events =\",txReceiptDeployTest.events); ``` Now, you have all the events of the block. Here, we have 2 events - the last one contains our data: ```typescript [ [Object: null prototype] { data: [ '0x2345b8cdd1eb333ac0959f7d908394b6540234345590e83367ae2a6cfbd4107' ], from_address: '0x465e68294995849bd00ac9f6ad4ee12be3cec963d8fe27172a1eadda608c110', keys: [ '0x28f911b08eb032a94e35f766f1310b2df2267eb9d25bb069a1e3a6754e4206d' ] }, [Object: null prototype] { data: [ '0x7e00d496e324876bbc8531f2d9a82bf154d1a04a50218ee74cdd372f75a551a', '0x3711666a3506c99c9d78c4d4013409a87a962b7a0880a1c24af9fe193dafc01', '0x1d3d81545c000' ], from_address: '0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7', keys: [ '0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9' ] } ] ``` Use the contract deployment address `testContractAddress`, to filter the events and read the data from your smart contract: ```typescript const event = txReceiptDeployTest.events.find( (it) => num.cleanHex(it.from_address) === num.cleanHex(testContractAddress) ) || {data: []}; const eventD1 = event.data[0]; const eventD2 = event.data[1]; const eventD3 = event.data[2]; ``` If you do not have the transaction hash, you have to search in the blocks of Starknet. See an example [here](connect_network#specific-rpc-methods)."}
{"title": "interact.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 6 --- # Interact with your contract Once your provider, contract, and account are connected, you can interact with the contract: - you can read the memory of the contract, without fees. - you can write to memory, but you have to pay fees. - On Mainnet, you have to pay fees with a bridged ETH token. - On Testnet 1 & 2, you have to pay with a bridged Goerli ETH token. - On devnet, you have to pay with a dummy ETH token. Your account should be funded enough to pay fees (0.01 ETH should be enough to start). ![](./pictures/Interact_contract.png) Here we will interact with a `test.cairo` contract (Cairo 0), already deployed in Testnet 1 and Tesnet 2, at addresses: - testnet1: [0x5f7cd1fd465baff2ba9d2d1501ad0a2eb5337d9a885be319366b5205a414fdd]( - testnet2: [0x2367db6b0df07033d196dcd25961109d8fbc86227158343149742284c7582e]( We will use Testnet1, so you need a funded wallet in this network. This contract contains a storage variable called `balance`. - It can be read with the `@view function: get_balance()` - Balance can be modified with the `@external function: increase_balance(amount1: felt, amount2: felt)` ```typescript import { Provider, Contract, Account, ec, json } from \"starknet\"; ``` ## Read from contract memory, with meta-class To read the balance, you need to connect a Provider and a Contract. You have to call Starknet, with the use of the meta-class method: `contract.function_name(params)` (here `params` is not necessary, because there are no parameters for the `get_balance` function). ```typescript //initialize Provider const provider = new Provider({ sequencer: { network: constants.NetworkName.SN_GOERLI } }); // Connect the deployed Test contract in Tesnet const testAddress = \"0x5f7cd1fd465baff2ba9d2d1501ad0a2eb5337d9a885be319366b5205a414fdd\"; // read abi of Test contract const { abi: testAbi } = await provider.getClassAt(testAddress); if (testAbi === undefined) { throw new Error(\"no abi.\") }; const myTestContract = new Contract(testAbi, testAddress, provider); // Interaction with the contract with call const bal1 = await myTestContract.get_balance(); console.log(\"Initial balance =\", bal1.res.toString()); // .res because the return value is called 'res' in the Cairo 0 contract. // With Cairo 1 contract, the result value is in bal1, as bigint. ``` ## Write to contract memory, with meta-class To increase the balance, you need in addition a connected and funded Account. You have to invoke Starknet, with the use of the meta-class method: `contract.function_name(params)` > After the invoke, you have to wait the incorporation of the modification of Balance in the network, with `await provider.waitForTransaction(transaction_hash)` Here is an example of how to increase and check the balance: ```typescript //initialize Provider const provider = new Provider({ sequencer: { network: constants.NetworkName.SN_GOERLI } }); // connect your account. To adapt to your own account: const privateKey0 = process.env.OZ_ACCOUNT_PRIVATE_KEY; const account0Address = \"0x123....789\"; const account0 = new Account(provider, account0Address, privateKey0); // Connect the deployed Test contract in Tesnet const testAddress = \"0x5f7cd1fd465baff2ba9d2d1501ad0a2eb5337d9a885be319366b5205a414fdd\"; // read abi of Test contract const { abi: testAbi } = await provider.getClassAt(testAddress); if (testAbi === undefined) { throw new Error(\"no abi.\") }; const myTestContract = new Contract(testAbi, testAddress, provider); // Connect account with the contract myTestContract.connect(account0); // Interactions with the contract with meta-class const bal1 = await myTestContract.get_balance(); console.log(\"Initial balance =\", bal1.res.toString()); // Cairo 0 contract // increase_balance needs 2 felts, to add them to the balance. const myCall = myTestContract.populate(\"increase_balance\", [10,30]); const res = await myTestContract.increase_balance(myCall.calldata); await provider.waitForTransaction(res.transaction_hash); const bal2 = await myTestContract.get_balance(); console.log(\"Final balance =\", bal2.res.toString()); ``` `Contract.populate()` is the recommended method to define the parameters to call/invoke the Cairo functions. ## Sending sequential transactions If you intend to send sequential transactions through the contract object, like so: ```typescript const tx = await cairo1Contract.array2d_ex(data); const tx1 = await cairo1Contract.array2d_ex(data); ``` Be sure to use `waitForTransaction` between the calls, because you may experience issues with the nonce not incrementing: ```typescript const tx = await cairo1Contract.array2d_ex(data); await provider.waitForTransaction(tx.transaction_hash); const tx1 = await cairo1Contract.array2d_ex(data); await provider.waitForTransaction(tx1.transaction_hash); ``` ## Write several operations, with Account.execute In a Starknet transaction, you can include several invoke operations. It will be performed with `account.execute`. We will later see this case more in detail in this dedicated [guide](multiCall.md), but in summary, you use this command with the following parameters: - address of the contract to invoke - name of the function to invoke - and an array of parameters for this function ```typescript const result = await account.execute( { contractAddress: myContractAddress, entrypoint: 'transfer', calldata: CallData.compile({ recipient: receiverAddress, amount: cairo.uint256(100000n) }) } ); await provider.waitForTransaction(result.transaction_hash); ``` ## Other existing methods Some other useful methods to interact with Starknet: ### Function name defined in the code If you want to call a function with its name contained in a variable: ```typescript const listFn = [\"calc-sum\",\"calc-hash\",\"calc-proof\"]; // fnChoice is a number defined during execution const res = await myTestContract[listFn[fnChoice]](200, 234567897n, 865423); ``` ### Light and fast call If you want to have a very fast execution, with minimum resource usage: ```typescript const specialParameters: Calldata = [ '2036735872918048433518', '5130580', '18' ]; const getResponse = await myAccount.call( \"get_bal\", specialParameters, { parseRequest: false } ); ``` You provide the low-level numbers expected by Starknet, without any parsing or checking. See more details [here](define_call_message.md#parse-configuration)."}
{"title": "intro.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 1 --- # Getting Started ## Installation ```bash # use the main branch npm install starknet # to use latest features (merges in develop branch) npm install starknet@next ``` ## Running test locally ### With Devnet The example devnet version is `0.5.3`. Get devnet with docker: ```bash docker pull shardlabs/starknet-devnet:0.5.3 docker run -p 5050:5050 shardlabs/starknet-devnet:0.5.3 --seed 0 ``` Open a new console tab, go to your starknet.js directory, and run: ```bash npm run test # all tests npm run test ./__tests__/contract.test.ts # just one test suite ``` By default, `defaultProvider` tests will be run through the `Sequencer`. If you want to run `defaultProvider` through the `RPC` run: ```bash export TEST_RPC_URL = \" # only RPC related tests: npm run test ./__tests__/rpcProvider.test.ts ``` ## Running docs locally If you want to change documentation and see how it looks before making a PR: ```bash cd www npm install # install docusaurus npm run start # fires up a local documentation site ``` ## Compiling Starknet Contracts Please check the Starknet documentation [here]( to compile Starknet contracts. Additional helpful resources can also be found at [OpenZeppelin]( documentation site. ## Full example with account & erc20 deployments Please take a look at our workshop using OpenZeppelin contracts [here]( Example with the Argent contract [here]( ## Contracts used in the guides You can find the compiled contracts used in these guides in `compiled_contracts` directory."}
{"title": "migrate.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 17 --- # Migrate from v4 to v5 This document only covers the features present in v4 which have changed in some significant way in v5. If you encounter any missing changes, please let us know and we will update this guide. ## _number_ utility replaced by _num_ To avoid confusion with the native `number` type, the `number` namespace has been renamed to `num`. ```typescript // v4 const res = number.isHex(d1); // v5 const res = num.isHex(d1); ``` `number.toFelt()` has been removed, if manual handling is necessary `cairo.felt()` can be used. ## _bn.js_ no longer supported The `bn.js` library has been removed in favor of using the native JavaScript `BigInt` data type. ```typescript // v4 const qty = new BN(\"0x4a8bc\"); // v5 const qty1 = BigInt(\"0x4a8bc\"); const qty2 = 32786324915918425n; ``` The `BigNumberish` type is now defined as: - String representing a number: \"123\", \"0xabc2\" - Number (max 53 bits): 123 - BigInt (max 255 bits): 12345612345n Some commonly used `BN` utility methods are of course no longer present, however, they have simple equivalents: - `.mul()` and `.div()`: common operators can be used with bigints: `+` `-` `*` `/` - `.umod()` can be easily replaced with: ```typescript // v4 const c = a.umod(b); // v5 const tmp = a % b; // a and b are bigint const c = tmp >= 0n ? tmp : tmp + b; ``` - `.toarray()` can be replaced with `num.hexToBytes(a)` ## ec (elliptic curve) With the `bn.js` removal the accompanying elliptic curve libraries have also been replaced, consequently many functions have been relocated or modified. The concept of a key pair, where the private and public key are used as a single entity, has been removed. `ec.getKeyPair()`, `ec.getKeyPairFromPublicKey()` and `ec.genKeyPair()` do not exist anymore, corresponding methods use the private key directly. Check the following examples: `Account` creation: ```typescript // v4 const privateKey0 = accountTestnet4PrivateKey; const account0Address: string = accountTestnet4Address; const starkKeyPair0 = ec.getKeyPair(privateKey0); const account0 = new Account(provider, account0Address, starkKeyPair0); // v5 const privateKey0 = accountTestnet4PrivateKey; const account0Address: string = accountTestnet4Address; const account0 = new Account(provider, account0Address, privateKey0); ``` Derive partial public key (`starknetPubKey`): ```typescript // v4 const starknetPubKey = ec.getStarkKey(keyPair); // v5 const starknetPubKey = ec.starkCurve.getStarkKey(privateKey); // only X part of full pubKey ``` Derive full public key (`fullPubKey`): ```typescript // v4 const fullPubKey = encode.addHexPrefix(keyPair.getPublic(\"hex\")); // v5 const fullPubKey = encode.addHexPrefix(encode.buf2hex(ec.starkCurve.getPublicKey(privateKey, false))); // full key ``` `ec.sign` and `ec.verify`: ```typescript // v4 const signature = ec.sign(keyPair, msgHash); const isVerified = ec.verify(inferredKeyPair, msgHash, signature); // v5 const signature = ec.starkCurve.sign(msgHash, privateKey); const verifStarknet = ec.starkCurve.verify(signature, msgHash, fullPubKeySource); ``` `pedersen` hash calculation: ```typescript // v4 const hashMsg = hash.pedersen([account, price]); // v5 const hashMsg = ec.starkCurve.pedersen(account, price); ``` ## 'declare**And**Deploy' renaming The `account.declareDeploy()` method has been renamed to `declareAndDeploy()`: ```typescript // v4 const response = await account0.declareDeploy({ contract: compiledTest, classHash: testClassHash }); // v5 const response = await account0.declareAndDeploy({ contract: compiledHelloSierra, casm: compiledHelloCasm }); ``` > Note: `declare` and `declareAndDeploy` no longer require `classHash`! The new ec library is now able to calculate it quickly > and does so automatically when it is not provided. If a contract has been written in Cairo 1 the `casm` property is needed. ## Calldata and returned values Deep modifications and improvements have been performed concerning exchange of data with the Cairo contract functions. The complete new rules are listed in this **[guide](define_call_message.md)**. In short, it is easier to construct a list of parameters while relying on the built-in verification of the conformity to the abi. Returned values from a Cairo 0 contract are identical, but returned values from a Cairo 1 contract are easier to recover. `stark.compileCalldata()` has been replaced by `CallData.compile()`. Regardless, the new `Contract.populate()` and `myCallData.compile()` methods are the recommended way to create calldata. ## Provider Constants for `Provider` initialization have been updated: ```typescript // v4 const providerTestnet2 = new Provider({ sequencer: { network: \"goerli-alpha-2\" } }); // v5 const providerTestnet2 = new Provider({ sequencer: { network: constants.NetworkName.SN_GOERLI2 } }); // or SN_GOERLI or SN_MAIN ``` `Provider.chainId()` has been removed, `Provider.getChainId()` should be used. ```typescript // v4 const chainId = myProvider.chainId(); // v5 const chainId = await myProvider.getChainId(); ``` ## Uint256 The approach to create a `uint256` variable has changed: ```typescript // v4 const amountIn = uint256.bnToUint256(amountToSwap); // v5 const amountIn: Uint256 = cairo.uint256(50000n); ``` ## get-starknet In your DAPP React code you can connect to ArgentX or Braavos wallets using the `get-starknet` library. The current v2.1.0 version is not yet compatible with starknet.js v5. An update is expected."}
{"title": "multiCall.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 15 --- # Interact with more than one contract within one transaction Interacting with more than one contract with one transaction is one of Starknet's features. To use this feature, two contracts are required. ## Setup Set up basic stuff before multicall. ```javascript // devnet private key from Account #0 if generated with --seed 0 const privateKey = \"0xe3e70682c2094cac629f6fbed82c07cd\"; const accountAddress = \"0x7e00d496e324876bbc8531f2d9a82bf154d1a04a50218ee74cdd372f75a551a\"; // Ether token contract address const contractAddress_1 = '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7'; // contract address which require ether const contractAddress_2 = '0x078f36c1d59dd29e00a0bb60aa2a9409856f4f9841c47f165aba5bab4225aa6b'; const account = new Account( provider, accountAddress, privateKey ); ``` ## Interact with contracts Interact with more than one contract by using `account.execute([calls])`. The example is as follows. ```javascript const multiCall = await account.execute( [ // Calling the first contract { contractAddress: contractAddress_1, entrypoint: \"approve\", // approve 1 wei for bridge calldata: CallData.compile({ spender: contractAddress_2, amount: cairo.uint256(1), }) }, // Calling the second contract { contractAddress: contractAddress_2, entrypoint: \"transfer_ether\", // transfer 1 wei to the contract address calldata: CallData.compile({ amount: cairo.uint256(1), }) } ] ) await provider.waitForTransaction(multiCall.transaction_hash); ```"}
{"title": "signature.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 14 --- # Signature You can use Starknet.js to sign a message outside of the network, using the standard methods of hash and sign of Starknet. In this way, in some cases, you can avoid paying fees to store data in-chain; you transfer the signed message off-chain, and the recipient can verify (without fee) on-chain the validity of the message. ## Sign and send a message Your message has to be an array of `BigNumberish`. First, calculate the hash of this message, then calculate the signature. > If the message does not respect some safety rules of composition, this method could be a way of attack of your smart contract. If you have any doubt, prefer the [EIP712 like method](#sign-and-verify-following-eip712), which is safe, but is also more complicated. ```typescript import {ec, hash, num, json, Contract } from \"starknet\"; const privateKey = \"0x1234567890987654321\"; const starknetPublicKey = ec.starkCurve.getStarkKey(privateKey); const fullPublicKey = encode.addHexPrefix( encode.buf2hex( ec.starkCurve.getPublicKey( privateKey, false))); const message: BigNumberish[] = [1, 128, 18, 14]; const msgHash = hash.computeHashOnElements(message); const signature: weierstrass.SignatureType = ec.starkCurve.sign(msgHash,privateKey); ``` Then you can send, by any means, to the recipient of the message: - the message. - the signature. - the full public key (or an account address using this private key). ## Receive and verify a message On the receiver side, you can verify that: - the message has not been modified, - the sender of this message owns the private key corresponding to the public key. 2 ways to perform this verification: - off-chain, using the full public key (very fast, but only for standard Starknet hash & sign). - on-chain, using the account address (slow, add workload to the node/sequencer, but can manage exotic account abstraction about hash or sign). ### Verify outside of Starknet: The sender provides the message, the signature, and the full public key. Verification: ```typescript const msgHash1 = hash.computeHashOnElements(message); const result1 = ec.starkCurve.verify(signature, msgHash1, fullPublicKey); console.log(\"Result (boolean) =\", result1); ``` > The sender can also provide their account address. Then you can check that this full public key is linked to this account. The public Key that you can read in the account contract is part (part X) of the full public Key (parts X & Y): Read the Public Key of the account: ```typescript const provider = new Provider({ sequencer: { baseUrl: \" } }); //devnet const compiledAccount = json.parse(fs.readFileSync(\"./compiled_contracts/Account_0_5_1.json\").toString(\"ascii\")); const accountAddress =\"0x....\"; // account of sender const contractAccount = new Contract(compiledAccount.abi, accountAddress, provider); const pubKey3 = await contractAccount.call(\"getPublicKey\"); ``` Check that the Public Key of the account is part of the full public Key: ```typescript const isFullPubKeyRelatedToAccount: boolean = publicKey.publicKey == BigInt(encode.addHexPrefix( fullPublicKey.slice( 4, 68))); console.log(\"Result (boolean)=\", isFullPubKeyRelatedToAccount); ``` ### Verify in the Starknet network, with the account: The sender can provide an account address, despite a full public key. ```typescript const provider = new Provider({ sequencer: { baseUrl: \" } }); //devnet const compiledAccount = json.parse(fs.readFileSync(\"./compiled_contracts/Account_0_5_1.json\").toString(\"ascii\")); const accountAddress =\"0x...\"; // account of sender const contractAccount = new Contract(compiledAccount.abi, accountAddress, provider); const msgHash2 = hash.computeHashOnElements(message); // The call of isValidSignature will generate an error if not valid let result2: boolean; try { await contractAccount.isValidSignature(msgHash2, [signature.r,signature.s]); result2 = true; } catch { result2 = false; } console.log(\"Result (boolean) =\", result2); ``` ## Sign and verify the following EIP712 Previous examples are valid for an array of numbers. In the case of a more complex structure of an object, you have to work in the spirit of [EIP 712]( This JSON structure has 4 mandatory items: `types`, `primaryType`, `domain`, and `message`. These items are designed to be able to be an interface with a wallet. At sign request, the wallet will display: - the `message` will be displayed at the bottom of the wallet display, showing clearly (not in hex) the message to sign. Its structure has to be in accordance with the type listed in `primaryType`, defined in `types`. - the `domain` will be shown above the message. Its structure has to be in accordance with `StarkNetDomain`. The predefined types that you can use : - felt: for an integer on 251 bits. - felt\\*: for an array of felt. - string: for a shortString of 31 ASCII characters max. - selector: for a name of a smart contract function. - merkletree: for a Root of a Merkle tree. the root is calculated with the provided data. ```typescript const typedDataValidate: TypedData = { types: { StarkNetDomain: [ { name: \"name\", type: \"string\" }, { name: \"version\", type: \"felt\" }, { name: \"chainId\", type: \"felt\" }, ], Airdrop: [ { name: \"address\", type: \"felt\" }, { name: \"amount\", type: \"felt\" } ], Validate: [ { name: \"id\", type: \"felt\" }, { name: \"from\", type: \"felt\" }, { name: \"amount\", type: \"felt\" }, { name: \"nameGamer\", type: \"string\" }, { name: \"endDate\", type: \"felt\" }, { name: \"itemsAuthorized\", type: \"felt*\" }, // array of felt { name: \"chkFunction\", type: \"selector\" }, // name of function { name: \"rootList\", type: \"merkletree\", contains: \"Airdrop\" } // root of a merkle tree ] }, primaryType: \"Validate\", domain: { name: \"myDapp\", // put the name of your dapp to ensure that the signatures will not be used by other DAPP version: \"1\", chainId: shortString.encodeShortString(\"SN_GOERLI\"), // shortString of 'SN_GOERLI' (or 'SN_MAIN' or 'SN_GOERLI2'), to be sure that signature can't be used by other network. }, message: { id: \"0x0000004f000f\", from: \"0x2c94f628d125cd0e86eaefea735ba24c262b9a441728f63e5776661829a4066\", amount: \"400\", nameGamer: \"Hector26\", endDate: \"0x27d32a3033df4277caa9e9396100b7ca8c66a4ef8ea5f6765b91a7c17f0109c\", itemsAuthorized: [\"0x01\", \"0x03\", \"0x0a\", \"0x0e\"], chkFunction: \"check_authorization\", rootList: [ { address: \"0x69b49c2cc8b16e80e86bfc5b0614a59aa8c9b601569c7b80dde04d3f3151b79\", amount: \"1554785\", }, { address: \"0x7447084f620ba316a42c72ca5b8eefb3fe9a05ca5fe6430c65a69ecc4349b3b\", amount: \"2578248\", }, { address: \"0x3cad9a072d3cf29729ab2fad2e08972b8cfde01d4979083fb6d15e8e66f8ab1\", amount: \"4732581\", }, { address: \"0x7f14339f5d364946ae5e27eccbf60757a5c496bf45baf35ddf2ad30b583541a\", amount: \"913548\", }, ] }, }; // connect your account, then const signature2: weierstrass.SignatureType = await account.signMessage(typedDataValidate) as weierstrass.SignatureType; ``` On the receiver side, you receive the JSON, the signature, and the account address. To verify the message: ```typescript const compiledAccount = json.parse(fs.readFileSync(\"./compiledContracts/Account_0_5_1.json\").toString(\"ascii\")); const contractAccount = new Contract(compiledAccount.abi, accountAddress, provider); const msgHash5 = typedData.getMessageHash(typedDataValidate, accountAddress); // The call of isValidSignature will generate an error if not valid let result5: boolean; try { await contractAccount.isValidSignature(msgHash5, [signature2.r, signature2.s]); result5 = true; } catch { result5 = false; } console.log(\"Result5 (boolean) =\", result5); ```"}
{"title": "use_ERC20.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 11 --- # Work with ERC20 tokens Based on what has been seen in the previous pages of this guide, we will use an ERC20 contract. ## What's an ERC20 As in Ethereum, a token has an ERC20 contract to manage it. This contract contains a table, that lists the quantity of tokens owned by each involved account: ![](./pictures/ERC20.png) For example, Account address 2 owns 100 tokens of this ERC20 contract. Users have the feeling that their tokens are stored in their wallets, but it's absolutely false. You have no list of assets stored in your account contract. In fact, a token has its own ERC20 contract, and the amount of token owned by your account address is stored in this contract. If you want to have your balance of a token, ask for its ERC20 contract, with the function `ERC20contract.balanceOf(accountAddress)`. When you want to transfer some tokens in your possession, you have to use the ERC20 contract function `transfer`, through the `account.execute` function (or meta-class methods). In this way, Starknet.js will send to the account contract a message signed with the private key. This message contains the name of the function to call in the ERC20 contract, with its optional parameters. The account contract will use the public key to check that you have the private key, then will ask the ERC20 contract to execute the requested function. This way, the ERC20 contract is absolutely sure that the caller of the transfer function knows the private key of this account. ## ETH token is an ERC20 in Starknet In opposition to Ethereum, the ETH token is an ERC20 in Starknet, like all other tokens. In all networks, its ERC20 contract address is: ```typescript const addrETH = \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\"; ``` ## Deploy an ERC20 Let's dive down the rabbit hole! This example works with an ERC20 mintable (everybody can mint new tokens), that we will deploy on the devnet (launched with `starknet-devnet --seed 0`). First, let's initialize an account: ```typescript // initialize provider const provider = new Provider({ sequencer: { baseUrl:\" } }); // initialize existing pre-deployed account 0 of Devnet const privateKey = \"0xe3e70682c2094cac629f6fbed82c07cd\"; const accountAddress = \"0x7e00d496e324876bbc8531f2d9a82bf154d1a04a50218ee74cdd372f75a551a\"; const account0 = new Account(provider, accountAddress, privateKey); ``` Declaration and deployment of the ERC20 contract: ```typescript // Deploy an ERC20 contract console.log(\"Deployment Tx - ERC20 Contract to Starknet...\"); const compiledErc20mintable = json.parse(fs.readFileSync(\"compiled_contracts/ERC20MintableOZ051.json\").toString(\"ascii\")); const initialTk: Uint256 = cairo.uint256(100); const erc20CallData: CallData = new CallData(compiledErc20mintable.abi); const ERC20ConstructorCallData: Calldata = erc20CallData.compile(\"constructor\", { name: \"niceToken\", symbol: \"NIT\", decimals: 18, initial_supply: initialTk, recipient: account0.address, owner: account0.address }); console.log(\"constructor=\", ERC20ConstructorCallData); const deployERC20Response = await account0.declareAndDeploy({ contract: compiledErc20mintable, constructorCalldata: ERC20ConstructorCallData }); console.log(\"ERC20 declared hash: \", deployERC20Response.declare.class_hash); console.log(\"ERC20 deployed at address: \", deployERC20Response.deploy.contract_address); // Get the erc20 contract address const erc20Address = deployERC20Response.deploy.contract_address; // Create a new erc20 contract object const erc20 = new Contract(compiledErc20mintable.abi, erc20Address, provider); erc20.connect(account0); ``` ## Interact with an ERC20 Here we will read the balance, mint new tokens, and transfer tokens: ```typescript // Check balance - should be 100 console.log(`Calling Starknet for account balance...`); const balanceInitial = await erc20.balanceOf(account0.address); console.log(\"account0 has a balance of:\", uint256.uint256ToBN(balanceInitial.balance).toString()); // Cairo 0 response // Mint 1000 tokens to account address const amountToMint = cairo.uint256(1000); console.log(\"Invoke Tx - Minting 1000 tokens to account0...\"); const { transaction_hash: mintTxHash } = await erc20.mint( account0.address, amountToMint, { maxFee: 900_000_000_000_000 } ); // Wait for the invoke transaction to be accepted on Starknet console.log(`Waiting for Tx to be Accepted on Starknet - Minting...`); await provider.waitForTransaction(mintTxHash); // Check balance - should be 1100 console.log(`Calling Starknet for account balance...`); const balanceBeforeTransfer = await erc20.balanceOf(account0.address); console.log(\"account0 has a balance of:\", uint256.uint256ToBN(balanceBeforeTransfer.balance).toString()); // Cairo 0 response // Execute tx transfer of 10 tokens console.log(`Invoke Tx - Transfer 10 tokens back to erc20 contract...`); const toTransferTk: Uint256 = cairo.uint256(10); const transferCallData: Call = erc20.populate(\"transfer\", { recipient: erc20Address, amount: toTransferTk // with Cairo 1 contract, 'toTransferTk' can be replaced by '10n' }); const { transaction_hash: transferTxHash } = await erc20.transfer( ...transferCallData.calldata); // Wait for the invoke transaction to be accepted on Starknet console.log(`Waiting for Tx to be Accepted on Starknet - Transfer...`); await provider.waitForTransaction(transferTxHash); // Check balance after transfer - should be 1090 console.log(`Calling Starknet for account balance...`); const balanceAfterTransfer = await erc20.balanceOf(account0.address); console.log(\"account0 has a balance of:\", uint256.uint256ToBN(balanceAfterTransfer.balance).toString()); // Cairo 0 response console.log(\" Script completed.\"); ```"}
{"title": "what_s_starknet.js.md", "repo_owner": "0xs34n", "repo_name": "starknet.js", "text": "--- sidebar_position: 2 --- # What is Starknet.js ? Starknet.js is a library that helps to connect your website or your Decentralized Application (DAPP) to the blockchain-based Starknet network, using Javascript / Typescript language. ## Overview ![](./pictures/starknet-js-chart.png) Some important topics that have to be understood: - You can connect your DAPP to several networks: - [Starknet mainnet]( (Layer 2 of [Ethereum network]( ). - [Starknet testnet 1]( & [testnet 2]( (Layer 2 of [Goerli network]( (testnet of Ethereum)). - [Starknet-devnet]( (your local Starknet network, for developers). and also to some more specific solutions: - private customized version of Starknet. - local Starknet node (connected to mainnet or testnet). > Understand what is Starknet and how it works is necessary. Then, you can learn how to interact with it using Starknet.js. So, at this stage, you should be aware of the content of the [Starknet official doc]( and [the Starknet Book]( - Only the `Provider` object is talking directly to the network - your DAPP will talk mainly to `Account` and `Contract` objects. You will define with the `Provider` with which network you want to work. You can ask the Provider for some low-level data of the network (block, timestamp, ...). - `Signer` and `Utils` objects contain many useful functions for interaction with Starknet.js. - The `Contract` object is mainly used to read the memory of a blockchain contract. - The `Account` object is the most useful: - as a wallet, to store your tokens. - as a way to pay the fees to the network, and to be able to write in its memory."}
